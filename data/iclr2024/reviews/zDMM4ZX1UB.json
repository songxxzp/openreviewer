[
    {
        "id": "ACm5w7GwRr",
        "forum": "zDMM4ZX1UB",
        "replyto": "zDMM4ZX1UB",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission8801/Reviewer_3XTL"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission8801/Reviewer_3XTL"
        ],
        "content": {
            "summary": {
                "value": "The paper proposes SymC, an approach to training a Transformer architecture that is invariant/equivariant to dependence-preserving reordering of code. SymC's formal foundation is a group theoretic definition of invariance and equivariance. The paper defines this symmetry group over program interpretation graphs, graphs whose nodes are program instructions and whose edges indicate whether there is any execution path in which there is a direct dependence between data computed by the two instructions. The paper then relaxes this to the sound overapproximation of dependence graphs, and shows an implementation of self-attention that is equivariant to actions of this symmetry group. The paper evaluates the proposed model on a range of invariant tasks, evaluating on code transformations that fall within and outside the scope of the invariance. The paper shows that SymC is competitive or surpasses baseline models on nearly all metrics of interest."
            },
            "soundness": {
                "value": "4 excellent"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "4 excellent"
            },
            "strengths": {
                "value": "* Broadly, the paper is very well written. The paper provides a clear description of all the background knowledge of symmetry groups, clearly grounds the theory in the task (symmetry groups of code ordering), explains the implementation reasonably well (invariant/equivariant self-attention), and has a clear evaluation.\n* The problem domain itself is interesting and important, and the proposed solution is novel\n* The evaluation is quite extensive, with strong results on all metrics of interest"
            },
            "weaknesses": {
                "value": "* The one part of the paper that could be more clear is in the precise discussion of the implementation of SymC in a Transformer. Specifically:\n  * I found the definition of the Aut(PDG) distance matrix to be a bit hard to reason about\n  * I also wasn't sure what the relationship between this distance matrix and the standard use of positional encodings is.\n* I would appreciate some discussion of why the F1/AUC results in Table 2 are not monotonic in the percentage of semantics-preserving permutations.\n* The evaluation also lacks any quantification of variance in the results (e.g., standard error across different training trials).\n* Minor typo: Section 3.3: \"tofuture\""
            },
            "questions": {
                "value": "* Does SymC use positional embeddings?\n* Why are the F1/AUC results in Table 2 not monotonic in the percentage of semantics-preserving permutations?\n* Could the authors provide examples of code where the relaxation of the interpretation graph to the program dependence graph is too conservative?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission8801/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698347836977,
        "cdate": 1698347836977,
        "tmdate": 1699637106633,
        "mdate": 1699637106633,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "PIQ06LvDmV",
        "forum": "zDMM4ZX1UB",
        "replyto": "zDMM4ZX1UB",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission8801/Reviewer_Srm2"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission8801/Reviewer_Srm2"
        ],
        "content": {
            "summary": {
                "value": "This paper introduces SymC, a novel approach that leverages code symmetries, defined through group-theoretic principles, to enhance large language models (LLMs) for program analysis. By embedding a group-equivariant self-attention mechanism within the Transformer architecture, SymC achieves significant improvements in understanding program semantics. The method demonstrates strong generalizability across various code transformations, outperforming existing state-of-the-art LLMs, including WizardCoder and GPT-4, by substantial margins in four specific tasks."
            },
            "soundness": {
                "value": "1 poor"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "1. The paper presents a unique and innovative approach to harnessing code symmetry, grounded in group theory, which stands out from previous methods that rely on ad-hoc heuristics. Instead of using these transformations for data augmentation, as is common in prior work, SymC ingeniously incorporates them into the attention layers of Transformers, showcasing a novel application.\n\n2. SymC's performance is noteworthy, as it surpasses the baselines across the various tasks presented in the paper, sometimes by a large margin."
            },
            "weaknesses": {
                "value": "1. The paper could benefit from a more comprehensive comparison with related works, such as DOBF (https://arxiv.org/abs/2102.07492), which exploits code symmetry in pretraining through a deobfuscation objective, and CodeT5 (https://arxiv.org/abs/2109.00859), which leverages code symmetry in pretraining with identifier-aware data augmentation. These related works were not discussed or compared to the proposed method in the paper.\n\n2. The evaluation framework relies heavily on four artificial tasks created by the authors, omitting well-established, practical benchmarks used commonly in the field. For instance, important code generation tasks like OpenAI HumanEval  (https://huggingface.co/datasets/openai_humaneval) and MBPP (https://huggingface.co/datasets/mbpp), as well as code translation, clone detection, defect detection, and code repair tasks from CodeXGLUE (https://github.com/microsoft/CodeXGLUE), are all relevant to the domain but were not considered. This absence of evaluation on existing benchmarks and comparison with related works raises questions about the paper's soundness and the model's real-world applicability.\n\n3. The paper does not discuss potential limitations of the SymC model, such as its requirement for input code to be processed by a parser and a static analysis tool. This requirement may limit the model's applicability when dealing with incomplete or syntactically incorrect code, such as in code completion tasks or when faced with an empty Python block. While it is acceptable to establish certain assumptions for input code, these assumptions must be explicitly discussed rather than overlooked."
            },
            "questions": {
                "value": "1. Can the authors provide a comparative analysis of SymC with related works such as DOBF and CodeT5 that also leverage code symmetry?\n2. Why were the evaluation tasks limited to four artificial tasks created by the authors?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission8801/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698510975814,
        "cdate": 1698510975814,
        "tmdate": 1699637106480,
        "mdate": 1699637106480,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "lxPosBP7P5",
        "forum": "zDMM4ZX1UB",
        "replyto": "zDMM4ZX1UB",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission8801/Reviewer_nM8R"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission8801/Reviewer_nM8R"
        ],
        "content": {
            "summary": {
                "value": "The authors introduce a group-theoretic framework that defines code symmetries as semantics-preserving transformations, enabling precise reasoning within LLMs. SYMC employs a novel variant of group-equivariant self-attention that is provably equivariant to code symmetries.\nThe evaluation results show that SYMC generalizes to unseen code transformations, outperforming the state-of-the-art code models by 30.7%."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "The idea of defining code symmetries as semantics-preserving transformations, enabling precise reasoning within LLMs is somewhat interesting. \nTo evaluate the approach, four analysis tasks that require a deep understanding of code behavior such that they are expected to stay invariant to code symmetries were considered. Also a set of real-world semantics-preserving transformations\nbeyond PDG automorphisms to evaluate SYMC\u2019s generalization in the experiments."
            },
            "weaknesses": {
                "value": "The paper needs more evaluations, e.g. an evaluation of the robustness of SYMC using the adversarial attack methods based on code transformations.\nSome contents are not well presented/stated."
            },
            "questions": {
                "value": "Q: As stated in the paper, current code LLMs struggle with generalization to new code. Have you tried to evaluate the robustness of SYMC using the adversarial attack methods based on code transformations? The evaluation may make your method more convincing. \n\nQ: Have you tried to compare with \"Graphcodebert: Pre-training code representations with data flow\", which is a state-of-the-art method considering the inherent structure of code, in your evaluation? \n\nQ: Page 5, \"PDG (VPDG,EPDG) is a super graph of IG, sharing the same vertices but having a superset of edges (EPDG \u2287 EIG), because we consider all memory accesses as aliasing, making PDG a conservative construction of IG\",\nIf you \"consider all memory accesses as aliasing\", which is apparently a very weak encoding of the program semantics, it seems there would be too many aliases in the programs, making most statements unexchangeable to accomplish semantics-preserving statement permutations?\n\nQ: Page 6, \"Each entry dij is a 2-value tuple (pij , nij), indicating the shortest path from the lowest common ancestor of Vi and Vj , denoted as Tij , to Vi and Vj , respectively\", is pij the positive distances and nij the negative distances as denoted in the next paragraph? Also, what do you mean by positive distances and negative distances?\n\nQ: Page 2, \"SYMC enforces its output to stay invariant via keeping its learned representation G-equivariant, where the code representation (e1, e2, e3, e4) is transformed into (e2, e3, e4, e1) xxx\", should \"(e2, e3, e4, e1)\" be \"(e2, e1, e3, e4)\" as shown in Figure 1a?\n\nQ: Page 9, the lines labeled 2nd, 4th, 6th in Figure 4a. Which lines are for Aut(PDG)-equivariant self-attention layers and which are for the Aut(PDG)-invariant ones?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission8801/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698566347212,
        "cdate": 1698566347212,
        "tmdate": 1699637106366,
        "mdate": 1699637106366,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "n5iubmHjds",
        "forum": "zDMM4ZX1UB",
        "replyto": "zDMM4ZX1UB",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission8801/Reviewer_6HuJ"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission8801/Reviewer_6HuJ"
        ],
        "content": {
            "summary": {
                "value": "This work explores invariance to symmetries in code that do not change the semantics of the code. This notion is formalized via automorphisms of program interpretation graphs. To achieve equivariance (and invariance) to these automorphisms, the authors use a self-attention based model with pairwise features based on an invariant distance matrix."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "1. Formalization of code symmetries as automorphisms of graphs is nice and seems like the correct formalism.\n2. SymC model achieves equivariance to the code symmetries under consideration in a natural way, which is not too different from existing Transformer-based models.\n3. Empirical results show that SymC outperforms strong baselines, while being small and robust to code symmetries."
            },
            "weaknesses": {
                "value": "1. Hard to understand exactly what program interpretation graphs and program dependence graphs look like, which is crucial to the paper.\n2. Experimental details are lacking. What is the training procedure for SymC, is it just supervised training on the downstream task? How about for the other models? For Function Name prediction, do the LLMs take in just the text as input, and what exactly does SymC take as input there?\n3. Computation of graphs associated to code may be costly and restrictive."
            },
            "questions": {
                "value": "1. Could you illustrate example program interpretation graph and program dependence graphs? This would be quite helpful for understanding.\n2. How costly is obtaining the code graphs?\n3. Why does SymC require \"40,162 lines of code\"? I'm curious as to what makes it require so much."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission8801/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission8801/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission8801/Reviewer_6HuJ"
                ]
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission8801/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698898398505,
        "cdate": 1698898398505,
        "tmdate": 1699637106265,
        "mdate": 1699637106265,
        "license": "CC BY 4.0",
        "version": 2
    }
]