[
    {
        "id": "1HAp7lpOj4",
        "forum": "oFNpRlPxyQ",
        "replyto": "oFNpRlPxyQ",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4465/Reviewer_a7Lb"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4465/Reviewer_a7Lb"
        ],
        "content": {
            "summary": {
                "value": "This paper proposes a pipeline scheduling framework, MSPipe, for memory-based TGNN training. The authors discuss the minimal number of staleness iterations and utilize the scheduler to delay memory fetching and prevent resource contention. Experiments validate that the proposed method achieves significant speedup with less accuracy degradation."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "1. This paper proposed a formulation for TGNN training pipeline and discussed the bottlenecks of the memory module and temporal dependencies. They designed a minimal staleness algorithm and lightweight staleness mitigation method for speeding up TGNN training with less accuracy loss. They also analyzed theoretical convergence to prove the robustness of the proposed method.\n\n2. The structure of the paper is clear and easy to follow.\n\n3. The experimental results are quite extensive."
            },
            "weaknesses": {
                "value": "1. The scale of the figures should be corrected. Especially in Figure 12. And some of the figures are out of text bound.\n\n2. In Experiments, as different datasets have different distributions of \\delta t, how can we find an optimal hyperparameter of \\lambda? This parameter selection should be discussed.\n\n3. Although the authors discuss the optimization and asynchronous training from previous work, the proposed method is still easy. The contribution seems insufficient."
            },
            "questions": {
                "value": "Please see above."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4465/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698596464795,
        "cdate": 1698596464795,
        "tmdate": 1699636422161,
        "mdate": 1699636422161,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "KlH8eogRb7",
        "forum": "oFNpRlPxyQ",
        "replyto": "oFNpRlPxyQ",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4465/Reviewer_Vi4E"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4465/Reviewer_Vi4E"
        ],
        "content": {
            "summary": {
                "value": "This paper, MSPipe, targets a timely problem: acceleration of (distributed) TGN training. MSPipe considers the 'memory update' procedure in the TGN training, which is the main bottleneck of the TGN training acceleration, and proposes two main ideas. In the baseline optimization, MSPipe overlaps the subgraph sampling and feature fetching. On top of it, first, it uses a staleness-based method to break the TGN memory dependency. Additionally, online scheduling minimizes the staleness bound. Second, using the similarity among vertices, it proposes a staleness mitigation method, which reduces the impact of staleness. With overlapping optimization, staleness-based strategy, and staleness mitigation, MSPipe provides a significant speedup from 1.50 to 2.45x."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "+ Adequately analyzed the training pipeline of TGNN training and accelerated it. While not very novel, this provides a reasonable and well-designed solution.\n+ Proposes some staleness mitigation strategy\n+ Provides significant throughput gain\n+ Various sensitivity studies in the appendix."
            },
            "weaknesses": {
                "value": "- Novelty is limited.\n- Some accuracy results does not make sense.\n- There is no discussion on GPU memory usage.\n- Baseline subgraph training methods are outdated compared to caching-based subgraph sampling acceleration works (e.g., SALIENT++).\n\nMSPipe provides an adequate training breakdown of TGNN training and targets to overlap the memory update procedure in TGN training. However, the staleness-based methods are widely used in GNN training. Even though MSPipe suggests that those works differ, the core idea is not very different: breaking the dependency, which is popularly used for GNN frameworks and algorithms.\nIn addition, when using a staleness-based strategy, the GPU memory usage should be reported, but there is a lack of such a discussion. The staleness mitigation method is interesting and valid but needs more details, and most importantly, it shows somewhat nonsense results in the LASTFM dataset. Overall, MSPipe is interesting and efficient, but some points should be addressed.\nWhile MSPipe points out that it differs from staleness-based works such as PipeGCN and Sancus"
            },
            "questions": {
                "value": "- In the LASTFM dataset, why does MSPipe achieve such high accuracy compared to TGL? Does the staleness mitigation strategy can outperform the AP of the baseline TGL?\n- Staleness-based strategies require more memory at the expense of the throughput increase. For example, in Fig. 1(c), when breaking the dependency, the intermediate GPU-memory usage may be twice as much more than the baseline training. Could the authors (theoretically) analyze and report the empirical memory usage overhead?\n- Recent works (e.g., SALIENT++, MLSys2023) propose caching-based methodologies to minimize the sampler overhead. Is MSPipe still a valid option when using such methods?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission4465/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4465/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4465/Reviewer_Vi4E"
                ]
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4465/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698820333449,
        "cdate": 1698820333449,
        "tmdate": 1700395122331,
        "mdate": 1700395122331,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "mcWxiEUEif",
        "forum": "oFNpRlPxyQ",
        "replyto": "oFNpRlPxyQ",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4465/Reviewer_juas"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4465/Reviewer_juas"
        ],
        "content": {
            "summary": {
                "value": "In the training process of memory-based TGNN, memory modules are used to store the temporal information computed by the RNN. These vectors, once computed on the GPU, are stored in the CPU memory, which introduces significant overhead, resulting in underutilization of the GPU. This work introduces staleness into the memory modules to break the time dependency, achieved through the minimal staleness algorithm. The algorithm determines the minimal staleness bound, denoted as 'k'. During the computation at the current i-th iteration, the results from the (i-k)-th iteration are used instead of the (i-1) iteration's results, allowing the training phases to be pipelined. This enables the GPU to seamlessly execute computations without waiting for data preparation, maximizing the TGNN training throughput. Additionally, this work proposes a similarity-based staleness mitigation method to further enhance the model's accuracy."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "1. Overall, the two optimization methods are reasonable.\n2. The experiment result is promising. It can be observed that the first optimization method, introducing staleness to break temporal dependencies, can improve training throughput and acceleration ratio. Furthermore, the algorithm identifies the minimal staleness bound 'k,' and experiments confirm its optimality in the trade-off between accuracy and throughput. The second optimization method, introducing a staleness mitigation approach, can enhance the model's precision. \n3. The method is novel. Inspired by PipeGCN's breakthrough in breaking the inter-layer dependencies of GNN, this work introduces, for the first time, a method to break the time dependencies of memory modules during TGNN training and provides detailed theoretical derivations."
            },
            "weaknesses": {
                "value": "1. Section 3.2 \"Minimal-staleness bound k\" should be the main contribution of this work, but the presentation is unclear. The process of determining the minimum k involves presenting three formulas corresponding to three constraints. The rationale behind the first two formulas is questionable, and it is not explained why these formulas satisfy the constraints.\n2. When conducting ablation studies, increasing the influence of GPU samplers is necessary, as TGL uses a CPU sampler, while MSPipe employs a GPU sampler. In addition to the four scenarios in Table 2, it is necessary to add scenarios where MSPipe uses a CPU sampler."
            },
            "questions": {
                "value": "1. In Section 3.2, titled \"Resource-aware online pipeline schedule\", it discusses pipeline scheduling after determining the Minimal-staleness bound, denoted as 'k.' In this section, Figure 6 is referenced for illustration. However, Figure 6(a) clearly does not satisfy the formula for determining the minimum 'ki' as outlined in Equation 1. Nevertheless, it does satisfy the constraints mentioned in the text, highlighting a contradiction between the formula and the stated constraints.\n2. The figure numbering is disordered: Fig. 7 appears before Fig. 6 in the text. The same figures appear multiple times: Fig. 4 (a) and Fig. 6 (a).\n3. The typo in Eqn.5: $j$ in second line should be $j+1$."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4465/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698832483903,
        "cdate": 1698832483903,
        "tmdate": 1699636421992,
        "mdate": 1699636421992,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "2a2I0O2HLW",
        "forum": "oFNpRlPxyQ",
        "replyto": "oFNpRlPxyQ",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4465/Reviewer_6Ut8"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4465/Reviewer_6Ut8"
        ],
        "content": {
            "summary": {
                "value": "Memory based TGNNs are an important subclass of TGNNs that rely on message passing to update node memory between events. However message updates suffer from a staleness problem. Since temporal edges are used as ground truth in self-supervised TGNNs, updates to node memory need to be delayed to avoid the information leak problem i.e., the updated memory of a node cannot be utilized for training during the current batch, instead the memory updates are applied at the end of each training iteration. Thus memory based TGNNs have temporal dependencies which affect training accuracy. In order to solve this problem, the authors propose a TGNN training framework called MSPipe which consists of a minimal staleness algorithm that 1) schedules the training pipeline by satisfying a minimal staleness bound condition and (2) exploits a  staleness mitigation method that leverages the memories of recently updated nodes with the highest similarity in order to reduce the staleness error. They provide experimental results comparing MSPipe  to existing TGNN  frameworks TGL and SALIENT."
            },
            "soundness": {
                "value": "1 poor"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "1 poor"
            },
            "strengths": {
                "value": "The paper formalizes the pipeline for memory-based TGNN training and proposes a staleness aware algorithm that ensures efficient training while minimizing the memory staleness bound.\n\nExperimental results show good runtime speedup with little decrease in accuracy."
            },
            "weaknesses": {
                "value": "The prime motivations behind this paper (eliminating staleness while improving training time)  are not valid.\n\n--- The paper proposes a pipeline scheduling framework to improve the runtime of TGL. As mentioned by the authors, the main factor that leads to inefficient TGN training is the dependency on the execution order of memory fetching and updating. The assumption that the memory update should be applied at the end of each training iteration is not valid. As shown in Fig. 2, both memory update and GNN training can naively be executed in parallel. The cost of a memory update can easily be overlapped with (absorbed by) GNN training, as GNN training is the main overhead. Therefore, there is no need to use stale memory. \n\n--This work is to improve previous work TGL. There seems to be a major design flaw. \u00a0They proposed to fetch a stale version of the node memory to overlap part of the mini-batch generation overhead with the actual training. However, there\u2019s no need to use stale memory at all, because updated node memory is firstly computed in the previous GNN training iteration, which can be directly used in the next iteration. The sampler can simply include the information of \u201cwhich node memory should be fetched from the global pool and which node memory should be used as in previous iteration\u201d in the mini-batch data. \n\nExperiments require improvements for soundness. \n\n-- The runtime breakdown shown in Table 1 seems doubtful. The sample overhead is larger than expected, considering that the authors have implemented a GPU-based most recent neighbor sampler and only one-hop neighbors are required for each node.\n-- MSPipe calculates a minimal staleness bound $k_i $ for each iteration $i$. However, there is a lack of experiments that demonstrate the variation of $k_i$ with respect to $i$. \n-- Fig. 11 depicts a fixed staleness bound value derived by MSPipe for one dataset, which can be confusing."
            },
            "questions": {
                "value": "This work is to improve previous work TGL. There seems to be a major design flaw. \u00a0They propose to fetch a stale version of the node memory to overlap part of the mini-batch generation overhead with the actual training. However, there\u2019s no need to use stale memory at all, because updated node memory is firstly computed in the previous GNN training iteration, which can be directly used in the next iteration. The sampler can simply include the information of \u201cwhich node memory should be fetched from the global pool and which node memory should be used as in previous iteration\u201d in the mini-batch data."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "1: strong reject"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission4465/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4465/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4465/Reviewer_6Ut8"
                ]
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4465/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699426380873,
        "cdate": 1699426380873,
        "tmdate": 1699636421929,
        "mdate": 1699636421929,
        "license": "CC BY 4.0",
        "version": 2
    }
]