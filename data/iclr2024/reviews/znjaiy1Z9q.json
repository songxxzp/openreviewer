[
    {
        "id": "rdbqGqqLeO",
        "forum": "znjaiy1Z9q",
        "replyto": "znjaiy1Z9q",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4893/Reviewer_6MQq"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4893/Reviewer_6MQq"
        ],
        "content": {
            "summary": {
                "value": "The paper addresses the standard problem of automatically parallelizing the serial version of the code to exploit the compute power of multi-cores in the relatively recent processors. The proposed method, *AUTOPARLLM*, combines GNN based technique to detect the parallelizable loops and then add only a custom defined OpenMP directives to parallelize the loop."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "- The paper addresses the problem of automatically parallelizing the source code as well as whether a given loop is parallelizable or not.\n- The paper is written reasonably and is easy to follow and understand.\n- Most of the recent literature in the sub-domain of automatic-parallelization is covered.\n- The OMPScore is also an interesting metric."
            },
            "weaknesses": {
                "value": "- The problem of OpenMP based auto parallelization is a well studied problem ever since the multi-cores became a common place in the modern CPUs. However, the paper tries to propose a limited version of the problem, that is only a loop can be parallelizable or not, if so just add private and/or reduce OpenMP clauses. Doing that with LLMs seem to be a too smaller of a task.\n   - Instead, more interesting would be to include all OpenMP pragmas, loop level scheduling, architecture aware compute efficiencies with hardware aware scheduling strategies, etc (for reference on see [1]). Combing all of these non-trivial loop level parallelizations would be a right task for such large capacity LLMs. \n- The difference in the execution times of the vanilla LLM generated parallel code versus AUTOPARLLM-CodeGen/GPT generated parallel code is so small <3.0 % (in the best case), it is difficult to state that the difference is significant. There is no mention of the reported execution times to be an average/median of multiple runs of the generated program from each method.  \n- Especially, given the availability of OpenMP enabled parallel programs in the open source, why not directly fine-tune an LLM to transform the serial code to parallel version.\n- There are approaches in LLM literature to transform one language code to another [2], why not try something similar to this directly to address the problem, of course, it requires some minimal refactoring int eh form of pre-train/fine-tuning these open CodeTransformer models.\n- The innovation side of the proposed approach are not appearing that great and convincing. It is simple use of multiple methods combined together, first the use of RGCN and then the LLM.\n   - In the methods section the details of loss functions at different components of the proposed method are missing. \n\n\n\n\n## References\n1. Chennupati G, Azad RM, Ryan C. Synthesis of parallel iterative sorts with multi-core grammatical evolution. InProceedings of the Companion Publication of the 2015 Annual Conference on Genetic and Evolutionary Computation 2015 Jul 11 (pp. 1059-1066).\n2. Z\u00fcgner D, Kirschstein T, Catasta M, Leskovec J, G\u00fcnnemann S. Language-agnostic representation learning of source code from structure and context. arXiv preprint arXiv:2103.11318. 2021 Mar 21."
            },
            "questions": {
                "value": "Please follow the weaknesses section for more details on the questions to be addressed."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4893/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698690635193,
        "cdate": 1698690635193,
        "tmdate": 1699636474137,
        "mdate": 1699636474137,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "0jOVShH4XZ",
        "forum": "znjaiy1Z9q",
        "replyto": "znjaiy1Z9q",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4893/Reviewer_PQiN"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4893/Reviewer_PQiN"
        ],
        "content": {
            "summary": {
                "value": "This paper introduces a framework for automatically identifying parallelism opportunities and generating appropriate program pragmas for auto-parallelization. The approach leverages a trained Graph Neural Network (GNN) to determine the most suitable parallelism pattern for a given loop nest, and then integrates the GNN's predictions into the prompt to guide a large language model (LLM) in rewriting the program with pragmas. The paper introduces a novel evaluation metric, OMPScore, for assessing auto-parallelization performance by combining regular expressions and program analysis. Experimental results reveal the superiority of this approach over the baseline method, which parallelizes programs directly using LLMs."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "+ The paper is clearly written with key concepts explained.\n+ The proposed OMPScore is carefully designed for evaluating the performance of auto-parallelization via OpenMP directives. \n+ The paper tries to tackle the problems of directive prediction and code generation at the same time to perform auto-parallelization. Such a task is significant and extremely challenging."
            },
            "weaknesses": {
                "value": "+ The paper uses large language models for code generation. As an auto-parallelizing framework, it is unclear whether we really need such LLMs. It appears that LLMs are primarily utilized for inserting pragmas into the outermost loop of a given loop nest, a task that could potentially be accomplished through simpler means such as loop analysis or pattern recognition. The paper could benefit from a more detailed explanation of the advantages of LLMs. For instance, could LLMs be employed to rewrite the code in a way that offers additional parallelization opportunities?\n+ The paper mentions that source-to-source compilers miss a lot of parallelism opportunities due to being overly conservative. However, the paper does not compare the optimization results against these compilers or manually-parallelized programs. Consequently, the true effectiveness of this approach remains uncertain.\n+ It seems that the OMPScore can only be applied to auto-parallelization with OpenMP directives. How does it compare to other metrics with parallel semantics (e.g., ParaBLEU[1])? Is there any common design philosophy of metrics targeting different code generation approaches?\n\n[1] BabelTower: Learning to Auto-parallelized Program Translation. International Conference on Machine Learning. PMLR, 2022."
            },
            "questions": {
                "value": "1.\tWhat are the advantages of adopting LLMs for auto-parallelizing?\n2.\tHow does AUTOPARLLM compare to source-to-source compilers or manually-parallelized programs (e.g., OpenMP version in NPB)?\n3.\tHow does it compare to other metrics with parallel semantics (e.g., ParaBLEU)? Is there any common design philosophy of metrics targeting different code generation approaches?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4893/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698719217032,
        "cdate": 1698719217032,
        "tmdate": 1699636474046,
        "mdate": 1699636474046,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "l4ZbOfwavf",
        "forum": "znjaiy1Z9q",
        "replyto": "znjaiy1Z9q",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4893/Reviewer_eS8a"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4893/Reviewer_eS8a"
        ],
        "content": {
            "summary": {
                "value": "The paper proposes a framework that incorporates LLMs to generate a parallel version of sequential programs. The idea is to first use a Graph Neural Network (GNN) to predict the parallel region and the possible OpenMP (OMP) clauses. This prediction can serve as a hint and can be included in the prompt to help the LLM generate better parallel code. The results demonstrate that the proposed method can achieve an average speedup of 2-3% in the benchmark dataset."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "1.\tThe idea of enhancing the prompt to generate better code is simple and reasonable.\n2.\tUsing GNN to predict the parallel region is novel and interesting.\n3.\tA new metric is proposed to provide a better evaluation for parallel code.\n4.\tThe evaluations show the effectiveness of the proposed methods."
            },
            "weaknesses": {
                "value": "1.\tGraph information is not clear: The authors used GNN to determine the parallel regions and predict the OMP clauses from the data-flow, control-flow, and call graphs. However, it remains unclear how the heterogeneous graphs are constructed and how the features of nodes are determined. Also, it would be better if the authors could provide the graph properties, such as the number of nodes, the number of node types, the number of edges, as well as the training details, such as training time and learning curves.\n\n2.\tCorrectness of the parallel version: The code generation heavily relies on GNN predictions; however, the training/test accuracy of the GNN predictions is not reported. What if the GNN gives a wrong prediction for the parallel regions or the OMP clauses? Furthermore, not all the parallel code can run correctly. The authors only reported the speedup but didn't mention if the program output matches that of the sequential version.\n\n3.\tImprovement is not significant: Although the authors claim that their methods can improve the execution time, a 2-3% speedup is not significant. It would be better to conduct multiple runs and report the mean and variance of the execution time to determine if it can indeed bring improvements. Alternatively, the author can demonstrate in which scenarios the framework can achieve more significant improvements.\n\n4.\tHeavily rely on the ability of LLM: Table 4 shows similar improvement across different LLM models. However, it also indicates that only stronger LLMs can generate better parallel code, which means the proposed method has a higher probability of generating suboptimal results when using weaker LLMs.\n\n5.\tThe ability to handle large programs: It appears that the evaluation only considers a single loop at a time. However, real-world programs may have hundreds of parallel regions. There is no evidence that the proposed method can handle multiple parallel regions at once, which may limit its contribution.\n\n6.\tComparison with Chain of thoughts: The idea of the proposed method is to use another model (GNN) to generate better prompts to guide the LLM in generating better results. The root cause is that LLMs cannot generate good results at once without hints. Therefore, it would be reasonable to compare it with the Chain of Thoughts method [1], which aims to complete a task using multiple intermediate reasoning steps. The GNN prediction part can be replaced with another prompt for the LLMs, and the output can be part of the next prompt. This could potentially yield better results compared to using only the basic prompt and could reduce the time required to construct the graphs and train the GNN model.\n\n7.\tNew metric OMPScore: The OMPScore is an extension of the Rough-L score, which is measured by the longest common subsequence. However, almost all the OpenMP pragmas share the same subsequence, ``#pragma omp parallel for``. Therefore, it doesn't appear to be a suitable metric. Additionally, the authors claim that the OMPScore metric has a high correlation with human evaluation, with a 99.99% Spearman correlation. Considering the potential human bias, it is not entirely convincing to achieve such a high correlation. It is recommended that the authors provide the details or raw data of the evaluation for both the OMPScore and the human evaluation to support this claim.\n\n[1] Wei, Jason, et al. \"Chain-of-thought prompting elicits reasoning in large language models.\" Advances in Neural Information Processing Systems 35 (2022): 24824-24837."
            },
            "questions": {
                "value": "The idea is simple and clear, but more details should be provided in the methods. Improving LLM generation by prompt engineering is not novel, as far as this reviewer is concerned. Using GNN to predict the parallel region is novel, but it is not quite convincing. It's hard to determine if it can be reproduced, especially regarding the GNN training, execution time improvement, and human evaluation for the metrics.  Can the authors comment on the novelty of the proposed approach, i.e. how does the proposed approach improve over the state-of-the-art?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission4893/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4893/Reviewer_eS8a",
                    "ICLR.cc/2024/Conference/Submission4893/Senior_Area_Chairs"
                ]
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4893/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698788427452,
        "cdate": 1698788427452,
        "tmdate": 1700690249330,
        "mdate": 1700690249330,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "uJrRsUktGu",
        "forum": "znjaiy1Z9q",
        "replyto": "znjaiy1Z9q",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4893/Reviewer_pN6K"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4893/Reviewer_pN6K"
        ],
        "content": {
            "summary": {
                "value": "In AutoParLLM the authors introduce a new guidance technique for prompting large language models for code to parallelize a presented piece of software by inserting OpenMP directives. To better measure the parallelization performance the authors additionally introduce a new evaluation metric called OMP-Score to better capture the preferences of parallelized code. The guiding graph neural network first learns the control flow, data flow, and call flow of the program, before feeding this additional context to the large language model, which is being prompted to parallelize the presented piece of code.\n\nThe guidance with graph neural networks produces consistently better results across established evaluation metrics, as well as the new OMP-Score across a set of 4 of the most commonly used large language models for code with CodeGen, CodeLLama, and the commonly used GPT-3.5, and GPT-4. Human evaluation of the OMP-Score with 2 experienced software engineers shows good alignment between the rating through OMP-Score, and the human rating of produced results."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "4 excellent"
            },
            "strengths": {
                "value": "With a strong clarity of exposition the strength of the paper lies in its clear story-line, which is complemented by strong evaluations on established benchmarks. Including a strong outperformance of the approach on the BLEU, CodeBLEU, Rogue-L, METEOR, CodeBERTScore, and OMPScore, as well as the more close to practice measurement of execution time.\n\nThe clear explanation of intuitions behind decisions, and the GNN-guidance make the paper very easy to understand, and is refreshing in its clarity. In addition the key contribution of the paper, the GNN-guidance to provide context to the LLM-query, is clearly pointed out and illustrated what this means for the prompts in practice.\n\nThe strong performance across all benchmarks only backs this contribution up further."
            },
            "weaknesses": {
                "value": "While the aforementioned analysis of the GNN-guidance for LLMs is very thorough, extensive, and backed up with strong results across the evaluation metrics, and execution time, I believe that the same cannot be extended to the proposed OMPScore metric. As such I would urge the authors to extend the evaluation, and validation of OMPScore as a new evaluation metric either in the core paper, or in the appendix.\n\nIn addition, I would urge the authors to include further literature references in related work. As the presented approach relies on the compilation through IR two works that stand out, and should see inclusion are:\n- Transcoder-IR --> Code translation with Compiler Representations\n- Automap/PartIR --> Automap: Towards Ergonomic Automated Parallelism for ML Models"
            },
            "questions": {
                "value": "- With the strong outperformance of AutoParLLM on the established evaluation metrics, as well as OMPScore, how would the authors explain that the average speed on the execution time is closer to 2-3%?\n- Taking CodeLlama as an example, would it be possible to additionally repeat the evaluation for the different sizes of CodeLlama available to verify that the authors claim holds across differently sized models?\n- Only having focussed on OpenMP CPU-parallelization, do you see this approach extending to OpenMP device offloading, where there is much less code available?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4893/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699012140183,
        "cdate": 1699012140183,
        "tmdate": 1699636473866,
        "mdate": 1699636473866,
        "license": "CC BY 4.0",
        "version": 2
    }
]