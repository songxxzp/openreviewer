[
    {
        "id": "ua7LBO3xT6",
        "forum": "mz8owj4DXu",
        "replyto": "mz8owj4DXu",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission1284/Reviewer_hwoc"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission1284/Reviewer_hwoc"
        ],
        "content": {
            "summary": {
                "value": "This presents Scalable Language Model (SLM), a new continual learning method for language modeling. It combines frozen large language models with Joint Adaptive ReParameterization (JARe) to adaptively adjust for new tasks. Experimental results show strong performance compared to popular continual learning methods."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "1. This is first paper to utilize a large language model such as llama2-7b to study continual learning problems on a larger scale. This should bring the research in the domain to the next level.\n2. Experimental results are strong.\n3. The proposed method is novel, and is indeed a new paradigm for continual learning. Prior methods heavily rely on memory replay, and this method explores a very different direction."
            },
            "weaknesses": {
                "value": "1. It may be harder to reproduce the method compared to prior ones, as it is quite different from existing methods."
            },
            "questions": {
                "value": "NA"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission1284/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698732793191,
        "cdate": 1698732793191,
        "tmdate": 1699636055430,
        "mdate": 1699636055430,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "34mxkJdW9u",
        "forum": "mz8owj4DXu",
        "replyto": "mz8owj4DXu",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission1284/Reviewer_phuQ"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission1284/Reviewer_phuQ"
        ],
        "content": {
            "summary": {
                "value": "This paper tackles the continual learning of large language models. The major idea is to save the individual task adaptation parameters in an efficient manner by using LoRA, then during the adaptation time, they proposed a way to mix the LoRA parameters. To mix such LoRA parameters, this paper suggests defining a metric function that measures the similarity of the task by using the extracted feature from an external model, i.e., sentence BERT. The paper shows better results than prior continual learning works in LLMs in several domains."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "4 excellent"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "**Strengths**\n\n(1) The overall presentation is very good, and the writing is very clear.\n\n(2) The method is sound and shows effective performance.\n\n(3) This direction resembles the recent interests of model soup [1], and also some prior works in meta-learning that linearly interpolates the learned modulations to adapt the current model [2]. I think it would be great to discuss the connection.\n\n------------\n\nReference\\\n[1] Wartsman, Model soups: averaging weights of multiple fine-tuned models improves accuracy without increasing inference time, ICML 2022\\\n[2] Triantafillou et al., Learning a Universal Template for Few-shot Dataset Generalization, ICML 2021"
            },
            "weaknesses": {
                "value": "**Weaknesses**\n\n(1) I disagree with the claim regarding the weakness of replay-based methods in the introduction. \n- While I do agree that replay-based methods require additional storage to save the previous datasets, this paper also requires saving the parameters of the previous task's low-rank parameters and saving the keys. \n- Since text dataset saving does not require much storage, **I believe comparing the storage is needed** for a fair comparison.\n\n(2) Comparing with the upper bound performance will be interesting by assuming the ideal update is made (i.e., D(p, p_i)=0 for non-relevant tasks and D(p, p_i)=1 for the current task). Maybe such results are not an upper bound, as the method has benefits on forward transfer.\n\n(3) Also, as the proposed and (c) task-id needed scenarios assume additional parameters (for adaptation), I believe outperforming replay-based, and regularization (e.g., EWC) is somewhat trivial. Furthermore, the proposed method requires an additional model like sentence-Bert.\n\n(4) Due to the fact that data replay is not a big issue (as mentioned in (1)), I think adding more baselines related to data replay is needed, e.g., online SGD or other replay-based approaches [1].\n\n------------\n\nOverall, I quite liked the paper's approach, and the paper has the strength to be accepted to the venue. While there are weaknesses (e.g., additional parameters and network like Sentence-BERT), I believe they can be solved by re-claiming the weakness of prior methods and by highlighting the weakness of the proposed method in the manuscript, e.g., in the discussion section. Therefore, I recommend, weak acceptance, assuming that the weakness will be addressed throughout the rebuttal.\n\n------------\n\n**Reference**\\\n[1] He at al., Analyzing the Forgetting Problem in Pretrain-Finetuning of Open-domain Dialogue Response Models, EACL 2021"
            },
            "questions": {
                "value": "See above"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission1284/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698755745279,
        "cdate": 1698755745279,
        "tmdate": 1699636055339,
        "mdate": 1699636055339,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "oSeu6zbRCM",
        "forum": "mz8owj4DXu",
        "replyto": "mz8owj4DXu",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission1284/Reviewer_US6d"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission1284/Reviewer_US6d"
        ],
        "content": {
            "summary": {
                "value": "- This paper proposes the Scalable Language Model (SLM) which accumulates knowledge over a sequence of tasks in a continual learning setup.\n- In SLM, for each task, the task knowledge is preserved in vector space as multiple (key, value) pairs where the keys are the vector representations of the centroid of the distributions of different groups within the task distribution, and the values are the corresponding weight increments which indicate the change/delta in weight parameters over the pre-trained model parameters after training on the task dataset. Here, low-rank adaptation techniques are used to store the weight increments to avoid computational overhead.\n- SLM integrates vector space retrieval into the language model to achieve scalable knowledge expansion and management \n- Specifically, SLM uses (a) Dynamic Task-related Knowledge Retrieval (DTKR) to fetch the most relevant knowledge (weight increments) for an input instance from the vector space based on its distribution, and (b) Joint Adaptive Re-parameterization (JARe) to adaptively consolidate the fetched weight increments and re-parameterize the model parameters to align them with the downstream task distribution.\n- In this way, SLM eliminates reliance on \"regularization constraints\" over weight parameters, \"data replay\" and \"inference task-IDs\", which makes it generalizable and scalable.\n- Extensive experimental setup demonstrates the efficacy and stability of the model. The proposed SLM model achieves an 80% reduction in catastrophic forgetting while only losing 0.5% of the performance on the BERT benchmark."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "4 excellent"
            },
            "strengths": {
                "value": "- Originality\n\t- The authors have proposed a novel continual learning (CL) method, the Scalable Language Model (SLM), which eliminates the use of \"regularization constraint\" and \"data replay\" using vector space retrieval of relevant past knowledge, thus making it scalable across a variety of downstream tasks.\n\t- Although it seems that SLM aligns with the CL methods which incorporate additional trainable parameters for each encountered task in the sequence, however, SLM does not append additional parameters in the model itself, the knowledge acquired from the past tasks (weight increments) can be selectively utilized for future tasks thus enabling efficient knowledge transfer, and does not require the task-ID at the inference time which makes it more generalizable.\n- Quality\n\t- The motivation is well-founded and the claims are sound.\n- Clarity\n\t- Mathematical formulation is very detailed and explanatory.\n\t- Paper is clearly presented and easy to follow.\n- Significance\n\t- The proposed SLM model is effective and consistently demonstrates state-of-the-art performance by outperforming baseline methods on diverse backbones and benchmarks.\n\t- Moreover, the SLM method goes beyond single task type and explores continual learning setup with diverse task types and data domains thus boosting its scalability claims."
            },
            "weaknesses": {
                "value": "- Quality\n\t- The number of data points in a task should also be considered while using the weight increments from that task during the retrieval step, otherwise, weight increments of the task with 100 data points will have the same importance/impact as the task with 10000 data points. Just like it happens in the weighted averaging strategy used in the FedAvg algorithm in federated learning settings.\n\t- The computational complexity of the proposed model seems high as the training is done for one data instance at a time and that too involves vector space retrieval of top-K relevant weight increments for each training example. Therefore, it would be fair if the authors could provide a comparison of time spent in training the proposed SLM method as compared to the baseline methods.\n- Clarity\n\t- It would further improve the understanding of the proposed method if authors could also provide an algorithm for the inference phase.\n\t- It is not clear how authors have performed the initialization of (key, value) pairs for each task as mentioned in algorithm 1. It would be better if the authors could provide the mathematical formulation of this initialization strategy.\n- Significance\n- Typographical errors\n\t- [Section-3.1, Line-1] \"researchs have\" -> \"research has\" or \"works have\""
            },
            "questions": {
                "value": "- As the pretrained model $f_s$ is frozen and $f_{\\theta}$ is always initialized with the same pre-trained initial weights, the keys of tasks with similar distributions can overlap with each other. In such cases, their values i.e., weight increments, should also be similar to each other. To understand this numerically, have authors done any such analysis to study the similarity between (key, value) pairs across tasks?\n- Related to the above question, during the inference phase if DTKR provide similar (key, value) pairs from different tasks, then is there any mechanism to avoid this as they will provide redundant information and can be ignored for other relevant but non-overlapping knowledge?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission1284/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698762007362,
        "cdate": 1698762007362,
        "tmdate": 1699636055273,
        "mdate": 1699636055273,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "XoeBpgSxeB",
        "forum": "mz8owj4DXu",
        "replyto": "mz8owj4DXu",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission1284/Reviewer_3jYk"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission1284/Reviewer_3jYk"
        ],
        "content": {
            "summary": {
                "value": "The authors present a novel approach aimed at continual learning of new tasks without the requirement of revisiting examples from preceding tasks, nor necessitating the taskID during the inference phase on the examples from the trained tasks. The proposed method hinges on the learning of keys and values, represented by low-rank weight matrices. Initially, the keys are learned for a task by aligning them closely with the input features derived using a frozen encoder from examples of the task. Subsequently, based on the keys, the corresponding low-rank matrices are fine-tuned. The method demonstrates superior performance compared to previous approaches."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "1. The proposed method exhibits good results on continual learning benchmarks as evidenced by the experiments \n2. The simplicity of the method, along with the lack of additional overhead, stands out."
            },
            "weaknesses": {
                "value": "1.The method's description appears somewhat convoluted, making it challenging to grasp the benefits fully. Relevant questions highlighting each part are in the Questions section.\n\n2. A basic baseline employing an average feature extractor across examples of a task as a key and training a singular low-rank weight for each task as value is absent. In this method, each task would have just one key and one low-rank weight, and retrieval for examples from a new task or an existing task could be executed using either Top-1 or Top-k with existing keys.\n\n3. The retention of performance on trained tasks seems less beneficial since for inference on an example originating from one of the trained tasks, the already trained model could simply be employed. The principal advantage of these continual systems lies in their capability to be deployed for inference as zero-shot evaluation. However, the results from Table 6 appear unconvincing as the baseline LLAMA model already exhibits decent performance. A more robust experiment could entail learning a sequence of tasks continually and evaluating the zero-shot performance with every newly learned task, please see training datasets from T0 Held-in as depicted in Figure 2 from https://arxiv.org/abs/2110.08207 for experimental setup."
            },
            "questions": {
                "value": "1. Is the preparation phase conducted collectively for all tasks, or is it executed sequentially\u2014preparation followed by fine-tuning\u2014for each task individually?\n2. For clarification, during each task, are the keys and low-rank weights updated utilizing the examples specific to that task? Upon the introduction of a new task, are these keys and low-rank weights frozen, or are they further fine-tuned?\n3. What is the initial count of keys, and is it dependent on the number of future tasks? If yes, this assumption appears unreasonable as the total count of tasks is undisclosed initially.\n4. How is the aggregation across groups achieved, especially given that in each group, the query is of reduced size, and are keys of reduced size too?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission1284/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission1284/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission1284/Reviewer_3jYk"
                ]
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission1284/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698869188280,
        "cdate": 1698869188280,
        "tmdate": 1699636055197,
        "mdate": 1699636055197,
        "license": "CC BY 4.0",
        "version": 2
    }
]