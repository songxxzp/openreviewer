[
    {
        "id": "RZ5MQ86XEk",
        "forum": "Tpk0p9QBM6",
        "replyto": "Tpk0p9QBM6",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4090/Reviewer_n51E"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4090/Reviewer_n51E"
        ],
        "content": {
            "summary": {
                "value": "The paper addresses the challenge of computing minimum-entropy couplings (MEC) for large-support distributions. \nMEC aims to find a joint distribution with the least joint entropy given two specific marginal distributions.\nExisting algorithms that find provable approximations for such couplings are unsuitable for very large-support distributions. \nCurrent heuristic methods, called Iterative Minimum-Entropy Coupling (IMEC), have limitations in handling these distributions.\n\nContributions:\n* Unified IMEC Algorithms: The authors provide a unified framework for IMEC algorithms using sets of partitions.\n* ARIMEC Introduction: Leveraging the unified view, a new method, ARIMEC, is introduced. It computes low-entropy couplings for any large-support distribution. Efficiency improvements, like lazy updates and entropy bounds, are incorporated.\n* Empirical Results: ARIMEC's effectiveness is showcased in Markov coding games and steganography, resulting in improved communication rates.\n\nThe paper presents a novel approach, ARIMEC, to compute low-entropy couplings for large-support distributions and validates its utility with real-world applications. \nThe authors promise to share their codebase with the community."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "4 excellent"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "As the author states, this paper has three contributions. Let's discuss the strengths of each in order.\n\n1. Unified IMEC Algorithms\nThe key strength of the unified IMEC framework, based on the description, seems to lie in its flexibility through the use of partitions. \nDepending on how these partitions are selected, different algorithms or strategies can be realized. \n\n2. ARIMEC Introduction\nThe proposed ARIMEC algorithm falls into the unified IMEC framework. \nIn the framework, irrespective of the specific autoregressive structure or the particularities of the marginal \\mu, \nthe algorithm can always satisfy the three conditions: Condition 3.1, 3.2 and 3.3. \nThis capability is significant because it allows ARIMEC to be applied to a wide range of problems or datasets \nthat have an autoregressive nature without the need for tweaking the algorithm for each specific case.\n\n3. Empirical Results\nilding on the work of Sokota et al. (2022), the authors explore an application of ARIMEC in the communication of messages \nthrough Markov decision processes. It's a unique application that hasn't been frequently touched upon in literature."
            },
            "weaknesses": {
                "value": "* The experiments seem to be heavily centered around specific domains like Markov coding games and steganography. \n  While these are valuable explorations, they might not give a complete picture of ARIMEC's versatility across other potential domains or applications.\n  I'd like a bit more discussion on the potential applications of ARIMEC."
            },
            "questions": {
                "value": "* In Section 3, a unified view of IMEC is proposed, but are there any existing algorithms to be unified other than TIMEC and FIMEC?\n* Figure 3, why do you compare Token-wise Error Rate?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4090/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698550852620,
        "cdate": 1698550852620,
        "tmdate": 1699636373589,
        "mdate": 1699636373589,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "FTl9scqE2B",
        "forum": "Tpk0p9QBM6",
        "replyto": "Tpk0p9QBM6",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4090/Reviewer_dCYg"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4090/Reviewer_dCYg"
        ],
        "content": {
            "summary": {
                "value": "The paper provides an efficient algorithm for min-entropy coupling that the authors call ARIMEC. The best previously known algorithm required one of the distributions to be  factorable into blocks with small supports, while their algorithm doesn't require that."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "The result is new and seems to be strong. It answers an open question from Sokota et al. (2022). The paper is easy to read, the main result is clear and its comparison with the state of the art is explained. The idea is nice and simple."
            },
            "weaknesses": {
                "value": "Even though I like the idea, the approach is not very sophisticated, it combines some standard (but non-trivial) combinatorial techniques with the results of prior works.\n\nAlso, even though the paper is easy to read, there are no rigorous formulations of the results in the main part of the paper, and some statements are not very precise (e.g. I find usage of terms like \"small\" in formal conditions not very nice)."
            },
            "questions": {
                "value": "I do not have any specific questions, since the paper basically solves the problem as it was stated in Sokota et al. (2022). Maybe just a high-level question: Did you think of any potential future directions where your approach could be useful?\n\nSuggestions: As I said before, I would also write conditions in more formal manner (e.g. I recommend to replace \"small\" by something concrete and formal, and then add a high-level explanation below or above the formal definition). I also recommend to write your results as theorems (and keep current high-level explanations close to the formal statements)."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission4090/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4090/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4090/Reviewer_dCYg"
                ]
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4090/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698766939105,
        "cdate": 1698766939105,
        "tmdate": 1699636373516,
        "mdate": 1699636373516,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "lXqtTvvdsn",
        "forum": "Tpk0p9QBM6",
        "replyto": "Tpk0p9QBM6",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4090/Reviewer_caMu"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4090/Reviewer_caMu"
        ],
        "content": {
            "summary": {
                "value": "Minimum entropy coupling (MEC) is the following problem. Given marginal distributions of two finitely supported random variables X and Y, find a joint distribution \\gamma on X and Y (called a \u201ccoupling\u201d of X and Y) s.t. the entropy of \\gamma is as small as possible. In addition to being a natural problem from a theoretical point of view, MEC also has various practical applications, including steganography (the art of hiding secret messages in plain sight).\n\nThe authors propose a unified framework that captures previous approaches to MEC and propose a novel *heuristic* algorithm for MEC called ARIMEC. That is, their method does not have provable guarantees regarding the entropy achieved by the output coupling. The reason for this is that MEC is NP-hard (where the instance size is defined to be the support size of X and Y) and provable approximation algorithms for MEC run in O(N log N) time, where N is the support size. In many interesting practical applications, the support size N is often extremely large so even linear-in-N time is considered too slow. Thus, the authors turn to heuristic algorithms and argue for the utility of their approach via empirical evaluation."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "The unifying framework using collections of partitions is relatively simple and nicely captures previous approaches, though its exposition could be improved. In addition, the application to steganography is interesting. Heuristic MEC algorithms, despite their lack of rigorous guarantees, could lead to interesting future work on steganography using large language models (LLMs) since for LLMs we have full access to the generating distribution."
            },
            "weaknesses": {
                "value": "The paper's failure to address several important issues, in addition to the numerous ambiguities in the exposition, diminishes the paper's overall quality. Therefore, I am inclined to reject the current version of the paper. My concerns include the following.\n\n- **Basic MEC setup is unclear.** Throughout the paper, the authors seem to *implicitly* assume that X, Y are both vectors (or strings). In fact, the prefix tree in Section 4 does not even make sense unless elements of X are strings. This implicit vector assumption is also used in Section 2.3, Algorithm 1 and 2. However, this assumption on the structure of X and Y doesn\u2019t seem to be stated explicitly anywhere in the paper.\n    \n    Also, what kind of access do we have to the marginals of X and Y? Do we get black-box queries to the probability mass evaluations? Is it a sampling oracle?\n    \n- **Notion of efficiency is never formally defined.** The main reason for using heuristic MEC algorithms instead of the provable approximation algorithms is to avoid the log-linear-in-N run time. Computational efficiency, at least in CS, is always be defined relative to some problem instance size (i.e., it is an asymptotic notion). If N is \u201ctoo big\u201d, then what is the right index for the instance size for MEC? This would make sense if one explicitly assumed that X is supported on {0,1}^n and Y is supported on {0,1}^m, and we call any quantity \u201ctoo large\u201d or \u201cintractably large\u201d if it grows superpolynomially in n or m.\n\n- **Small support size of conditional distributions does not imply efficient sampleability (Condition 4.6).** Suppose X is a random vector in {0,1}^n defined as the output distribution of a pseudorandom generator (PRG), i.e., the pushforward of the uniform distribution over {0,1}^s through the PRG. Clearly, each conditional distribution arising in the autoregressive form of this distribution is supported on {0,1}, which is of size 2. However, these conditional distributions are not even efficiently computable (since they are given by a PRG).\n\n- **Missing run-time analysis of subroutines.** In Algorithm 3 (IMEC), is it clear that the optimization over the collection of partitions U can be implemented efficiently?\n\n- **Motivation for ARIMEC.** In what sense is ARIMEC better than previous approaches? In the regimes where TIMEC and FIMEC performs well, is it expected that ARIMEC performs not worse than these two approaches? Also, what is the motivation behind using partitions defined using the prefix tree?\n\n- **Missing details on the steganography task.** Details of the steganography experiment are missing (even including Appendix D), which makes it hard to understand what experiment is exactly being conducted here. Could the authors please expand on the last paragraph of Section 5?"
            },
            "questions": {
                "value": "- What kind of access do we have to the marginals of X and Y? Do we get black-box queries to the probability mass evaluations? Is it a sampling oracle?\n- In Condition 2.5, what qualifies as \u201csmall\u201d support size and what quantifies as \u201cintractably large\u201d?\n- In Algorithm 3 (IMEC), is it clear that the optimization over the collection of partitions U can be implemented efficiently?\n- If the encoding is perfectly secure (i.e., encoding of ciphertext X into stegotext S is deterministic) and the distribution of stegotext S and covertext C is the same, doesn\u2019t this mean that one can \u201challucinate\u201d secret messages from innocuous text?\n\n**Editorial comments**\n\n- The NP-hard reference is rather misleading. For the NP-hardness result, the instances are indexed by N, the support size. Even if MEC were in P, this would not suffice for the setting this paper is interested in.\n- In the Algorithm boxes, the subscript 1:j-1 doesn\u2019t make sense for j = 1."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4090/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699399662335,
        "cdate": 1699399662335,
        "tmdate": 1699636373450,
        "mdate": 1699636373450,
        "license": "CC BY 4.0",
        "version": 2
    }
]