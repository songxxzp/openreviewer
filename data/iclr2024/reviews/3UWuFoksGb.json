[
    {
        "id": "HRFypKT79y",
        "forum": "3UWuFoksGb",
        "replyto": "3UWuFoksGb",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission6513/Reviewer_NUXY"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission6513/Reviewer_NUXY"
        ],
        "content": {
            "summary": {
                "value": "This work proposes a framework that learns state and action abstractions for planning. It does this by leveraging demonstrations with corresponding language annotations. These demonstrations are used to discover actions, which in turn is used to generate state abstractions. Finally, low-level policies are also learned corresponding to the high-level actions. The evaluation is done on two domains and the results show generalization wrt environments and objects."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "1. The paper is well written. Except for the algorithm description, other parts like motivation, problem formulation, etc., are explained nicely.\n2. The approach seems to be novel."
            },
            "weaknesses": {
                "value": "1. Other related approaches: \n* There are related approaches that use language to guide the abstraction process. E.g., Peng et al., the difference is that human input. Here, this paper gets it in the form of language-annotated task descriptions.\n* Approaches like LIV (with PointCLIP instead of CLIP) can learn a latent representation, which can be used for planning. \n\nPeng et al., Learning with Language-Guided State Abstractions.\n\nLIV: Ma et al., LIV: Language-Image Representations and Rewards for Robotic Control.\n\nCLIP: Radford et al., Learning Transferable Visual Models From Natural Language Supervision.\n\nPointCLIP:  Zhang et al., PointCLIP: Point Cloud Understanding by CLIP.\n\n\n2. Reproducibility:\n* I am not sure how reproducible the work is. There are a large number of details that are swept under the rug. And without an algorithm, it gets difficult to follow the paper. The supplementary material is also not submitted. \n* The inputs are not clear. \n\n3. Experimental Evaluation:\n* I would suggest performing experiments for the accuracy of the feasibility function. \n* The experiments from the grid-like BabyAI setup are not convincing of generalization. The paper claims to withhold \"red key\" in training, but they can learn the model agnostic to such properties. So, this is more of a verification that their approach works. But as we can see, the accuracy for novel concept combinations is only 91\\%.\n\nMinor points:\n* Incorrect citation: I do not believe Silver et al. learn (invent) new predicates as stated in the last two lines of page 1."
            },
            "questions": {
                "value": "1. Who provides the examples for prompting in Fig. 3 left?\n2. The training is performed on how many tasks? Was the environment structure the same for all of them? Or was it changed in between tasks? If it was changed, was it ensured that the test environment configuration was not present in the training set? \n3. What is the reason for not achieving 100\\% accuracy for novel concept combinations?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission6513/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6513/Reviewer_NUXY",
                    "ICLR.cc/2024/Conference/Submission6513/Senior_Area_Chairs"
                ]
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission6513/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698798802653,
        "cdate": 1698798802653,
        "tmdate": 1700698200753,
        "mdate": 1700698200753,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "qBFSdARy55",
        "forum": "3UWuFoksGb",
        "replyto": "3UWuFoksGb",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission6513/Reviewer_V9Cw"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission6513/Reviewer_V9Cw"
        ],
        "content": {
            "summary": {
                "value": "The paper introduces a framework for learning state and action abstractions from language-annotated demonstrations. The abstract actions and states are use to train a transition model in the latent space to learn the feasilbility of newer latent actions. This allows agents to generalize actions learned from language to longer, unseen tasks."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "**Originalty:** The paper investigates a problem is not tackled in the literature but can realistically exist. The paper is a novel and creative framework for addressing this problem.\n\n**Clarity:** The paper is well-writtten.\n\n**Significane:**  This work has the potential to be impactful in language-based agent interactions. Furthermore, the framework can be adapted to other sequential planning domains. \n\n**Quality:** The problem described is well-motivated. The approach to addressing the problem is laid out clearly and simply and it reads reasonably. The model framework is creative and intuitive. The experimental design is sound and makes sense to test their claims and results support the claims made by the authors."
            },
            "weaknesses": {
                "value": "I don't have any major gripes. However, I found the description of the experimental domains lacking. Particularly I am not totally clear on the difference between the key-door and two-corridor environments."
            },
            "questions": {
                "value": "No questions."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission6513/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6513/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6513/Reviewer_V9Cw"
                ]
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission6513/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698798879650,
        "cdate": 1698798879650,
        "tmdate": 1699636731466,
        "mdate": 1699636731466,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "afYcjwCM4p",
        "forum": "3UWuFoksGb",
        "replyto": "3UWuFoksGb",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission6513/Reviewer_B6My"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission6513/Reviewer_B6My"
        ],
        "content": {
            "summary": {
                "value": "The paper proposes a framework for solving problems in sequential-decision making by combining LLM-generated high-level abstract actions, imitation learning and a low-level policy by a framework-agnostic traditional RL agent.\n\nThe pipeline in more detail is that given a prompt in human language which defines \u201ca language goal\u201d, an LLM decomposes to a verb and corresponding nouns and adjectives (e.g. \u2018place\u2019, \u2018bowl\u2019, \u2018green\u2019), with the assumption that these prompts can always be decomposed to this format. After this,\n\n- a state abstraction function is learned that can identify the objects in the environment\n\n- an abstract transition model is learned which predicts the next state given the current abstract state and high-level action. This model also has a feasibility component that predicts whether a future action can accomplish the language goal\n\n- A breadth-first search algorithm selects the shortest sequence of actions that accomplishes the language goal\n\n- Finally, a low-level policy is applied according to the sequence of high-level actions. These policies are learned with traditional RL\n\nThe paper tests the method on two environments: BabyAI (three task setting) and Kitchen-Worlds (two task settings), compare against low-level (regular) and high-level (when the agent has access to the defined ) RL in the former and Goal-Conditioned BC in the latter."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "Originality: the paper proposes a novel way to solve sequential decision making problems by combining LLM prompting, imitation learning and traditional reinforcement learning.\n\nQuality: the paper places the work in the literature very well, comparing the differences between previous works and mentions future work. The problem formulation is mostly clearly written up.\n\nClarity: The paper is mostly well-written and apart from a few inconsistencies, easy to understand.\n\nSignificance: its originality could be considered significant."
            },
            "weaknesses": {
                "value": "I have three main reservations:\n\n- There is no available code, no experiment details (chosen hyperparameters, tuning) about the algorithm or the baselines and as such the results are not reproducible\n\n- The experiments themselves, the results, and the metrics are described in a very high level without details which does not allow the reader to indeed verify how well they support the claims.\n\n- Scalability: as the number of actions, objects and their combinations increase, the necessary training data size increases intractably (combinatorial explosion). I am concerned that this approach might be feasible for simple problems only due to its inherent limitations.\n\nFurthermore, there are a few things that are unclear to me which could be further weaknesses. (I\u2019ve listed the questions in the next section.)\n\nMy initial rating is due to the above reasons. I would be willing to increase the score if the above concerns are addressed adequately.\n\nClarity issues:\nThe notion of \u201ctasks\u201d is not defined in the problem formulation. I understand this is not easy to do, but including it would make the paper stronger. The expression \u201clanguage goal\u201d is also used a few times throughout the paper, without definition (and I believe tasks = language goals)\n\n4.2 third paragraph third sentence. Did you mean to say something along the lines of \u201cmaps the abstract state representation at the current step and an abstract action $a\u2019$ to the next abstract state $s\u2019_{t+1}$\u201d ?\n\nTypos/style issues that did not affect the score:\n\nIntroduction\nFirst paragraph; A \u201cgood\u201d state and action representations -> Remove \u201cA\u201d\n\u201cAs the state abstraction extracts relevant information about the actions to be executed\u201d no need for the first \u201cthe\u201d, and could you back this up with some sort of example in brackets, ideally with a citation (I can sort of guess what you mean, but I find this a bit too vague and unclear) \n\nThird paragraph: \u201can particular object\u201d -> a particular object\n\n4th paragraph: \u201cthat setups\u201d -> that sets up\n\n4.2\n\nSecond paragraph:\n\u201cWhich encodes the raw state from a given point cloud\u201d: from -> to\n\u201cBy applying a pooling operation for the point cloud\u201d for -> to\n\nThird paragraph:\n\n\u201cThe abstract transition function $\\tau\u2019$ takes the following form. It maps [...] -> remove \u201ctakes the following form. It\u201d\n\n5th paragraph\n\n\u201cWe appends\u201d -> we append\n\n\u201cOf the Transformer encoder at this query possible will be used\u201d -> no need for possible?\n\n4.3\n1st paragraph: last sentence is not needed, or its information content should be moved towards the end of the second paragraph. E.g. \u201cwe can generate the final tree, the leaves of which are $a\u2019_K$ which correspond to the underlying abstract action in the language goal\u201d.\n\n2nd paragraph: subsequence -> subsequent\n\nsearchs ->searches\n\n5\nEXPERIMENT -> EXPERIMENTS\n\n5.2\n\n2nd paragraph: \u201cdesigned to evaluate models\u2019 abilities\u201d -> missing the after evaluate\n\nCitation for the Goal-Conditioned BC baseline is missing.\n\n6\n\n\u201cA framework that leverage\u201d -> leverages"
            },
            "questions": {
                "value": "In the state abstraction function, how do you know when to stop training to have the right number of point clouds? Or else, do you assume that the number of objects in the environment is known beforehand? Is this end-to-end trained? (I think the paper would benefit if these points were made clearer there.)\n\nWhat kind of pooling operation do you use? Max or average? And what is the dimensionality of the per-object latent feature?\n\nHow is the generalization success rate actually calculated? What does it mean that an agent \u201cfails to solve the tasks\u201d? I am assuming given the allowed number of steps?\n\nFor the loss of the feasibility prediction model, do you use the L_2 norm?\n\nThis is just notation, but in the reinforcement learning literature s\u2019 usually denotes the next state, and $\\hat{s}$ is used for an approximate state. Why did you decide to change this convention?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission6513/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698811904191,
        "cdate": 1698811904191,
        "tmdate": 1699636731347,
        "mdate": 1699636731347,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "m0xDdsfG0S",
        "forum": "3UWuFoksGb",
        "replyto": "3UWuFoksGb",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission6513/Reviewer_Q2SJ"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission6513/Reviewer_Q2SJ"
        ],
        "content": {
            "summary": {
                "value": "This paper presents an RL agent that solves the problem by utilizing symbolic abstraction and object-centric representation learning. Given a problem and a goal description for the environment, the proposed method uses LLM as a parser to translate the goal description (or instruction) as a collection of action predicates (verb and objects combination), where those action predicates are used as action abstraction (options or skills in hierarchical reinforcement learning).\n\nTraining requires human demonstration annotated with an action predicate. Given the demonstration data, the proposed method trains several functions. State abstraction function takes in the segmented output of a point cloud transformer to disentangle pixel input and it provides a latent space state representation. Action transition model takes in the latent abstract state and symbolic encoding of action predicates. Feasibility function predicts whether an abstract action is applicable in the current state.\n\nAfter training necessary functions with annotated demonstration data, the planning stage uses the state abstraction function to get a latent state and utilize the feasibility function to select applicable actions. Planning with symbolic action predicates is done by brute-force search over all actions in the problem. Last,  given a high-level plan, the low-level policy is trained."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "* Originality: The novel aspect of the presented method is combining symbolic planning with action predicates extracted from natural language goal descriptions or instructions and latent space representation learning with point cloud transformers. The abstract planning is done at the symbolic level, and the abstract state transitions are tracked with object-centric representation learned from segmented pixel data.\n* Quality: The overall description of the method is easy to understand and the experiment was conducted on two types of the environments.\n* Clarity: Figures help understanding the overall approach\n* Significance: I think this is an interesting work that integrating many things to work."
            },
            "weaknesses": {
                "value": "* Originality: Individual components are existing approaches and the originality is on bring those components and implement an agent to solve mini-grid and kitchen world problems.\n* Quality: Due to missing details, it is difficult to assess the quality.\n* Clarity: There are many missing details in the paper.\n* Significance: The comparison is made only against a simpler baselines (end to end RL and behavior cloning)."
            },
            "questions": {
                "value": "### General questions\n1. The title is \u201clearning planning abstractions from language.\u201d In the paper, the role of the LLM is parsing an instruction sentence to extract action predicates and objects. The remaining part of the work is independent of language models or language. The parsing could have been done manually or other methods. I cannot see the rationale of using LLM, other than demonstrating that LLM can do the parsing. What is \u201clearned\u201d from language?\n\n2. What if the goal description or instruction did not reveal enough information to extract required high-level actions? Then, should we collect demonstrations following the derived high-level actions?\n\n3. The instructions in the paper are quite simple sentences to parse. What is the longest abstract plan needed to solve the problem? How many abstract actions were needed?\n\n### Section 4\n4. In section 4.2, how the model was trained given annotated demonstrations? Is it learned per each abstract action? How many trajectories were given to the training process? How did you train Point Cloud Transformer for mini-grid environment and kitchen world environment? Can you present the details on the training of models?\n\n5. In section 4.3, planning is done with BFS search. If the feasibility prediction fails, how did you handle the error? Does a set of actions derived from LLM parser always guarantee to solve a problem? How can you ensure the action space can solve all problems in the test set? Or a human demonstrator should create trajectories that solves problem given the action predicates?\n\n6. In section 4.4, low-level policy is trained using an actor-critic algorithm. Can you present the details?\n\n### BabyAI experiments.\n\n7. The report on BabyAI experiments shows that baseline will not completely fail in all problems. The presented paper and the report also used similar low-level policy algorithm and neural network architectures. It also offers imitation learning experiments. Can you make some comparison with those baselines? What are the high-level actions extracted from LLM and what are the plans found for the problems? Can you present the sample efficiency or training/test performance?\n\n[1] Hui, D. Y. T., Chevalier-Boisvert, M., Bahdanau, D., & Bengio, Y. (2020). BabyAI 1.1.\u00a0arXiv preprint arXiv:2007.12770.\n\n### Kitchen Worlds experiments.\n8. How many high-level actions were annotated and trained to solve this environment?\u00a0 From the description in the experiment section, the length of the plan is mostly one or two. Could you present details on the high-level plan and the low-level policies?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission6513/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698894480985,
        "cdate": 1698894480985,
        "tmdate": 1699636731232,
        "mdate": 1699636731232,
        "license": "CC BY 4.0",
        "version": 2
    }
]