[
    {
        "id": "mNALhmROkR",
        "forum": "EhrzQwsV4K",
        "replyto": "EhrzQwsV4K",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission8334/Reviewer_Sz28"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission8334/Reviewer_Sz28"
        ],
        "content": {
            "summary": {
                "value": "The paper presents L2MAC, a framework for using large language models (LLMs) as automatic computers for long and consistent code generation. The framework consists of an LLM, an external memory (which stores both instructions and data),  and a control unit (which manages the interaction between the LLM and the external memory). The CU enables the LLM to execute a prompt program that contains a list of instructions to solve a user-given task. The CU also provides the LLM with precise read and write operations to access and update the memory, as well as error checking and correction mechanisms to ensure the quality and coherence of the generated code. The paper demonstrates the effectiveness of L2MAC by implementing Code-L2MAC, a practical instantiation of the framework for code generation tasks. Code-L2MAC can generate large code bases for system design tasks that require multiple components and features, outperforming existing SOTA methods such as GPT4 and AutoGPT."
            },
            "soundness": {
                "value": "4 excellent"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "4 excellent"
            },
            "strengths": {
                "value": "+ The paper presents a novel approach with the introduction of the L2MAC framework, which augments LLMs by integrating memory and control mechanisms. This innovation stands as the first practical LLM-based stored-program computer.\n+ The authors have instantiated the LLM SPC framework as Code-L2MAC, specifically tailored for intricate tasks like long code generation. The proposed method exhibits superior performance compared to state-of-the-art techniques.\n+ The introduced benchmark and evaluation metrics for long code generation tasks are valuable for further research in this field."
            },
            "weaknesses": {
                "value": "+ In the manuscript, there appears to be an inconsistency in the usage of the terms \"L2MAC\" and \"Code-L2MAC.\" The authors aim to differentiate between the overarching framework, denoted as L2MAC (which stands for LLM-based SPC), and its specific instantiation, referred to as Code-L2MAC, designed for long code generation tasks. Notably, the title of the paper erroneously employs \"L2MAC\" when \"Code-L2MAC\" would be more appropriate for the context of long code generation. Similar discrepancies are observed in the abstract, the first summarized contribution, Figure 1, and its accompanying text, among other sections. It is recommended that the authors undertake a meticulous revision to clearly delineate between these two terms. Additionally, while the L2MAC framework's primary focus is on the long code generation task, its potential applicability to a wider array of experiments should not be overlooked. To underscore the framework's versatility and generalizability, it would be advantageous for the authors to incorporate additional tasks.\n+ Regarding the comparative analysis, the manuscript omits some pivotal baselines, notably the Reflecting LLMs. While the related works section enumerates three methodologies\u2014Single LLMs, Reflecting LLMs, and Autonomous Agent LLMs with memory\u2014the results presented in Table 2 only encompass those of GPT-4 and AutoGPT. This omission should be addressed to provide a more comprehensive evaluation."
            },
            "questions": {
                "value": "1. In Section 3.3.1, the authors mention that if none of the introduced errors are found, CU asks the LLM to summarize the generated output in the current context window. The degree of summarization determines whether contextual information will be lost, which is crucial for long context handling. Can you provide a detailed and clearer explanation?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission8334/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698681597672,
        "cdate": 1698681597672,
        "tmdate": 1699637036934,
        "mdate": 1699637036934,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "YTMmJeRGgo",
        "forum": "EhrzQwsV4K",
        "replyto": "EhrzQwsV4K",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission8334/Reviewer_4yCT"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission8334/Reviewer_4yCT"
        ],
        "content": {
            "summary": {
                "value": "The paper proposes L2MAC, a practical LLM-based stored-program automatic computer for long and consistent code generation. The experimental results show L2MAC outperforms GPT-4 and AutoGPT for a variety of tasks, including URL shortening, online microblogging, and online chat applications."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "The paper introduces a practical LLM-based stored-program automatic computer framework-- L2MAC, for long code generation tasks. L2MAC can generate code for a variety of tasks, including URL shortening, online microblogging, and online chat applications, and outperform SOTA works."
            },
            "weaknesses": {
                "value": "1.\tThe performance of L2MAC is evaluated on URL shortening, online microblogging, and online chat applications. Can this method be used for other applications, such as programming?\n2.\tIs there a limit on the length of the generated code files? \n3.\tHow to ensure the efficiency of generated code files?"
            },
            "questions": {
                "value": "Please refer to weaknesses."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission8334/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission8334/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission8334/Reviewer_4yCT"
                ]
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission8334/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698725756927,
        "cdate": 1698725756927,
        "tmdate": 1700388331831,
        "mdate": 1700388331831,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "MQqLfxzuO5",
        "forum": "EhrzQwsV4K",
        "replyto": "EhrzQwsV4K",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission8334/Reviewer_4zmV"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission8334/Reviewer_4zmV"
        ],
        "content": {
            "summary": {
                "value": "The paper presents a LLM-based computer that uses LLM in its core as the `computation` engine and enables the model to interact with two different memories, `instruction registry` as a storage for prompts and user-defined instructions and `file store` as a means to store intermediate outputs. The authors create an interesting synergy with how conventional computers (e.g. Von Neumann architecture) operate and aims to replace the core compute and control engine with LLMs. As one of the applications, the author explored how such LLM-enabled computing platform can productively be used for the task of code generation."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "$\\mathtt{+}$ I found the synergy between conventional von Neumann architecture and L2MAC interesting and how the authors created a 1to1 mapping between different components in conventional computing platforms and their proposed design.\n\n$\\mathtt{+}$ The results for code generation tasks is promising."
            },
            "weaknesses": {
                "value": "$\\mathtt{-}$ While I think the paper proposes an interesting idea, but I found the writing very challenging and difficult to understand and follow.\n\n$\\mathtt{-}$ While the general-purpose computers can excel work in a variety of task, L2MAC focuses on one particular task and it is not clear how such model can generalized to different application and programs.\n\n$\\mathtt{-}$ While the core idea is still new, most of the explored idea like self-refinement, using external memory, etc. have been explored before in the literature."
            },
            "questions": {
                "value": "This is an interesting and timely idea. While the authors only explore one application for such general purpose computer, it would be interesting to see what other applications this computer can enable. To be honest, I found the writing of the paper/formulating the idea challenging to follow and that makes contributions less clear. \n\n(Q1) I appreciate the authors providing a comparison with the related work in Table1. I am wondering if it would make sense to have a comparison with those in the scope of code generation. I am curious to see how your approach compares with reflecting LLM techniques. \n\n(Q2) I understand the choice of target application for your model, but how do you think L2MAC can be extended to cover other applications and domains?\n\n(Q3) Can you clarify how do you generate test programs for each applications? Do you have another verifier to ensure the correctness of the unit test? What would happen if the unit test are limited coverage in testing the target application?\n\n(Q4) I also find the metric of `feature %` to be confusing. As an end-user, I would like my program to be fully functional and correct. Why do you need to design a new metric for the evaluation? How do you relate your metric with correctness of the program? Is there any correlation here?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission8334/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699325776520,
        "cdate": 1699325776520,
        "tmdate": 1699637036665,
        "mdate": 1699637036665,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "ROc6A5DNvy",
        "forum": "EhrzQwsV4K",
        "replyto": "EhrzQwsV4K",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission8334/Reviewer_v4fH"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission8334/Reviewer_v4fH"
        ],
        "content": {
            "summary": {
                "value": "The paper investigates the challenges and capabilities of Large-Language Models (LLMs) in the context of code generation from natural language instructions. A central issue identified is the difficulty LLMs face when generating extensive programs due to the limitations imposed by context window length. To tackle this problem, the authors introduce a system, L2MAC, which augments LLMs with an instruction registry and a file store. Through the orchestration of a control unit, L2MAC breaks down code generation into smaller, more manageable steps, and permits the modification of previously generated code via the file store. Evaluations presented in the paper indicate that L2MAC delivers superior performance in three system design tasks compared to two established benchmarks, GPT-4 and AutoGPT."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "1. **Relatively Novel Approach**: The paper presents a novel idea of employing a control unit, instruction registry, and a file store to enhance LLMs. Although the individual components have been introduced in prior work (planning, test case generation, using external tools, refining with code execution feedback), the application of these to a stored-program computer in this context seems to be a fresh approach.\n\n2. **Detailed Descriptions**: The paper provides a thorough description of all the crucial modules. The inclusion of example prompts and turn-by-turn actions in the appendix is an added advantage, as it supports better comprehension and reproducibility.\n\n3. **Addressing Key Challenges**: The paper tackles an important and complex problem - the generation of comprehensive and cohesive programs. It makes significant observations, such as emphasizing the need to enable LLMs to revise previously-generated code, which contributes to the understanding of the problem."
            },
            "weaknesses": {
                "value": "1. **Questionable Evaluation Metrics**: The paper employs several evaluation metrics that are based on LLMs rather than ground truths like human-written test cases. This approach raises concerns about the representation of these metrics in terms of code quality. For instance, 'Features %' is determined by a GPT-4 call and not by running and testing the code. Similarly, 'Tests Passed' is based on the LLM-generated test cases, which may not accurately reflect test coverage or code quality. The paper could improve its evaluation by incorporating well-established metrics, such as human-written test cases, and applying a consistent set of tests across different methods. [partially addressed in the rebuttal].\n\n2. **Overclaiming**: Although the paper introduces an intriguing concept, it also overstates several claims. For example, it suggests that L2MAC could enable LLMs to generate virtually unbounded code, but in practice, it is still limited by the context window when breaking down tasks and reading/writing code files. Moreover, while the paper claims that L2MAC can generate large codebases, the evaluation only presents a modest code length (300-400 LOCs).\n\n3. **Weak Baselines**: The paper fails to incorporate more state-of-the-art code generation baselines like CodeT (Chen et al., 2022), Self-refine (Madaan et al., 2023), and Reflexion (Shinn et al., 2023). The use of GPT-4 alone as a baseline appears to be a strawman argument, while AutoGPT is not renowned for superior code generation capability in any popular benchmark, such as HumanEval or MBPP [addressed in the rebuttal]."
            },
            "questions": {
                "value": "1. Have you considered incorporating ground truths, such as human-written test cases, into your evaluation metrics? Were there any challenges in doing so? Additionally, have you conducted any evaluation using more established metrics, and if so, could you share the results?\n\n2. Might the inclusion of more sophisticated code generation models such as CodeT, Self-refine, and Reflexion have provided a broader comparison of L2MAC's performance? If this is the case, could you possibly incorporate some of these comparative results in the paper?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission8334/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission8334/Reviewer_v4fH",
                    "ICLR.cc/2024/Conference/Submission8334/Senior_Area_Chairs"
                ]
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission8334/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699427960449,
        "cdate": 1699427960449,
        "tmdate": 1700517526740,
        "mdate": 1700517526740,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "Cta1Uxf4Ub",
        "forum": "EhrzQwsV4K",
        "replyto": "EhrzQwsV4K",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission8334/Reviewer_mgbF"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission8334/Reviewer_mgbF"
        ],
        "content": {
            "summary": {
                "value": "Authors propose L2MAC tool that implements automatic generation of large code bases using LLMs. Authors implement context management to keep relevant context and summarize/compress previous context to keep it within context size bounds. They implement approach to read and write file data across all created files. They also implement generated output checker that runs static analysis and unit tests and processes error messages. Authors evaluate their tool on a benchmark set and demonstrate improved results compared to state-of-the-art baselines."
            },
            "soundness": {
                "value": "4 excellent"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "- Structured framework for LLM-based computation that can deal with limited context, file input/output and output evaluation and testing.\n- Context handling that preserves information needed for the tasks and limits context to the context size\n- Read and write implementation for files generated during subtasks. Demonstrated capabilities to write, then read and update files.\n- Strongly improved results on benchmark tasks compared to strong baseline models/tools."
            },
            "weaknesses": {
                "value": "- File read/write implementation details are not clear. Please explain how your system decides what files to write, read, and update and how this is different from previous systems that did not have this functionality.\n- Benchmark set is not described. It is not clear if the benchmarks are representative of large code base creation tasks. Evaluation is done on only 3 tasks. The number of tasks should be increased to show the versatility and that the results are not outliers.\n\nMinor comments:\n- Stored-program computer subsection does not seem to contribute much to the paper. Probably shorten or remove.\n- Code-LLMatic is used instead of CodeL2MAC in couple places. Did not update old name?\n- Footnotes on page 4 mostly do not add to the narrative. Remove?\n- Figure 3 is placed after Figure 4 for some reason."
            },
            "questions": {
                "value": "- Figure 4 (c) - could you explain why for Code-L2MAC the figure shows the number of tests passed, while for other two tools it shows the number of tests failed? Are these numbers comparable? If so, why and how?\n- Does the \"checking of generated output\" part contain novel contributions? It seems to me that other tools and approaches also have feedback loops where code is regenerated on errors. It would be good if this was clarified. (This is possibly a minor weakness).\n- If I understand correctly, unlike autonomous tools that can add additional subtasks dynamically L2MAC creates a subtask list once at the beginning and does not subdivide or add additional tasks later. It seems that authors consider this to be a strength, because L2MAC will not go into hallucination subtask loop. However, this could also be a drawback since L2MAC may create subtask that needs to be subdivided later and it will not be able to do so. This should be evaluated. This also connects to the weakness of benchmark set that only has 3 benchmarks: perhaps other benchmarks would show the strength or weakness of this approach."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 5,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission8334/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699567329402,
        "cdate": 1699567329402,
        "tmdate": 1699637036418,
        "mdate": 1699637036418,
        "license": "CC BY 4.0",
        "version": 2
    }
]