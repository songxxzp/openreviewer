[
    {
        "id": "51aEAegduG",
        "forum": "vXxardq6db",
        "replyto": "vXxardq6db",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission5654/Reviewer_jAXk"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission5654/Reviewer_jAXk"
        ],
        "content": {
            "summary": {
                "value": "The authors of this paper describe their methodology as a transformation of a Transformer network from LayerNorm to RMSNorm. They implement an approach involving the application of orthogonal-matrix transformations and the selective removal of columns and rows from the transformed weight matrices. This process is aimed at reducing the overall model size while preserving performance integrity. The results of their research demonstrate a significant improvement in perplexity on benchmark datasets, OPT and Llmas2, aligning with the 2:4 scheme and underscoring the substantial enhancement in model efficiency and accuracy."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "* The formulation is clear and enhanced by illuminating diagrams for better comprehension.\n* The experimental results illustrate the method's effectiveness, establishing a well-defined trade-off between accuracy and sparsity."
            },
            "weaknesses": {
                "value": "The experimental section has certain shortcomings:\n\n1. The experiment section does not comprehensively address the comparison between SliceGPT and SparseGPT. While 2:4 sparsity implies a 50% compression rate, Table 1 exclusively showcases SliceGPT with up to 30% compression. This limitation hinders a clear conclusion regarding the superior performance of SliceGPT over SparseGPT.\n\n2. The absence of inference time data for SparseGPT in the experiments makes it challenging to convincingly demonstrate the superior efficiency of SliceGPT.\n\n3. The paper lacks a comparative analysis with state-of-the-art pruning methods such as low-rank approximation, unstructured sparsity, and block sparsity. The omission of these comparisons limits the paper's ability to establish the competitiveness of SliceGPT within the broader context of pruning techniques."
            },
            "questions": {
                "value": "* Can you show the performance (perplexity, inference time) of SliceGPT at 50% sparsity?\n* Can you show the inference time of SparseGPT in comparsion to SliceGPT under the same experimental setup?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "details_of_ethics_concerns": {
                "value": "No concern."
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission5654/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission5654/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission5654/Reviewer_jAXk"
                ]
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission5654/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698413917910,
        "cdate": 1698413917910,
        "tmdate": 1700070814354,
        "mdate": 1700070814354,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "JC2HR8LnSv",
        "forum": "vXxardq6db",
        "replyto": "vXxardq6db",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission5654/Reviewer_fXjP"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission5654/Reviewer_fXjP"
        ],
        "content": {
            "summary": {
                "value": "This paper introduces SliceGPT, a method to reduce the size of matrices for inference of LLMs. The method uses orthogonal matrices to project to a lower-dimensional space the weight matrices, these orthogonal matrices being constructed using PCA."
            },
            "soundness": {
                "value": "4 excellent"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "- The paper is well written and pleasant to follow. Ideas are simply explained and figures are helping the understanding. \n- Experimental results are convincing.\n- I think this method could be really used in practice to reduce inference time."
            },
            "weaknesses": {
                "value": "- I think section \"layernorm transformers can be converted to RMSnorm\" is not well motivated. Could the authors explain more in details the subtleties of this section and why it was written? I may have missed the point.\n- I'll wait for other reviewers weaknesses to see whether I agree with them."
            },
            "questions": {
                "value": "- Do the authors plan to release the code? I think open sourcing it is very important for the community.\n- The latex is broken, citations are not redirecting, I think your should recompile the pdf.\n- Could the authors comment on the use of a random projection (which is orthogonal in expectation, as in sketching methods) compared to $Q_\\ell$ computed using by PCA, which is more expensive?\n- In practice, not all layers may be equivalent signal-wise, could the authors comment on the possible use of weight watcher ( https://github.com/CalculatedContent/WeightWatcher ) to analyze how to select a different projection dimension for each layer? This question is purely curiosity but I think, combining both SliceGPT and weight watcher could greatly improve the method.\n- p8: what do the authors mean by \"using dense kernels in our compressed models\"? Did they code specific kernels for SliceGPT?\n- I think the authors should write a small proof of Equation (2) to increase the readability of the paper. Can the authors provide it in their answer?\n- \"Theorem\" is too strong for Theorem 1, I suggest \"Proposition\" or \"Remark\".\n- p4: typo: OBC instead of OBS.\n\nOverall I liked the paper and the method, and satisfying answers to my questions and weaknesses would make me consider increase my score."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission5654/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698683615522,
        "cdate": 1698683615522,
        "tmdate": 1699636588484,
        "mdate": 1699636588484,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "lOwJWQiDrC",
        "forum": "vXxardq6db",
        "replyto": "vXxardq6db",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission5654/Reviewer_96nz"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission5654/Reviewer_96nz"
        ],
        "content": {
            "summary": {
                "value": "The authors propose a technique for pruning neurons in Tranformer architectures based on a clever application of orthogonal matrices, which enables PCA-based elimination of rows and columns throughout the architecture. The authors evaluate their technique on a range of large language models from the OPT and Llama-2 families and demonstrate improvements in inference runtime on GPUs."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "4 excellent"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "The paper was very well written and organized. I found the method easy to understand. The insights that underpin the method (e.g., invariance to repeated application of orthogonal matrices) are clever and I think the PCA-based pruning of rows and columns in weight matrices is nicely grounded relative to other neuron pruning techniques."
            },
            "weaknesses": {
                "value": "I think there are two main weaknesses in this paper. First, the authors don\u2019t acknowledge prior work on neuron pruning. Admittedly most of the papers that I\u2019m aware of on this topic focus on convolutional neuron networks. But, some of the methods are likely to provide a reasonable baseline for the proposed technique. I\u2019ve cited some potentially relevant papers below [1, 2, 3, 4, 5].\n\nSecond, the results in Table 1 suggest to me that 2:4 sparsity is preferable to the proposed technique? If I understand correctly, 2:4 will remove 50% of the weights in the model and the results in Table 1 show that it suffers less quality degradation than removing 30% of the parameters with SliceGPT. Based on this, I expect 2:4 sparsity would show larger inference runtime savings for a given quality than the results in Table 2.\n\n[1] https://arxiv.org/abs/1708.06519\n\n[2] https://arxiv.org/abs/1707.06342\n\n[3] https://arxiv.org/abs/1707.01213\n\n[4] https://arxiv.org/abs/1707.06168\n\n[5] https://arxiv.org/abs/1810.05270"
            },
            "questions": {
                "value": "I have no additional question."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission5654/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698762702196,
        "cdate": 1698762702196,
        "tmdate": 1699636588389,
        "mdate": 1699636588389,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "NbEcY7ak4n",
        "forum": "vXxardq6db",
        "replyto": "vXxardq6db",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission5654/Reviewer_gLsa"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission5654/Reviewer_gLsa"
        ],
        "content": {
            "summary": {
                "value": "This paper introduces SliceGPT - a new approach for compressing large language models. By deleting rows and columns based on computational invariance, SliceGPT can significantly reduce the computation and memory required for inference while maintaining high accuracy. The evaluation demonstrates that this method is effective for large models such as OPT-66B and Llama-70B."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "- A novel method of compression based on computational invariance\n- No special code is required to run the compressed models and achieve speedup and memory savings\n- Works for Llama-70B and OPT-66B\n- It is well-written and easy to follow"
            },
            "weaknesses": {
                "value": "- The accuracy loss is not \"negligible\". With 25% sparsity, the perplexity of Llama-2-70B on WikiText2 increases from 3.32 to 4.89, which is similar to a dense Llama-2-13B. However, a 25% sparse Llama-2-70B has much more parameters than a dense Llama-2-13B.\n- The speedup is not impressive.\n- Compared to the quantization-based method, there is no advantage."
            },
            "questions": {
                "value": "1. In Table 2, it is not fair to multiply the number of GPUs by the total latency and get \"GPUms\". Huggingface Transformers implements naive model parallelism (or device placement, or pipeline parallelism without pipelining) method to parallelize the models, which means that only one GPU is active at a time. A correct implementation of tensor parallelism or pipeline parallelism will give different results. Considering this, the latency speedup is less impressive.\n2. Give the same parameter count budget or inference latency budget, how does this method compare to quantization-based method?\n3. The \"computational invariance\" trick is similar to a trick in SmoothQuant[1] (equation 3). Both of them multiplicate some matrices between the X and W, so it is good to do some comparison here.\n\n[1] SmoothQuant: Accurate and Efficient Post-Training Quantization for Large Language Models."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission5654/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698794702731,
        "cdate": 1698794702731,
        "tmdate": 1699636588254,
        "mdate": 1699636588254,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "wzanu4qE6s",
        "forum": "vXxardq6db",
        "replyto": "vXxardq6db",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission5654/Reviewer_7EAi"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission5654/Reviewer_7EAi"
        ],
        "content": {
            "summary": {
                "value": "The paper proposes to idea of using computation invariance for row-/column-wise sparsification. The authors leverages the idea of pre- and post-multiplying each block in a transformer model by orthogonal matrices that warrants computational invariance of each block. On the surface, adding new operations increases the raw FLOPs. However, following this technique, the authors show that they can sparsify most of operations in a transformer models, including attention and FFN layers."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "$\\mathtt{+}$ The idea of computational invariance and re-purposing additional computation for higher opportunity for sparsification is interesting and warrants further investigation.\n\n$\\mathtt{+}$ The results are promising and show the benefits across a range of SOTA models. The comparison with SparseGPT technique is also valuable."
            },
            "weaknesses": {
                "value": "$\\mathtt{-}$ The paper lacks sufficient insights of how the rows and columns are sparsified. It was not clear whether some operations are friendlier to row vs. column sparsification or this is a byproduct of the computational invariance approach.\n\n$\\mathtt{-}$ The paper compares accuracy with 2:4 structured sparsity but does not provide head-to-head comparison with SparseGPT (2:4) in terms of latency. \n\n$\\mathtt{-}$ One of the premises of the paper is memory saving, but going through the results it is not clear how the memory savings are in comparison to 2:4 sparsity. Showing a trade-off possibly can clarify this point."
            },
            "questions": {
                "value": "I think if the authors could clarify the following questions/comments and include few additional results, the quality of the paper could significantly increase:\n\n(Q1) Show latency comparison across different baselines, (a) Dense, (b) SliceGPT, (c) SparseGPT. \n\n(Q2) I may have missed this in the paper, but can you please clarify how you decide on row/column sparsity and how you select them? If the sparsed rows/columns are spread across the matrix, how do you manage to do the multiplication while getting latency benefits? or the overall benefits are derived from memory savings?\n\n(Q3) Do you have any insights as which operation/layer is more sensitive to sparsification? Have you thought of not uniformly sparsifying all the layers? Can looking into the range of values in the weight matrices provide insights on how to apply the sparsificiation (both degree and pattern)?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 5,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission5654/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698932150222,
        "cdate": 1698932150222,
        "tmdate": 1699636588150,
        "mdate": 1699636588150,
        "license": "CC BY 4.0",
        "version": 2
    }
]