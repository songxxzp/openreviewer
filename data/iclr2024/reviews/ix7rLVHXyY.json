[
    {
        "id": "zNxhW6pwmc",
        "forum": "ix7rLVHXyY",
        "replyto": "ix7rLVHXyY",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission2928/Reviewer_jit6"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission2928/Reviewer_jit6"
        ],
        "content": {
            "summary": {
                "value": "This paper introduces a dataset for learning code performance improvements. Based on this dataset, the capabilities of both open-source (CodeLlama) and proprietary models (GPT3.5/GPT4) to optimize code were tested using various PROMOTING and FINETUNING methods. The effectiveness of different methods and the performance differences between open-source and proprietary models are analyzed based on the experimental data."
            },
            "soundness": {
                "value": "4 excellent"
            },
            "presentation": {
                "value": "4 excellent"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "This paper conducts comprehensive experiments on the task of improving code performance using LLM, and offers a comparative analysis of the effectiveness of various recent methods. This work will contribute to aiding researchers in the domain to better enhance the capabilities of code generation models."
            },
            "weaknesses": {
                "value": "1. Regarding the experiment in Section 4.1: In Table 2, the performance of GPT-4 under the Few-Shot and CoT methods for code optimization was not tested.\n\n2. Data in Section 4.2 shows that after training on the synthetic dataset, there is a noticeable performance improvement in Best@1, but only a slight increase in Best@8. In fact, for the combination of < HQ+Self-Play, GPT-3.5 >, there is a minor performance decrease (95.42%->95.11%). The paper does not provide a convincing explanation for this.\n\n3. Different types of code have varying scopes and complexities for optimization. The paper does not clearly state the proportion of each language type in the training data nor in the test code."
            },
            "questions": {
                "value": "1. How do you view the impact of training LLMs using synthetic data (generated either by the trained model itself or from other models)? Assuming synthetic data is generated by the trained model M and undergoes data filtering, how would the output distribution of M change?\n\n2. I noticed a statement regarding the comparison of LoRA training: \"We hypothesize that this gap may be because performance optimization examples do not occur naturally in the training data.\" Can you provide a clearer version of this statement, or offer a more specific explanation?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission2928/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission2928/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission2928/Reviewer_jit6"
                ]
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission2928/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698665890157,
        "cdate": 1698665890157,
        "tmdate": 1699636236607,
        "mdate": 1699636236607,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "vLeyg6r8nW",
        "forum": "ix7rLVHXyY",
        "replyto": "ix7rLVHXyY",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission2928/Reviewer_VFMY"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission2928/Reviewer_VFMY"
        ],
        "content": {
            "summary": {
                "value": "This paper proposes a dataset called Performance-Improving Edits (PIE). It contains 77K pairs of C++ programs where one is a performance-improved version of the other, filtered from CodeNet. It also proposes to use gem5 simulator to simulate an Intel CPU as the runtime metric rather than running the programs and measuring wall time. The paper proposes a number of ways to use the PIE dataset to induce large language models to improve code performance, including prompt engineering, retrieval augmented generation, and fine-tuning. The best result is from fine-tuning GPT-3.5, with a surprising speedup of 6.86X, beating best human performance."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "This work is well motivated and addresses a meaningful task. The construction process described in section 2 seems reasonable. The different methods to adapt models in section 3 cover most main stream methods."
            },
            "weaknesses": {
                "value": "The results are too good to be true. It's surprising to see that, for C++ competitive programming tasks, the fine-tuned GPT-3.5 beats the best human submission by a large margin: 6.86X speed up versus 4.06X speed up. So let's take a look at the examples in appendix A.1 which are code improvements generated by the model. Figure 3 of A.1 contains two programs that are functionally different. Figure 4(a) in A.1 is so bad that it seems unlikely in a C++ competition. Figure 5 contains two programs that are functionally different and also have different interfaces for execution (unclear how it passes correctness test). Figure 6 contains two programs that are functionally different and Figure 6(b) is missing an obvious break statement to help performance. Overall none of before-optimization examples seems plausible as competitive C++ programming submissions. By looking at these examples, I question the quality of the PIE dataset.\n\nI randomly looked at some entries in the supplementary material and they seem consistent with examples in appendix A.1 and not plausible for competitive C++ programming submissions.\n\nA side evidence for the issue can also be seen in Tables 1 and 2, where the correct percentages are high and indicate that the difficulty level of the programming tasks is low.\n\nIt is stated on page 6 that \"For generations that are either incorrect or slower than the original program, we use a speedup of 1.0 for that example, given that, in the worst case, the original program has a speedup of 1.0.\" This explains some of the 6.86X result: the evaluation setup is such that only good generations are considered in calculating the metric."
            },
            "questions": {
                "value": "The following are questions in addition to the weakness section.\n\nThe rationale of using gem5 simulation instead of measuring wall time makes sense but won't this run the risk of overly focused on a single CPU (Inter Skylake)? Also gem5 simulation still does not capture big O complexity which is often a goal in optimizing code.\n\nIt is counter-intuitive that Section 3.2 only uses 4K out of the 77K pairs in PIE to fine-tune GPT 3.5. Then 3K synthetic data are created and used. Could you explain the rationale of these choices? This seems to contradict the quality claim of the PIE dataset."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission2928/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission2928/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission2928/Reviewer_VFMY"
                ]
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission2928/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698729558089,
        "cdate": 1698729558089,
        "tmdate": 1700671415199,
        "mdate": 1700671415199,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "ieRhpxAzdk",
        "forum": "ix7rLVHXyY",
        "replyto": "ix7rLVHXyY",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission2928/Reviewer_nenm"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission2928/Reviewer_nenm"
        ],
        "content": {
            "summary": {
                "value": "This paper proposes a new benchmark for training and evaluating LLMs to generate performance-improving code edits given an existing unoptimized program as well as an evaluation of current and novel prompting/finetuning methods for adapting LLMs for this task. The benchmark is constructed from CodeNet tasks and the authors annotate the runtimes using the gem5 environment along with caveats that this performance measurement can be very difficult in other benchmarking setups. The authors show improvements over the human baselines on speedups with a variety of methods, and show a systematic ablation with various models, prompting, and retrieval schemes on both open-source and private large language models."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "The benchmark is an important artifact that the community will continue to build upon, especially as code-generating/editing large language models continue to be developed and deployed in research and production environments. The analysis and ablations are very thorough and further justify the benchmark and prompting strategies as important contributions."
            },
            "weaknesses": {
                "value": "The experiments are very thorough, but it seems that the correctness of the models degrades with introduced methods. While it seems that the paper's primary contribution is the dataset, further analysis of correctness (as opposed to just pure speedups/optimization %) would further solidify the adaptation methods sections of the paper."
            },
            "questions": {
                "value": "Are the speedups reported only on edited programs that are verified to be correct?\nHow does the model generalization scale with the amount of synthetic data used?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission2928/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission2928/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission2928/Reviewer_nenm"
                ]
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission2928/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698810733014,
        "cdate": 1698810733014,
        "tmdate": 1699636236424,
        "mdate": 1699636236424,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "rgBN5tF6tF",
        "forum": "ix7rLVHXyY",
        "replyto": "ix7rLVHXyY",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission2928/Reviewer_8KXu"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission2928/Reviewer_8KXu"
        ],
        "content": {
            "summary": {
                "value": "The paper proposes PIE dataset. Each sample in the dataset is basically a pair, showing a program and its optimized counterpart. \nThe impact of PIE dataset is further studied on several LLMs (both open and closed), including the family of CodeLlama and GPT3.5 and GPT-4. Moreover, a broad range of adaptations is used to improve the results of the LLMs, such as instruction, few shot, chain of thoughts, dynamic few shot, and fine-tuning. \nThe experimental results indicate that each adaptation strategy improves the results, with fine-tuning having the most significant improvement over the others."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "+ The problem of performance editing is important. Not only should the generated code be correct, but also it should be as efficient as possible. Therefore, the paper targets an important problem. \n\n+ The range of adaptations considered is wide, and the experimental results give the reader a clear image of how each adaptation strategy can be used to improve the results. \n\n+ The paper uses top closed-sourced (GPT3.5 and 4) and open-sourced (CodeLLama 7B, 13B, 34B) to study the impact of PIE dataset. It clearly shows the gap between closed and open LLMs and how different adaptations can narrow this gap."
            },
            "weaknesses": {
                "value": "- The study mostly focuses on the percentage of performance, and in cases where the runtime of the generated program is slower or the code is incorrect, speed up is considered one. This is not a good approach. In particular, a study is needed on what category of programs LLMs often fail to produce correct code or optimized code. In such a study, it will be easier to infer in which cases it is better not to use the LLMs. Or which category of programs needs to be further improved. \n\n- For synthetic data, it is mentioned that semantic duplicates are tracked, but no information is provided on how semantic similarity is conducted. Is it also based on CodeBertScore? \n\n- It is interesting to see that Perf-Cond has decreased the percentage of correctness. Any reason why Perf-Cond degrades the ability of the LLMs to produce the correct code? \n\n-  The presentation could be improved as an example, Table 1 is not referenced anywhere in the text, or in Table 2, it is better to group the Dynamic Retrievals together. The additional horizontal line is confusing. \n\n- In Table 2, why is the choice of models not consistent across different methods? Like, there is no few shots learning or COT for GPT-4."
            },
            "questions": {
                "value": "For detailed questions, please refer to the weakness section.\n\n- The authors have not discussed enough about the cases where the LLMs fail or why they fail. Could they add further experiments and clarify it?\n\n- In Table 2, why is the choice of models inconsistent across different methods? Like, there are no few shot learning or COT for GPT-4. \n\n- Why does Perf-Cond degrade the ability of the LLMs to produce the correct code? \n \n- How semantic similarity is conducted where semantic duplicates are tracked?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission2928/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699069099013,
        "cdate": 1699069099013,
        "tmdate": 1699636236342,
        "mdate": 1699636236342,
        "license": "CC BY 4.0",
        "version": 2
    }
]