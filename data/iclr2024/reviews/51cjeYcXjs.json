[
    {
        "id": "l2UZjNqGUO",
        "forum": "51cjeYcXjs",
        "replyto": "51cjeYcXjs",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission2932/Reviewer_5Qou"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission2932/Reviewer_5Qou"
        ],
        "content": {
            "summary": {
                "value": "The authors propose a methodology for retrieving malware from a large corpus of data through a kNN algorithm applied on a novel feature extraction set, leveraging on Data Dependancy Graphs (DDG). Each program of the corpus is then expressed as a set of hashes that describe them, and that they can be used to be retrieved at need.\nThe authors describe some cherry-picked results to clarify how their methodology work, also showing an example of the first 7 neighbours of the Sekoia Rootkit."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "1 poor"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "1. Interesting retrieval approach that could be used to understand similarities between malware.\n2. The approach is easy to understand."
            },
            "weaknesses": {
                "value": "**Missing a clear evaluation of the results.** The authors show one example retrieval, but all the discussion of Sect.3 is not enough to clarify the optimality and soundness of the proposal. In particular, how a practitioner could validate that the algorithm is picking up from the corpus of data meaningful neighbours? Also, the authors do no specify *why* the results of Fig.7 are relevant. What have these in common? The authors should provide some ground truth, trying to explain why they achieved those results.\nOtherwise, if the methods would have retrieved other 7 samples, what would have been the conclusion?\n\n**Possible errors in disassembly.** The authors state that they leverage *objdump* as disassembler. However, there are plenty of techniques that malware programs use to avoid reverse engineering. Usually, practitioners leverage other tools like IDA and Ghidra that are better in disassembly than objdump. Thus, the results might be biased towards the representation that is tool is providing, rather than capturing the indended functionality and graph shapes.\n\n**Confused paper structure.** The manuscript would benefit for a re-arrangement of its structure. First, the abstract starts directly with the problem to solve, making it for newcomers to understand what is the problem to solve and why. Then, the introduction is missing which are the core contribution of the paper (hinted in Sect.2, but in a confused way). Most of the discussion is focused on just one cherry-picked example. There are no limitations, and no code is provided (that would have removed the need for Sect 4.1)."
            },
            "questions": {
                "value": "1. Which are the advantage of using this method, and not other retrieval methods? The paper states the presence of related work, but none is compared to the proposed technique.\n2. How this technique can be validated?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission2932/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1697730935052,
        "cdate": 1697730935052,
        "tmdate": 1699636236890,
        "mdate": 1699636236890,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "KLlWQMjmRk",
        "forum": "51cjeYcXjs",
        "replyto": "51cjeYcXjs",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission2932/Reviewer_Qcjm"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission2932/Reviewer_Qcjm"
        ],
        "content": {
            "summary": {
                "value": "The author proposes a novel representation method for binary programs. First, reverse engineering is employed to extract data dependency graphs (DDGs) from each program. Subsequently, a set of graph hashes is utilized to represent the distinct basic block segments within a DDG. By comparing the DDG Fingerprint of an unknown program with existing programs, the author employs k-Nearest Neighbors to determine its functionality. This approach enables the identification of the functionality of unknown programs through the comparison of DDGs."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "The topic of searching and retrieving novel malware is both intriguing and significant. \nThe paper's structure and logic are lucid. \nThe discovery of a similarity between ZeusGameover Feb2014 and the Client/Server Runtime Subsystem is interesting."
            },
            "weaknesses": {
                "value": "The novelty of this method is limited, as it builds upon existing methods such as DDG, graph hash, and knn.\nThe experimental setup is overly simplistic, hindering the ability to effectively demonstrate the method's efficacy."
            },
            "questions": {
                "value": "1.The novelty of the proposed method is limited as it heavily relies on existing methods, thus the innovation of this paper is considered to be constrained.\n\n2.The motivation behind selecting DDG as a feature is not adequately explained. Specifically, it is unclear what advantages this feature offers compared to other features such as control flow graphs or function call graphs in the context of software search and retrieval tasks.\n\n3.The definition of Feature Resolution is excessively abstract, making it difficult to comprehend. It would be beneficial to provide an early explanation of this concept in the introduction section.\n\n4.The DDG Fingerprint constructed by the authors appears to have a very high dimensionality, resulting in sparse data. Although the authors mention that \u201cthe feature resolution can be adjusted once the specific characteristics of the search have been refined\u201d, I still struggle to understand how these specific characteristics are determined.\n\n5.The experimental section is overly simplistic. 1), constructing a benign sample library with only 500 data is insufficient. 2), quantitative experiments are lacking. The authors only conducted qualitative analyses without providing accuracy metrics for identifying similarities between samples. 3), the use of only two selected samples in Figure 6 does not sufficiently establish the credibility of the results."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission2932/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission2932/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission2932/Reviewer_Qcjm"
                ]
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission2932/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698594108992,
        "cdate": 1698594108992,
        "tmdate": 1699636236809,
        "mdate": 1699636236809,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "hocIhuuNYd",
        "forum": "51cjeYcXjs",
        "replyto": "51cjeYcXjs",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission2932/Reviewer_PPca"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission2932/Reviewer_PPca"
        ],
        "content": {
            "summary": {
                "value": "The work presents an approach to generate malware representation using static analysis. That is, pieces of dependency graphs are built based on the assembly instructions of a given malware sample and then hashed using the Weisfeiler-Lehman graph hashing algorithm to retain the semantics of the dependency graphs and graph isomorphism. Finally, the hash values can be used to compute with Hamming Distance and KNN clustering. Only few evaluations with limited samples demonstrated the potential of the work."
            },
            "soundness": {
                "value": "1 poor"
            },
            "presentation": {
                "value": "1 poor"
            },
            "contribution": {
                "value": "1 poor"
            },
            "strengths": {
                "value": "- Clear presentation"
            },
            "weaknesses": {
                "value": "It mainly lacks novelty and supportive arguments.\nThis work only adopts well-developed methods, including the Weisfeiler-Lehman graph hashing algorithm, Hamming Distance, and KNN, rather than developing a solution. Also, transforming static features of a given sample into hash values for further analysis is similar to some related work (Wu, et. al, 2021; Sun, et. al., 2022;), which also considers graph-based static features and maps to a representation for malware detection. \n\nWu, Chia-Yi, Tao Ban, Shin-Ming Cheng, Bo Sun, and Takeshi Takahashi. \"IoT malware detection using function-call-graph embedding.\" In 2021 18th International Conference on Privacy, Security and Trust (PST), pp. 1-9. IEEE, 2021.\n\nSun, Qirui, Eldor Abdukhamidov, Tamer Abuhmed, and Mohammed Abuhamad. \"Leveraging spectral representations of control flow graphs for efficient analysis of windows malware.\" In Proceedings of the 2022 ACM on Asia Conference on Computer and Communications Security, pp. 1240-1242. 2022."
            },
            "questions": {
                "value": "Questions:\n- Is it possible to show the semantic preserving when assembly codes were transformed into blocks of dependency graphs and hash values?\n\nSuggestion:\n- A clear contribution can be shown with comprehensive evaluations of large-scale samples and compared with other approaches, such as control-flow malware variant detection (Cesare et. al., 2013)."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "1: strong reject"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission2932/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission2932/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission2932/Reviewer_PPca"
                ]
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission2932/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698761229335,
        "cdate": 1698761229335,
        "tmdate": 1699636236734,
        "mdate": 1699636236734,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "TBv8EMayp3",
        "forum": "51cjeYcXjs",
        "replyto": "51cjeYcXjs",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission2932/Reviewer_pKB5"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission2932/Reviewer_pKB5"
        ],
        "content": {
            "summary": {
                "value": "The author introduces a novel method for representing binary program features. This method utilizes data dependency to express the operational semantics and structural characteristics of the program, effectively capturing its semantic and functional aspects. Furthermore, the author introduces a bottom-up feature construction approach, enabling additional reasoning based on existing knowledge."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "This article addresses a crucial field, considering the rapid proliferation of malware. Swift detection of zero-day malware and the identification of code reuse in zero-day malware present intriguing and formidable challenges. \n\nThe article introduces the DDG Fingerprinting method for detecting malware similarity, significantly enhancing the interpretability of detection outcomes."
            },
            "weaknesses": {
                "value": "In the Data Collection section, why were those two categories chosen, and other categories not considered? Are the malicious categories up-to-date?\n\nImportant terms should be further clarified, such as the frequently references ``resolution''. I couldn't find a clear and detailed definition or explanation of this term.\n\nHow are the issues encountered in reverse engineering addressed, such as code obfuscation and anti-debugging techniques? I believe reverse engineering is not a trivial matter, yet it is only briefly discussed.\n\nIn the Data Dependency Graph Extraction section, it isclaimed to be an undirected graph, yet Figure 1 shows a directed graph. Moreover, there is no explanation about 'ai' in Figure 1. Why is the 'mov' instruction singled out as capturing most changes without any data or experimental support to back this claim?\n\nFigure 5 lacks detailed information on the horizontal and vertical axes, making it difficult to understand. More detailed analysis would be better."
            },
            "questions": {
                "value": "Please see the weakness section."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission2932/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699005546814,
        "cdate": 1699005546814,
        "tmdate": 1699636236656,
        "mdate": 1699636236656,
        "license": "CC BY 4.0",
        "version": 2
    }
]