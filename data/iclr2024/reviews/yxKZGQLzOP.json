[
    {
        "id": "uRk01htinO",
        "forum": "yxKZGQLzOP",
        "replyto": "yxKZGQLzOP",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission6796/Reviewer_3Xjo"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission6796/Reviewer_3Xjo"
        ],
        "content": {
            "summary": {
                "value": "The authors present a framework built on the Rational Speech Acts model that iteratively tunes a listener and speaker model to generate programs fitting a spec. This framework can essentially be viewed as a bootstrapping method to build a dataset and listener and speaker models in a more efficient way than blindly sampling programs. Experiments on a regex dataset show that this framework outperforms naively training a single L/S model pair with a moderately sized dataset as well as prompting a LLM. This framework also outperforms using a human dataset instead of a listener."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "- The presented method outperforms the literal and GPT baselines. It also outperforms HFT which suggests that the iterative listener training makes a difference.\n- The method outperforms a small human labeled dataset, which suggests that it may be better to use this method if one does not have access to lots of human annotations.\n- The method converges at a comprable rate to the literal and HFT methods, so the bootstrapping method appears to work."
            },
            "weaknesses": {
                "value": "- The method is only tested on a regex dataset. This ignores programs that cannot be written as regexes and more complicated programs.\n- This paper only compares the pragmatic framework against the literal and HFT baselines, which are derivatives of the pragmatic framework. While there is a comparison against GPT3.5, I would have liked to see other program synthesis baselines that do similar things for a more thorough comparison.\n- There are no ablations on the number of samples needed to get good performance and other similar hyperparameters."
            },
            "questions": {
                "value": "- Will the dataset be released?\n- How do you guarantee your base program/sample dataset has sufficient coverage to get a usable listener/speaker model? Do you have a prior over which programs and samples may be more useful for training a model?\n- What distribution do you use to sample the set of rows and columns to update for RSA?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission6796/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6796/Reviewer_3Xjo",
                    "ICLR.cc/2024/Conference/Submission6796/Senior_Area_Chairs"
                ]
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission6796/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1697939573755,
        "cdate": 1697939573755,
        "tmdate": 1700512582017,
        "mdate": 1700512582017,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "UwFy6kIB9L",
        "forum": "yxKZGQLzOP",
        "replyto": "yxKZGQLzOP",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission6796/Reviewer_h5RG"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission6796/Reviewer_h5RG"
        ],
        "content": {
            "summary": {
                "value": "In this paper, the authors propose a method for program synthesis (specifically the programming-by-examples variety of it) framed as a two-player game. A _speaker_ model $S$ is charged with generating informative examples, which a _listener_ model $L$ uses to generate programs; within this setup, a given set of examples can be consistent with multiple programs. The authors get around this difficulty by devising an approximation of a pre-existing Bayesian scheme, dubbed RSA. Using LLMs as speaker and listener models, and by performing RSA only on a partial consistency matrix $M$ of programs/examples pairs sampled from them (instead of the full matrix which is prescribed by exact RSA), the authors make it possible to select the examples which are most informative for a given program, resolving the aforementioned ambiguity. These examples are then added to the dataset of (example, program) pairs and used to train the speaker and listener in an Expert Iteration fashion. \nThe authors demonstrate that their proposed method, trained using only synthetic data and their ExpIt-like procedure, performs better than a set of baselines, including a model trained on high quality data sourced from human annotators, and GPT 3.5."
            },
            "soundness": {
                "value": "4 excellent"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "4 excellent"
            },
            "strengths": {
                "value": "- While RSA is not novel in itself, the paper is anyway quite novel in making it applicable to a large-scale program synthesis task, and in using LLMs to model speaker and listener.\n- The paper is accessible and written well, though it does contain a very large number of details and some typos.\n- The authors set up a comprehensive experimental pipeline inclusive of humans in the loop. Most papers on code synthesis do not actually test their methods \"in the wild\", while this paper does.\n- The proposed method does beat the considered baselines by a good margin."
            },
            "weaknesses": {
                "value": "- It appears that one assumption of RSA is that given a certain example, the literal listener $L_0$ should assign equal probability to all programs consistent with it. This is unlikely to be the case once $L_0$ is a neural net, unless this has been perfectly trained.\n- Synthetic data needs to be available to pre-train the literal speaker and listener models. These might not be available when considering more rich \"programming\" languages than regexs.\n- Both the training and evaluation protocols are quite complex, meaning that multiple reads of the paper  are necessary to get all of the details.\n- The set of baselines considered is somewhat narrow, and does not include any previous efforts on the particular task considered (i.e. inferring regular expressions). The authors compare only against effectively an ablation of their own method (LITERAL), their method but trained on a set of human-annotated data (HFT), and a generalist LLM (GTP 3.5)."
            },
            "questions": {
                "value": "- As mentioned above, the RSA framework assumes $L_0$ to assign equal probability to all consistent programs, which is not going to be the case once it is approximated with a Neural Net. Could the authors comment on this?\n- The literal listener $S_0$ is not defined in section 2. Only $L_0$ and $S_1$ are defined. Could the authors provide a definition?\n- Why didn't the authors include any baselines (neural or not) specific to the task of inferring regexs?\n- Some details of the evaluation protocol are a bit obscure. First of all, how do the authors compute their top-1 metric on the validation dataset, when doing model selection? They only provide a definition of the metric as part of the final human trial, so it's not clear how the model would be prompted when computing it at the model selection stage.\n- The authors state that \"TOP-1@$t$ measures whether the model's top-1 matches intended regular expression at any point at turn $t$ of the interaction\". Is it at any point, or a turn $t$? Since the interaction ends after a match is achieved, it can only be at turn $t$, but the text is ambiguous.\n- The authors detail their inference procedure in section 4.4. Therein they state that programs inconsistent with a given example are filtered out. Shouldn't they be left in in order to build the consistency matrix $M$? Does this paragraph only detail the inference protocol for the evaluation phase, or also for the training phase? This is not clear.\n- I assume that the numbers reported in the tables refer to the _fraction_ of instances in which an interaction was successful at time $t$, so it's technically incorrect that the metrics measure \"whether\" something happens. They actually measure \"how often\" it happens over a set of interactions. It would be helpful to the reader to amend this somewhat inaccurate language.\n- From section 4.7: \"4 shows the progression of...\" 4 what? I assume that this actually refers to figure 3 and this is a typo.\n- From the intro: \"A synthesizer trainer in the style of Devlin et al....\" what does this mean? Could the authors be more explicit?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "details_of_ethics_concerns": {
                "value": "No concerns."
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission6796/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6796/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6796/Reviewer_h5RG"
                ]
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission6796/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698683470737,
        "cdate": 1698683470737,
        "tmdate": 1699636785373,
        "mdate": 1699636785373,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "A0bw3CnzUe",
        "forum": "yxKZGQLzOP",
        "replyto": "yxKZGQLzOP",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission6796/Reviewer_Lieb"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission6796/Reviewer_Lieb"
        ],
        "content": {
            "summary": {
                "value": "The paper scales pragmatic inference for program synthesis to realistic problem\nsizes using neural networks. The authors introduce a listener and a speaker\nneural model and train these iteratively. The models are used to generate\ndatasets containing increasingly informative program specifications, and they\nthemselves are trained further on these datasets in each iteration. To build the\ndataset, the models suggest candidate specifications, and the specifications to\nbe included are chosen from these using pragmatic inference (the Rational Speech\nActs framework).\n\nThe method is evaluated on the task of inferring regular expressions from a set\nof examples in a human interaction study with 11 participants and outperforms a\nbase literal model, a human finetuned model, and GPT-3.5."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "Scaling up pragmatic inference for realistic program synthesis could open up\npromising future research.\n\nThe paper is clearly written with illustrative figures. I found the explanation\nof the pragmatic model of program synthesis really good and easy to follow.\n\nThe paper includes a real-world study of program synthesis with 11 human\nparticipants."
            },
            "weaknesses": {
                "value": "I believe the main weakness of the paper is that the presented method is not\ncompared to any existing neural program synthesis system (like DeepCoder,\nPCCoder, DreamCoder, CrossBeam, LambdaBeam, etc.). I think this would be\nimportant as the main thesis of the paper is scaling up pragmatic inference to\nthe level of these systems. It would also be good to include a domain for\nsynthesizing programs that's more general and widespread in the literature than\nregexes.\n\nI think that Section 4.6 about the human annotated dataset should be earlier as\nit's already referred to earlier.\n\nSome typos:\n- Introduction: \"an user\", \"coorporative\", \"human ... atempt to communicate\",\n  \"of of\"\n- page 3 top line \"an sampled example\"\n- 4.3 Measurement: \"top-1 matches THE intended regular expression\"\n- 4.7 Results: \"informatively\", \"4\" should be \"Figure 3\"\n- 6 Related work: \"datas\""
            },
            "questions": {
                "value": "I couldn't understand the argument for sampling a subset of the consistency\nmatrix $M$ in 3.3. If $M$ is sparse, why does that allow us to sample a subset\nof the rows and columns? Wouldn't we mostly sample zeros? Or is there a strategy\nfor sampling (e.g., sampling dense areas) which is not mentioned?\n\nI also don't understand exactly how the conditioning on previous examples are\ndone when sampling in terms of the consistency matrix. Could you elaborate on\nthat?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission6796/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6796/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6796/Reviewer_Lieb"
                ]
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission6796/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698766063379,
        "cdate": 1698766063379,
        "tmdate": 1700560114518,
        "mdate": 1700560114518,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "9QlIbtTa5u",
        "forum": "yxKZGQLzOP",
        "replyto": "yxKZGQLzOP",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission6796/Reviewer_Dg1v"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission6796/Reviewer_Dg1v"
        ],
        "content": {
            "summary": {
                "value": "This paper focuses on program synthesis by example for regexes. It aims to learn a program synthesis model that reasons pragmatically. As many possible programs can meet ambiguous input example specifications, counterfactual thinking should be usefully employed to differentiate among the many valid hypotheses. Other works have investigated this possibility, most under the rational speak acts (RSA) framework, but this kind of reasoning is intractable to do exactly for non-trivial domains. The paper suggests a bootstrapped learning approach to overcome this limitation, by jointly learning a speaker model (which suggests pragmatic examples given an input program) and a listener model (which suggests a likely program, given a list of assumed pragmatic examples). Over multiple rounds, these networks are trained on one another\u2019s predictions, chosen according to an RSA methodology, made tractable by restricting the hypothesis space according to the programs sampled from the model. Experiments with human-trials demonstrate that listener models trained in this framework perform better than comparison approaches."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "I enjoyed this paper and I would support its acceptance into the conference proceedings. \n\nThe proposed approach is sensible and well-explained. The methodology appears quite general, and should be able to be used broadly as it requires no human GT data during training. In fact, the human GT data that is used in validation seems like it could be removed, as based on the trend in figure 5 it doesn\u2019t appear as though the method is overfitting in any sense over bootstrapping rounds.\n\nThe experimental design and presentation is sound and convincing for the regexes inference domain. The paper mainly validates the proposed system with human-trials, which makes sense as its hard otherwise to source \u2018pragmatic\u2019 examples, and it confirms the system would actually be easier to work with for an end-user"
            },
            "weaknesses": {
                "value": "While a lot of effort has gone into validating the system is working for this particular regex domain, the paper does not explore other problem settings to any degree. I don\u2019t think this is a major limitation, but it is probably holding the paper\u2019s rating back slightly. The impressive results on one-domain are likely of interest to a subset of the ICLR community, but showing that this methodology can generalize effectively across domains would broaden this interest. As a note, I don\u2019t even think these other domains would need to be *more difficult* than regexes (e.g. like python code generation mentioned in the conclusion), but could even be other domains of similar complexity. \n\nIn some ways the comparison against HFT is a bit unfair, as the proposed method has effectively unlimited training data (although only a set amount of bootstrapping rounds are employed), whereas HFT is fine-tuned with a fixed amount of human-feedback. To get a \u201cfairer\u201d upper-bound of how \u201cgood\u201d the pragmatic examples produced by the system are with respect to the human provided exemplars, it might be good to include an additional condition where the listener model is fine-tuned on a fixed amount of data (i.e. the same amount as used in HFT) where the I/O examples are produced by the final speaker model. \n\nMinor:  \n\nThere is a connection to be made between the proposed method and bootstrapped \u201cwake-sleep\u201d approaches for program synthesis [1,2]. Both learn \u201cgenerative\u201d and \u201cinference\u201d models that learn on one another\u2019s outputs. The modeling set-ups are different, as these wake-sleep approaches move towards a target distribution, whereas the proposed method optimizes for synthetic training data that matches a prior desiderata (pragmatic I/O examples), but these ideas are close enough that they should be discussed within the related work section. \n\n[1] DreamCoder: growing generalizable, interpretable knowledge with wake\u2013sleep Bayesian program learning\n[2] Learning to learn generative programs with Memoised Wake-Sleep"
            },
            "questions": {
                "value": "(1) The proposed system effectively improves the listener model by finding \u201cbetter\u201d synthetic training I/O examples, where better means there is a pragmatic connection between the examples and the target program. However, it\u2019s unclear if this improvement changes the upper-bound of the listener model performance, or if it just helps the listener model reach a good performance with less training iterations. Training the base model for 300k programs, for a single epoch, it's not clear whether the model has started to plateau in performance. It would be helpful to provide evidence that the base model has saturated, by e.g. plotting validation performance over pretraining iterations. What would this plot look like?\n\n(2) It\u2019s also not clear to me why starting from a pretrained model like ByT5 would be necessary or helpful. The programs come from a constrained DSL, where unlimited synthetic data can be sampled, so it should be possible to train the base models from scratch. It would be good to include an ablation on how starting with or without pretraining affects the proposed method. What is the justification for starting with a pretrained model?\n\n(3) Much of the evaluation is based off of human-interactions, which is present only in limited quantities. Are there any metrics which could be evaluated without human interactions? For instance, what about the following set-up:\n\n1. Pick a target regular expression and a single I/O example at random\n2. The listener samples a target expression given the current specification\n3. With respect to (2), the speaker samples an example, which is annotated as consistent/inconsistent by an oracle\n4. Repeat steps 2 and 3 until the listener samples the *correct* target expression\n\nThe metric would then be the number of example generations needed for the listener to predict the correct regular expression, where the idea would be that as the speaker is better at producing \"pragmatic\" examples it should require less steps versus a baseline that for instance randomly sampled an example. Beyond serving an evaluation set-up that requires no human-data, this kind of framework could conceivably even be useful for \u201creal-world\u201d applications: e.g. this could reduce the burden on an end-user, who instead of having to think up new examples as input, would just need to label them.\n\n## Minor:\n\n(4) Is the hypotheses set in Appendix D randomly sampled programs from the DSL? Please make this clear. More generally, some of the terminology used in the pseudo-code could be more directly mapped back to concepts in the main paper, or given a more detailed treatment in the supplemental text. \n\nThere is a typo in the figure 3 caption: metrix"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission6796/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6796/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6796/Reviewer_Dg1v"
                ]
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission6796/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698770753746,
        "cdate": 1698770753746,
        "tmdate": 1699636785150,
        "mdate": 1699636785150,
        "license": "CC BY 4.0",
        "version": 2
    }
]