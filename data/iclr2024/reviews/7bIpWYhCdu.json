[
    {
        "id": "zUrLW0grid",
        "forum": "7bIpWYhCdu",
        "replyto": "7bIpWYhCdu",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission9014/Reviewer_ydVV"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission9014/Reviewer_ydVV"
        ],
        "content": {
            "summary": {
                "value": "The paper proposes Fili, an to training syntax repair neural networks. Fili works by iteratively attempting to repair a set of broken programs, then adding all pairs of (original broken program, fixed proposed program) and (still broken proposed program, fixed proposed program) to its dataset, re-training on the new dataset, and repeating. The paper augments this by proposing a curriculum learning approach, in which the neural network is presented with (broken, fixed) program pairs with larger and larger edit distances over the course of training. The paper evaluates Fili against the prior state-of-the-art baseline, Bifi, and finds that Fili improved on Bifi by about 1%. The paper also evaluates Fili against LLMs prompted to perform syntax repair, finding that GPT-3.5 generates parseable programs more often than Bifi, but with a significantly higher edit distance (making other program changes)."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "4 excellent"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "* The problem domain is interesting and well motivated\n* The solution itself (Fili) is clever, and leads to a simpler training approach than prior work\n* In addition to being simpler, the proposed approach also performs somewhat better than prior work (BiFi).\n* The paper is quite well written: I had no issues understanding any content or concepts\n* The evaluation is fairly extensive, comparing a range of baselines, ablations, and other related research questions"
            },
            "weaknesses": {
                "value": "* The intuition of the connection between iterative error fixing and curriculum learning (Section 4.3) is tenuous at best\n* The evaluation shows only modest improvements compared to prior work, and is potentially outperformed by LLMs:\n  * Fili uses a beam width of 30, while Bifi uses a beam width of 10. Bifi is a somewhat more involved model though. Are the FLOPs used to train equivalent between these models? I do see that Appendix A.3 has Fili with a beam size of 10: why was this not chosen as the model evaluated in the paper (for fairness with Bifi)?\n  * The LLM experiments are zero-shot and do not include GPT-4, but still surpass the proposed approach in the accuracy (without edit distance) metric. As for accuracy with edit distance, the LLM's prompt (\"Fix all the syntax errors to make the program parsable\") does not include the statement that the program should remain otherwise unchanged or that the edit distance should be minimized."
            },
            "questions": {
                "value": "* What is the comparison in #parameters and #FLOPs of the BiFi and Fili models in the evaluation?\n* Do LLMs still result in a large edit distance when examples are provided in the prompt, or when the prompt is modified to mention that the program should remain otherwise identical?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission9014/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698352183264,
        "cdate": 1698352183264,
        "tmdate": 1699637135624,
        "mdate": 1699637135624,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "L8XdZbJiKu",
        "forum": "7bIpWYhCdu",
        "replyto": "7bIpWYhCdu",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission9014/Reviewer_yQj5"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission9014/Reviewer_yQj5"
        ],
        "content": {
            "summary": {
                "value": "This work proposes a FILI (fix-it-learn-it) method to train the model for fixing syntax errors in programs. It improves over the existing BIFI approach, without having to train any additional models for data augmentation. As a result, in each iteration, FILI finetunes the fixer model by its own prediction."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "The proposed FILI method appears to be reasonable, and it simplifies the data augmentation approach used in BIFI. Thereby, the new method is much more efficient and easier in the training, and it achieves (slightly) better results than BIFI."
            },
            "weaknesses": {
                "value": "The delta-distance based metric adopted in the evaluation cannot fully reflect the repair performance when comparing with repair baselines. To justify that FILI outperforms large language models (LLMs), the edit accuracy subject to some delta-distance is used, with \u03b4 denoting the number of changes the fixer makes to the incorrect program.  It turns out this edit accuracy is inadequate and potentially biased, as it overlooks the semantic correctness of the program and it also ignores the possible semantic change after the repair.  \n \n \nSyntax errors are a class of relatively easier software problems to repair, and it seems that LLMs handle program syntax repair even better than FILI regarding accuracy.  It was mentioned that LLMs tend to make more changes in the program repair. However, the changes made by LLMs may depend on how the LLMs were prompted."
            },
            "questions": {
                "value": "Is there a way to more comprehensively compare with FILI and LLMs for repairing program syntax?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission9014/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698504209774,
        "cdate": 1698504209774,
        "tmdate": 1699637135503,
        "mdate": 1699637135503,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "5zFP0UzDWh",
        "forum": "7bIpWYhCdu",
        "replyto": "7bIpWYhCdu",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission9014/Reviewer_5pCb"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission9014/Reviewer_5pCb"
        ],
        "content": {
            "summary": {
                "value": "The paper presents a new technique for repairing syntax errors. The goal is to train a fixer model, one that takes a \"bad program\" that does not parse, and outputs a \"good program\" that parses correctly.\n\nTo control for arbitrary modifications, evaluation only considers edits that are up to some fixed edit distance from the original \"bad\" program. \n\nPrevious work (BIFI) used a combination of a Fixer/Breaker models to  train the Fixer model (and simultaneously, a Breaker model used to generate incorrect examples that are similar to real-world bad programs).\n\nIn contrast, this work (FILI) only uses a single Fixer model, and uses negative samples from the Fixer's beams to augment the data used to fine-tune the fixer. FILI uses high-confidence incorrect predictions from the highly-ranked beams as negative examples to be paired with the correct program (one that parses). This is similar to the approach taken by (Cao et al. 2021).\n\nThe new approach shows a modest improvement over BIFI, but does that when only using a single Fixer model."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "- Thorough evaluation. Appreciated the supplemental materials and the qualitative examples. These were very helpful, especially with respect to the evaluation metric. \n\n- It is surprising and valuable to note that a FILI outperforms BIFI while only using a single Fixer model, leveraging negative samples from the Fixer's beams. Maybe this says something about the nature of the errors being fixed and how close they are to the correct program?"
            },
            "weaknesses": {
                "value": "- The bottom-line improvement over BIFI is not significant. I do appreciate that it is hard to improve every basis point beyond 90.5% obtained by BIFI. I also understand that this is obtained without a Breaker model. \n\n- The claim that LLMs tend to make more global changes seems plausible, but you can probably control for that with prompt engineering. So the comparison with LLMs ability to fix these errors is not giving LLMs the full ability to address the problem as defined."
            },
            "questions": {
                "value": "- You write \"A key contribution of our work is to significantly simplify the process of training a syntax fixer of (slightly) higher quality than prior work (viz., BIFI).\" - is this process a bottleneck for applying the technique? What is the cost/barrier for applying BIFI that is significantly improved by FILI? \n\n- Do you have any hypothesis on why you did not see further improvement beyond two rounds? \n\n- Can you try experiments with LLMs when providing them with instructions to only make local modifications? How would that look? \n\n- page 7: should be \"FILI cannot solve 1263, while BIFI cannot solve 1428\"?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission9014/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698659458259,
        "cdate": 1698659458259,
        "tmdate": 1699637135372,
        "mdate": 1699637135372,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "YTaN2acsh8",
        "forum": "7bIpWYhCdu",
        "replyto": "7bIpWYhCdu",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission9014/Reviewer_9dQP"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission9014/Reviewer_9dQP"
        ],
        "content": {
            "summary": {
                "value": "This paper proposes FILI (Fix-It-Learn-It), which simplifies a previous work -- BIFI (Break-It-Fix-It), an unsupervised learning approach for fixing syntax errors in programs. BIFI requires two trained models (i.e., a breaker and a fixer), while FILI requires only one fixer model. The observation is that the fixer model is not perfect and thus generates correct fixes as well as incorrect fixes. In the latter case, the fixer model itself can be viewed as a breaker model. Instead of training a separate breaker model, which can be expensive, one fixer model can be used to generate both good programs and bad programs. The evaluation on the same dataset shows that FILI slightly outperforms BIFI."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "- Compared to the previous work BIFI, LIFI is simple, more efficient, and achieves (slightly) better performance. \n- Extensive evaluations and comparisons with BIFI are performed on the original dataset."
            },
            "weaknesses": {
                "value": "- The idea of using a fixer as a breaker is fairly incremental, and the improvement of performance is quite minor. Given that BIFI already achieves 95.5% accuracy over the chosen dataset, further improving it to 96.1% adds little value. \n- Curriculum learning only makes very small differences and thus seems not an essential part of the LIFI."
            },
            "questions": {
                "value": "In Table 2, two accuracy scores (the last two columns) are reported. Can you elaborate on the key difference? Why is there a sharp drop for all approaches, especially GPT-3.5-turbo?\n\nIs there any particular reason that a breaker model is more difficult to train? Page 6 mentions that training a fixer for two rounds takes around 20 hours, while a breaker model requires 2 days. \n\nThe dataset collected by BIFI seems pretty much saturated. Have the authors considered a different dataset? (A comment rather than a question).\n\nThere is a minor typo at the bottom of page 7, \"BIFI cannot solve 1263, while BIFI cannot solve 1428\". BIFI was mentioned twice, one of which should be LIFI."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission9014/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698889439686,
        "cdate": 1698889439686,
        "tmdate": 1699637135198,
        "mdate": 1699637135198,
        "license": "CC BY 4.0",
        "version": 2
    }
]