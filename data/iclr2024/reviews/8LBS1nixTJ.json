[
    {
        "id": "pYE2xCC6UH",
        "forum": "8LBS1nixTJ",
        "replyto": "8LBS1nixTJ",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission8097/Reviewer_n1d2"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission8097/Reviewer_n1d2"
        ],
        "content": {
            "summary": {
                "value": "Graph reordering is effective in improving the cache utilization of graph processing. This paper observes that existing graph reordering algorithms have a tradeoff between effectiveness (i.e., quality of the reordering) and efficiency (i.e., execution time of the reordering algorithm). To mitigate this tradeoff, the paper proposes a new graph reordering algorithm that uses MinHash to generate hash signatures for the nodes and then sorts the signatures for reordering. Experiment results show that the HashOrder algorithm is both efficient and effective."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "I enjoy this paper because graph reordering is a well-known difficult problem, and the paper solves it with a novel and effective idea. \n1. Using MinHash to conduct graph reordering is a novel idea and makes sense. \n2. Section 3.3 shows why MinHash works in theory.\n3. The experiment results are strong, showing that the proposed HashOrder algorithm is efficient and effective."
            },
            "weaknesses": {
                "value": "The authors may be more detailed when discussing how hashing is used to handle graph problems in the related work, e.g., by describing how a graph problem is mapped to hashing. This does not hurt the novelty of the paper and allows readers to learn more."
            },
            "questions": {
                "value": "A common trick in hashing is to hash multiple times to enlarge the collision probability gap between similar and dissimilar object pairs. Any idea on how HashOrder can benefit from multiple hash signatures? I think that may be an interesting problem."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "details_of_ethics_concerns": {
                "value": "NA"
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission8097/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698206516609,
        "cdate": 1698206516609,
        "tmdate": 1699637003539,
        "mdate": 1699637003539,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "88Jj4ykE8j",
        "forum": "8LBS1nixTJ",
        "replyto": "8LBS1nixTJ",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission8097/Reviewer_EBBV"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission8097/Reviewer_EBBV"
        ],
        "content": {
            "summary": {
                "value": "This paper emphasizes the importance of improving cache utilization in efficiently processing large graphs. To address low cache utilization in graph learning and other applications, this paper studies graph reordering, a task-independent approach to improving cache efficiency, and proposes HashOrder, a probabilistic algorithm using randomized hashing. The authors try to improve the efficiency of memory access. The authors also discuss the tradeoff between the quality of graph reordering and the efficiency of the reordering process and argue that the proposed algorithm, HashOrder, improves the quality of reordering while significantly reducing the computational overhead. They also show that the proposed hashing-based ordering guarantees a certain quality, assuming the cache efficiency is based on a specific fitness. Experimental comparison with existing methods confirms that a certain speedup is achieved for web graphs and social networks."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "1 poor"
            },
            "strengths": {
                "value": "The flow of the discussion is understandable and easy to read. Furthermore, a theoretical analysis of the effectiveness of the proposed method is provided, which guarantees the quality of the proposed graph reordering algorithm under certain assumptions. Theoretical guarantees are helpful because they cannot be demonstrated experimentally. Furthermore, the authors compared the proposed method with several graphs and existing experimental methods and emphasized its usefulness."
            },
            "weaknesses": {
                "value": "The paper has two major weaknesses.\n\n1. Throughout the paper, it isn't easy to see the difference between the existing and proposed methods. It appears as if the proposed method incorporates randomness into the existing hash-based graph sorting algorithm. It should be clarified what method is used for the existing method that is the basis of the proposed method and how it differs from the proposed method. We believe this will further clarify the contributions of the proposed method and make the paper a good one.\n\n2. Only small-world and scale-free graphs such as web graphs, social networks, and citation networks were used in the experiments. Although I understand that these graphs are commonly used in machine learning, the proposed HashOrder may be effective only for these highly central graphs. Therefore, it would be better to experiment with a broader range of graph data with different properties."
            },
            "questions": {
                "value": "The questions are related to what was mentioned in the Weaknesses section.\n\n1. Can you briefly describe what kind of graph reordering algorithms are used in the existing methods based on the proposed method? Also, can you explain the difference between the proposed and existing methods?\n\n2. Can you provide experimental results using other than small-world and scale-free graph datasets such as web graphs or social networks? Or can you discuss the performance of the proposed method on them?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission8097/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission8097/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission8097/Reviewer_EBBV"
                ]
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission8097/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698294096336,
        "cdate": 1698294096336,
        "tmdate": 1699637003424,
        "mdate": 1699637003424,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "qG7gwCwHrw",
        "forum": "8LBS1nixTJ",
        "replyto": "8LBS1nixTJ",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission8097/Reviewer_KkKE"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission8097/Reviewer_KkKE"
        ],
        "content": {
            "summary": {
                "value": "This paper proposes an efficient graph reordering algorithm based on randomized hashing: HashOrder. Detailly, the authors propose a probabilistic algorithm for high-quality ordering, which is lightweight and parallelizable. Evaluations on graph processing workloads and GNN data loaders show that the proposed HashOrder outperforms the existing state-of-the-art method with considerable speedup."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "1. The authors proposed an efficient graph reordering algorithm based on randomized hashing to improve graph algorithms. They also introduce a probabilistic perspective to demonstrate the advantages over previous algorithms. For the in-bucket ordering operation, they employ neighbor grouping and degree sorting techniques and analyze the ablation study for different numbers of hops k and threads to show the scalability of HashOrder.\n\n2. The authors analyze the reordering time and overall execution speedup for graph algorithms. The proposed HashOrder achieves a better tradeoff between reordering consumption and reordered data quality."
            },
            "weaknesses": {
                "value": "1. novelty of this paper is limited. As admitted by the authors, LSH has been used in similar problems for graph reordering. \n\n2. There is not much \"machine learning\" in this paper. While it targets GNNs, the paper is more of a system work in my opinion. I am not sure ICLR is the proper venue for it."
            },
            "questions": {
                "value": "1. The proposed HashOrder algorithm seems to be a CPU algorithm, since it is parallelizable, can it run on GPU?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission8097/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698596340104,
        "cdate": 1698596340104,
        "tmdate": 1699637003303,
        "mdate": 1699637003303,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "2E0nPA3WRd",
        "forum": "8LBS1nixTJ",
        "replyto": "8LBS1nixTJ",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission8097/Reviewer_L3q7"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission8097/Reviewer_L3q7"
        ],
        "content": {
            "summary": {
                "value": "This paper proposes to use HashOrder for remapping graph ids, with the goal of improving cache efficiency. The intuition is that cache utilization can be improved by placing neighbors that are frequently co-accessed together close in memory and that in-neighborhood intersection has direct connections to the cache efficiency metric. The authors propose to leverage minHash to compute LSH codes and then within each bucket, nodes are sorted by neighbor grouping or degree. Experiments are conducted."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "1. The idea of using LSH ordering is interesting and cool.\n2. The paper is easy to read.\n3. The authors have conducted quite extensive experiments."
            },
            "weaknesses": {
                "value": "1. My main concern lies in the experimental results. \n-- It does not seem to have significant improvements compared to Gorder in Figure 3.\n-- It is better to report median speedup, instead of \"Upto xx\". The median speedup seems to be limited? and some are experiencing degration, e.g., in Figure 4.\n-- It would be good to show end2end time for GNN training, instead of only reporting GNN data loader time in Figure 4. \n2. It would be good if you can measure cache hit in the experiments.\n3. Will reordering lead to other side effects? E.g., GNN training time and accuracy?"
            },
            "questions": {
                "value": "1. why there exist blanks in Figure 4, e.g., graphsaint + speedup panel?\n2. why choose the number of hash functions l = 2? will this affect the result?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission8097/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission8097/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission8097/Reviewer_L3q7"
                ]
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission8097/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698717300464,
        "cdate": 1698717300464,
        "tmdate": 1699637003092,
        "mdate": 1699637003092,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "tWdQMKCeJu",
        "forum": "8LBS1nixTJ",
        "replyto": "8LBS1nixTJ",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission8097/Reviewer_3s87"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission8097/Reviewer_3s87"
        ],
        "content": {
            "summary": {
                "value": "The paper presents a row ordering strategy for sparse matrices based on locality aware hashing. Theoretical results are provided to show that this scheme is near-optimal for well-separable sparse matrices. The experimental evaluation considers the speed-up obtained by the reordering scheme for various graph work-loads, with other reordering schemes as baselines. Reordering time and parallelization are also considered."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "+ The approach in the paper makes a lot of sense and appears to be new. While hashing has been used in many works on efficient sparse matrix computations, I was not able to find prior references that specifically consider locality-aware hashing of sparse matrix rows to optimize for locality.\n + The experimental results are promising, showing that the proposed reordering scheme outperforms several common alternative reordering methods.\n + The paper is generally fairly well-written and organized."
            },
            "weaknesses": {
                "value": "- I don't follow the structure of the theoretical results. Lemma 1 assumes existence of a hash family that is never proven, then Theorem 1 builds on Lemma 1, but drops the assumption that Lemma 1 had. This seems incorrect.\n - The paper misses what I would consider a seminal work that is also most-closely related to the approach in the paper\n     Saad, Yousef. \"Finding exact and approximate block structures for ILU preconditioning.\" SIAM Journal on Scientific Computing 24.4 (2003): 1107-1123.\n   This paper aims to reoder similar rows of a sparse matrix together by hashing and by cosine comparison (similarity in nonzeros), as well as a hybrid method. These methods are different from that in the paper but obviously closely related and warrant discussion as well as experimental comparison.\n - The experimental results are based only on the authors' implementation. Some comparisons to existing libraries would be helpful in gauging whether the timings are competitive.\n - While the implementations are not fully described, the workloads largely seem to be all based on repeated SpMV and SpMM. It would be clearer to evaluate the reorderings for efficiency of those two basic kernels. The consideration of end-applications related to GNNs is secondary (they are dominated by SpMM), and seems motivated by the choice of publication venue.\n - Building on the prior point, I think there would be more expert reviewers, interest, and appropriate feedback for this type of paper at high-performance computing, scientific computing, and parallel computing publication venues such as Supercomputing, SPAA, IPDPS, SISC, etc., as these communities extensively study optimization of graph and sparse matrix primitives.\n\nOverall, the paper presents an interesting and promising row-reordering scheme for sparse matrix products. However, the theoretical results seem to contain some errors or are imprecise. The experimental results are reasonable. I would be supportive of publication of this work if the theoretical results are corrected / claims are made more modest (assumptions provided) as appropriate. Due to the presence of issues with the theoretical result, and as ICLR seems a suboptimal publication venue to me for this type of work, I would lean toward rejection."
            },
            "questions": {
                "value": "Please provide clarification or planned revision regarding concerns of in the theoretical results."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission8097/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission8097/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission8097/Reviewer_3s87"
                ]
            }
        },
        "number": 5,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission8097/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698768443291,
        "cdate": 1698768443291,
        "tmdate": 1699637002984,
        "mdate": 1699637002984,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "rHi2Jc33iG",
        "forum": "8LBS1nixTJ",
        "replyto": "8LBS1nixTJ",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission8097/Reviewer_M1A7"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission8097/Reviewer_M1A7"
        ],
        "content": {
            "summary": {
                "value": "This paper introduces an efficient and effective graph reordering algorithm utilizing node clustering based on randomized hashing. It theoretically shows that the orderings ensure some quality guarantees under clustering assumptions. The experiments verify that the proposal is efficient and effective."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "S1. The experiments verify the effectiveness of the proposal under several representative graph analysis tasks.\n\nS2. The proposal provides a theoretical guarantee for the quality of graph ordering."
            },
            "weaknesses": {
                "value": "W1. Regarding the evaluation of GNN data loading, the purpose is unclear. The evaluation should focus more on practical performance aspects of GNN, such as training time and inference time, Indeed, [1] conducted various experiments on typical GNN methods, such as GCN and GIN, using various graph analysis frameworks like DGL and PyG, to assess their training and inference times.\n\nW2. Insufficient comparison with related techniques.\n- The proposal performs node clustering using Minhash and parallelization. In fact, Rabbit order (Arai et al., 2016) shares a similar design concept, as it conducts node clustering using a modularity-based method and also incorporates parallelization. Hence, the authors should offer a comprehensive comparison between the proposal and Rabbit order, including performance experiments.\n- The definition of fitness is slightly extended from the one introduced in GO algorithm (Wei et al., 2016), so novelty is relatively weak.\n\nW3. Theorem 1 is founded on the cluster quality (Definition 1). However, it does not provide the size of \\eplsion for Minhash, which is used in the proposal. \n\nW4. It would be beneficial to include an end-to-end evaluation that encompasses both reordering and graph analysis."
            },
            "questions": {
                "value": "We would appreciate it if the authors could provide us with feedback regarding the points raised in W1-W4."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission8097/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission8097/Reviewer_M1A7",
                    "ICLR.cc/2024/Conference/Submission8097/Senior_Area_Chairs"
                ]
            }
        },
        "number": 6,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission8097/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698809328896,
        "cdate": 1698809328896,
        "tmdate": 1700710093362,
        "mdate": 1700710093362,
        "license": "CC BY 4.0",
        "version": 2
    }
]