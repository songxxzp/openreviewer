[
    {
        "id": "77iBxHej5u",
        "forum": "nnsPXGPcgI",
        "replyto": "nnsPXGPcgI",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4633/Reviewer_brSL"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4633/Reviewer_brSL"
        ],
        "content": {
            "summary": {
                "value": "As the size of models becomes larger, distributed training has been paid much attention to. In this paper, the authors develop an infrastructure for automatic parallelism. Their infrastructure is based on two data structures and compatible with multiple ecologies, including PyTorch and JAX. The performance of their solution is better than existing methods."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "1. The problem investigated in this paper is fundamental.\n2. The presentation of this paper is clear. It is easy for me to follow the paper.\n3. The infrastructure has great performance."
            },
            "weaknesses": {
                "value": "1. The main issue of this paper is the motivation of this paper is not clear. Since we already have the Alpa system to do distributed training automatically, I do not know why we need to develop a new tool. In addition, the experimental results show that the infrastructure developed in this paper has similar results as Alpa over GPT and WideResnet. Furthermore, the GAT model is not large enough. In most cases, we use the GAT model to solve small-size graphs. Therefore, I believe that Alpa is good enough.\n2. As for automatically distributed training, the search time is an important metric. Is it possible to compare the search time of MetaDist with Alpa in the experiment section?\n3. Could the authors evaluate their infrastructure over multiple nodes?\n4. Megatron-LM is a widely used distributed training framework. I think the authors also need to add Megatron-LM as baseline for Pytorch implementation.\n5. As an infrastructure, I think the authors should open their source code. If this infrastructure is used by many researchers and engineers, it means that this infrastructure is useful. In view of this, the GitHub star and download times are two important metrics for an open-sourced infrastructure. \n6. This paper looks like a system paper, and I am not sure whether this paper could be accepted by the ICLR community."
            },
            "questions": {
                "value": "Please see the Strengths and Weaknesses."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "details_of_ethics_concerns": {
                "value": "N/A"
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4633/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698201931096,
        "cdate": 1698201931096,
        "tmdate": 1699636442856,
        "mdate": 1699636442856,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "wuhotLXB8S",
        "forum": "nnsPXGPcgI",
        "replyto": "nnsPXGPcgI",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4633/Reviewer_9K4K"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4633/Reviewer_9K4K"
        ],
        "content": {
            "summary": {
                "value": "This work proposes MetaDist, which provides automatic parallelism for different frameworks such as PyTorch and Jax."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "I appreciate the engineering effort made in this work and it is really thrilling to see an automatic parallelism toolkit that is framework agnostic. I believe this is significant for the industry to ease the difficulty of training large models."
            },
            "weaknesses": {
                "value": "(W1) Limited contributions. It is unclear how the proposed MetaDist representation and the ShardCombine algorithm improve over existing works.\n\n(W2) This work does not support pipeline parallelism. And the searching algorithm does not take computation cost into account.\n\n(W3) More baselines are expected and some of the experimental results need elaboration."
            },
            "questions": {
                "value": "(Q1) From my humble opinion, this work is not well motivated and the rationality behind the proposed methods is not well explained.\n- First, in the introduction section, the authors discussed two main challenges, i.e., (i) lack of ecological compatibility, and (ii) difficulty in development, maintenance, and benchmarking. However, they seems more of an implementation issue rather than a research topic.\n- Second, there is no discussion about the limitations of existing methods and how the MetaDist representation and the ShardCombine algorithm tackles them (see questions below). For me, they are just put forward straightforwardly.\n\n(Q2) In essence, MetaDist can be viewed as a kind of IR in a distributed manner. Therefore, I believe it is necessary to compare MetaDist related works such as pONNX [1] and Unity [2]. For me, the ShardSpec and CombineSpec can be broken down into the partition, combine, replicate, and reduce operators in Unity, and the latter can provide more fine-grained representations.\n\n[1] Wang et al. Parallel Training via Computation Graph Transformation.\\\n[2] Unger et al. Unity: Accelerating DNN Training Through Joint Optimization of Algebraic Transformations and Parallelization.\n\n(Q3) MetaDist focuses on intra-op parallelism, so it is unknown whether could it support pipeline parallelism, which is frequently used in large-scale distributed deep learning.\n\n(Q4) Section 3.3 states that \u201cThe ShardCombine algorithm is an exploration algorithm\nthat utilizes heuristic information to shard input data, and attempts to re-combine local results\ninto global results using the TryCombine function\u201d. What is the heuristic information here? Furthermore, how the heuristic information helps your algorithm design?\n\n(Q5) Section 3.4.1 states that \u201cThe objective of the problem is to minimize the communication cost\u201d. It is confusing why computation cost is not taken into account here. Furthermore, it is unclear how the ILP differs from the one in Alpa.\n\n(Q6) The experiments were conducted on a single GPU server with eight GPUs. I am afraid the exploration space of parallelism would be extremely limited and could not evaluate the performance thoroughly.\n\n(Q7) Regarding the experimental results, there are a few issues:\n- The major competitors are Alpa and FairScale, however, there should be frameworks that are more widely used for large model training in practice, such as DeepSpeed and Megatron-LM. I believe comparisons are necessary.\n- The authors stated that \u201cZeRO-3 is difficult to scale efficiently because of its communication overhead\u201d. When memory is not scarce, ZeRO-2 may be a better option than ZeRO-3 and pure DataParallel. Please also compare with ZeRO-2.\n- When training on a single GPU, there should be no performance differences, but they are reported in Figure 8. Please elaborate.\n- There are several cases that MetaDist-BS runs out of memory. Does it indicate that your searching algorithm does not take memory limit as the constraint?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4633/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698573502858,
        "cdate": 1698573502858,
        "tmdate": 1699636442751,
        "mdate": 1699636442751,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "UbRtLrw3cL",
        "forum": "nnsPXGPcgI",
        "replyto": "nnsPXGPcgI",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4633/Reviewer_Rppy"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4633/Reviewer_Rppy"
        ],
        "content": {
            "summary": {
                "value": "This manuscript / work is investigating the automatic parallelism and in particular is concerned with the selection of the best combination of strategies from a selection space of parallel strategies. The authors present the MetaDist, which they claim it is an infrastructure for automatic parallelism. They propose two abstract data structures, the MetaOp and MetaIR, respectively, which enable them to construct the MetaSPMD space. \nThe ShardCombine Algorithm obviates the need for manual annotation, significantly reducing the development and maintenance cost. Moreover, their approach is natively compatible with multiple ecologies, including PyTorch and JAX. To validate their design, they implement two baseline automatic parallelism algorithms based on MetaDist. Their experiments demonstrate that our approach achieves state-of-the-art performance compared with other distributed solutions."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "+ Automatic parallelism is a crucial problem for current computing systems and especially recent machine learning architectures"
            },
            "weaknesses": {
                "value": "- The impact of pruning on the prediction results needs to be addressed. How does pruning influence the accuracy or effectiveness of the model?\n- When measuring throughput, it should be ensured that the profiling time and the time taken for pruning do not adversely affect the overall performance of the framework. The authors should explain how they have accounted for these factors in their evaluation.\n- Incomplete discussion of prior work on automatic parallelization especially those that consider compiler approaches that are independent of a specific processor architecture."
            },
            "questions": {
                "value": "1) In section 3.2, what is callable primitive operator stans for in op_function, invars, outvars, and spmd_rules?\n2)In figure 2, what is the MetaIR? There is a MetaIR on the left side and another MetaIR in the middle.\n3) In Section 3.3 Sharedim(id=j)(Sj) is used to determine the parallelism strategies. How many such strategy could be applied? I notice the paper mentioned S1 S2 S3 in the rest of the paper. For Si, how many ways to partition the tensor?\n4) What is the definition of score function? Is it just the train time? If two parallelisms could be applied, how to evaluate which one is better?\n5) How is the communication bandwidth affect the result?\n6) The treatment and discussion of prior work on automatic parallelism and compiler approaches for automatic parallelization only covers papers from 2022 and 2023 when there are pioneering approaches even before that. Here are some examples of compiler approaches to automatic parallelization: \"A load balancing inspired optimization framework for exascale multicore systems: A complex networks approach.\" In 2017 IEEE/ACM International Conference on Computer-Aided Design (ICCAD), pp. 217-224. IEEE, 2017. \"Self-optimizing and self-programming computing systems: A combined compiler, complex networks, and machine learning approach.\" IEEE transactions on very large scale integration (VLSI) systems 27, no. 6 (2019): 1416-1427. \"A distributed graph-theoretic framework for automatic parallelization in multi-core systems.\" Proceedings of Machine Learning and Systems 3 (2021): 550-568. \"Plasticity-on-chip design: Exploiting self-similarity for data communications.\" IEEE Transactions on Computers 70, no. 6 (2021): 950-962. The authors have to check the literature and carefully contrast all existing related approaches to automatic parallelization and compiler approaches especially when these prior approaches were developed to be computer architecture independent and adaptable to general settings."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission4633/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4633/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4633/Reviewer_Rppy"
                ]
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4633/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698798669105,
        "cdate": 1698798669105,
        "tmdate": 1700006806895,
        "mdate": 1700006806895,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "DayugUD4CB",
        "forum": "nnsPXGPcgI",
        "replyto": "nnsPXGPcgI",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4633/Reviewer_KMij"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4633/Reviewer_KMij"
        ],
        "content": {
            "summary": {
                "value": "The authors propose a technique to help address and improve the manual efforts necessary to parallelize training pipelines for large models on limited hardware. Two data structures MetaOps and MetaIR are proposed to construct the MetaSPMD space. MetaIR and MetaOp are framework-agnostic approaches where the computational graph of a network can be converted into MetaIR and the corresponding operators are converted to MetaOps. MetaSPMD specifies the operator-level parallel space of MetaOps and details how to shard inputs and combine local results into global ones.\nBased on these structures, the paper proposes the ShardCombine algorithm to successfully shard input data and re-combine local results."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "+ The ideas presented are well thought out, and much needed\n+ Good that it works on both PyTorch and JAX\n+ Experimental results could improve, but are not a bottleneck for an acceptance"
            },
            "weaknesses": {
                "value": "- It might help to have some examples when the cache mechanism lacks effectiveness and is effective. \n- The major issue with this is reproducibility. Simply by reading the paper, it will be difficult for me to reproduce the work in this paper. Artifacts will help. But the parts/sections about the MetaIR, MetaOps, and MetaSPMD could have been written so that one can understand how they are being practically generated. Conceptually, it\u2019s fine.\n- Why does Beam Search + ResNet + JAX in Figure 7 so much longer than any other combination? Is it simply because JAX has more fine-grained operators?\n- The wiring could improve a bit, especially Sections 3 and 4.\nIt would have been nice to have some results on at least a 1 billion scale model. Or do the four different model sizes refer to GPT2, 3.5, etc."
            },
            "questions": {
                "value": "Please check the  Weaknesses for detailed questions to be answered.\n- Are there some examples when the cache mechanism lacks effectiveness and is effective?\n- Are there artifacts available for reproducibility purposes?\n - Why does Beam Search + ResNet + JAX in Figure 7 so much longer than any other combination? Is it simply because JAX has more fine-grained operators?\n- Are there results on at least a 1 billion scale model? do the four different model sizes refer to GPT2, 3.5, etc?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4633/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698809123472,
        "cdate": 1698809123472,
        "tmdate": 1699636442543,
        "mdate": 1699636442543,
        "license": "CC BY 4.0",
        "version": 2
    }
]