[
    {
        "id": "67qRa7n4yf",
        "forum": "mZn2Xyh9Ec",
        "replyto": "mZn2Xyh9Ec",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4211/Reviewer_Jn9J"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4211/Reviewer_Jn9J"
        ],
        "content": {
            "summary": {
                "value": "This paper describes FlashAttention-2 which improves upon FlashAttention by introducing \"tweaks\" to improve performance on GPUs.   The paper claims the tweaks improve performance by increasing occupancy and use of matrix-multiply hardware (tensor cores).  The paper reports a bit under $1.3\\times$ wall clock speedup versus FlashAttention."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "Improving training speed of LLMs is of great interest to many."
            },
            "weaknesses": {
                "value": "Could do a better good job explaining how a given \"tweak\" helps achieve a given improvement (occupancy, use of tensor cores)."
            },
            "questions": {
                "value": "Regarding the equation at the top of Page 5, I am unclear \"$\\mbox{diag}(l^{(1})^{-1}$\" is to the power -1.  Comparing to the prior equation seems like exponent of -1 should be 1.\n\nI think it would help some readers (like me) understand the contribution a bit better if the paper briefly summarized the key changes in the six (unnumbered) equations on Page 5 that are described as the \"online softmax trick\" versus the six on Page 3.  \n\nHow do the \"tweaks\" in Section 4.1.1 help reduce non-matrixmul FLOPs?  I know a fair amount about tensor cores, but it wasn't obvious to me.\n\nThe paper claims occupancy is increased on Page 6 but it was unclear: (i) what definition of occupancy is being used (GPU resources could mean many things and occupancy often just refers to number of warps that can concurrently run versus max number supported by hardware ); and (ii) whether any measurement has been made to confirm the claimed improvement (e.g., using NVIDIA Parallel Nsight or similar approaches for collecting performance counters).\n\nMuch of Algorithm 1 seems similar to the original FlashAttention.  It may help summarizing which lines are different.  It would also help the reader if there was a summary of which lines lead to the reduction in non-matrixmul FLOPs and improved occupancy.\n\n\"Only at the every end of the\" - typo.\n\nFor the backward pass (Section 3.1.2): It was unclear what the relevance of the paragraph on MQA and GQA is to the changes in FlashAttention-2 versus FlashAttention.  \n\nIn Figure 2, does an uncolored square mean no computation?  Does the backward pass for a given worker start right away or do workers need to synchronize between forward and backward pass?  Do you not need to compute the combined result for the forward pass before you can start the backward pass?    If you do need to wait, then how can one achieve greater than 50% use of peak performance if roughly half the compute cycles are spent waiting for the longest running forward/backward pass thread block to complete?   If you don't need to wait, why not?\n\nI'm not sure how to relate Figure 3 to Algorithm 1 (i.e., which lines it is meant to illustrate).  From the two paragraphs above Figure 3 I get it there are two potential sources of reduced execution time: fewer shared memory accesses and fewer synchronizations (__syncthreads, I assume).  Unclear which of those matters most and why given that shared memory accesses proceed about as fast as register file accesses and synchronization with a thread block is low overhead.  \n\nWhy is FlashAttention (version 1) missing in Figure 5?\n\nAs someone who knows GPUs well, I would have liked to see more performance counter data to backup the claims of the sources of performance improvements.   I understand space is limited in the main text, but in checking the supplemental material, while it is great to see all the code, there appeared to be no PDF providing additional data or details.  Including one might have helped."
            },
            "flag_for_ethics_review": {
                "value": [
                    "Yes, Other reasons (please specify below)"
                ]
            },
            "details_of_ethics_concerns": {
                "value": "Hard to say this submission conforms to double blind review standards given the title of the paper strongly suggests author overlap with the prior FlashAttention work.   Given the nature of unconscious bias, I cannot say whether this may have influenced me and if so how (which is the whole purpose of using double blind review)."
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission4211/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4211/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4211/Reviewer_Jn9J"
                ]
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4211/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699074515782,
        "cdate": 1699074515782,
        "tmdate": 1699636388262,
        "mdate": 1699636388262,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "UmS7FpjK6j",
        "forum": "mZn2Xyh9Ec",
        "replyto": "mZn2Xyh9Ec",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4211/Reviewer_hPzR"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4211/Reviewer_hPzR"
        ],
        "content": {
            "summary": {
                "value": "The authors present a new algorithm, FlashAttention-2, which builds in FlashAttention to improve the efficiency of the attention algorithm when executed on GPUs. The authors focus, in particular, on maximizing the amount of time spent in \"matrix-multiply\" FLOPs, that is, computation that is using matrix multiplication units, which are better lent to GPU hardware given particular division of work amongst warps and loose requirements around shared memory accesses.\n\nThese optimizations include:\n1. Deferring scaling of values in the online softmax computation to further reduce HBM utilization\n2. Save a logsumexp for online softmax backwards rather than max and sums to reduce the memory usage.\n3. The bulk of the changes present in FlashAttention-2 are related to scheduling. Parallelization over the sequence dimension results in better warp occupancy in cases where there are few attention heads or a low batch size. Further, the authors change how the backward pass shares computation in the query derivative update, which also reduce HBM utilization. Splitting the KV cache amongst thread blocks also helps to saturate memory bandwidth. Better partitioning amongst warps, overall, drives better utilization."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "- The proposed approach shows promising improvements in a performance-critical parts of end-to-end transformer computation.\n- The approach is symmetrically applicable for both training and inference with broad applications in both research and production settings.\n- It is important that engineering contributions such as FlashAttention-2 (which I will refer to FA-2) are part of conference literature, and the attention to detail therein is what drives the solid impact of this work rather than a special \"algorithmic contribution\" in a classical sense.\n- The devil is in the details: careful analysis of scheduling and an intuitive approach to laying out computation drives the approach's strong results.\n- The work builds on an already-strong baseline, FlashAttention.\n- The paper is well-written and organized and clearly lays out the authors' contributions; in particular, the paper is quite accessible to those without a low-level background in machine learning computation or GPU programming."
            },
            "weaknesses": {
                "value": "- The baselines benchmarked in the paper can be stronger.\n  - For latency benchmarks in Figure 5, the only baselines are a FasterTransformer and PyTorch. The authors do not consider compilers\n  - Do the PyTorch benchmarks in Figure 5 use CUDA Graphs? PyTorch has significant framework overhead, and CUDA Graphs can give an order of magnitude speedup for some workloads, especially latency-sensitive ones.\n- The above applies more generally to the other evaluation in Section 4; FlashAttention-2 is compared to PyTorch, then implementations with Triton and Cutlass, but not with any other frameworks capable of code generation. For example: while XLA may not be memory-bandwidth-aware by default, it can still generate kernels with fused operators that significantly reduce total memory I/O.\n- While not needing to resort to approximations is a significant advantage of FlashAttention-2, this could be highlighted much more in the manuscript. Section 1 discusses many alternative attention approximations -- even speculation about why these aren't used (i.e. they are riskier when researchers have limited resources and don't adapt as easily) would strengthen the exactness boon of the authors' approach.\n\nSeveral improvements to writing might improve the paper:\n- The constant and equation in general in Sections 4.1 (i.e. 4) is not adequately explained (why is the sequence length squared? why 4?). Clarifying these might help new readers.\n- The usage of \"major problem\" in the first sentence of the abstract is unclear -- it's clear that scaling sequence lengths is difficult; are the authors suggesting the problem is difficult, significant, or both?\n- Section 1: \"However, context length increases\" <-- is missing \"**as** context length increases\"\n- Text in all of the provided diagrams can be made clearer, and the diagrams can be rendered more clearly. It is difficult to read them as is.\n- Section 3.2 might more clearly explain \"prefill\" and \"KV cache\" to readers. While somewhat ubiquitously understood amongst people doing performance engineering for large-scale transformers, some clarification would help the paper flow and increase its accessibility.\n- Figure 2 can be clearer with respect to rows and columns -- this is the attention matrix -- what is its size/can the axes be labeled?"
            },
            "questions": {
                "value": "- Why are the gaps between FA/FA-2 different with Cutlass versus in Triton, if the authors were to speculate? Further, the comparison in section 4.1 can be clarified -- is the assertion that the performance of the vanilla CUDA implementation of FlashAttention and the Cutlass FlashAttention implementation in xformers are congruent?\n- The authors might also consider mentioning in the manuscript what they think trends in changing GPU hardware will mean for FA-2's general direction. Given that HBM bandwidth is not improving as quickly as SM arithmetic latency and that the amount of vram available on GPUs is not increasing, how will the approaches used in FA-2 change in relevance over time?\n- Do you think a compiler could realistically generate FA-2? What sort of cost models might be required?\n- How does FA-2 function when there is no explicit sequence length dimensions? In many training setups, tokens are padded without sequence boundaries, and models learn end-of-sequence tokens implicitly. What is the default behavior in this regime?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission4211/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4211/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4211/Reviewer_hPzR"
                ]
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4211/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699147804403,
        "cdate": 1699147804403,
        "tmdate": 1699636388174,
        "mdate": 1699636388174,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "RchnThk41v",
        "forum": "mZn2Xyh9Ec",
        "replyto": "mZn2Xyh9Ec",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4211/Reviewer_RLZf"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4211/Reviewer_RLZf"
        ],
        "content": {
            "summary": {
                "value": "This paper presents improvements to FlashAttention (Dao et al., 2022), a established method for efficiently computing attention through fused ops. These improvements are designed specifically for better parallelism and work partitioning in GPUs, resulting in the development of FlashAttention v2. Performance benchmarks have been conducted for both training and inference phases. Additionally, the authors provide comprehensive results from training end-to-end GPT-style models with 1.3 billion and 2.7 billion parameters and 2k and 8k context sizes."
            },
            "soundness": {
                "value": "4 excellent"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "4 excellent"
            },
            "strengths": {
                "value": "There are many things to like in this paper, such as:\n\n1. The paper is well-written\n2. The improvements are well-explained and justified\n3. The paper covers both training and inference time optimization\n4. The results are encouraging\n\nIn summary, I expect widespread adoption of FlashAttention v2 within the community. Furthermore, the methods proposed and utilized in this paper could inspire the creation of more efficient components in machine learning."
            },
            "weaknesses": {
                "value": "FlashAttention v2 has a notable limitation: it relies on recent, specialized GPU architectures like the A100 (and H100). Additionally, the requirement for custom CUDA kernels adds a layer of complexity. \n\nA small critique is that Figure 3 could benefit from a more descriptive caption."
            },
            "questions": {
                "value": "Which GPU architectures currently support FlashAttention v2?\nWhat are the minimum requirements for its use?\nWhat modifications are necessary to adapt FlashAttention v2 for use with relative positional encoding methods (e.g., RoPE and ALiBi)?\nDoes FlashAttention v2 offer compatibility with sparse block masks (as in v1)?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "10: strong accept, should be highlighted at the conference"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4211/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699400339142,
        "cdate": 1699400339142,
        "tmdate": 1699636388113,
        "mdate": 1699636388113,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "QeaOL3CvbI",
        "forum": "mZn2Xyh9Ec",
        "replyto": "mZn2Xyh9Ec",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4211/Reviewer_AK2B"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4211/Reviewer_AK2B"
        ],
        "content": {
            "summary": {
                "value": "Scaling Transformers for longer sequences holds the promise of enhancing language modeling and understanding complex inputs, but is hindered by the attention layer's quadratic scaling in memory and runtime. FlashAttention has mitigated this by bringing linear memory usage and considerable runtime speedup, yet it still lags behind the efficiency of optimized matrix multiplication operations. To address this, FlashAttention-2 is introduced with improved work partitioning, yielding a significant speedup and reaching closer to the efficiency of matrix multiply (GEMM) operations. Empirical validation shows that FlashAttention-2 significantly increases the training speed of GPT-style models on both A100 and H100 GPUs."
            },
            "soundness": {
                "value": "4 excellent"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "* The proposed platform-specific optimizations are clever and sound.\n* The resulting software artifacts are useful and have has the potential to benefit both researchers and practitioners."
            },
            "weaknesses": {
                "value": "* The work is mostly engineering-focused, with several \"tweaks\" made to FlashAttention.\n* The performance gains are relatively marginal, especially when compared to those of the original FlashAttention over the baseline.\n* The absence of an ablation study makes it difficult to pinpoint the exact sources of efficiency."
            },
            "questions": {
                "value": "Thank you for submitting to ICLR 2024. FlashAttention-2 is a very useful artifact that has the potential to benefit both researchers and practitioners, and the proposed optimization techniques appear sound.\n\nHere are my questions I would like the authors to answer:\n* Perhaps the most significant omission in this paper is the lack of an ablation study. This makes it challenging to discern the contributions of individual optimizations. Among the proposed optimizations, which one has the highest impact?\n* In Section 3.1, is the technique of skipping blocks for \"causal masking\" also applied to FlashAttention? As the authors mention, this technique can be applied to both FlashAttention and FlashAttention-2, and I am curious about how the application of this technique would affect the performance gap between FlashAttention and FlashAttention-2 if it had not been applied to FlashAttention.\n* In Section 3.3, what is the performance impact of \"tuning block sizes\"? Was the same level of parameter tuning effort applied to FlashAttention? My question concerns the extent to which the performance gains over FlashAttention can be attributed to algorithmic improvements versus additional tuning effort, with the latter being less significant."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4211/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699604636530,
        "cdate": 1699604636530,
        "tmdate": 1699636388057,
        "mdate": 1699636388057,
        "license": "CC BY 4.0",
        "version": 2
    }
]