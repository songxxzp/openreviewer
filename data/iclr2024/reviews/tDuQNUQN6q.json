[
    {
        "id": "xory8Yy4eb",
        "forum": "tDuQNUQN6q",
        "replyto": "tDuQNUQN6q",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission6055/Reviewer_wrST"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission6055/Reviewer_wrST"
        ],
        "content": {
            "summary": {
                "value": "This paper addresses the computation of attention matrix in a dynamic setting where an entry of one of matrices corresponding to query and key tokens can make a change. In static case where input matrices are fixed, it is known that attention computation cannot be performed in subquadratic time when input matrices have larger entries, even if an additive approximation error is permitted. This paper proposes an algorithm for the online version such that an update takes only amortized subquadratic time and a query, computing one entry of attention, takes only worst-case subquadratic time, without approximation. This paper also suggests a conditional lower bound for the time complexity of online attention matrix computation that matches the complexity of the proposed algorithm."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "The finest contribution I think is that it achieves truly subquadratic ($O(n^{2-\\Omega(1)})$) time for attention matrix computation without approximation by considering dynamic setting. As shown in [Alman & Song, 2023], in the static setting where each matrix is given and fixed in advance, the attention matrix computation cannot be performed in $O(n^{2-\\Omega(1)})$ time when the entries of matrices are not bounded between $-\\sqrt{\\log n}$ and $\\sqrt{\\log n}$ even an additive error of $1/\\mathrm{poly}(n)$ is permitted. This paper considers dynamic setting where an update of one entry of matrix and a query for computing one entry of attention come in an online manner. This paper proposes a data structure satisfying both subquadratic update time and sublinear query time.\nHere I mention the query time; since the query in dynamic setting only computes one entry of the result matrix, one suspects that the full attention computation might take more than quadratic time. However, the result of [Alman & Song, 2023] holds even when the number of columns, $d$, of input matrices is far smaller than $n$, i.e., $d=O(\\log n)$. In this case, since there are only $nd=O(n\\log n)$ entries for the result matrix, the full computation of attention takes only subquadratic time. Note that this does not violate the result of [Alman & Song, 2023] since the proposed algorithm takes at least quadratic time for preprocessing.\n\nMoreover, this paper also proves a matching conditional lower bound for the time complexity, meaning that the proposed algorithm is optimal if the conjecture is true."
            },
            "weaknesses": {
                "value": "* The online setting dealt in this paper has less reality; in the dynamic setting of this problem, only one entry of input matrices is changed by one update. However, in real situation, although it can be assumed that the values of entries change slowly, a substantial portion of entries are subject to change. Therefore, when applied to real situations, polynomially many update operations may occur, which eventually result in quadratic computation time.\n* The proposed algorithm relies heavily on fast matrix multiplication. Therefore, I think the proposed algorithm is practically useless although its theoretical implication is inevitable."
            },
            "questions": {
                "value": "* As described in \"weaknesses\" section, I think this work has of theoretical interest, and so the worst-case update time instead of amortized update time is preferable if possible. As described in Remark B.2, since the proposed algorithm relies on the periodic rebuilding of data structures, we can make the update time fit for worst-case analysis theoretically by dividing the rebuilding of data structures into updates. So, the question is, why the main result (Theorem 1.3 or Theorem B.1) is posed on amortized update time? For clarity?\n* I'm interested in the situation that we are in a static setting but we only have to compute one entry of attention matrix. In such a case, there is possibility to lower time complexity, but it is not straightforward because it involves $n\\times n$ matrix's inverse. Do you have any idea for this? If so, it complements this work since in the dynamic setting we also have to compute only one entry of attention for a query."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission6055/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6055/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6055/Reviewer_wrST"
                ]
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission6055/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698750932480,
        "cdate": 1698750932480,
        "tmdate": 1699636651536,
        "mdate": 1699636651536,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "pACZWCUKXE",
        "forum": "tDuQNUQN6q",
        "replyto": "tDuQNUQN6q",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission6055/Reviewer_ymZ9"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission6055/Reviewer_ymZ9"
        ],
        "content": {
            "summary": {
                "value": "The paper studies an algorithmic problem that arises in the context of transformers. In transformer architectures, implementing the attention layers corresponds to the following task: Given matrices Q, K, V, compute A = exp(QK^T), and output AV^T with the rows of A scaled by the corresponding row-sums. \n\nSeveral approaches have been proposed for performing these steps faster by exploiting specific structures of the matrices or by using approximations (e.g., hashing, KDE). However, most work has been for static settings where the matrices Q, K, and V do not change.\n\nThe present paper studies a setup where while Q is fixed, K, V can be updated. In each round, one vector of K, V could change and the goal is to still compute the attention mechanism efficiently per each update/query after a pre-processing step. This is an interesting setup; however, a drawback is that Q is not allowed to change, and in most architectures, it would. \n\nThe main idea in the current work is to batch together the updates and then use a fast matrix multiplication subroutine to improve on performing each step immediately. The authors also show that their algorithm is optimal under a believable conjecture from algorithms."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "The paper studies an interesting model that while not capturing the real-world setup exactly could be a useful step. The algorithm proposed is nice and the quantitative bounds are tight."
            },
            "weaknesses": {
                "value": "The model doesn't allow for Q to be updated which it could be. The algorithm while nice, is a somewhat straightforward adaptation of known ideas."
            },
            "questions": {
                "value": "Can you address why Q cannot be updated?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission6055/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698768690452,
        "cdate": 1698768690452,
        "tmdate": 1699636651406,
        "mdate": 1699636651406,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "UeQWx6gfCs",
        "forum": "tDuQNUQN6q",
        "replyto": "tDuQNUQN6q",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission6055/Reviewer_YepA"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission6055/Reviewer_YepA"
        ],
        "content": {
            "summary": {
                "value": "The attention scheme has been widely used in models including LLMs. This paper proposes a dynamic version of the attention matrix multiplicaion problem, in contrast to previous static attention multiplications. Specifically, the paper deal with entry-level update of K and V, as well as entry-level query of the attention matrix. Results in this paper are two folds. The first is an algorithm that supports the dynamic attention with specific amortized update time and worst-case query time. The second is a lower bound indicating that the proposed algorithm will be conditionally optimal given that the hinted matrix vector multiplication conejcture is correct."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "- The paper provides detailed introduction of dynamic attention matrix multiplication problem, and the hinted MV conjecture. \n\n- A detailed theoretical analysi of the proposed lower bound of the dynamic attention matrix multiplication problem."
            },
            "weaknesses": {
                "value": "- The paper mentioned attention is used in LLMs, but it seems that the proposed method is not targeted for LLMs. \n\n- Even though this paper is a relatively theoretical paper, it would be better to provide some experiments/simulation results about amortized update time and query time, and comparison with other related works mentioned in the paper.\n\n- The proposed theoretical results cannot cover updating K, V together, which is usually the case for model training/fine-tuning nowadays.\n\n- Minor points: \n1. The paper structure is a little bit unbalanced, with the first introduction section taking up more than half of the pages. The related work section (Sec 1.2) can be compressed. \n\n2. The citation style is not in parenthesis (\\citep{})."
            },
            "questions": {
                "value": "- The biggest question I have is why we need dynamic attention multiplication. There are many works for sparse attention and low-rank attention [1, 2], which provide potential solutions for the long-range attention problem. And when we do fine-tuning on LLMs, we can also freeze part of its parameters and only tune the rest. It seems not very common to do targeted update for specific entries of K, V, or query specific positions of the attention matrix. So I'm not sure what is the scenario that the proposed method is mostly suitable for.\n\n[1] Choromanski, Krzysztof, et al. \"Rethinking attention with performers.\" arXiv preprint arXiv:2009.14794 (2020)\n\n[2] Beltagy, Iz, Matthew E. Peters, and Arman Cohan. \"Longformer: The long-document transformer.\" arXiv preprint arXiv:2004.05150 (2020)"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "details_of_ethics_concerns": {
                "value": "No ethics concerns."
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission6055/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6055/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6055/Reviewer_YepA"
                ]
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission6055/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698827482936,
        "cdate": 1698827482936,
        "tmdate": 1699636651303,
        "mdate": 1699636651303,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "wy9gRphYjm",
        "forum": "tDuQNUQN6q",
        "replyto": "tDuQNUQN6q",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission6055/Reviewer_tLaa"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission6055/Reviewer_tLaa"
        ],
        "content": {
            "summary": {
                "value": "This work studies the problem of dynamically maintaining an attention matrix (termed ODAMV): given an entry-wise update per iteration to the attention matrix, design an algorithm that can efficiently compute any desired entry of the updated attention matrix upon some query. This work proposes an algorithm based on lazy update techniques with guaranteed amortized run time and worst case run time. Furthermore, this work provides a matching conditional lower bound of the run time of the proposed algorithm, assuming the hardness of Hinted Matrix Vector Multiplication conjecture holds."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "The proposed problem of dynamically maintaining the attention matrix is novel and interesting."
            },
            "weaknesses": {
                "value": "$\\textbf{Problem definition.}$\nDuring the training or deployment of an LLM, for example, the input sequences (of length $n$) are different per sample. Hence, the matrices $Q, K, V$ are different for each sample, and it is hardly the case that the attention matrix will be updated by only one entry at a time. Is it possible to give a practical scenario where the problem of dynamic/online attention maintenance with entry-wise updates considered in this work applies? \n\nIt might be more interesting to consider a row or a column, or even a submatrix of fixed size, being updated in each iteration.\n\n$\\textbf{Presentation needs to be greatly improved.}$\n\n- In the abstract, $\\omega(1,1,\\tau)$ and $\\tau$ are undefined notations that make it hard for the readers to understand the core results of the paper at first glance. While one might be able to infer that $\\omega$ means the matrix multiplication exponent from the context, it is hard to understand $\\omega(1,1,\\tau)$. Also, without properly introducing $\\tau$, it is unclear whether the run time results hold for a specifically chosen $\\tau$ (might be too complicated to write out in the abstract) or for any $\\tau\\in (0, 1]$. \n\n- In Theorem 1.3, $\\delta$ is undefined. I was thinking about some notion of failure probability when I first read this, but it turns out in later sections that $\\delta$ is indeed the update to the attention matrix. \n\n- The \u201cTransformer Theory\u201d and the details of classical optimization dynamic matrix maintenance in Section 1.2 \u201cRelated Work\u201d do not seem to be directly related to the problem considered in this work. It\u2019d be better to be moved to the Appendix.\n\n- Section 3.1 does not give a precise and clear overview of the lazy update based algorithm that solves ODAMV. For example, it is unclear what \u201cList_C, List_D, List_V\u201d in \u201cLazy Update\u201d store. In \u201cFast Query\u201d, it is confusing as why there are two stacked matrices, $\\Delta_{V, 1}$ and $\\Delta_{V, 2}$ from List_V.\n\n- In Section 3.2 and 4 on the Lower Bound (LB), it is unclear why this work presents the LB result for a simpler problem called OAMV, which is not the true problem ODAMV considered, instead of directly presenting the LB results of ODAMV. Section 4 is essentially a more detailed / formalized version of Section 3.2. These two sections might be combined.\n\n- Minor issue: In Theorem 1.3, \u201cThis operation has the same \u2026 as K update\u201d should be \u201cThis operation has the same \u2026 as UpdateK\u201d?\n\n- Minor issue: Below Definition 1.2, \u201cWhen then complement our result \u2026\u201d => \u201cWe then complement our result\u201d\n\n- Minor issue: In the paragraph \u201cFast Query\u201d in Section 3.1, \u201cdenote the lates $D^{-1}$\u201d => \u201cdenote the latest $D^{-1}$\u201d"
            },
            "questions": {
                "value": "1. On the algorithm / upper bound side, is there any utility guarantee of the algorithm? For example, given a query to the $(i, j)$-th entry, how close it is between $\\widetilde{B}_{i, j}$ \n\nand $B_{i, j}$, where $B$ is the target matrix after updates (as defined in Section 3.1) and $\\widetilde{B}$ is the updated matrix computed by the algorithm?\n\n2. A follow-up question: why does one need to recompute the attention matrix every $n^{\\alpha}$ updates? Is it because after that many updates, certain utility guarantee no longer holds?\n\n3. What is the algorithmic challenge in designing the lazy update algorithm for ODAMV? Is it a straightforward application of previous techniques? \n\n4. In Conjecture 3.1 on HMV, is the time complexity of Phase 1 and Phase 2 the time it takes to read the input matrices? \n\n5. Correct me if I am wrong, as I am not a complexity expert --- Below Conjecture 3.1, I think \u201creduce OAMV and ODAMV to HMV\u201d should be \u201creduce HMV to OAMV and ODAMV\u201d. Because the goal here is to show OAMV and ODAMV are harder to solve than HMV (in terms of computational complexity), and so the LB on computational complexity holds for HMV also holds for OAMV / ODAMV. \nNevertheless, the contradiction-based LB proof shown in Section 3.2 and 4 makes sense to me.\n\n6. It is common to compute an approximation to the attention matrix (for faster run time). Do the techniques (algorithm and the lower bound) developed in this work extensible to dynamically maintain an approximation to the attention matrix?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission6055/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6055/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6055/Reviewer_tLaa"
                ]
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission6055/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698986859608,
        "cdate": 1698986859608,
        "tmdate": 1699636651206,
        "mdate": 1699636651206,
        "license": "CC BY 4.0",
        "version": 2
    }
]