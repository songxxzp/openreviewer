[
    {
        "id": "ivigjXjyWf",
        "forum": "17ZbByq95E",
        "replyto": "17ZbByq95E",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission5200/Reviewer_JVog"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission5200/Reviewer_JVog"
        ],
        "content": {
            "summary": {
                "value": "The proposed RMM utilizes random projection to reduce the memory required to store input activations of the linear layer while still achieving comparable accuracy."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "This paper is \n\n1. well-written, \n\n2. provides justification for the RMM method through a comparison of gradient variance with SGD, and \n\n3. demonstrates the usefulness of the algorithm in RoBERTa."
            },
            "weaknesses": {
                "value": "1. Lack of experiemntal results\n\n: The paper claims the efficacy of the method for large linear layers, but only presents experimental results from the GLUE benchmark of RoBERTa. A performance comparison with larger models, such as LLaMA-2-7B with over 7B parameters, seems necessary.\n\n2. Lack of comparison between previous works\n\n: In fact, there have been many attempts in the past to save memory through activation compression. Notably, GACT (2022) is capable of compressing all input activations, including those of the linear layer, to an average of 4-bit in BERT-Large. A comparison between such existing methods and RMM seems necessary.\n\n3. Lack of novelty\n\n: As the author pointed out, random projection has long been a widely used method, and applying it to activation compression doesn't necessarily mean it lacks novelty. However, there have already been cases using random projection under the same objective of activation compression. EXACT (2022) compresses activations using random projection, which seems strikingly similar to the proposed RMM."
            },
            "questions": {
                "value": "1. Lack of experiemntal results\n\n: Please provide experimental results on larger models like LLaMA-2-7B. This is crucial in bolstering the claims made in the paper.\n\n2. Comparision with previous works\n\n: A quantitative experimental comparison with recently proposed activation compression algorithms like GACT (2022), EXACT (2022), AAL (2023), and DropIT (2023) seems necessary. If the review period is limited, please at least provide a comparison with GACT (2022), which is the-state-of-art activation compression technique,  in terms of 1) accuracy and 2) memory saving through experimental data. For the remaining algorithms, a qualitative analysis can be included in the related work section.\n\n3. Lack of novelty\n\n: A detailed comparison with EXACT, which also uses random projection, seems necessary. To offer some advice, 1) Unlike EXACT, RMM appears to compress the batch dimension. Demonstrating mathematically that this difference allows RMM to further reduce gradient variance, or 2) showing through actual experimental results that RMM offers a significant accuracy improvement over EXACT, would likely address concerns regarding novelty.\n\nHowever, one concern is that, based on the comparison results in the Appendix for GCN2, EXACT seems to achieve higher accuracy than RMM. Given that both algorithms adopt very similar approaches, the accuracy of RMM must necessarily be higher than that of the existing EXACT.\n\n* GACT: Activation Compressed Training for Generic Network Architectures (2022)\n* EXACT: Scalable Graph Neural Networks Training via Extreme Activation Compression  (2022)\n* DropIT: Dropping Intermediate Tensors for Memory-Efficient DNN Training (2023)\n* Learning with Auxiliary Activation for Memory-Efficient Training  (2023)"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission5200/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission5200/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission5200/Reviewer_JVog"
                ]
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission5200/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698655367049,
        "cdate": 1698655367049,
        "tmdate": 1699636517092,
        "mdate": 1699636517092,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "IHxLQYUTHt",
        "forum": "17ZbByq95E",
        "replyto": "17ZbByq95E",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission5200/Reviewer_k3XT"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission5200/Reviewer_k3XT"
        ],
        "content": {
            "summary": {
                "value": "This article proposes a way to reduce the memory cost of the backpropagation of linear layers, with Randomized Matrix Multiplication."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "1 poor"
            },
            "strengths": {
                "value": "This article is relatively well-written and easy to follow.\nThe RMM algorithm is simple and well-motivated, lowering immediately the memory cost of backward operations on linear layers in DNN.\nThe authors bring a novel analysis of variance in both SGD and RMM."
            },
            "weaknesses": {
                "value": "**Novelty** The novelty of the method is very limited. The main idea is already present in Adelman et al. (2021), even though their goal was not to save the memory during the stage. The authors do not bring many contributions over Adelman, the theoretical analysis of the variance being unclear in particular. \n\n**Variance** $D_{SGD}$ and $D_{RMM}$  are not defined clearly (or in equations (10) and (11), is $D_{RMM}=D$?). In the Appendix, the equation (21) $D^2_{SGD}(X,Y)= \\frac 1 {B\u22121} D^2 _Z(X,Y)$ is not clear.\n\nMore generally, it is quite unclear what should be the conclusion of the analysis of the variances of SGD and RMM in Sections 2.3 and 3.3. The theoretical analysis gives an upper bound of the variance of RMM, but we observe that in practice the variance of RMM is much higher than the one of SGD, meaning that RMM brings a lot of noise to the training, which seems to hinder training. What is the conclusion of these sections? I also would at least have appreciated the theoretical upper bound on Figure 3.\n\n**Computation cost** The computation requirements should be moved from the appendix to the main paper and discussed there, considering their importance. In particular, the comparison between the computation costs $O(BN^2)$ and $O(\u03c1BN(B+ N))$ is important, as it showcases that the method may be slower, an important drawback that is confirmed in Table 3. For such a high computation time cost, other methods that compress the activation vector $X$ will be favored.\n\n**Pretrained network** Experiments being done on a pre-trained network do not allow a clear measurement of the degradation due to RMM during training.\n\nSection 3.4 brings nothing new compared to Table 2."
            },
            "questions": {
                "value": "\"In Adelman et al. (2021) the construction of S requires the knowledge of the norms of the rows of Y\". I may be mistaken but I do not understand why this is the case. Bernoulli-CRS is unbiased whatever the values of $p_{j}$ are. Therefore it can be applied to RMM with no knowledge of $Y$ for any distribution $p_j$.\n\nThe results of Section 3.3 seem surprising. Why is the SGD variance increasing during training, while the network should converge?\n\nWhy say that \"Subsampled Orthonormal with Random Signs (SORS)\" is not considered if there is a Comparison of Randomized MatMuls in Section 3.5?\nConsidering the cost of computation of RMM, why should we choose Gaussian RMM rather than DCT or DFT, which the authors note have a much smaller computation cost?\n\n\"Moreover, we empirically found that our randomization is faster if \u03c1 \u2264 0.1.\" Doesn't Table 3 show that even with $\\rho=0.1$ the randomization is still longer than no RMM?\n\nVarious remarks and errors:\n* Section 2.2: \"this should be?\", \"target really accurate\", \"it may seem\"\n* Section 3 \"We rewrite implementation\". PRNG stage $G$ is only used here. \" compression in 5\u201310 times\" \"study influence of randomized\" \"However, overfitting point\"\n*"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission5200/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698692018632,
        "cdate": 1698692018632,
        "tmdate": 1699636517005,
        "mdate": 1699636517005,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "C91enBLy7V",
        "forum": "17ZbByq95E",
        "replyto": "17ZbByq95E",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission5200/Reviewer_fccg"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission5200/Reviewer_fccg"
        ],
        "content": {
            "summary": {
                "value": "This work presents a memory-efficient method for computing the needed gradients in backpropagation training through large linear layers.\nThe method uses the randomized matrix multiplication approach to achieve this.\nIt randomly creates a matrix S that projects the signal X into a smaller dimension space.\nThe reduction is controlled by $\\rho$, which takes up a value between 0 and 1.\nThe only required condition for S is that its autocorrelation equals the identity matrix I.\n\nThis work further analyzed the gradient variance induced by the randomized computation.\nIt also provides a detailed explanation of how the new approach reduces the memory requirement for backpropagation.\nThe work provides simulation results to support the main claim."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "The paper is well organized and the literature review provides enough context needed to understand this work.\nThe topic is an interesting one that is worth pursuing, especially in the era of ever-growing large models that rely on transformer modules."
            },
            "weaknesses": {
                "value": "One of the suggested claims (under section 2.3) is not well-supported.\nThis work seems to suggest that the difference between the exact gradient and the randomized approximation is a form of noise injection.\nIt went on to state that it can play the role of a regularizer.\nYou will need to model the effect of the randomized error as such to make this claim. \nI do not think this paper contains such an explanation. \n\nThe paper states that the only requirement for the random matrix S is that its autocorrelation be equal to I.\nBut the definition of the random Gaussian random matrix suggests that the autocorrelation is  $\\frac{1}{B_{proj}} I$.\nI think you should align the two.\nYou can treat the constant as a scale on the learning rate."
            },
            "questions": {
                "value": "1). How will the sample size of $S$ affect the performance of this method?\nI think the algorithm statement suggests that you only picked one sample of S.\nIf we compute the gradient over multiple samples of $S$ and take the average, will this improve the performance or not? \nThis follows from equation (4), which relies on the expectation of the randomized gradients over $S$\nIt will be interesting to see the trade-off between the additional workload and the \n \n2). How does the depth of the network affect the variance and error induced by the randomized gradients?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission5200/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission5200/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission5200/Reviewer_fccg"
                ]
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission5200/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698736272647,
        "cdate": 1698736272647,
        "tmdate": 1699636516842,
        "mdate": 1699636516842,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "G87jRpwEnS",
        "forum": "17ZbByq95E",
        "replyto": "17ZbByq95E",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission5200/Reviewer_aWYY"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission5200/Reviewer_aWYY"
        ],
        "content": {
            "summary": {
                "value": "The presented paper proposes a stochastic estimator for the gradient of a linear transform. The proposed estimator is unbiased and relies on a randomized algorithm for matrix multiplication. In practice, this results in the introduction of a randomized linear layer where instead of storing the full batch of inputs during the forward pass, a random projection of the input tensor onto a lower dimensional space is stored for the backward pass. This results in memory savings together with a tradeoff on the variance of the resulting gradient estimate. The authors derive a theoretical analysis of the additional variance introduced by the randomized matrix multiplication and conduct experiments on fine-tuning tasks for NLP applications.\n\nThe presented method shares strong similarities with previous work on randomized matrix multiplication in the context of deep learning [1].\n\n[1] EXACT: Scalable Graph Neural Networks Training via Extreme Activation Compression"
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "1) The authors provide a theoretical analysis of the additional variance induced by the randomized matrix multiplication procedure.\n2) The authors reports practical savings observed in the fine-tuning tasks with respect to their implementation."
            },
            "weaknesses": {
                "value": "1) The paper lacks comparison to other works aiming at reducing memory requirements during training. For example, both [2] and [3] compress activations with a quantization procedure. [1] jointly uses randomized matrix multiplications and quantization to compress the stored activations. The lack of comparison with these methods makes it difficult to evaluate the relevance of the contribution against these alternatives. These papers aren't mentioned in the related work section.\n2) The EXACT method [1] stores a random projection of the input where the compression is applied to feature channels. In the presented work, the compression is applied to the batch dimension. More generally, it would be interesting to know the practical importance of the dimension chosen for compression in the presented method.\n3) In a fully-connected layer, the weights themselves have a substantial memory footprint, which explains why retaining only 10% of the input dimensionality only yields 25% memory savings. For convolutional architectures, however, the weight space is much smaller, meaning that the relative savings would be much higher. It would be interesting to know how the proposed method translates in this setting.\n4) Given that transformers are now widely adopted in both NLP and computer vision, it would also be interesting to know how the proposed methods perform for a ViT on CIFAR10 and ImageNet, which would enrich the experimental section with minimal coding efforts.\n5) [Minor comment] If the RMM forward block sends $W, b, S^{\\top}X$ then the FC forward block should send $W, b, X$ instead of $W, b$.\n\n[2] ActNN: Reducing Training Memory Footprint via 2-Bit Activation Compressed Training\n[3] GACT: Activation Compressed Training for Generic Network Architectures"
            },
            "questions": {
                "value": "1) Could the author provides comparison with other works based on quantization of the activations?\n2) Could the author provide experiments on convolutional architectures or on computer vision benchmarks with a transformer-based architecture?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission5200/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699043767696,
        "cdate": 1699043767696,
        "tmdate": 1699636516758,
        "mdate": 1699636516758,
        "license": "CC BY 4.0",
        "version": 2
    }
]