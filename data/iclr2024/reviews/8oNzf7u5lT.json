[
    {
        "id": "DgPdqlwrHv",
        "forum": "8oNzf7u5lT",
        "replyto": "8oNzf7u5lT",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission6159/Reviewer_uEX5"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission6159/Reviewer_uEX5"
        ],
        "content": {
            "summary": {
                "value": "The paper presents an approach that uses the code of the simulator (or I would the analytical model) and a set of interesting events to solve problems with complex dynamics system. The approach first searches over a sequence of interesting events that reach a goal and then reduces achieving each interesting event (as I understand) as an optimization problem."
            },
            "soundness": {
                "value": "1 poor"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "1 poor"
            },
            "strengths": {
                "value": "- The paper is easy to read. It nicely uses a running example to ground the concepts discussed in the paper. \n\n- The paper makes its assumptions clear which makes the paper really understandable."
            },
            "weaknesses": {
                "value": "While the paper presents attempts to solve an interesting approach, it has a few significant limitations: \n\n- In my opinion, the paper seriously lacks novelty. It invents (or introduces) new terms for concepts that have long existed. E.g., the main contribution claimed by the paper is using **code of the simulator** for solving the problem faster. However, this is nothing but having access to an analytical model of the system. Why to complicate the paper? The second term would be the **meaningful events**. The events that are required or necessary to be achieved in order to reach the goal state. These is analogous to landmarks [1] or critical regions [2]. Landmarks and critical regions have been extensively used in planning and robotics literature. \n\n- The approach requires the analytical of the model of the system as well as a set of landmarks or critical regions to be provided upfront. This does not only require a domain expert at the train time but at the test time as well. Which is infeasible to have. Especially, when a lot of research has been focused on learning these landmarks or critical regions automatically as well as approaches than learn policy without explicitly having access to an analytical model of the environment and treating the simulator as a blackbox. \n\n- It is not clear from the paper that how a sequence of low-level action is generated to reach each meaningful event. My educated guess is the problem is reduced to an optimization problem but it has to be clear from the paper. \n\n- Lastly, the empirical evaluation is extremely weak. Especially, the choice of the baselines. Given that this approach is a model-based optimization approach. This should be compared with a hierarchical planning approach [2,3,4] or a hierarchical optimization approach [5] or a model-based RL approach. \n\n### References \n\n\n[1] Hoffmann, J\u00f6rg, Julie Porteous, and Laura Sebastia. \"Ordered landmarks in planning.\" Journal of Artificial Intelligence Research 22 (2004): 215-278.\n\n[2] Shah, Naman, and Siddharth Srivastava. \"Using Deep Learning to Bootstrap Abstractions for Hierarchical Robot Planning.\" Proceedings of the 21st International Conference on Autonomous Agents and Multiagent Systems. 2022.\n\n[3] Garrett, Caelan Reed, Tom\u00e1s Lozano-P\u00e9rez, and Leslie Pack Kaelbling. \"Pddlstream: Integrating symbolic planners and blackbox samplers via optimistic adaptive planning.\" Proceedings of the International Conference on Automated Planning and Scheduling. Vol. 30. 2020.\n\n[4] Shah, Naman, et al. \"Anytime integrated task and motion policies for stochastic environments.\" 2020 IEEE International Conference on Robotics and Automation (ICRA). IEEE, 2020.\n\n[5] Toussaint, Marc. \"Logic-Geometric Programming: An Optimization-Based Approach to Combined Task and Motion Planning.\" IJCAI. 2015."
            },
            "questions": {
                "value": "Please refer to the previous section."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission6159/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6159/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission6159/Reviewer_uEX5"
                ]
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission6159/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698790047752,
        "cdate": 1698790047752,
        "tmdate": 1699636668397,
        "mdate": 1699636668397,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "VICjRqpDb5",
        "forum": "8oNzf7u5lT",
        "replyto": "8oNzf7u5lT",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission6159/Reviewer_ppCk"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission6159/Reviewer_ppCk"
        ],
        "content": {
            "summary": {
                "value": "The paper describes an approach that utilizes code inspection techniques to locate discontinuities in a task together with user-provided critical junction points to formulate a tree-based search problem. The approach assumes that solutions between junction points can be found by local numerical search methods while the global sequencing is guided by the user-provided \"meaningful events\"."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "The general idea of the work is interesting in that it attempts to leverage program verification approaches and logic to solve complex global optimization problems."
            },
            "weaknesses": {
                "value": "While the general idea is interesting, there are many issues with the paper in its current form.\n\nThe paper argues that other methods rely on specialized representations, which makes them hard or inconvenient to use. However, the proposed method requires the user to specify so-called \"meaningful events\". Judging from the examples and the description, this would appear to be an even more onerous requirement as they have to be defined by the end-user instead of the designer of a general method for particular problem scenarios. This aspect is insufficiently discussed in the paper, making it unclear that this approach is practical in contrast to other methods such as reinforcement learning, model-based control, or Monte Carlo tree search.\n\nThe core aspect of the work revolves around tracing the code logic to find control flow statements. In that context, the paper repeatedly mentions simulators as the code to be traced. However, in the experiments, only one example traces through something akin to a simulator and in all other instances, some generic logic code is traced. Therefore, the mention of simulators is quite confusing as in no instance is a proper simulator, such as pybullet, mujoco, Isaac Sim, drake, etc., traced. It also remains unclear that the discontinuities in the simulation that this process should find are necessarily \"telegraphed\" by control flow statements rather than pure linear algebra, which the proposed approach would not appear to register. Tracing general program execution can still be interesting, as the experiments show. However, the description of the applications and properties described in the main body of the text is misleading. Without seeing the experiments, I would have expected the proposed method to be able to trace through complex physics engines as employed by Isaac sim or pybullet.\n\nThe proposed method uses quite a few components and joins them together. While an overview is provided in Figure 1, this figure is never used in the text to help the reader understand how things connect. As such, it is hard to follow where the different pieces go and how they interact. For example, there is a connection between user-defined events, code tracing, and trace predicates. This can be gleaned from the text to some extent, but making the connections more easily understood and more evident would improve the readability of the paper significantly.\n\nThe paper states that the local search is sufficient to find parameters to reach the next meaningful event. However, it is not mentioned how this can be guaranteed or why this should hold in the first place. Are there theoretical guarantees that can alert the user when this is impossible, or does the user have to add \"meaningful event\" specifications until things can be solved?\n\nThe experimental section, while containing several experiments, is lacking in detail. There are detailed descriptions of the experimental setups, yet the discussion of the results is unsatisfactory as they provide no real insight. Furthermore, the choice of baselines and problem setups is perplexing. The biggest issue is that some of the experiments would be ideally suited for Monte Carlo tree search methods, especially given the tree search nature of the proposed system, yet approaches based on this technique are absent. Another aspect is that the problem setups for different methods are not identical,  making it unclear whether the results are comparable. A good example of this is 4.2, where the proposed method operates on a state representation of button states while the RL and MPC baseline operate on an entirely different state space.\n\nWhile the idea, in general, is interesting, I cannot recommend this paper for publication in its current state."
            },
            "questions": {
                "value": "- Some of the description and experimental tasks used give a task and motion planning vibe, would such tasks and methods be sensible comparisons for this work?\n- Is the need to have traced control flow labels, predicates, and user-specified \"meaningful events\" not more challenging and domain-specific than representations required by other approaches?\n- How can the assumption of local searches finding connections between the sequence of \"meaningful events\" be guaranteed?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission6159/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698850433944,
        "cdate": 1698850433944,
        "tmdate": 1699636668259,
        "mdate": 1699636668259,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "rrjaKp7q37",
        "forum": "8oNzf7u5lT",
        "replyto": "8oNzf7u5lT",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission6159/Reviewer_wE34"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission6159/Reviewer_wE34"
        ],
        "content": {
            "summary": {
                "value": "The paper presents a novel method of using trace information from the source code of a simulator to more efficiently solve planning problems. The method is evaluated on three simulation examples where it compares favorably to RL (SAC) and sampling-based MPC."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "- The idea of using the source code of a simulator to speed up planning is interesting and appears novel.\n- The paper is fairly well-written, but there are a lot of things going on\n- The benchmark results are encouraging"
            },
            "weaknesses": {
                "value": "The fundamental limitation of this approach is that it needs a human to extract what they call \"meaningful events\" that serves as the - foundation of the planning tree. This makes comparisons against model-free methods like RL and sampling-based MPC rather apples-to-oranges. If this step was more automatic, or shown to be very simple, I think the paper would be much stronger.\n- This is exacerbated by not using any standard benchmarks that I can see.  \n- The performance difference compared to model-free approaches also does not appear that large in two of three experiments. Ultimately if this is useful or not probably depends on the users proficiency in the syntax of the proposed framework and the level of understanding of the simulator code. Not sure if a user study might help.\n\nMinor:\n- The success rate curves could also use a confidence interval (or quartiles)."
            },
            "questions": {
                "value": "- Why did you not include any standard benchmark environments from e.g. RL as you are comparing against RL?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission6159/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698878526975,
        "cdate": 1698878526975,
        "tmdate": 1699636668128,
        "mdate": 1699636668128,
        "license": "CC BY 4.0",
        "version": 2
    }
]