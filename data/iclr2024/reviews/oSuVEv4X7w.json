[
    {
        "id": "dVgswPZW7G",
        "forum": "oSuVEv4X7w",
        "replyto": "oSuVEv4X7w",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission113/Reviewer_L24Y"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission113/Reviewer_L24Y"
        ],
        "content": {
            "summary": {
                "value": "The paper presents a technique for \"verifiable code generation\" in which rather than the generated artifact being code alone, one should think about an artifact that consists of a triplet (code, docstring, annotation).\n\nThe core idea is to use a consistency checker to verify that the triplet (c,d,a) is consistent. To do that, Clover performs a 6-way check:\n1. code \u2192 docstring\n2. docstring \u2192 code\n3. code \u2192 annotation\n4. annotation \u2192 code\n5. docstring \u2192 annotation\n6. annotation \u2192 docstring\n\nThe paper also presents the CloverBench, a set of 60 small textbook-style programs (e.g., binary_search, bubble_sort)."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "4 excellent"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "- An interesting approach for making generated code carry supporting evidence for its correctness.\n- A benchmark suite that can enable further experimentation on (code,docstring,annotation) triplets or subsets thereof.\n- Clear and compelling presentation."
            },
            "weaknesses": {
                "value": "- I like the approach, but I'm afraid that the evaluation really falls short. The main weakness is that CloverBench contains classical examples for which GPT4 is clearly able to generate docstring, invariants, and code quite easily from each component of the triplet. In fact, I am guessing that it has seen different versions of the loop-invariant for each of these examples multiple times in different styles and languages.\n- The weakest link in the Clover approach itself is the natural language description in the docString. Would realistic docStrings contain the level of details required for correspondence with the annotation? What happens when they do not? The under-specification gap between a docString and the annotation may be hard to bridge?\n- Equivalence checking is always a challenge. This challenge is even more pronounced for checking \"equivalence\" between natural language descriptions.\n- The Dafny syntax gets in the way of getting a clear reading of where are the problems. Given the simple examples, I would hypothesize that the Clover would have seen 100% success with GPT4 and a mainstream language for annotations."
            },
            "questions": {
                "value": "- Your docStrings (e.g., as shown in Listing 2) are quite elaborate and are much closer to the formal spec than to a natural language docString that you'd expect to find in real programs. The distance between realistic NL docStrings and the formal annotation can be a real challenge for Clover. Do you have any thoughts on how to address that?\n- Maybe you can consider Clover with a set of input/output examples instead of or in addition to the docString. Maybe it makes sense to consider (code,annotation, docString+examples) either as a triplet in which examples make the docString more robust, or as a quadruple in which examples provide yet another aspect, making it a four-leaf clover.\n- When all three artifacts (code,docstring, annotation) are generated by the same source, they may be consistent but incorrect. Did you consider using a combination of different models for generating the triplet?\n- Why don't you repeat the experiments with an annotation language embedded into a mainstream language as a library / helper functions? Something that would be then easy to translate back to Dafny. Alternatively, use the prompt to \"teach\" GPT4 some basic Dafny syntax and its meaning."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission113/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698776976728,
        "cdate": 1698776976728,
        "tmdate": 1699635936345,
        "mdate": 1699635936345,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "7xncn2xFoX",
        "forum": "oSuVEv4X7w",
        "replyto": "oSuVEv4X7w",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission113/Reviewer_29hf"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission113/Reviewer_29hf"
        ],
        "content": {
            "summary": {
                "value": "Summary:\n-------------\nThis paper introduces the Clover paradigm, which aims to ensure the correctness of code generated by large language models (LLMs), through a closed-loop verification process. As the process of formal verification of code is tedious when done manually by human experts, the authors propose an LLM-based automated approach for the same. The paper provides an interesting insight that AI-generated codes (i.e. C) should inherently also include formal specifications (annotation i.e. A which includes precondition, postcondition, loop-invariants) and natural language descriptions (docstring i.e. D). As such, the six ordered pairs of these three components (code, annotation, docstring) viz. A-D, D-A, C-D, D-C, A-C, and C-A can be mutually verified for consistency through either a LLM or a SAT/SMT solver. Therefore, a code can be considered formally verified when all these six consistency checks are passed. Essentially, the Clover checks act as a conservative filter that approves of codes that are formally verified, well-documented, and internally consistent.\n\nThe paper also puts forward a miniature CloverBench dataset of 60 codes written in the Dafny programming language. The codes are small-sized and contain at most one method or helper function (termed as those 'found in standard CS textbooks'). Each code has a ground-truth version (where the code, annotation, and docstring are manually verified to be correct and consistent), three incorrect versions, and five unit tests.  \n\nAn input program is assumed to contain annotation (A), documentation (D), and code (C). As part of the Clover paradigm, the paper proposes how each of the six ordered pairs among A, D, and C can be mutually verified. For instance, the ordered pair A-D can be verified using an LLM. Given an annotation (A), an LLM is asked to generate a docstring (D_gen). Subsequently, it is checked whether D and D_gen are equivalent. Such LLM-based generation and equivalence checking is carried out for A-D, D-A, C-D, D-C, and A-C ordered pairs. However, for the C-A ordered pair, Dafny's deductive verifier is used to check whether the code satisfies the generated annotation. The paper also elaborates on how equivalence can be tested between each input component and its corresponding generated version viz. (C, C_gen), (A, A_gen), and (D, D_gen). (C, C_gen) equivalence is tested using the unit tests included as part of the Clover dataset. (A, A_gen) equivalence is tested by writing the equivalence of the two annotations as a formal lemma and asking Dafny's formal tool to prove the lemma. (D, D_gen) equivalence is tested by asking an LLM whether the two docstrings are semantically equivalent. The LLM used for all these checks is GPT-4. \n\nFor evaluation, the authors first check whether GPT-4 can generate code with annotations and docstrings included. Using a zero-shot approach, given the annotation the LLM can produce the correct code for 41/60 in the dataset. This accuracy iteratively increases when the LLM is provided with the Dafny compiler and verifier's output as feedback and the LLM is repeatedly asked to correct itself. A similar pattern is observed when the LLM is asked to generate an annotation given a Dafny code. Secondly, the author evaluates their Clover paradigm using the six consistency checks. The Clover paradigm accepts 45 of the 60 correct codes in the CloverBench dataset and rejects all the incorrect versions. The major reason for non-acceptance is incorrect syntax in the LLM-generated Dafny codes. The paper also puts forward a fairly elaborate ablation study on the different aspects of the Clover paradigm. \n\nThe paper also discusses the limitations of the current implementation of the Clover paradigm, including the need for more research to improve the formal verification tools and to expand the coverage to more mainstream languages. However, the authors argue that the Clover paradigm has the potential to significantly reduce the time and expertise required for formal verification and to improve the trustworthiness of code generated by LLMs."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "- The paper is very nicely written and proposes a well-principled approach to verify AI-generated codes.\n\n- Particularly, I found the insight interesting where the authors propose that AI-generated codes should inherently also include formal specifications (annotation viz. precondition, postcondition, loop-invariants) and natural language descriptions (docstring). This is a principled strategy that essentially asks an LLM to provide some form of certification justifying what it generated.\n\n- The proposed set of six checks in the Clover paradigm has the potential towards a good foundation for verifying AI-generated codes, especially because LLM-generated codes are typically erroneous when the complexity of codes increases."
            },
            "weaknesses": {
                "value": "- Although the paper proposes a good concept for program verification, it's still in a nascent stage and has a long way to go for real-world deployment. I understand that this is a first step towards a bigger objective when the author mentions that \"we predict that Clover, coupled with steadily improving generative AI and formal tools, will enable a future in which fully automatic, scalable generation of formally verified code is feasible. This paper charts the first steps towards realizing this vision\". However, a few aspects of the paper concern me. For example, the Clover paradigm is tested on a simple and very small dataset of 60 programs that contain at most one helper function (or even none). This is a significantly trivial benchmark to test on, even for a proof of concept. In my opinion, for the readers to be convinced of the applicability of the Clover paradigm, it should be tested on relatively larger benchmarks. \n\n- Even for a proof of concept, a paper should argue how it can suffice for challenging cases. When a paper aims to propose a promising program verification approach, it is not sufficient to say that \"This test is, of course, imprecise (complete but not sound), but our evaluation suggests that it suffices for the level of complexity in CloverBench. More advanced equivalence checking techniques might be required for more complex examples.\" or \"This method is conservative in the sense that it succeeds only if the two annotations are indeed equivalent, but it may fail on equivalent annotations due to limitations of the verification tool being used.\". It would be nice to get an insight into how the authors aim to check (or at least approximately) code equivalence for difficult benchmarks. \n\n- The paper provides no insight into the performance of Clover on other mainstream programming languages like C, C++, Java, and Python. Although I agree with the fact that AI-generated codes should include formal specifications and natural language descriptions which is inherent in a language like Dafny that supports formal specification, there should be at least some insight about how this should be tackled in or extended to the mainstream languages of today. Otherwise, this would essentially mean that to get the benefit of a closed-loop verifier for AI-generated codes, the whole community should shift towards a verifier-friendly language like Dafny, which is not possible. \n\n- The related work of the paper is not elaborate enough and fails to describe in which line of work the present paper is closest to. Is the paper the first to propose a verifier for (AI/LLM)-based code generation from docstrings and annotations? If not, what were the limitations in the other papers that motivated the authors to come up with this approach? The related work will also look better if structured by organizing it into comprehensive categories that encompass various code verification methods in use.\n\n- The paper does not compare their proposed approach against other similar works in program verification. The input requirements for Clover are quite strong (in the sense that it requires annotation and documentation along with the code). So, an AI-generated program that has all these three can be verified by Clover and any other similar SoTA program verification approaches that do not have such strong requirements. As such, it makes sense to provide a comprehensive comparison with SoTA approaches and justify empirically whether there is a significant improvement in verification filtering after imposing the strong input requirements. If not, why will the strong input requirements make sense for an automated verifier?\n\n- Although the paper is well-written, I believe the structure could be made more reader-friendly. It needed two passes for me to understand the concept. The insights given in the later part of the introduction felt too abstract on the initial read. It required me to go through the whole proposed approach and come back to the introduction again to grasp the insights given in the introduction. Algorithm-1 is helpful in this context, but I presume that was pushed to the appendix due to lack of space.\n\n- Consider a situation: A user provides a prompt to the LLM to generate a code according to some specification (e.g. sort the input array in ascending order). The LLM generates a code that sorts the input array in descending order. Along with the code, the LLM provides annotation and docstring that are fully consistent with the generated code. In this case, the Clover checks will be successful because the code-annotation-docstring is mutually consistent with the six checks. But, the code does not match the user specifications. Because the paper proposes a closed-loop approach of code generation + verification, it would be insightful to tackle such odd but common cases where the generated annotation, docstring, and code are mutually consistent, but do not tally with the prompt given by the user to generate the code (original functionality intended by the user).\n\n- (Minor) There are a few spelling and syntactic mistakes in the current version e.g. \"tranlations\" on Page 6, \"COLVER\" on Page 22, and space missing before full-stops in quite a few places.\n\n- Reproducibility: I did not see any URL to access the code or dataset."
            },
            "questions": {
                "value": "Is the paper the first to propose a verifier for (AI/LLM)-based code generation from docstrings and annotations? If not, what were the limitations in the other papers that motivated the authors to come up with this approach?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission113/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission113/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission113/Reviewer_29hf"
                ]
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission113/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698815024873,
        "cdate": 1698815024873,
        "tmdate": 1699635936234,
        "mdate": 1699635936234,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "ACKG8Kka4D",
        "forum": "oSuVEv4X7w",
        "replyto": "oSuVEv4X7w",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission113/Reviewer_kgwt"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission113/Reviewer_kgwt"
        ],
        "content": {
            "summary": {
                "value": "This paper presents Clover, a method to generate safe and formally verified code using LLMs.\nIn the first step, Clover can utilize LLMs like GPT-4 to generate (i) Code (ii) DocStrings in Natural Language (iii) Formal Specifications (e.g. loop-invariants, pre and post conditions).\nIn the second step, Clover applies pairwise consistency checks on the LLM generated Code, Docstrings, and Specifications. \nMore specifically, consistency checks are performed via reconstruction testing (for Specifications <=> Docstring and Code <=> Docstring checks) and deductive verification tools (for Code <=> Specification checks). Reconstruction testing utilizes LLMs to reconstruct one component (e.g. Code ) from another (e.g. Docstring), and further uses an LLM to verify the equivalence between the reconstructed and the original output.\n\nThe paper makes reasonable contributions overall, and its strengths and contributions include choosing and formalizing an important problem, and dataset (CloverBench) construction."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "- This paper explores a method to rigourously verify the artifacts generated by Code-LLMs. This problem should be of wide interest, but there seem to be little efforts in this direction.\n- Clover exhibits high acceptance rates for correctly generated artifacts while precisely rejecting the incorrect ones.\n- The paper contributes CloverBench, which could be a useful benchmark in the future."
            },
            "weaknesses": {
                "value": "- It seems Clover will need to depend on very strong LLMs (e.g., to generate code/docstring from just the annotations). Thus, consistency checks may often fail if the LLM is weak.\n- Dependence on a verification tool. (Can it check any given java file or just short program snippets?)\n- A very small evaluation set of just 60 examples."
            },
            "questions": {
                "value": "- How much do code LLMs (e.g., CodeLlama, StarCoder, WizardCoder) benifit from the Clover approach? What fraction of the code generated by these LLMs is typically unacceptable in the first place?\n- It would be interesting to see experiments with open-source LLMs as well.\n- How does Clover ensure the security aspects of the generated code? Is there an actual example in the eval set (CloverBench) to demonstrate it?\n- What is the domain of dafny examples (competitive programming / ... ?)\n- In Section 4.2, how do you determine whether GPT-4 passes or fails for the task of generating Code/Annotations? Do you use Clover to determine pass/fail?\n- Can Clover be extended to repository level code verification?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission113/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission113/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission113/Reviewer_kgwt"
                ]
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission113/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699113130862,
        "cdate": 1699113130862,
        "tmdate": 1699635936164,
        "mdate": 1699635936164,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "Z3Rn8CpWy8",
        "forum": "oSuVEv4X7w",
        "replyto": "oSuVEv4X7w",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission113/Reviewer_M5ic"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission113/Reviewer_M5ic"
        ],
        "content": {
            "summary": {
                "value": "This paper proposes Clover to check the consistency among code, docstrings and formal annotations. Specifically, it conducts a six-way check: code to docstring, docstring to code, code to annotation, annotation to code, docstring to annotation, and annotation to code. Clovers does experiment with a benchmark of 60 small programs.\n\nClover uses a verification tool to check whether code satisfies the annotation, which I agree. But I have a concern. The programs used in the paper are simple ones. As far as I know, verification tools suffer from scalability issues. I would like to know the insights of the authors regarding this.\n\nTo check whether an annotation is consistent with code, Clover uses LLM to generate new code for a given annotation and checks whether the generated code and the original are equivalent. Firstly, in many cases, there would be multiple annotations for a given piece of code. For example, for a sorting algorithms, an annotation can specify all the elements in a given set are in ascending order and another annotation specifies all the elements in the given set remain the same. How Clover deal with such cases? Secondly, the generated code from LLM may not be consistent with the given annotation. So if the generated code and the original code are inconsistent, it does not mean the annotation does not align with the original code. This second concern also holds for other checking. Basically, Clover assumes that LLM must have a very high accuracy in translating one artifact to another. I admit that LLMs are powerful, but LLMs do have limitations like hallucinations. I would suggest to discuss the threats to validity. Moreover, the paper claims that Clover has the potential to improve the trustworthiness of code generated by LLMs. It is kind of the chicken-egg thing. \n\nWhen checking whether two pieces of code are consistent, Clover leverages a set of input-output pairs which makes a lot of sense. But such pairs are not always availble. What would be the solution without the pairs? Sometimes, we do have such data availble, but not complete. It is possible that the two pieces of code pass the test, but actually they are inconsistent. I would suggest the paper includes some disscussion on this. \n\nThe paper employs LLM to check the semantic equivalence between two natural language sentenses. Natural languages are ambigious. Even human may not fully understand the actual semantic in a natural language sentence. I have concerns on the acccuracy of the result from LLM. Also, the paper does not have details regarding how to use LLMs to do this task.\n\nClover is used on a very small dataset of 60 textbook-style programs. I would suggest the authors to test on relatively larger benchmarks to better demonstrate the potencial of the proposed work."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "+ An important problem\n+ Easy follow paper"
            },
            "weaknesses": {
                "value": "- Unsound design\n- Small-scale experiment\n- Lack important details"
            },
            "questions": {
                "value": "How LLMs are used to check whether two docstrings are semantically equivalent?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission113/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission113/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission113/Reviewer_M5ic"
                ]
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission113/-/Official_Review"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699646262234,
        "cdate": 1699646262234,
        "tmdate": 1699646262234,
        "mdate": 1699646262234,
        "license": "CC BY 4.0",
        "version": 2
    }
]