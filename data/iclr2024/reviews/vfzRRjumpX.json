[
    {
        "id": "hAyTXmty46",
        "forum": "vfzRRjumpX",
        "replyto": "vfzRRjumpX",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission3746/Reviewer_n8qP"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission3746/Reviewer_n8qP"
        ],
        "content": {
            "summary": {
                "value": "This paper introduces a novel two-step pretraining methodology for encoder-only code language models (LMs). The approach starts with masked language modeling (MLM) and follows up with contrastive learning to foster robust code representations that can be effectively employed in downstream tasks such as retrieval or classification. The resulting model consistently outshines existing baselines across various downstream tasks, including notable ones from the widely recognized CodeXGLUE benchmark. Furthermore, comprehensive ablation studies are conducted to dissect and understand the individual contributions of each component within the proposed framework."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "1. Code representation learning is a significant and often overlooked aspect of this domain.\n\n2. The evaluation methodology used in this study is solid, showing the proposed method's efficacy through extensive experiments on various downstream tasks from the well-established CodeXGLUE benchmark. Notably, the method exhibits remarkable performance, substantially outperforming established baselines such as CodeT5 and StarEncoder.\n\n3. The inclusion of detailed ablation studies is a strong point of the paper, shedding light on the impact and effectiveness of each component within the proposed method. The insights gleaned from these analyses, especially concerning the methodologies used for contrastive learning, are indeed meaningful."
            },
            "weaknesses": {
                "value": "1. The naming convention for the model configurations is somewhat confusing. For instance, \"CodeSage-Small\" (6 layers, 1024 dim, and 130M params) is roughly equivalent to BERT-Base (12 layers, 768 dim, 110M params) in terms of its parameters, while \"CodeSage-**Base**\" is on par with BERT-**Large** (24 layers, 1024 dim, 330M params). This inconsistency could potentially lead to confusion when making comparisons.\n\n2. The LaTeX typesetting requires significant improvement, as there are inconsistencies in font styles and sizes throughout the paper, notably in Section 4, Figures 2(a) and 6, and Appendix A.5. Additionally, the small text in Figure 4(b) is difficult to read without zooming in, and there are redundant references for CodeBERT and CodeXGLUE.\n\n3. The paper's title, \"Code Representation Learning at Scale,\" is rather broad and lacks specificity.\n\n4. The evaluation could be more comprehensive by including additional tasks, such as POJ104 from the CodeXGLUE benchmark, which is relevant but absent from the current evaluation.\n\n5. The baselines utilized for comparison are generally smaller than the proposed model. It would be beneficial to include larger baselines, such as CodeT5+ (16B) and CodeLLaMa (34B), for a more balanced comparison."
            },
            "questions": {
                "value": "1. Is there a reason why some tasks from the CodeXGLUE benchmark, like POJ104, were excluded from the evaluation?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission3746/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698559635535,
        "cdate": 1698559635535,
        "tmdate": 1699636330785,
        "mdate": 1699636330785,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "XBD9elRVgp",
        "forum": "vfzRRjumpX",
        "replyto": "vfzRRjumpX",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission3746/Reviewer_RZCJ"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission3746/Reviewer_RZCJ"
        ],
        "content": {
            "summary": {
                "value": "The paper considers the problem of learning better representations of code. The authors propose a model called CodeSage which is based on the Transformer architecture trained on a large corpus of code (The Stack) with various techniques such as masked language modeling, deobfuscation pre-training, and bimodal contrastive learning with hard negative and hard positive examples. \n\nThe authors showed that the learned representations can be used for various downstream tasks such as zero-shot code-to-code, natural language-to-code search and code classification. They compared the performance of the proposed model with other prior models such as CodeBERT, GraphCodeBERT, StarEncoder, CodeT5, UniXcoder, and OpenAI's text-embedding-ada-002. The results show that the proposed model outperforms all the other models on nearly all the tasks except for the code classification on code defect detection benchmark."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "1 poor"
            },
            "strengths": {
                "value": "- The paper is well written and the proposed model is well motivated. \n- The experiments are thorough and the results are convincing. \n- The paper is a good contribution to the field of code representation learning."
            },
            "weaknesses": {
                "value": "- The paper is not very clear about the differences between the proposed model and the prior models. \n- For instance, it seems that the proposed model is a combination of the prior models (CodeBERT and DOBF) with some additional techniques, such as bimodal contrastive learning. It would be good to clarify the differences between the proposed model and the prior models.\n- page 3, line 27: remove the last comma in the following square brackets: [x_1, x_2, \\ldots, x_N ,]"
            },
            "questions": {
                "value": "How would you explain why the performance of smaller models (e.g., CodeSage-Small and CodeSage-Base) is sometimes better than larger model? Does this mean that the proposed idea is not scalable to larger models or more effective for smaller models?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission3746/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698721868437,
        "cdate": 1698721868437,
        "tmdate": 1699636330695,
        "mdate": 1699636330695,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "d11MX4keDl",
        "forum": "vfzRRjumpX",
        "replyto": "vfzRRjumpX",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission3746/Reviewer_iHpZ"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission3746/Reviewer_iHpZ"
        ],
        "content": {
            "summary": {
                "value": "The authors propose pre-training of encoder style for the domain of programming languages at a larger scale (pre-training data and model parameters) than most encoder style models. These models are then tested on tasks in the code understanding domain like text to code search (or semantic code search) and classification tasks on code. The authors also study the impact of different pre-training choices on the model's performance through their ablations to back their methodology."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "- Scaling the pre-training stage of an encoder only model is a very interesting idea, and hasn't received much attention compared to decoder only models that support generation tasks.\n\n- Exhaustive ablation studies that justify the need for different objectives proposed in pre-training.\n\n- Impressive performance in zero-shot settings on search tasks compared to previous encoder style models"
            },
            "weaknesses": {
                "value": "- Missing comparison with decoder only models: Proposing to scale encoder style models is interesting, but the current results are not convincing as to why this is needed when large scale decoder style pre-trained models have been proposed. While pre-trained decoder only models like CodeGen2.5, CodeLlama, Llama are not specifically proposed for code search or classification, they could be adapted for all the downstream tasks studied by the authors in Sec 4.1. For instance, the last token's encoding from a decoder can be used for search related tasks. Fine-tuning for classification can be performed by framing the classification as a seq2seq problem or by training a classification head on top of the last token's representation. Zero-shot or few shot prompting performance of these decoder style models can be reported for comparison.\n\n- Common Code Understanding benchmarks ignored: The choice of benchmarks is consistent with contemporary literature for the text to code search task, but not for other tasks in the classification settings. This makes it hard for a reader to assess the quality of the pre-trained CodeSage model and compare it to other pre-training strategies from previous works. There are many code understanding tasks (eg. ones from the CodeXGlue benchmark) which have been used in previous works (CodeBERT, GraphCodeBERT, UniXCoder, CodeT5) that are not a part of the evaluation suite here. See Table 1 of https://arxiv.org/abs/2203.03850 - Clone Detection datasets.\n\n- Missing fine-tuned results on CSN, AdvTest and CoSQA: While the benchmark is consistent with previous work for text to code search, the setting chosen is zero shot whereas many previous works show fine-tuned results on the sizeable training datasets provided by these benchmarks (CodeSearchNet, CoSQA, AdvTest). Given that the size of these models is reasonable (130M - 1.3B params) compared to the models studied today (>6-10B params), fine-tuning is an important aspect to be studied with these models.\n\nFor instance, MRR scores in Table 2 on the CodeSearchNet benchmark are reported only in the zero-shot setting.  Fine-tuning improves many of these baselines substantially, and beats CodeSage's zero shot performance by significant margin. Post fine-tuning CodeT5+ is at 77 MRR overall, while CodeT5 is at 71, UniXCoder is at 74.4. See Table 6 of https://arxiv.org/abs/2305.07922. Same is the case with CoSQA and AdvTest results. Also, large scale pre-trained decoder only models CodeGen & Llama2 are missing when evaluating in the zero shot setting. While these are not encoder only models, their embeddings can be leveraged for search related tasks.\n\nAlso, it's strange why text-embedding-ada-002 is chosen as a baseline here. OpenAI's cpt-code (https://openai.com/blog/introducing-text-and-code-embeddings) would have been a stronger baseline to compare with instead of text-embedding-ada-002 model for code related search tasks.\n\nWriting:\nAbsract: unclear what downstream task is, is it gen?\nIntro: No discussion of next token pred objective from decoder only or encoder-decoder models\n\nTypos:\n\nWriting:\nAbsract: unclear what downstream task is, is it gen?\nstructure --> structural aspect\npretraining schemes decide --> dictate/influence/impact\n\nIntro:\npara 1: Don't agree that only encoder models are embedding models. Even Llama, CodeLlama, CodeGen can serve as embedding models.\npara 2: make it --> makes it\npara 3: representation's discriminative power\n\nCodeT5 appears twice in the bib"
            },
            "questions": {
                "value": "- Why are decoder only models not studied as baselines for the code understanding tasks?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission3746/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission3746/Reviewer_iHpZ",
                    "ICLR.cc/2024/Conference/Submission3746/Senior_Area_Chairs"
                ]
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission3746/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698916897576,
        "cdate": 1698916897576,
        "tmdate": 1700623194100,
        "mdate": 1700623194100,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "p6Hc21Hw9s",
        "forum": "vfzRRjumpX",
        "replyto": "vfzRRjumpX",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission3746/Reviewer_zUhF"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission3746/Reviewer_zUhF"
        ],
        "content": {
            "summary": {
                "value": "This paper proposes CodeSage, a new series of models for learning representations of source code, ranging from 130M to 1.3B parameters. CodeSage is pretrained on the Stack dataset, with masked language modeling, identifier deobfuscation, and contrastive learning objectives, and all three objectives are carefully tailored specifically for code representation learning. Experiments are conducted on code search and classification tasks, against strong baselines. Results show that CodeSage not only outperforms all previous open-source code embedding models of similar sizes (i.e., ~125M), scaling it up to 1.3B further improves the performance and it also outperforms the `text-embedding-ada-002` embedding model from OpenAI."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "4 excellent"
            },
            "contribution": {
                "value": "4 excellent"
            },
            "strengths": {
                "value": "S1: All the pretraining objectives are specifically designed for code, the discussions on why such objectives need to be changed (e.g., no random token replacement) for code are very useful for future research in this domain;\nS2: To the best of my knowledge, CodeSage 1.3B is the largest (and best performing) code embedding model to date. Scaling up encoder-based models, especially for code representation learning, is an underexplored area;  \nS3: The experiments are very comprehensive. CodeSage is compared with strong baselines and it was able to beat all of them on the same model size, it also shows that the performance is significantly improved when scaled up to 1.3B. The ablations studies are rather thorough in showcasing the design choices;  \nS4: The writing of this paper is also great, making it very easy to follow, and conclusions from the figures and tables are very clear. For example, I found Figure 2(a) very helpful in showing why random token replacement makes less sense for code."
            },
            "weaknesses": {
                "value": "I do not have any significant concerns about this work. But I do have a couple of questions, which are listed in the \"Questions\" section. \n\nOne suggestion: it would be great if we could have an ablation on how each of the training objectives affects the performance (e.g., remove one at a time and see how the performance changes). But I also understand that such ablation is quite expensive."
            },
            "questions": {
                "value": "Q1: Do you plan to release the model and/or the code?  \nQ2: About not using random token replacement, this makes a lot of sense to me. But we would probably have the same problem for natural language, if we consider multiple languages, right? Is the same practice common in training multi-lingual text embeddings?  \nQ3: What is the pretraining hardware and compute?   \nQ4: Can you comment on the possibility to train even larger code embedding models using this method? It seems that most of the benchmarks are still improving by going from CodeSage-base to CodeSage-large in Table 1 and Table 2.   \nQ5: For Table 1, are the baseline models also trained on the 9 programming languages being evaluated here?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission3746/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699485418826,
        "cdate": 1699485418826,
        "tmdate": 1699636330510,
        "mdate": 1699636330510,
        "license": "CC BY 4.0",
        "version": 2
    }
]