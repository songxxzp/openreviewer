[
    {
        "id": "dCIuXUmDed",
        "forum": "Qp33jnRKda",
        "replyto": "Qp33jnRKda",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission2716/Reviewer_qBe2"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission2716/Reviewer_qBe2"
        ],
        "content": {
            "summary": {
                "value": "This work proposes a method to augment network architectures by finding layers with an \"expressivity bottlenecks\" and widening the network there. \n\nSpecifically, they calculate the functional derivative $v_\\text{goal} = - \\nabla_{u = f(x)} \\mathcal{L}(u)$ characterizing the best infinitesimal variation of the outputs of $f$ to decrease the loss at $x$. The derivative $v_\\text{goal}$ is then compared with its projection on the tangent space $T_\\mathcal{A}^{f_\\theta}$ of the manifold $F_\\mathcal{A}$ (networks with architecture $\\mathcal{A}$) at the point $f_\\theta$. The norm of the difference between these two directions is used to quantify the expressivity bottleneck. This gets also generalized not just for the logits $u$ but for all pre-activation values $a_l$. \n\nThe authors continue by providing a procedure how one calculates the best variation of the parameters for one layer $\\delta W_l^*$ (Proposition 3.1) in order to calculate the expressivity gap $\\Psi^l$, as well as a procedure to add neurons and initialize them optimally (Proposition 3.2). A series of Propositions (4.1 - 4.3) follow, shining light on the properties regarding the greediness of the approach. \n\nThe proposed approach is evaluated on the CIFAR-10 dataset. The authors start with an architecture consisting of two blocks of 2 convolutions and 2 MaxPooling each followed by two fully-connected layers using selu activation. The proposed method outperforms GradMax. The authors attribute this to the redundancy of GradMax. \n\nMinor comments:\n- in 2.2, paragraph \"Optimal move direction\" should $\\Theta$ be $\\Theta_\\mathcal{A}$? \n- Proof for 3.2 in the appendix: the first sentence seems incomplete"
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "4 excellent"
            },
            "strengths": {
                "value": "- The idea is interesting\n- The approach appears to be sound, although the reviewer could not verify the proofs (maybe due to some misunderstandings, see more in the questions). \n- Overall well written, although the technical reasoning should be improved.\n- Mentioned Limitations where insightful.\n- Helpful Appendix."
            },
            "weaknesses": {
                "value": "- The limitations regarding more complex datasets remains unclear. \n- There don't seem to be many experiments: How does the method perform on other seed architectures? \n- The math, especially the proofs should be more detailed."
            },
            "questions": {
                "value": "In no particular order: \n\n- How does the approach compare to NEAT based techniques? What are differences / communalities? \n\n- How well would your approach work on datasets with lower signal to noise ratio compared to CIFAR-10? Would you expect to see overfitting? \n- How do you terminate the training procedure? Is there some schedule according to which you pick which layer gets widened? Do you pick the layer with the largest (normalized) expressivity gap? \n- what exactly do they improve?\n- Did you consider combination of standard gradient descent and your proposed method? How would they work out? \n\n- I could not find a formal definition for $\\partial / \\partial t$ in Section 2.2\n- Proposition 3.1 (Appendix):\n\t- What happens in the step where after \"$M^+$, we get:\"? To me it looks like you substituted $\\delta W_l$ with $\\delta W_l^*$ in $V_\\text{goal}^l B_{l-1}^T = \\delta W_l B_{l-1} B_{l-1}^T$, as this is where the gradient of $g(\\delta W_l)$ vanishes, and then multiplied $\\tfrac{1}{n} (B_{l-1} B_{l-1}^T)^+$ from the right. However, i am missing the reasoning why $B_{l-1} B_{l-1}^T \\tfrac{1}{n} (B_{l-1} B_{l-1}^T)^+ = I$. \n- Proposition 3.2: \n\t- As $S$ is just positive semi-definite ($S := \\tfrac{1}{n} B_{l-2} B_{l-2}^T$) and not necessarily positive definite (i.e. may not have full rank), how do we know that $S^{-1/2}$ exists in Proposition 3.2? \n\t- Of which matrix are $\\lambda_k$ the Eigenvalues? Currently i see that they are the singular values of $S^{-1/2} N$. \nOverall, especially Proposition 3.1 and 3.2 would really benefit from detailed explanations. \n\n- Does you method scale to ImageNet?\n- Did you compare the three different initialization approaches? Random initialization, zero initialization and your in Proposition 3.2 proposed initialization?  \n- Which hardware did you use to run your experiments?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission2716/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698748455684,
        "cdate": 1698748455684,
        "tmdate": 1699636214031,
        "mdate": 1699636214031,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "HexVZYJYDn",
        "forum": "Qp33jnRKda",
        "replyto": "Qp33jnRKda",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission2716/Reviewer_vNAT"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission2716/Reviewer_vNAT"
        ],
        "content": {
            "summary": {
                "value": "TINY is proposed to grow neural network architectures with the aim to remove expressivity bottlenecks. The authors propose a scheme to increase the width of a considered feed-forward neural network architecture (with either fully-connected or convolutional layers) by adding neurons and thus increasing the width of the network during the growth process. (No dynamic addition of layers or other modules is considered.) \nThe proposed method is similar to GradMax but tries to avoid adding redundant neutrons."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "- The authors work on a timely problem and try to reduce the computational requirements of deep learning by growing relatively small neural networks rather than training large ones from scratch.\n- The authors aim to reduce redundancy in the addition of neurons when neural networks are grown.\n- The proposal is theoretically motivated based on potential optimal additions of neurons in function space.\n- The experiments show improvements in test accuracy over GradMax on CIFAR10."
            },
            "weaknesses": {
                "value": "- The exposition lacks a related literature discussion. While the introduction mentions different lines of research, it mostly focuses on early works in the related directions. Only Section 3 mentions a few related works on neural architecture growth and redundancy, which are easy to miss in the middle of the paper. As a result, an overview of the state of the art is missing.\n- A similar criticism also holds for the experiment section, which only compares with GradMax and not different types of approaches.\n- It is impossible to deduce from Section 3 what the actual algorithmic proposal is. The links in the algorithm to the supplement are broken. (The actual description is on page 15.) The actual update equations are not provided in the main paper. \n- Limitation: It appears that the number of neutrons that are added in each step is a hyper-parameter.\n- The update seems to involve a spectral decomposition to avoid neuron redundancy that is computationally costly. \n- The computational complexity of the full training process (including the network growth) has not been evaluated, even though it forms in integral part of the claimed contributions.\n- The method is not very flexible in adding layers or different kind of modules. It only grows the width of a chosen architecture.\n- The novelty of the method appears to be limited in comparison with GradMax.\n- Experiments are limited to CIFAR-10, a relatively small dataset of low complexity. \n(Note that GradMax was evaluated also on CIFAR-100 and ImageNet.)\n- The performance of the learned models on CIFAR-10 lacks far behind the test accuracy that can be achieved on this dataset with standard, relatively small ResNet architectures (like ResNet18).\n\n\nMinor points:\n- Broken figure link in Section 3 on page 4.\n- The supplement is not included in the main paper so that important links are broken (see algorithm, for instance)."
            },
            "questions": {
                "value": "- How does the proposed method perform on CIFAR100 and ImageNet?\n- How is the matrix N on page 15 computed, since it depends on the (unknown?) $V_{goal}$?\n- What is the runtime complexity of an update step?\n- How do the computational requirements compare with training just a wider model from scratch once?\n- How does training the obtained end neural network from scratch compare to the proposed training + growing process? Is a real improvement in generalization performance observed?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission2716/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698758089629,
        "cdate": 1698758089629,
        "tmdate": 1699636213917,
        "mdate": 1699636213917,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "8o5Nbl5adM",
        "forum": "Qp33jnRKda",
        "replyto": "Qp33jnRKda",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission2716/Reviewer_XQVK"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission2716/Reviewer_XQVK"
        ],
        "content": {
            "summary": {
                "value": "This paper shows how to grow tiny networks by leveraging the functional gradient to optimize the network architecture on the fly. They define the expressivity bottlenecks by the distance between the desired activity update and the reachable update from the current parameter space. And they greedy reduce the expressivity bottlenecks during training when neurons are added."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "1 poor"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "The problem is interesting and well-defined mathematically. Theoretically, they show how to solve the problem and have solid propositions and proofs, although I did not follow most of them. Empirically they compared their method to the previous method showing that they achieve better accuracy on cifar10 when growing from a tiny model."
            },
            "weaknesses": {
                "value": "The paper is not easy to follow and there are a lot of typos in the paper, i.e., missing figure number in section 3, no caption for the algorithm. I do think we should have a main algorithm that describes the whole training process, like how function gradients are calculated and how the optimization problem is solved according to which proposition. Empirical results seems very limited even compared to the baseline methods, such as gradmax."
            },
            "questions": {
                "value": "How do we add neurons to the convolutional layers? Are we structurally adding kernels or adding neurons treating them as fully connected layers?\n\nWhat are the benefits of the proposed method? Are we trying to have a method that tries to get the best model among a certain size or a method that can efficiently and effectively grow a tiny network to an arbitrary size? If it is the latter one, can we have some experiments with models that people use in practice?\n\nWhat is the computational cost of the proposed methods?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission2716/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698804016870,
        "cdate": 1698804016870,
        "tmdate": 1699636213846,
        "mdate": 1699636213846,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "2K65enSvPC",
        "forum": "Qp33jnRKda",
        "replyto": "Qp33jnRKda",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission2716/Reviewer_7xtb"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission2716/Reviewer_7xtb"
        ],
        "content": {
            "summary": {
                "value": "The submission presents a novel method to increase the width of a network during optimization, inspired from a functional argument. The method starts from the gradient of the loss wrt the output of the network, and finds weights by trying to align the output to this desired change."
            },
            "soundness": {
                "value": "1 poor"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "The method is novel and the problem of fitting both the weights and the architecture at the same time is relevant and very much open. I have heard the idea of \"let's do gradient descent on the architecture\" multiple time, but little in the way of actual attempts to define what is meant by that statement, which is welcome."
            },
            "weaknesses": {
                "value": "$\\newcommand{\\R}{\\mathbb{R}}$$\\newcommand{\\L}{\\mathcal{L}}$\n\nThe paper presents an interesting idea and I am generally positive towards it, but I found it hard to get the intended message. I think it would greatly benefit from an update to improve the clarity of the message, especially on the following points\n- The presentation of the functional analysis viewpoint. I found it hard to follow, probably due to notation overload.\n- The submission seems to not directly address how to trade-off increasing number of parameters vs. updating the parameters we already have.\n- Given that a stated contribution of the submission is a definition of optimality, what is meant by that should be stated explicitly.\n- Some statements should be made more carefully to avoid overly general claims.\n\nI give more details and specific examples of each of the points below. I will increase my score if these points are adressed by a revision during the discussion period.\n\nAs my issues have to do with clarity, I tried giving specific and clear descriptions, leading to a possibly (overly long) review. The length of the section below should not be taken as a negative assesment of the submission. My hopes is that those can help the authors make the message of the paper clearer. \n\n---\n\n## Details\n\n**Clarity of the functional view**\n\nI might be missing some key background reference, but I struggle to follow section 2.2. My understanding of the high-level idea is that $v_{\\text{goal}}(x)$ indicates the desired change in output of the network by indicating what infinitesimal change in the output of the network is desired. This goal reasonable and I wouldn't have an issue if it had been stated as such, but I don't understand how it follows from the functional perspective outlined in \u00a72.2. \n\nThe notation seems overloaded to represent the functional and the \"standard\" ML notation. The lack of distinction makes the text hard to parse. For example, the expression $\\nabla_{f}\\L(f)$ implies that $\\L$ takes a function, but in $\\nabla_{u=f(x)} L(u)$, it is evaluated at the output of the network, a vector in $\\R^p$.\n\nThe text also implies that $\\nabla_f \\L(f) = \\nabla_{u=f(x)} \\L(u)$\" by the definition and evaluation of $v_{\\text{goal}}$. Assuming my interpretation above is correct, this equivalence is not obvious to me. It would benefit from an explanation as to why it holds, or a reference. It is also unclear to me why this holds without defining the space of functions, for example whether $\\mathcal{F}$ is the class of function representable by any width-$M$ networks and taking the union over all $M$s, some RKHS, or whether we any arbitrary pathologic discontinuous functions is allowed.\n\n**Balancing optimization and adding parameters**\n\nThe last contribution states that the submission \"naturally obtain[s] a series of compromises between performance and number of neurons, in a single run, thus removing the need for width hyper-optimization\". I would expect this contribution to refer to a particular result highlighting how the proposed methods trades-off (a) fitting the current architecture/doing more traditional GD steps vs. (b) adding neurons. Unless I missed something, the proposed method does not inherently address this tradeoff, and instead adds a fixed number of neurons. This seems to be replacing the width hyperparameter by a \"how-much-width-to-add\" hyperparameter. The method can still be an improvement by lowering the dependency of the performance on the hyper-parameter, but should be discussed more directly in the main text.\n\n**Definition of optimality**\n  \nThe submission uses the term optimal in many instances with what appears to be different meanings. It is not clear what criteria is used to establish optimality. To take an example from optimization, gradient descent being optimal could refer to the fact that it is the result of minimizing a surrogate quadratic problem, or to say that it attains the best rate of convergence among first-order algorithms in some problem class.\n\nAs the goal of the submission is to \"mathematically define the best possible neurons\" and fixing expressivity bottlenecks \"optimally\", it would be beneficial to be explicit about what is meant by \"optimal\". Especially as the submission can be interpreted as proposing two definitions; one implied in \u00a72.2 as minimizing the distance between $v_{\\text{goal}}$ and the actual update, and another looking at the layers independently in 2.3 to make the problem tractable (especially as the submission states in \u00a73.3 that \"this move is sub-optimal\").\n\nFor example, \"picking optimal directions that avoid redundancy in the pre-activation space\" at the end of the submission seems to reflect that \"optimal\" is taken to mean the optimal direction to decrease the first-order approximation of the loss, a concept that is missing from other instances such as \"Optimal functional move\", \"The optimal update of the weights at a given layer\", or the optimality in Prop 3.2.\n  \n**Overly broad claims**\n\n- (Intro) \"This removes the optimization issues (local minima) that usually arise when considering thin architectures\"; \"remove optimization issues\" is too broad, and might imply that local minima are the only optimization problem. The contribution should state that it is possible to avoid some local minima (with a forward reference to the specific result in \u00a74), or specify that this result applies to 1-hidden-layer networks.\n- (\u00a73.2) \"[adding random neurons] would not yield any guarantee regarding the impact on the system loss\"; I read this sentence as implying that this is in contrast with the proposed method, which then should have a guarantee that adding the proposed neurons decreases the loss. As no such results are presented, the description should be changed.\n- Going into \u00a72.3, I interpreted the description of \"recursive\" as implying that some invariant would be maintained, and specifically that the resulting update wouldn't change. To avoid this confusion, I would suggest being explicit are the start of \u00a72.3 that what follows is a an approximation to what is desired in \u00a72.2, as this only spelled out in \u00a73.1.\n\n\n**Related work**\nThe description of prior work could be more detailled to help readers unfamiliar with the literature. For example, it is not clear how the description of Net2Net, AdaptNet and MorphNet (\"propose different strategies to explore possible variations of a given architecture\") differs from the approach proposed here. \n\nI was also surprised to not see a citation to the classical works of neuron boosting/incrementally learning a neural network one neuron at a time (For example, Bengio, Le Roux, Vincent, Delalleau, and Marcotte. Convex neural networks. 2006, or other references found in the GradMax paper of Evci et al.), which I think would be relevant for historical context.\n\nAlthough focused on optimization of a fixed architecture, there is a line work in optimization for deep learning that takes a constrained optimization/Lagrangian view to obtain per-layer updates that look similar to the recursion argument in \u00a72.3--\u00a73.1. The following works might be of interest to the authors if they were previously unaware of those. _(to be explicit; although I do believe there is a connection and that some discussion could be beneficial, I am not requesting that the submission cite those works)_\n- Lecun. A Theoretical Framework for Back-Propagation. Proceedings of the 1988 connectionist summer school \n- Carreira-Perpi\u00f1\u00e1n and Wang. Distributed optimization of deeply nested systems. AISTATS 2014.\n- Taylor, Burmester, Xu, Singh, Patel and Goldstein. Training Neural Networks Without Gradients: A Scalable ADMM Approach. ICML 2016.\n- Frerix, Mollenhoff, Moeller and Cremers. Proximal Backpropagation. ICLR 2018.\n- Amid, Anil and Warmuth: LocoProp: Enhancing BackProp via Local Loss Optimization, AISTATS 2022\n\n---\n\n**Minor points (no need for a response):**\n- \"Under standard weak assumptions (A.1)\" made me think I should look for a an \"Assumption 1\", as this style of reference is common. I'd suggest spelling out \"(see Appendix A.1)\".\n- (after Prop 4.3) \"by requiring the added neuron to have infinitely small input weights\"; a literal interpretation of this sentence requires the inputs to be 0. I suggest rephrasing in terms of \"direction\" instead.\n- What \"time\" in $\\frac{\\partial\\theta}{\\partial t}$ is not defined, \n- \"shown empirically to be better optimized than small ones Jacot et al. 2018\" seems to imply that this is what Jacot et al. shown. I assume the citation should have been moved earlier in the sentence, for the theoretical part.  \n- There are multiple instances where \\citet and \\citep are mixed, leading to missing parentheses around citations, especially in paragraphs discussing related works (\"Notions of expressivity\" paragraph)\n- The \"amplitude factor $\\gamma$\" used in the Algorithm given in Fig. 6 seems undefined in the main paper."
            },
            "questions": {
                "value": "The specifics of my points above do not require a response and can instead be adressed through a revision, although I am open to a discussion if the authors disagree with my comments.\n\nFor specific questions;\n\n- **Clarity of the functional view**\n\n  Are the notation issues identified above correct, or did I completely miss something? If so, what is the formal definitions of the objects used, and why is the functional gradient the same as the derivative wrt the output of the network?\n  (Those questions be adressed by a revision to the paper and need not be written in openreview posts)\n\n- **Balancing optimization and adding parameters**\n\n  Shouldn't the functional view provide a way to perform this trade-off, for example through some regularization parameter that could impact how much better the \"adding new weights\" step should be vs. updating existing weights?\n\n- **Complexity of the methods** \n\n  The introduction claims that the method is is \"competitive\" in computational complexity with standard training. However, it seems that the methods requires the computation of SVDs of matrices whose size dependent on the width of the network, and the complexity should scale (at least) with that width squared, which is much more than gradient descent. Could the authors clarify what was meant?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission2716/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699595393244,
        "cdate": 1699595393244,
        "tmdate": 1699636213784,
        "mdate": 1699636213784,
        "license": "CC BY 4.0",
        "version": 2
    }
]