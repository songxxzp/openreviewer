[
    {
        "id": "ycSa1YR5cz",
        "forum": "ASppt1L3hx",
        "replyto": "ASppt1L3hx",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4367/Reviewer_LvyT"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4367/Reviewer_LvyT"
        ],
        "content": {
            "summary": {
                "value": "In this paper, the authors propose a cooperative mini-batching design that utilizes the overlap of sampled subgraphs. The propose approach claims to optimize the communication during GNN training."
            },
            "soundness": {
                "value": "1 poor"
            },
            "presentation": {
                "value": "1 poor"
            },
            "contribution": {
                "value": "1 poor"
            },
            "strengths": {
                "value": "Optimizing the communication during GNN training is an important topic."
            },
            "weaknesses": {
                "value": "\u2014The writing is informal and not well organized, which is reflected but not limited to the following aspects: 1) ambiguous terminology and inconsistent word choice, e.g., \"work\" (not clear what this really means); 2) overly extensive background (not sure how most content in the background is related to the target problem); 3) causal usage of theorem.\n\n\u2014The theoretical result states that the expected work increases as batch size increases, which clearly depends on the setting. For example, what if, in the extreme case,  the communication speed is infinite? What if I am using different GNN models? The theoretical result does not provide any specification with this regard and it is not clear how one can prove such a result.  In addition, it is not clear how the theoretical results motivate or connect with the proposed approach.\n\n\u2014No discussion on related works, despite there exists an extensive line of research from both algorithm and system communities that try to optimize distributed/large-scale GNN training. For example, I found the idea is closely related to layer sampling that is commonly used in GNN, and the communication optimization proposed in [1].\n\n[1] Gandhi, Swapnil, and Anand Padmanabha Iyer. \"P3: Distributed deep graph learning at scale.\" 15th USENIX Symposium on Operating Systems Design and Implementation (OSDI), 2021."
            },
            "questions": {
                "value": "The theoretical result states that the expected work increases as batch size increases, which clearly depends on the setting. For example, what if, in the extreme case,  the communication speed is infinite? What if I am using different GNN models? The theoretical result does not provide any specification with this regard and it is not clear how one can prove such a result.  In addition, it is not clear how the theoretical results motivate or connect with the proposed approach."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "1: strong reject"
            },
            "confidence": {
                "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission4367/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4367/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4367/Reviewer_LvyT"
                ]
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4367/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698587852353,
        "cdate": 1698587852353,
        "tmdate": 1699636409288,
        "mdate": 1699636409288,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "gttVV2IoEx",
        "forum": "ASppt1L3hx",
        "replyto": "ASppt1L3hx",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4367/Reviewer_m5Sh"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4367/Reviewer_m5Sh"
        ],
        "content": {
            "summary": {
                "value": "This paper addresses the issue of redundant data access and computation across processing elements (PEs) in the context of independent minibatch Graph Neural Network (GNN) training. The authors conduct both empirical and theoretical investigation for the monotonicity of work size and the concavity of the expected subgraph size needed for GNN training, with respect to the batch size. Based on these two properties, the author introduces cooperative and dependent mini-batching methodologies. These strategies are designed to minimize computational redundancy and optimize temporal locality for data access. The evaluations on several datasets with different system setups show that the proposed techniques can speedup multi-GPU GNN training by up to 64%."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "+ The paper is well-written and addresses a practical issue in minibatch GNN training.\n+ The proposed methodologies are strongly motivated from both empirical and theoretical perspectives.\n+ The paper demonstrates significant performance improvement with minimal overhead. The appendix serves as a good supplement to the main content."
            },
            "weaknesses": {
                "value": "- The paper lacks sufficient evaluation to demonstrate the generalizabiliy and scalability of the proposed technique.\n- The paper omits some relevant citations for related work that should be discussed and compared.\n- There are some points need further clarifications."
            },
            "questions": {
                "value": "1. The paper only evaluates the proposed method on one GNN model. How generalizable is this method to other types of GNNs, especially those deep GNNs with tens of layers?\n2. The parameter (\\kappa) for batch dependency is set as 256, however, Figure 4 indicates minimal difference between 64, 256, and even infinity. Furthermore, Figure 3 shows that the GNN model validation F1-score drops when \\kappa is 256 (or larger). Given these observations, how do you justify the choice of \\kappa as 256 for the evaluation instead of 64?\n3. Could you clarify the unit of measurement for the cache size? Is it quantified in bytes or in terms of the number of vertices/features? What are the key factors for determining the optimal cache size for different datasets, GNN models, and the hardware platforms?\n4. What are the communication cost with and without applying the proposed technique?\n5. The work in [1] also solves the redundancy issue across the PEs using cooperative training. However, this related work is not cited or compared in this paper.\n6. It might be beneficial to include more illustrative figures, especially, for the algorithm 1. This would help readers to follow the steps of the proposed method more easily.\n\n[1]. GSplit: Scaling Graph Neural Network Training on Large Graphs via Split-Parallelism"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission4367/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4367/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4367/Reviewer_m5Sh"
                ]
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4367/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698779697899,
        "cdate": 1698779697899,
        "tmdate": 1699636409172,
        "mdate": 1699636409172,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "2oweVBDE0x",
        "forum": "ASppt1L3hx",
        "replyto": "ASppt1L3hx",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4367/Reviewer_GNH8"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4367/Reviewer_GNH8"
        ],
        "content": {
            "summary": {
                "value": "The paper identifies an issue with standard mini-batching approaches for training graph neural networks: that redundant computations are performed by processors due to them sharing edges and vertices. A new method, cooperative mini-batching, is proposed, in which processors jointly process a single global mini-batch, exchanging information as needed to avoid redundant computation. Independent versus cooperative mini-batching is then compared experimentally."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "1. The paper identifies an important difference between mini-batching in standard DNN training and in GNNs, which I had not before observed, and proposes a method to avoid inefficiencies in independent mini-batch training in GNNs. This has the potential to positively impact the training of GNNs.\n2. There is both theoretical and experimental justification for this method.\n3. The paper includes extensive experiments to support its points."
            },
            "weaknesses": {
                "value": "1. The paper seems to be missing a discussion of the communication costs of its method, which seem like they could be significant, especially in a multi-node setup.. This is in contrast to independent mini-batching, which has the nice property of avoiding communication. The appendix (A3) notes communication overhead is not an issue, but this could be measured in detail, and in any case only considers a small-scale, on-node scenario.\n2. How is the 1D partitioning done, in detail? Appendix A3 notes that using METIS was beneficial, so why not always use this (or a similar graph partitioning algorithm)?\n3. The paper does not discuss the memory overhead of cooperative mini-batching. It seems to me that all samples in a K-hop neighborhood of each vertex need to be present for the method, which seems like it would result in significant memory overheads, especially as the number of layers increases (the paper only considers a network with three layers).\n4. The paper seems to be only considering neighborhood sampling as a way of performing independent mini-batching. However, there are other ways to do this, e.g., graph cut algorithms. (See, for example, Rozemberczki et al., \"Little Ball of Fur: A Python Library for Graph Sampling\", CIKM 2020.)"
            },
            "questions": {
                "value": "1. What are the communication costs of cooperative mini-batching? How does the method perform in cross-node scenarios?\n2. How is partitioning done? Why not always use a method that reduces cross-device edges?\n3. How does cooperative mini-batching scale with the depth of the network?\n\n-----\n\nI thank the authors for their clarifications, and have slightly raised my score accordingly. I would, however, echo the concerns of reviewer LvyT regarding the text."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission4367/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4367/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4367/Reviewer_GNH8"
                ]
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4367/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699064975799,
        "cdate": 1699064975799,
        "tmdate": 1700672675427,
        "mdate": 1700672675427,
        "license": "CC BY 4.0",
        "version": 2
    }
]