[
    {
        "id": "Vm8uTJiPTh",
        "forum": "lIwp1C1eSK",
        "replyto": "lIwp1C1eSK",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4155/Reviewer_6vbo"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4155/Reviewer_6vbo"
        ],
        "content": {
            "summary": {
                "value": "In this paper, the authors address the task of training reinforcement learning agents with goals defined by language instruction, focusing on reducing sample complexity and generalization. They propose to use LLM to parse the instructions to simple boolean expressions for World Value Functions (WVF) learning. WVF was introduced in a previous paper, utilizing logical operators to design value functions to solve compositional tasks. The approach is evaluated in BabyAI environments, achieving a  success rate of 92%, which matches the upper-bound performance of an Oracle parser, outperforming the standard baseline in sample efficiency and generalization."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "1 poor"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "- The paper effectively leverages LLM to enhance reinforcement learning within the BabyAI environments.\n- It explores a substantial set of 162 tasks, showcasing the breadth of the research.\n- The proposed approach delivers superior results."
            },
            "weaknesses": {
                "value": "- The approach is incremental.  Since components like WVFs were known before (Nangue Tasse et al., 2020), the main contribution is the usage of LLM. However, it is straightforward to apply LLM to parse the instruction especially since previous papers suggested LLM as a good parser (Shin et al., 2021). \n- In terms of practicality, for BabyAI, it is easy to program a perfect parser, and thus, it is not necessary to use LLM in this task.\n- The baseline is too primitive. It is not surprising that the proposed method outperforms the baseline because it has access to additional information (e.g. compositions of the instruction). Please consider other baselines on Baby AI such as those in Carta et al., (2023)\n- The pre-training time can be an issue. In Figure 3, after the pertaining time of the proposed method, the baseline already converges to a reasonable performance. Although the baseline cannot improve further, its reasonable performance may outweigh the cost of additional training of the proposed method\n- The writing is hard to follow. More background on WVF is needed to understand the approach. The abstract also lacks information to capture the main idea of the paper (use LLM to parse instructions for WVFs). The method combines different components from different papers, so it is better to present an algorithm to describe the whole workflow in detail (especially the part that uses parsed symbols to select the WVF basis and the training of WVFs in the downstream task).\n\n\nCarta, Thomas, Cl\u00e9ment Romac, Thomas Wolf, Sylvain Lamprier, Olivier Sigaud, and Pierre-Yves Oudeyer. \"Grounding large language models in interactive environments with online reinforcement learning.\" arXiv preprint arXiv:2302.02662 (2023)."
            },
            "questions": {
                "value": "- What is trained during the downstream tasks? Are you fine-tuning the basic value functions?\n- How many runs are used to generate the plot in Figure 3? The variance of GPT 3.5 is high. \n- Table 2, the first Assistant should not have ~?\n- Can you summarize 18 goals in a table? This sentence is hard to understand \"Each WVF is implemented using |G| = 18 CNN-DQN (Mnih et al., 2015) architectures\"\n- How did you generate 162 tasks? Are any criteria used?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4155/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698285386885,
        "cdate": 1698285386885,
        "tmdate": 1699636381364,
        "mdate": 1699636381364,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "oWDMv9MOfB",
        "forum": "lIwp1C1eSK",
        "replyto": "lIwp1C1eSK",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4155/Reviewer_VNmK"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4155/Reviewer_VNmK"
        ],
        "content": {
            "summary": {
                "value": "This paper proposes a framework for solving logical compositional goal-reaching tasks instructed by language. The framework is a two-stage approach. In the first stage, it pretrains a collection of value functions for basic tasks that can later be composed to build other tasks with reinforcement learning. In the second stage, it leverages a large language model to convert language instructions into logical expressions over the basic symbols obtained in the first stage. The predicted logical algebra is executed in the environment to obtain the success or not signal, and the successful examples are then added to the in-context examples to prompt the LLM. Empirical studies are conducted in the BabyAI environment focusing on different combinations of attributes. The proposed framework shows better overall success rates and better generalization ability than the baseline without compositional representation and LLM."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "1. Combining the ability of zero-shot compositional generalization in boolean expressions of world value functions and parsing language instructions into logical expressions is a novel solution.\n2. The generalization performance of the proposed method is impressive.\n3. The idea of using environmental rollout signals as in-context examples as feedback to the LLM is interesting, and could be of benefit to readers who are integrating combining LLM with RL."
            },
            "weaknesses": {
                "value": "1. More empirical baselines should be studied to verify the effectiveness of the proposed method. For example, (a) defining some kind of action space for boolean expressions and then using RL to learn a policy that converts language instructions into boolean expressions. This baseline could better illustrate the contribution of LLM; (b) Fine-tuning the language model using the environmental feedback so as to show the impact of in-context learning from environmental feedback.\n2. I think the empirical validation is not sufficient enough to support the claim made fully. The method purposefully treats all the basic value functions as symbols without semantic meaning so as to be applicable to different domains with different definitions of such value functions. Currently, it is only experimented on BabyAI, a relatively neat and simple environment. It would be better to run the method in some other domains (ideally more realistic domains, such as robot manipulation). \n3. As the authors have mentioned, the proposed method requires pretraining a set of WVFs as a basis for further language instruction parsing. Currently, what the set of WVFs is composed of requires an in-depth understanding of the domain. Automating the design of WVFs or allowing to dynamically modify WVFs will strengthen this work."
            },
            "questions": {
                "value": "In this work, only the boolean expressions that lead to sufficiently high success rates are added to in-context samples. Does it mean that the correct boolean expression should be easy to explore for the LLMs? Is it possible to obtain more supervision from failed environmental rollouts?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4155/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698493276429,
        "cdate": 1698493276429,
        "tmdate": 1699636381276,
        "mdate": 1699636381276,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "YSAljwlKMN",
        "forum": "lIwp1C1eSK",
        "replyto": "lIwp1C1eSK",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4155/Reviewer_wEbe"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4155/Reviewer_wEbe"
        ],
        "content": {
            "summary": {
                "value": "This paper proposes a method for performing RL tasks specified using natural language commands. The approach involves using an LLM to map a given natural language specification to an expression representing a Boolean combination of primitive tasks and then applying an existing compositional RL technique for obtaining an optimal policy/Q-function for the corresponding task. LLM prompts are generated automatically including in-context examples which are obtained from prior interactions with the environment. Experiments indicate that this approach is more sample efficient in learning to perform multiple tasks (specified in natural language) when compared to a baseline that trains a policy end-to-end. The authors also show that their approach improves the transferability of the learnt policy to unseen tasks."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "- Although the idea of generating a structured representation from natural language is not new (e.g., code generation), the idea of using feedback from the environment to create in-context examples and the idea of using LLM generated logical specifications in conjunction with compositional RL approaches are interesting.\n- The paper is well-written and fairly easy to follow. The problem is well motivated and the solution is well explained.\n- The approach seems to enable learning policies that can follow a wide range of natural language instructions."
            },
            "weaknesses": {
                "value": "- _Need for user-defined primitive tasks:_ The compositional approach presented in this paper requires manual specification of primitive tasks and training a Q-function for each primitive task. This set of primitive tasks might not be readily available; which makes this approach not easily applicable to realistic scenarios. Furthermore, the baseline approach does not have access to any such additional information.\n\n- _Unfair comparison to baseline:_ As mentioned above, the baseline does not have access to additional information that is being used to achieve the decomposition necessary for the approach presented in this paper. Furthermore, the baseline approach does not have access to any pre-trained LLM and has to learn the logical structure in the natural language instructions from scratch by interacting with the environment. It is worth considering a baseline that uses the output of a hidden layer of a pre-trained LLM as the encoding of the natural language specification.\n\n- _Only Boolean combinations supported:_ The instructions are assumed to always correspond to a Boolean combination of primitive tasks. There is no support for temporal compositions such as doing one task after another. Furthermore, this reduces the problem to finding the mapping between keywords in the textual task description and the set of symbols used to denote the primitive tasks. In fact, I believe LLMs such as GPT3.5 can already construct Boolean formulas from such language instructions if this mapping is given. Although this mapping is being learned in the proposed approach, I am not sure if there are use cases where the set of primitive tasks is available but the mapping to the symbols is not."
            },
            "questions": {
                "value": "1. Did you consider using a pre-trained encoding of the natural language instruction instead of learning this from scratch in the baseline? Would the peak performance of the baseline still remain lower than the GPT4.0 LLM agent?\n1. How would an LLM agent that has mappings from primitive tasks to symbols representing them (but has to still generate the Boolean formula) perform in comparison to the proposed approach (and the oracle agent)?\n1. Do you have any thoughts on how your approach can be modified to support a richer set of tasks (for example, involving temporal compositions)?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission4155/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4155/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4155/Reviewer_wEbe"
                ]
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4155/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698630218472,
        "cdate": 1698630218472,
        "tmdate": 1699636381200,
        "mdate": 1699636381200,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "vPgRD3nIuJ",
        "forum": "lIwp1C1eSK",
        "replyto": "lIwp1C1eSK",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4155/Reviewer_Gnf9"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4155/Reviewer_Gnf9"
        ],
        "content": {
            "summary": {
                "value": "The paper proposes to combine natural language instructions with boolean compositional value functions for improved generalization and sample efficiency of instruction following models. The method leverages an LLM to parse a natural language instruction into the corresponding boolean formula. Based on this boolean formula the action value function for the specific instruction is constructed following the framework of Nangue (2022). The method is evaluated on a set of 162 instruction following tasks build on top of the BabyAI environment. The experiments investigate the sample efficiency and generalization performance of their method against a non-compositional CNN-DQN baseline using either GPT3.5 or GPT4 as the underlying LLM. The method generalizes better to a held-out set of tasks. For all experiments the parsing of GPT3.5 leads to worse results than the parsing with GPT4."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "The method and experiments were presented in a clear and understandable way, which was easy to follow.\n\nThe method shows improved generalization performance. \n\nA reward signal is used to choose in-context learning examples for the LLM, which is to the knowledge of the authors as well as mine a novel approach of prodividing environment feedback to LLMs. \n\nUsing LLMs as semantic parsers to bridge the gap between natural language instructions and logical formulas tackles the problem of how to obtain logical formulas for certain tasks without much engineering effort. Prior work often assumes such formulas or a parser as given."
            },
            "weaknesses": {
                "value": "Sample Efficiency: \n\n- Given the results in Figure 3. I do not think one can make the statement that the method is more sample efficient, than the baseline. The baseline stops improving after the number of environment steps has reached the number of pretraining steps. To me one method is more sample efficient than the other if it reaches the same performance with less samples. The conclusion that can be drawn from the plot is that the method outperforms the baseline in terms of final performance. And to me it is not immediately clear why the baseline is limited in its final performance, would a larger network or more carefully tuned hyperparameters lead to better final performance? \n\nBaseline:\n\n- Why were there no pretrained language embeddings used for the baseline? That should have a large impact on at least the sample efficiency of the baseline.\n\nFormalities:\n\n- I would present Figure 4 in the same way Figure 3 is presented. The authors state that because they look at generalization performance and not sample efficiency a clear separation of the pretraining samples and the training samples is not necessary. However, the plot looks at generalization performance after a certain number of environment steps, and for a given point on the x-axis the current plot compares the generalization performance of two method trained with different number of samples. If I understood it correctly the number of steps for which the baseline was trained in that scenario is 10 million, so it is close to only half of all the pretraining steps. Since the generalization performance of the baseline is so low I do not think it makes much difference in the conclusions that can be drawn, but would result in a more accurate comparison."
            },
            "questions": {
                "value": "- The sucess rate that boolean expressions need to satisfy to be added to the database of boolean expressions that can be added to the prompt, seems to be set by expected performance of the oracle parser. Did you perform any ablations on that hyperparameter? A lower threshold might lead to worse formulas being added but also more formulas early on and vice versa. It would be interesting to see how sample efficiency changes with that parameter. \n\n- In the boolean expressions abstract symbols were used for concepts such as \"grey object\", why not the corresponding natural language labels. Would that not make parsing for the LLM easier?\n\n- In paragraph 3.2.1 it says that during training a beam of 10 parses was looked at. During the evaluation of the agent, did the agent choose the most likely parsing and evaluate it for 100 episodes or was the average evaluation of all 10 parses looked at ?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission4155/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4155/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4155/Reviewer_Gnf9"
                ]
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4155/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698660556571,
        "cdate": 1698660556571,
        "tmdate": 1699636381099,
        "mdate": 1699636381099,
        "license": "CC BY 4.0",
        "version": 2
    }
]