[
    {
        "id": "RikSDTInEm",
        "forum": "FH7lfTfjcm",
        "replyto": "FH7lfTfjcm",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission7810/Reviewer_hxrU"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission7810/Reviewer_hxrU"
        ],
        "content": {
            "summary": {
                "value": "This paper introduce a novel source-to-source transpilation framework between deep learning frameworks, named ADELT.\nThe core innovation is to decouple the process into code skeleton transpilation and API keyword mapping, so more structural information and domain information could be injected through prompting and adversarial training. \nThe proposed method outperforms the SOTA method by a good margin on PyTorch-Keras and PyTorch-MXNet transpilation pairs."
            },
            "soundness": {
                "value": "4 excellent"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "4 excellent"
            },
            "strengths": {
                "value": "I think the proposed ADELT is solid and innovative.  \nI like the idea of decoupling an end-to-end generation process into separate parts, which allows more context/structural information to be incorporated into the process. But it's often hard to achieve because of the complexity of different tasks. For the transpilation task, I think the author find a good combination of the code skeleton and the API keywords mapping. And the experimental results show a significant improvement over the SOTA system, which is quite convincing.\nOverall I think it's a solid paper, well-written and easy to understand."
            },
            "weaknesses": {
                "value": "One suggestion is that in the code skeleton process, all the API keywords are replaced by placeholders (namely PLACEHOLDER_1,2 ...).\nI wonder if it will be beneficial to add more context information into the placeholders, given them more concrete meanings. \nFor example in machine translation, the name entity is often replaced as <NUM>, <TIME>, <NAME> etc, which will give more context information in the downstream translation process.   So maybe the same idea could be applied in transpilation."
            },
            "questions": {
                "value": "As the transpilation is decoupled into two sub-parts:  the code skeleton and the API keywords mapping.\nIs it possible to measure the precision of each process and how do they effect the final performance ?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission7810/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission7810/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission7810/Reviewer_hxrU"
                ]
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission7810/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698753706449,
        "cdate": 1698753706449,
        "tmdate": 1700790250651,
        "mdate": 1700790250651,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "7qL10pkdhO",
        "forum": "FH7lfTfjcm",
        "replyto": "FH7lfTfjcm",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission7810/Reviewer_DL7Y"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission7810/Reviewer_DL7Y"
        ],
        "content": {
            "summary": {
                "value": "This paper presents a method translate short code snippets from one deep learning framework to another. The authors create a mapping of keywords from one framework to another, using a new BERT-like model pre-trained on Python code. This model is augmented with a generator and discriminator, and finetuned using unsupervised data to maximize cosine similarity, similar to dense retrieval methods. The authors then pipeline prompting LLMs to translate the code, and then use their mapping to replace the keywords from the source framework to the target. The proposed method outperforms prompting LLMs, unsupervised NMT approaches, and simple heuristic approaches on a small evaluation set of 50 samples of around 10 lines each."
            },
            "soundness": {
                "value": "1 poor"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "1. A BERT model trained on Python code, which could have interesting applications - for example for code refactoring, static analysis, etc. \n1. Using retrieval cosine similarity to map API keywords from one framework to another, which is learnt using fully unsupervised and unaligned data."
            },
            "weaknesses": {
                "value": "1. Very small evaluation dataset size of 50 samples. This makes any evaluation or comparisons made on this data less robust, with 95% deviations of upto +- 8.8 points.\n1. The evaluation dataset construction process itself introduces biases - \n    1. By selecting only pairs with high BLEU score, this makes the dataset somewhat simpler than what a more uniform sampling might have yielded (say with a manually created dataset, with humans transpiling the code). This \"simpler\" dataset then in turn hides how the proposed method may compare to others (such as prompting LLMs) in more complicated instances.\n    1. The BLEU score filtering also biases the dataset towards shorter snippets with $\\approx10$ lines of code - This restricts the scope of this method, to real world scenarios with very small code snippets to translate, and again makes realistic comparisons difficult.\n1. The pre-training dataset used may itself have been on interest, but perhaps will not be feasible to release due to copyright concerns."
            },
            "questions": {
                "value": "1. For table 9, could the authors provide GPT4's 95% intervals, specifically for F1? (corresponding to scores in Table 1)\n\nPresentation suggestion - \n1. 2 decimal digits (in Table 1, etc) make it hard to read the table to quickly compare values. 1 decimal digit will be easier/faster to understand. However, given the 95% confidence intervals are so large, any decimal digit is meaningless - Perhaps no decimal digits should be shown.\n1. Datasets in A.1 are reported in GBs, but often a significant fraction of ipynb notebook files is binary data in output cells - a better metric to report here would be either tokens, or dataset size without the binary parts of ipynb."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission7810/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698763071905,
        "cdate": 1698763071905,
        "tmdate": 1699636955884,
        "mdate": 1699636955884,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "NKKm31VXgA",
        "forum": "FH7lfTfjcm",
        "replyto": "FH7lfTfjcm",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission7810/Reviewer_TwWZ"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission7810/Reviewer_TwWZ"
        ],
        "content": {
            "summary": {
                "value": "The paper introduces a novel approach called the Adversarial DEep Learning Transpiler (ADELT) for source-to-source transpilation between deep learning frameworks.\n\nThis work has two contributions, as follows:\n\n1. ADELT is trained on an unlabeled web-crawled deep learning corpus, avoiding the need for hand-crafted rules or parallel data. It outperforms several related methods and significantly surpass the state-of-the-art large language model Codex, by 19.33 and 12.50 points, respectively.\n\n2. The authors construct a PyTorch-Keras-MXNet corpus of deep learning code from various Internet sources, containing 19,796 PyTorch modules, 3,703 Keras layers/models, and 1,783 MXNet layers/models. An evaluation benchmark is then built to assess both the API keyword mapping algorithm and the overall source-to-source transpilation.\n\nIn summary, ADELT represents a significant advancement in the field of source-to-source transpilation for deep learning frameworks, offering improved performance without the need for labeled data and providing a valuable resource for the deep learning community by sharing code, corpus, and evaluation benchmarks openly."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "1. Originality:\n\na. Decoupling of Transpilation Components: ADELT's approach to decoupling code skeleton transpilation and API keyword mapping is a unique and innovative contribution. This separation allows for more flexibility and adaptability in the transpilation process, and it sets ADELT apart from existing end-to-end methods.\n\nb. Few-shot Prompting and Domain-Adversarial Training: The use of few-shot prompting on large language models for code transpilation and domain-adversarial training of contextual embeddings for API keyword mapping is a novel combination. It leverages the strengths of these techniques to enhance transpilation accuracy.\n\n2. Quality:\n\na. Performance Improvement: ADELT demonstrates substantial improvements in transpilation accuracy compared to state-of-the-art transpilers. The increase in exact match scores for PyTorch-Keras and PyTorch-MXNet transpilation pairs is impressive, indicating the high quality of the proposed approach.\n\nb. Data Utilization: ADELT's ability to achieve these results without relying on labeled data is a testament to its quality. Training on an unlabeled web-crawled deep learning corpus showcases the effectiveness of the approach in real-world scenarios.\n\n\nBesides, the clear problem statement makes the problem of source-to-source transpilation accessible to a broad audience. The methodology, including the use of few-shot prompting, domain-adversarial training, and the construction of a corpus, is well documented, enhancing the clarity of the proposed approach. ADELT represents an important step forward in addressing the challenges of working with different deep learning frameworks."
            },
            "weaknesses": {
                "value": "1. Lack of Negative Results: The paper primarily focuses on the strengths and successes of ADELT. Including discussions on potential limitations, challenges, or cases where ADELT might not perform as well would make the paper more balanced and provide a more realistic perspective.\n\n2. Generalization of the Approach: The paper primarily focuses on specific transpilation pairs like PyTorch-Keras and PyTorch-MXNet. To enhance the paper's significance, discussing the potential for ADELT's application to a broader range of deep learning frameworks and scenarios would be valuable."
            },
            "questions": {
                "value": "1. How does ADELT handle situations where different versions of deep learning frameworks require different expressions? Can you give more explanations? Such as, \nfor the old version of Python:\nx = torch.autograd.Variable(torch.Tensor([1.0]), requires_grad=True)\nfor a newer version:\nx = torch.tensor([1.0], requires_grad=True)\n\n2. In the METHOD section, the authors mention that they \"convert each API call into its canonical form\". How exactly is this achieved? Can you provide a detailed explanation, or are there existing open-source tools for this purpose?\n\n3. I don't quite understand what ${e_i^{(1)}}\\_{i=1}^{m^{(1)}}$ and ${e_j^{(2)}}_{j=1}^{m^{(2)}}$ mean in the last paragraph of Section 2.3.\n\n4. Instead of an end-to-end model, ADELT is actually a pipeline solution, consisting of multiple components, such as \"Canonicalizion\" \"Extract API calls\" \"Code to Skeleton\" and \"Dictionary Lookup\" and so on, right? Have the authors tested the accuracy of each component? They will ultimately impact the overall quality of the code skeleton transpilation."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission7810/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698811557356,
        "cdate": 1698811557356,
        "tmdate": 1699636955766,
        "mdate": 1699636955766,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "r7AelBEPc2",
        "forum": "FH7lfTfjcm",
        "replyto": "FH7lfTfjcm",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission7810/Reviewer_MAQg"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission7810/Reviewer_MAQg"
        ],
        "content": {
            "summary": {
                "value": "The paper introduces Adversarial DEep Learning Transpiler (ADELT) for source-to-source transpilation between deep learning frameworks. It accomplishes this by transpiling the code's skeleton using a pretrained language model and mapping keywords through a keyword translation dictionary generated by domain-adversarial training process. The author also built an evaluation benchmark for PyTorch-Keras and PyTorch-MXNet transpilation."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "Strengths:\n\n1. The method proposed in this article seems to be effective. ADELT uniquely decouples the code skeleton transpilation and API keyword mapping, which allows for greater flexibility and adaptability in the transpilation process.\n\n2. The authors establish a small evaluation dataset. The paper conducts comprehensive ablation studies."
            },
            "weaknesses": {
                "value": "1. The description in the Method section is somewhat challenging to understand. For instance, the example in Figure 1 is too simple, and it's not clear how the complete actions of step 2 and step 3 are reflected. Additionally, based on the description, it seems like steps 3, 4, and 5 are executed sequentially. However, in Figure 1, it appears that step 4 is executed in parallel with the steps 3,5, which is somewhat perplexing.\n\n2. The size of the evaluation dataset is somewhat small, with only 50 samples, making it challenging to ensure the reliability of the experiments and comparisons. \n\n3. Some details of the comparisons were not clearly explained, such as what prompts were used for GPT-4, as the choice of prompts can significantly impact the model's performance.\n\n4. If I did not overlook, the article only provides an account of the construction process for the PyTorch-Keras benchmark in Appendix A.4, but, it does not cover the construction process for the PyTorch-MXNet benchmark.\n\n5. The execution efficiency also needs some comparisons, such as runtime, as the speed of a pipeline is typically expected to be slower than a single end-to-end model. However, the paper does not quantify the magnitude of this difference."
            },
            "questions": {
                "value": "In section 2.4, what do you mean by \u201cIn dictionary generation, we do not allow callable names to be translated to callable names\u201d? Can you provide a detailed explanation or an example to explain it?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission7810/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698822104287,
        "cdate": 1698822104287,
        "tmdate": 1699636955646,
        "mdate": 1699636955646,
        "license": "CC BY 4.0",
        "version": 2
    }
]