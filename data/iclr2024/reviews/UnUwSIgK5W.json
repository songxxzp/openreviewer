[
    {
        "id": "vWIaR1xatK",
        "forum": "UnUwSIgK5W",
        "replyto": "UnUwSIgK5W",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission488/Reviewer_FnZW"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission488/Reviewer_FnZW"
        ],
        "content": {
            "summary": {
                "value": "This paper presents a novel approach called \"Code Evol-Instruct\", which adapts the \"Evol-Instruct\" method to the domain of code, enhancing the performance of open-source Code LLMs.The authors use Code Evol-Instruct to evolve basic code instruction data and then fine-tune existing open-source Code LLMs, resulting in the creation of \"WizardCoder\" models to improve the ability of these models to generate high-quality code based on more complex instructions. The WizardCoder outperforms other open-source models and even rivals larger closed-source LLMs in certain coding tasks."
            },
            "soundness": {
                "value": "4 excellent"
            },
            "presentation": {
                "value": "4 excellent"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "1. Introduction of Code Evol-Instruct, an innovative method for enhancing open-source Code LLMs, which significantly improves their performance in code generation tasks.\n2. Even the smaller 15B version of WizardCoder outperforms larger closed-source LLMs like Claude and Bard on certain benchmarks, while the 34B version achieves performance comparable to GPT-3.5 (ChatGPT) and surpasses it on specific benchmarks."
            },
            "weaknesses": {
                "value": "1. In section 4.3, Table 1, Result of pass@1(%) on HumanEval and MBPP, the result of pass@1(%) on MBPP is not as good as the result on HumanEval. HumanEval only tests a narrow distribution and can be overfitted. The benchmark needs to be upgraded."
            },
            "questions": {
                "value": "1. In section 3.2, TRAINING WizardCoder,\" We iteratively employ the Code Evol-Instruct technique on this dataset consisting of around 20k samples to produce evolved data.\"  What is the number of iterations and the criteria for completion?\n2. In section 3, when iterating the Code Eval-Instruct on the sample dataset, what model is used to generate evolved data? Does the difference in the quality of pre-trained model outputs lead to different results?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission488/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission488/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission488/Reviewer_FnZW"
                ]
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission488/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698802933133,
        "cdate": 1698802933133,
        "tmdate": 1699635975477,
        "mdate": 1699635975477,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "unsL3ugxtv",
        "forum": "UnUwSIgK5W",
        "replyto": "UnUwSIgK5W",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission488/Reviewer_QRie"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission488/Reviewer_QRie"
        ],
        "content": {
            "summary": {
                "value": "The paper extends the idea of instruction fine-tuning to code LLMs. The proposed approach uses GPT-3.5 to evolve existing instruction data to generate complex and diverse set of examples in an iterative manner. Using the synthetic evolving data followed by instructions, the authors fine-tune SOTA coda LLMs. The results show improved performance of the models for a wide range of tasks."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "$\\mathtt{+}$ I think overall exploring ideas around how we can improve the efficacy of LLMs for different application is interesting.\n\n$\\mathtt{+}$ Improving SOTA using the proposed instruction-tuning method is valuable and opens up new direction. The ablation studies further help to expand how and to what extend each technique helps (with some caveats that I will expand in the question section)."
            },
            "weaknesses": {
                "value": "$\\mathtt{-}$ It is not clear how the authors came up with the list of heuristics for data evolution. This unclarity makes such approaches less applicable to wide range of tasks.\n\n$\\mathtt{-}$ While the ablation studies in the main body provides some insights on the efficacy of the technique (additional clarification in the questions/recommendation section).\n\n$\\mathtt{-}$ While the idea is interesting, but it seems very incremental compared to prior work and the contributions are limited."
            },
            "questions": {
                "value": "(Q1) Table 4, the Pass@1 score decreases as the number of iterations increases. Do you have any insights as why this is happening? \n\n(Q2) How the performance of your model increases as you use less capable models for generating evolving data? In addition, do you think we can use the same model to generate the data for next iteration? \n\n(Q3) Can you clarify how did you come up with the heuristics? Did you eliminate any of them based on the final outcome? Was the process a trial-error approach or there were some insights behind making any of the decisions?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission488/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698932039051,
        "cdate": 1698932039051,
        "tmdate": 1699635975395,
        "mdate": 1699635975395,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "rIGktcwlx8",
        "forum": "UnUwSIgK5W",
        "replyto": "UnUwSIgK5W",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission488/Reviewer_fiHu"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission488/Reviewer_fiHu"
        ],
        "content": {
            "summary": {
                "value": "The paper proposed a new way, Code Evol-Instruct, to fine-tune an LLM for coding tasks. The method starts from a set of existing code questions, then uses another LLM (GPT 3.5, in this case) to add one more step of complexity or difference to make a new question. Detailed prompts for evol-instruct are provided in the paper. 4 rounds of evol-instruct expanded the original 20k Code Alpaca instruction set to 87k. The WizardCoder model fine-tuned with this set ranked only behind GPT-4 in HumanEval and other popular coding benchmarks, beating other major open and closed-sourced models.\n\nThe paper also analyzes the effectiveness of the evol-instruct set from different rounds of expansion. The results show that generally more data leads to better performance (except with the addition of round 4), the same amount of tokens from more complex instructions works better, and the data expansion didn't create more similar data to the test set."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "- The method works. It produced a top-performing open source code model that surpasses bigger and closed-source models in multiple open evaluations. This is the biggest strength of the paper and the value to the research community.\n\n- Paper provided extensive comparison with existing models and between different rounds of evol-instruct expansions."
            },
            "weaknesses": {
                "value": "- Missing some key details. Where does the new coding solution come after expanding the instruction? Did we use the base model itself, or GPT-3 to generate them? Did we do any deduplication of the expanded instructions? Did we verify the quality of new instructions by executing the code generated?\n\nUpdate: based on the author's feedback, the coding solutions in the training data are from GPT-3.5-turbo. This presents a risk of data leakage, that WizardCoder becomes an implicitly distilled model of GPT-3.5-turbo on a specific capability.\n\n- Weak analysis. Why does round 4 have a negative impact on the quality? The paper mentioned \"some evolution process will fail\" but provided no detail. Other analysis related questions will be in the \"questions\" section.\n\n- Writing quality can be improved. The paper uses more sentences to repeatedly claim WizardCoder's performance (which is indeed impressive) but vague on implementation details and analysis.\n\n- Inconsistency in the data. Figure 2 reported GPT-4 has a HumanEval pass@1 of 88.4, while Table 1 showed 67.0."
            },
            "questions": {
                "value": "- Where does the new coding solution come after expanding the instruction?  Did we use the base model itself, or GPT-3 to generate them?\n\n- Did we do any deduplication of the expanded instructions?\n\n- Did we verify the quality of new instructions by executing the code generated?\n\n- Figure 1 lower plot. It's better to use pattern instead of color to separate two data classes to make it more friendly for color-blindness.\n\n- Section 1 paragraph 2. Reviewer thinks \"Code\" need not to have capitalized first letter.\n\n- Section 2 Related Work. We should also mention CodeLlama's self-instruct work and compare the differences. https://arxiv.org/abs/2308.12950\n\n- Page 4, Code Evolution Heuristic Methods table. Please explain the 4th instruct's purpose and examples of expansion. \"Provide a piece of erroneous code as a reference to increase misdirection\". It's not clear to the Reviewer what this is doing and why it would be effective.\n\n- Page 4, Code Evolution Heuristic Methods table. Last prompt about increasing time/space complexity: how can we verify the response actually achieved it?\n\n- Section 5 paragraph 1, \"amalgamate the training set\", what about using a simpler word like  \"merge the training set\"? \n\n- Section 5 paragraph 2. The Reviewer assumes more rounds equals more complexity. But it's better to make it explicit and provide some examples to show what does complexity actually mean in this context..\n\n- Section 5 \"Complexity and Similarity\". This paragraph didn't really talk about complexity, unless more rounds = more complexity?\n\n- Table 4. It's better to show the confidence interval on this table, if possible, since 400 examples is not that large a test set.\n\n- Section 6: conclusion. \".. the pivotal role of instruction complexity in enhancing coding performance\". Reviewer doesn't think this claim holds well given the analysis in the paper. For example, in Table 4, later rounds (assuming more complexity) lead to a lower performance (or statistically insignificant changes)."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission488/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission488/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission488/Reviewer_fiHu"
                ]
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission488/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699070807149,
        "cdate": 1699070807149,
        "tmdate": 1700677106316,
        "mdate": 1700677106316,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "fCVAuyazDV",
        "forum": "UnUwSIgK5W",
        "replyto": "UnUwSIgK5W",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission488/Reviewer_6CYQ"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission488/Reviewer_6CYQ"
        ],
        "content": {
            "summary": {
                "value": "WizardCoder proposes an instruction fine-tuning method for code - Code Evol-Instruct where a large synthetic dataset is created using a seed set of code tasks (Code Alpaca) which are evolved by GPT-3.5 to increase their difficulty and complexity in multiple rounds. When fine-tuned using this dataset, publicly available models like CodeLlama and StarCoder are shown to outperform all other open sourced alternatives, and are comparable to some of the closed source ones on many different benchmarks on code generation like HumanEval, MBPP and DS-1000."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "- Clever instruction finetuning idea on creating datasets synthetically using gpt-3.5 and a small set of seed tasks\n- Exhaustively tested on different programming languages, impressive performance gains using publicly available models (StarCoder and CodeLlama-34B) across several benchmarks. -HumanEval+, MBPP, MultPL-E, and DS-1000"
            },
            "weaknesses": {
                "value": "- While results on code benchmarks are impressive, novelty of the scientific methodology itself is quite limited as it is an adaptation of Evol-Instruct for Code.\n- Missing human assessment - It is not clear how useful the final fine-tuned model is outside the benchmarks that focus exclusively on functional correctness. Model hasn't been tested on developer productivity tasks like completion, code refinement.\n- Not clear if data leakage has been prevented. Does the evolved data or seed data overlap with HumanEval or other benchmarks' test set?\n- The paper assumes the reader to be familiar with Evol Instruct, and does not provide sufficient context to follow the method."
            },
            "questions": {
                "value": "- Figure 3: Why are results from evol round 0 + 1 + 2 + 3 + 4 worse than 0 + 1 + 2 + 3? Do returns from EvolInstruct start to diminish or turn negative after a certain number of rounds? This is not discussed or explored in this paper.\n\n- Analysis - Complexity and Quantity: This section is not clear to me. What are the results shown in Table 4? How does Table 4 make one conclude that the gains are not due to increase in samples or tokens? Are the 4 rows in Table 4 pass@1 metric for model checkpoints when sequentially trained on each round?\n\n- How dependent is the performance of Evol-Instruct on the evolving model? Will the performance substantially improve if we use GPT-4 to generate evolved rounds? Will it worsen if the evolving model is changed to other open sourced alternatives?\n\n- Section 3.1: We optimised the evolutionary instructions by eliminating deepening and complicating inputs, as well as In-Breadth Evolution. What does this mean? Not clear how 1 and 2 are different, can you describe precisely with an example?\n\n- Can you provide details of the compute infrastructure involved and hyperparameters in fine-tuning? (number of GPU hours, batch-size, sequence length) and other details)\n\n- The abstract (and some places in the paper) comment on model sizes of Claude and Bard as 'largest closed-source LLMs', this is not verifiable, so I suggest the authors re-word this without commenting on their model size and avoid other such colloquial writing present in the paper to improve its soundness.\n\nTypos:\n- Intro Para 3: several key adaptions --> adaptations"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission488/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission488/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission488/Reviewer_6CYQ"
                ]
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission488/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699498580881,
        "cdate": 1699498580881,
        "tmdate": 1699635975200,
        "mdate": 1699635975200,
        "license": "CC BY 4.0",
        "version": 2
    }
]