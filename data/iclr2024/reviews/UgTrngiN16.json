[
    {
        "id": "dkjpDR1zmo",
        "forum": "UgTrngiN16",
        "replyto": "UgTrngiN16",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission3579/Reviewer_ayZc"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission3579/Reviewer_ayZc"
        ],
        "content": {
            "summary": {
                "value": "This paper proposes to adopt LLM to generate codes for the planning part of the autonomous driving. The planning code could be updated according to certain scores (IL/Dagger/RL) with prompts feeding into LLM."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "1. The idea of generate planning code by LLM is interesting."
            },
            "weaknesses": {
                "value": "1. After complex training pipelines (online IL + RL), the generated code's performance is still far from hand-crafted rules which has only hundreds of lines (55 vs 76 in longest6). It casts doubts on the effectiveness of the proposed method.\n\n2. The motivation is unclear to me. The authors assume that the perception problem is solved since they feed ground-truth information about the scene to LLM.  The experiments is conducted in a further simplified environment only including ego states, other agents' states, traffic lights, and stop signs. However, in the actual driving scenario, there could lots of complex obstacles or information should be noticed in the driving scene, which might not be easy to describe precisely in language. (It is note worthy that 3D occupancy and open-set scene understanding are hot topics discussed in the community). Thus, I am not sure this framework is particularly useful for the actual usage of the planning process.\n\n3. Novelty. The authors claim that *we are the first to completely translate and apply the training paradigm used in machine learning for iterative code generation.* However, as mentioned by the authors, works like Auto-GPT and MineDojo VOYAGER also have similar paradigms. My research focus is on autonomous driving and I am not an expert in LLM.  Thus, I am not sure whether it is an overclaim. I hope the author could explain that how your paradigm differs significantly from existing LLM Agent works instead of an implementation in the autonomous driving field.\n\nIn summary, while I appreciate the authors' engineering efforts, I do not think it is particularly useful for the actual usage of autonomous driving. Besides, the model's performance is actually limited (< hundreds of lines of hand-crafted code). Thus, I give a Reject. However, the authors are encouraged to explain the novelty and contribution of LangProp in the LLM+Code area (beyond autonomous driving) based on your claim *we are the first to completely translate and apply the training paradigm used in machine learning for iterative code generation*. I might change my score accordingly."
            },
            "questions": {
                "value": "See weakness part.\n\nFor Table 1 - LangProp: Offline IL, it seems that the agent almost did not move at all (R~=0). I am wondering what code scripts cause that and why?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "3: reject, not good enough"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission3579/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1697542354711,
        "cdate": 1697542354711,
        "tmdate": 1699636313132,
        "mdate": 1699636313132,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "DIL3k2EqV9",
        "forum": "UgTrngiN16",
        "replyto": "UgTrngiN16",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission3579/Reviewer_woM2"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission3579/Reviewer_woM2"
        ],
        "content": {
            "summary": {
                "value": "In this paper, the authors propose a code generated framework leveraged by LLMs, named LangProp. This framework can generate interpretable and transparent code that can be verified and improved in a metric- and data-driven way. The authors demonstrate the first proof of concept of automated code optimization for autonomous driving in CARLA."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "1.\tThe research topic is innovative and carries significant relevance.\n2.\tThe proposed LangProp is a code generation methodology that leverages the power of LLM to generate syntactically and logically compliant code.\n3.\tThe proposed LangProp demonstrates the first proof of automated code optimization in the field of autonomous driving, generating interpretable and transparent driving strategies that can cope with some complex scenarios in CARLA."
            },
            "weaknesses": {
                "value": "1.\tThe framework's capacity to deliver driving strategies that are both interpretable and transparent raises concerns.\n2.\tThe framework depends on the quality and coverage of LLM, which limits the effect and performance of LangProp. If LLM fails to generate sensible initial code, or struggles with some syntactic or logical issues, then LangProp is also hard to optimize. Existing LLMs may face some generation challenges or high uncertainty. \n3.\tFurther analysis and in-depth exploration of the suitability of LLM in the context of autonomous driving is essential."
            },
            "questions": {
                "value": "My main concerns and questions lie in the weaknesses. The author should discuss them in detail."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission3579/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698656019665,
        "cdate": 1698656019665,
        "tmdate": 1699636313046,
        "mdate": 1699636313046,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "Dt2joLY1R4",
        "forum": "UgTrngiN16",
        "replyto": "UgTrngiN16",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission3579/Reviewer_cL61"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission3579/Reviewer_cL61"
        ],
        "content": {
            "summary": {
                "value": "The paper proposed a framework, LangProp, to produce good performing codes by iteratively refining them by an LLM with execution feedback. LangProp works as a classic machine learning training process conceptually, however, the model under training is a piece of code, the reward / feedback is the execution result of the code, and the optimizer is an LLM that modifies the code based on the reward and feedback. A number of machine learning techniques can be applied to this learning process as well, such as online/offline learning, DAgger and RL.\n\nTo demonstrate the viability and performance, the paper applied LangProp to an self-driving cars problem, where the model to be optimized is a python program that drives a car (in simulated environment, CARLA). Experiments showed that the training process converges and LangProp can produce a reasonably good program that drives the car. The paper also compared the performances of different ML \"meta\"-techniques (DAgger/RL); online DAgger/RL has the best performance.\n\nThe authors will open source the data and source code of LangProp."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "4 excellent"
            },
            "strengths": {
                "value": "- Novelty. This is an innovative use of LLM in iterative code refinement. There is previous work on how LLM can help with debugging and code refinement, but the Reviewer has not seen the use of LLM as an optimizer in a meta learning setup. (It's totally possible that Reviewer missed some previous work)\n\n- Effectiveness. Experiments showed that the meta-learning process actually works and the training will converge. This is a good signal."
            },
            "weaknesses": {
                "value": "- Lack of variety in experiments. To claim that LangProp is a viable meta-learning framework, we need some more examples than driving. The driving problem in the paper is more like estimating a driving function (\"our expert\") by a piece of python code. It's practical and useful, but also special. The Reviewer loves to see a few more different applications, especially if the optimization phase (code refinement) will always converge.\n\n- No examples of the resulting code (policy). One of the claimed advantages is that a learned piece of code is more understandable than deep model weights. However in this optimization, it's possible that the code ends up being unfriendly to human. It will be very helpful to show some examples of good and bad performing policies in the paper.\n\n- High cost. The training process will resulted in many calls to an LLM which could be costly. It will be helpful if the paper can offer a performance/cost curve to help decide the practicality for certain tasks.\n\nNote: Reviewer hesitates to accept the paper as-is (with only writing improvements), unless convincing examples of learned policy are available. One or more applications would be a huge plus.\n\nUpdate after rebuttal: Reviewer saw the example policy in the github project, they are indeed understandable by human. I see the points other rejecting reviewers made, but will still maintain the accept suggestion mostly based on the new way of doing things, not on the cost/effectiveness/performance of the resulted policy."
            },
            "questions": {
                "value": "- Section 1 paragraph 2. The second sentence is super long, consider break it down for easy reading.\n\n- Section 3.1.5 Paragraph 1. \"For each of these policies, the tracker is queried...\" what is the tracker? Better explain to reduce reader's mental workload.\n\n- Reviewer suggests removing \"applied to driving\" from the title since this is about ML, not driving."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission3579/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission3579/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission3579/Reviewer_cL61"
                ]
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission3579/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698787564005,
        "cdate": 1698787564005,
        "tmdate": 1700632619016,
        "mdate": 1700632619016,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "v43XU3aifm",
        "forum": "UgTrngiN16",
        "replyto": "UgTrngiN16",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission3579/Reviewer_ZuhC"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission3579/Reviewer_ZuhC"
        ],
        "content": {
            "summary": {
                "value": "This paper proposes a framework that uses LLMs for data-driven code optimization and demonstrated its capability in generating driving policies in CARLA. It allows for training with different paradigms and objective functions, leading to more interpretability and transparency in machine learning. \n\nFeatured contributions:\n\n* The LangProp framework utilizes LLMs for code optimization in generating driving policies.\n* It supports various training paradigms and objective functions for improved interpretability.\n* Training with LangProp provides more transparent machine learning and opens up new possibilities."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "4 excellent"
            },
            "contribution": {
                "value": "4 excellent"
            },
            "strengths": {
                "value": "1. The overall idea and story are innovative, proposing a set of methods that allow LLM to generate code iteratively, and can utilize existing objectives for supervision, demonstrating effectiveness in the task of driving. Also, the idea of comparing LLM to an optimizer is something I find very interesting. The discovery of causal confusion in the offline imitation experiments is also very interesting, which reflects the interpretability of this method.\n2. It can have a certain influence; this framework can provide more ideas and options for subsequent researchers, for example, in the directions of LLM, symbolic systems, and embodied AI.\n3. The overall quality is good, with fluent writing, detailed elaboration, and the core code has been open-sourced. I believe it has a high degree of credibility."
            },
            "weaknesses": {
                "value": "1. The paper has some overclaims, and the experimental part is not sufficient enough. It states that this is a universal framework, but why are experiments only conducted in the CARLA simulator for autonomous driving scenarios? If experimental results could be obtained in other more complex and diverse environments, such as Minecraft or tasks related to robotics, it would greatly enhance the credibility of the paper.\n2. You have only showcased the LLM's capability for code optimization, which is constrained by the LLM's window size. This means that inference is limited to simple-logic functions, which are far from sufficient for the more complex interactive tasks and long-tail problems in autonomous driving. Though achieving high score in CARLA, it is way far from reality. How can we extend the code generation task to be more complex and diverse? For example, similar to VISPROG[1], to complete more complex tasks through the combination of models. I would like to hear your thoughts on this matter.\n3. I am quite confused with Figure 3: \n *  how is the training score calculated for Offline IL? Do you use L1/L2 for IL while using the training objected as you mentioned in Appendix C.2 for hybrid-RL? In that case they are in difference scales. If so, how do you ensure that the objectives for IL and RL are comparable, since the scales of the objectives are completely different?  Additionally, why are they distributed in the range of [-1, 1]? Did you normalize the objectives?\n * Furthermore, I suggest adding another graph showing the close-loop score versus the number of steps. This would allow for a comparison of scores across all methods and clearly show how the final close-loop score (most important) changes as the number of steps increases. Though it could be time-consuming but very sparse sampled point would be helpful, just like validation per epoch.\n\n[1] Gupta, Tanmay, and Aniruddha Kembhavi. \"Visual programming: Compositional visual reasoning without training.\" Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition. 2023."
            },
            "questions": {
                "value": "Please refer to the weakness part."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "details_of_ethics_concerns": {
                "value": "No ethics review needed."
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission3579/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission3579/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission3579/Reviewer_ZuhC"
                ]
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission3579/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698792046433,
        "cdate": 1698792046433,
        "tmdate": 1699636312824,
        "mdate": 1699636312824,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "btRrZCUOlc",
        "forum": "UgTrngiN16",
        "replyto": "UgTrngiN16",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission3579/Reviewer_maNz"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission3579/Reviewer_maNz"
        ],
        "content": {
            "summary": {
                "value": "The paper introduces LangProp, a framework designed for the iterative optimization of code generated by large language models (LLMs) within supervised and reinforcement learning settings. LangProp addresses the suboptimal nature of zero-shot code solutions produced by LLMs, particularly their tendency to fail in edge cases. The framework enhances code by automatically evaluating its performance against a dataset of input-output pairs, identifying exceptions, and using this feedback to guide the LLM towards generating improved code iterations.\n\nSpecifically, the LangProp model consists of a setup prompt, an update prompt, and a collection of executable code generated by LLM. Given any metric of success defined by data-driven way, LangProp uses LLM to optimize policies to improve performance, with updates generated by an evolutionary algorithm. The model keeps a bunch of policies which are used for selection of the best inference model. A forward-pass is referred to as getting predictions from all policies from the inputs, and scores or exceptions are collected as feedback to LLM to improve the policies' code. \n\nIn its experiments, the paper underscores LangProp's effectiveness in producing driving policies within the CARLA simulation environment, illustrating that traditional training paradigms like imitation learning, DAgger, and reinforcement learning are compatible with LangProp. The framework's approach to code optimization, treating policy code as model parameters and using LLMs as code optimizers, brings forth a new way to guide policy selection based on performance metrics. The authors posit that LangProp fosters a new way for data-driven machine learning that offers enhanced interpretability and transparency\u200b."
            },
            "soundness": {
                "value": "2 fair"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "The work proposes a framework to perform code optimization based on data-driven feedback from LLM. It provides an example of applying this code optimization to the setting of autonomous driving. The results look better than baselines. The idea of using LLM to optimize the code and the implementation to apply it on imitation learning and/or reinforcement learning is interesting. \n\nAfter the rebuttal, I upgrade my rating since the authors helped to clarify some of the unclear parts of the paper."
            },
            "weaknesses": {
                "value": "While the idea of using LLM to optimize code based on data-driven scores feedback is interesting, it is hard to find evidence why this is more interpretable or reliable than training with imitation learning or reinforcement learning for self-driving. LLM is still suffering from the problems of hallucinations and its output can be very stochastic and there is no existing proof that LLM can automatically solve any coding bugs. The authors only provide examples of how to use LLM to optimize a function that calculates the factorial of an integer input, but did not provide real examples of how LLM is used to optimize a code that is used for self-driving car. \n\nThis is more like a work that uses LLM to automate the process of writing imitation learning/reinforcement learning code, rather than inventing a novel way to obtain a policy for self-driving. The problems that imitation learning/reinforcement learning have will not go away using this kind of training, such as lack of interpretability, and the lack of ability of solve edge and long-tailed cases. \n\nThere is not enough detail on how the authors cope with cases where LLM could not solve bugs in the code, nor enough detail on what is the final planning policy look like for the driving task. Also it looks like the author assumed privileged access to ground truth bounding boxes, positions etc. information from the simulator, while in the real world this is always going to be some noise in these observations. It is not clear how in that case, the policies can be robust."
            },
            "questions": {
                "value": "Could you provide a concrete example code that LLM optimizes in the end that is able to drive in the CARLA environment? Is it a neural network or a rule-based code? If it is a rule-based code, how can you guarantee it will always work in any situations, or how to ensure it can generalize? \n\nThe authors claimed this is more interpretable, but as far as I can see, it is not clear how this is achieved due to the lack of examples of the final policies optimized by LLM."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission3579/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission3579/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission3579/Reviewer_maNz"
                ]
            }
        },
        "number": 5,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission3579/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698989022976,
        "cdate": 1698989022976,
        "tmdate": 1700699478040,
        "mdate": 1700699478040,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "mQMDXyfdVa",
        "forum": "UgTrngiN16",
        "replyto": "UgTrngiN16",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission3579/Reviewer_JXcz"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission3579/Reviewer_JXcz"
        ],
        "content": {
            "summary": {
                "value": "LangProp is a framework that utilizes Large Language Models (LLMs) to iteratively generate and optimize symbolic scripts, drawing a parallel to the way neural networks are trained. This approach combines the interpretability of Symbolic AI with the self-improving capabilities of machine learning, aiming to produce transparent systems that can improve over time through data-driven feedback. By treating code generated by LLMs as modifiable parameters, LangProp optimizes these scripts based on performance feedback, akin to traditional model training. The framework has been tested in the context of autonomous driving, demonstrating the potential to create interpretable, language-instructable systems that enhance performance with more data. LangProp's adaptability suggests it could extend beyond specific applications like Minecraft (where similar concepts have been explored) to a wide range of domains where model transparency is essential."
            },
            "soundness": {
                "value": "1 poor"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "* proposal of a framework capable of automatically optimizing code generated by large language models. \n* employs methods of supervised and reinforcement learning to autonomously evaluate the code's performance on input-output datasets and feedback the results to the language model, allowing for iterative improvement of the generated code. \n* provides an example demonstrating how to use this framework to generate driving strategies for autonomous vehicles."
            },
            "weaknesses": {
                "value": "* it requires a substantial amount of training data to train the language model and optimize the generated code. \n* since the framework uses methods of supervised and reinforcement learning, there may be issues with overfitting or undertraining during the training process. \n* the framework requires proper normalization and standardization of inputs and outputs; otherwise, it may result in degraded performance of the generated code."
            },
            "questions": {
                "value": "1. How does the LangProp framework's evolutionary algorithm-based updating process compare in efficiency and effectiveness with the gradient-based optimization used in traditional neural network training?\n2. How does the diversity of initial policies generated by the LLM affect the convergence and performance of the LangProp model in various stages of training?\n3. Is the LangProp framework's priority and reranking mechanism going to be redundant when the training iteration increased?\n4. How do different prompt template strategies affect the LangProp framework\u2019s ability to generate and refine code?\n5. Is there going to be a limit one generating correct code since the model parameters are not trained during the process?\n6. What are the potential risks and challenges associated with the use of evolutionary algorithms for code optimization in safety-critical applications such as autonomous driving?\n7. How does the framework address the issue of interpretability of the generated code?\n8. What are the potential applications of the LangProp framework beyond autonomous driving, and how does it generalize to other domains and programming languages?\n9. How can we quantify the trustworthiness in the generated code? Are there any ways to quantify subjectivity in driving behaviors while getting / obtaining a measure of trust in the outcome or end result of LangProp. I think the startegy in Figure 2 can gain inspiration from a trustworthiness framework developed for deep reinforcement learning in autonomous driving and CNNs:  \"A general trust framework for multi-agent systems.\" In Proceedings of the 20th International Conference on Autonomous Agents and MultiAgent Systems, pp. 332-340. 2021 \"Trustworthiness Evaluation and Trust-Aware Design of CNN Architectures.\" In Conference on Lifelong Learning Agents, pp. 1086-1102. PMLR, 2022 A major issue with the proposed framework is that it does not have any way of verifying and validating the safety or trustworthiness which are critical for autonomous driving.\n10. How does the quality of the dataset influences the performance of the LangProp because this can depend on what driving scnearios are considered?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "details_of_ethics_concerns": {
                "value": "none"
            },
            "rating": {
                "value": "1: strong reject"
            },
            "confidence": {
                "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 6,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission3579/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699110765647,
        "cdate": 1699110765647,
        "tmdate": 1699636312624,
        "mdate": 1699636312624,
        "license": "CC BY 4.0",
        "version": 2
    }
]