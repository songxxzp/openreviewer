[
    {
        "id": "DlPuDAz6J1",
        "forum": "y0GJXRungR",
        "replyto": "y0GJXRungR",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission3865/Reviewer_LPE6"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission3865/Reviewer_LPE6"
        ],
        "content": {
            "summary": {
                "value": "The authors break the problem of program repair into four steps:\n\n1. (LLM) Generate an initial population of programs.\n2. Run the programs to obtain error messages.\n3. (LLM) Analyze the errors, and generate feedback as to the cause of failure.\n4. (LLM) Given the feedback, generate a repaired program.\n\nThis paper differs from prior work in part because it emphasizes the importance of step (3) -- using feedback to direct the repair.  The authors run a number of experiments with different models, explore what happens when a stronger model provides feedback to a weaker one, and also explore what happens when humans provide feedback to a model.\n\nThe authors also explicitly model the cost of repair.  Is running steps (3) and (4) more effective than simply drawing more samples from the initial population?  The answer turns out to be \"not really\".  \n\nThe experiments are well-designed and the authors make several interesting observations.  To paraphrase:\n\nA.  LLMs are currently quite bad at program repair.  The best way to get a correct program is to generate a large and diverse initial population, in the hopes that one of the initial programs is \"close enough\" to work with minimal tweaks.  Even a single repair step yields at best marginal improvements.  LLMs are thus very different from human programmers; they seem to be unable to iteratively refine and debug programs over multiple steps.  \n\nB.  The main limitation is the quality of feedback.  Given feedback from a stronger model, or from a human, LLMs show substantial gains from repair.  However, LLMs seem to have difficulty finding problems in the code that they generate."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "4 excellent"
            },
            "strengths": {
                "value": "The paper is well-written, and the authors formulation of the problem is insightful.  In particular, they do not merely test the accuracy of program repair in isolation, they compare it against the alternative, which is generating new initial programs from scratch.  \n\nThe experiments seem to be well done, particularly the ones which use a stronger model or human to provide feedback to a weaker model."
            },
            "weaknesses": {
                "value": "The authors do not attempt to fine-tune a model on the task of program repair.  Thus their experiments mainly demonstrate that LLMs, *as currently trained*, do not do a good job at the repair task.\n\nTo be fair, fine-tuning is probably out of scope for this paper, especially since some of they models they test are private, and accessible only via an API."
            },
            "questions": {
                "value": "Your illustration of the repair-tree is interesting, and it brings to mind the idea of extending this evaluation technique to a proper tree search.  You might be able to get better results by using a value network, and focusing only on the nodes of the tree that are most promising for repair, in a manner reminiscent of evolutionary search, with the LLM as mutator. \n\nSuccessful repair attempts, preferably after several iterations of feedback and repair, could also be used to fine-tune the LLM to generate better feedback, and to generate better repair code given the feedback.  (See weaknesses, above.)\n\nHave you considered any experiments along these lines?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission3865/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission3865/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission3865/Reviewer_LPE6"
                ]
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission3865/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698791784927,
        "cdate": 1698791784927,
        "tmdate": 1699636344883,
        "mdate": 1699636344883,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "ooxGpLOiZc",
        "forum": "y0GJXRungR",
        "replyto": "y0GJXRungR",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission3865/Reviewer_PNGf"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission3865/Reviewer_PNGf"
        ],
        "content": {
            "summary": {
                "value": "This paper investigates the ability of large language models (specifically, Code Llama, GPT-3.5, and GPT-4) to perform self-repair which refers to the model's capacity to identify and correct mistakes in its own generated code. The paper analyzes the effectiveness of self-repair in addressing code generation errors, specifically on problems sourced from HumanEval or APPS datasets. The findings suggest that the gains achieved through self-repair are often modest and vary significantly across different subsets of data. In some cases, self-repair does not result in noticeable improvements. The paper proposes that this limitation might be due to the model's ability to provide feedback on its own code, and stronger models might enhance self-repair effectiveness. Additionally, the paper explores the impact of providing the model with feedback from human participants, showing that this feedback significantly benefits the self-repair process, even for the advanced GPT-4 model. The paper offers a brief qualitative analysis to shed light on why this human feedback is valuable in improving code repair performance. Overall, the study provides insights into the challenges and potential enhancements of self-repair mechanisms in large language models for code generation tasks."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "__The paper systematically analyzes the self-repair capability of LLMs.__\n\nWhile existing works of self-repair mostly argue that self-repair is feasible for LLM, this paper is the first work to systematically study the strengths and weaknesses of self-repair. Specifically, I appreciate the systematic comparison between self-repair and the pass@k performance, though the conclusion might not be generalizable (see Weaknesses), showing that when the computation is comparable, their benefits are also similar, and also suggesting the optimal combination of these two techniques is the most effective. Also, studying the quality of feedback is also a novel perspective to analyze the self-repair capability of LLM\n\n__The paper sheds light on the weaknesses of LLM in self-repair, providing clear takeaways and indicating the potential future work in this direction.__\n\nThe paper is well written and properly organized, and it sheds light on the weaknesses of LLM's self-repair capability. Such weaknesses can be due to the lack of both data and carefully crafted training strategy for self-repair capability, indicating the future research direction of refining the existing LLM with better self-repair capability."
            },
            "weaknesses": {
                "value": "I am overall positive regarding this paper, and I appreciate the systematic study the paper performs to quantify LLM's self-repair capability. However, the conclusions are claimed in a strong and general tone, while the study itself is actually limited in scope for two reasons.\n\n__The scope of the study is limited to solving isolated programming challenges while ignoring real-world development.__\n\nThe study focuses completely on the programming challenges datasets, such as HumanEval and APPs. These datasets have several characteristics that are not realistic in daily development, therefore, though I appreciate the initial conclusions of this paper, these takeaways might not be applicable to a more realistic scenario. \n\nFirst, the samples in the studied datasets are provided with clear and complete problem descriptions, which are not always available in real-world programming practice. One of the main reasons that pass@k works so well in programming challenges is that the expected functionality of the program is fully revealed and clearly explained in the prompt, so the model is able to maximize the diversity within a narrowed semantic space when generating multiple sequences. However, such clearly explained prompts, as natural language, are typically not available during the ongoing development, where the developers start with a very high-level goal and eventually design modules and implement them piece by piece. During this process, the human intent is not always explicitly specified, as docstring or comment, before the code LM is prompted to complete the following code snippets. In these cases, the execution of unit tests provide meaningful feedback to specify and concretize the expected functionalities, which cannot be leveraged by the top-k generation but is valuable guidance for iterative self-repair. Therefore, though I agree with the takeaway that pass@k is comparable to, sometimes better than, self-repair in the programming challenge dataset, such observation might not be realistic for daily development and requires further study.\n\nSecond the samples in the studied datasets are mostly short and self-contained, missing the complicated data and inter-procedural dependencies. Pass@k explores the breath of each token within the sequence without directional guidance, but such breath or search space exponentially increases with the increase of the code length. The program challenges datasets contain samples mostly up to tens of lines of code, significantly underestimating the complexity of real-world software, which includes hundreds or thousands of lines of code within one single file and maintains complicated dependencies. Generating k sequences blindly without feedback may hardly fulfill the expectation due to the large search space, while execution feedback, such as the indication of a missing third-party library, helps the model quickly locate the problematic code and focus on fixing just that part. Therefore, when the complexity of the program increases, it requires further study to understand whether self-repair is equivalent as top-k generation.\n\n__It is not clear whether fine-tuning for self-repair could easily overcome the weaknesses or not.__\n\nThis paper focuses on the LLM's self-repair capability only with prompting, without optimizing the model parameters towards the self-repair capability. It is not clear whether a cheap fine-tuning could quickly enable the model's capability of understanding and leveraging the feedback efficiently. Drawing the conclusion that self-repair is not a silver bullet without trying straightforward fine-tuning might be too strong.\n\nTo conclude, I would encourage the author to consider constraining their conclusions with the study's scope and add a discussion section to mention"
            },
            "questions": {
                "value": "Please explain and address the weaknesses. Otherwise, the paper is well-written and clear."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission3865/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission3865/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission3865/Reviewer_PNGf"
                ]
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission3865/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698892720381,
        "cdate": 1698892720381,
        "tmdate": 1700672830950,
        "mdate": 1700672830950,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "61K4YnL2Hb",
        "forum": "y0GJXRungR",
        "replyto": "y0GJXRungR",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission3865/Reviewer_Vfe4"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission3865/Reviewer_Vfe4"
        ],
        "content": {
            "summary": {
                "value": "This paper investigates the sample efficiency of a self-repair approach for LLM based code-generation tasks. It evaluates performance of this approach on HumanEval and APPS dataset using ColdeLLama-13b-instruct, GPT3.5, and GPT4  and provides several insights based on the results: 1) Sampling without repair can perform equally or better than self-repair in almost all sample budgets; 2) Initial sampling diversity is more critical than the diversity of repair samples; 3) Quality of feedback significantly improves the performance of self-repair."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "* This paper provides several new insights on self-repair for code generation compared to the baseline method of sample generations without self-repair. It shows how sample budget and initial sample diversity could impact the efficiency of code generation. \n* The investigations on self-repair performance improvement only by improving feedback quality could enable more interesting future ideas.\n* Overall, the paper is well-written and easy to read. The authors did a great job in highlighting the key limitations of the analysis."
            },
            "weaknesses": {
                "value": "The experimental results presented in this support the claim around the limitations of self-repair. Interestingly, the findings around overall efficacy compared to baseline somewhat contradicts with the results from Chen et. al. 2023b that shows self-repair could provide significant increase in sample efficiency. Although \u2018self-debuggging\u2019 work from Chen et. al. is mentioned in the related work, I think more comparative analysis would strengthen the claim of this paper. Analysis results from more diverse code generation task including datasets other than python language would also be interesting additions to the analysis."
            },
            "questions": {
                "value": "1. Is there a specific reason to restrict feedback and repair samples to 1 in the analysis of feedback boosting (section 4.2)? \n2. Should we expect similar results using the \u2018self-debugging\u2019 approach that uses few-shot prompts?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission3865/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission3865/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission3865/Reviewer_Vfe4"
                ]
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission3865/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699350944810,
        "cdate": 1699350944810,
        "tmdate": 1700620045954,
        "mdate": 1700620045954,
        "license": "CC BY 4.0",
        "version": 2
    }
]