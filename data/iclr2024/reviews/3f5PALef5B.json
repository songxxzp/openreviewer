[
    {
        "id": "OGRwWfgmEd",
        "forum": "3f5PALef5B",
        "replyto": "3f5PALef5B",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission3246/Reviewer_Nn2P"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission3246/Reviewer_Nn2P"
        ],
        "content": {
            "summary": {
                "value": "The prior work on theorem proving enhanced by LLMs (or, more generally, machine learning) has a problem that only the fixed library of theorems can be assumed. To solve this drawback, the paper proposes LEGO-Prover, which in parallel grows the library of proven theorems for reuse (called skills in the paper) and proves the theorems of interest. LEGO-Prover utilizes LLMs to retrieve skills from the growing library and decompose overall informal theorems into small snippets in a step-by-step style.\n\n== POST-REBUTTAL ==\nI raised my rating from 6 to 8 because the response addressed my major concerns."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "4 excellent"
            },
            "strengths": {
                "value": "- The paper addresses a new problem of how (automation of) theorem proving can be enhanced under a growing library of proven theorems (skills).\n- The paper utilizes LLMs to retrieve skills from a growing library effectively. The problem is that the grown library cannot be accessed during training. The paper addresses the issue by employing LLMs as an oracle telling useful skills in the growing library. Without a very general model like LLMs, the issue would become more challenging to solve.\n- The effectiveness of the proposed method is experimentally shown."
            },
            "weaknesses": {
                "value": "- I am unsure why the paper splits the miniF2F dataset into valid and test datasets, although the proposed method does not need training.\n- The proposed method outperforms the previous approaches significantly on miniF2F-valid, but the difference on miniF2F-test is smaller. The paper does not discuss this point.\n- The paper says, \"Consistent with the (Jiang et al. 2022b; Zhao et al., 2023), each problem undergoes 100 attempts of proving,\" but I cannot find such a setting in the paper of Zhao et al. (2023).\n- Table 1 includes cells that have no number (represented by \"-\"), but there is no explanation nor justification for it.\n- (Minor) The presentation can be improved. The figures in the paper include code fragments, but it is difficult to read and understand them due to the small font size and the lack of explanation. Regarding the latter, for instance, I cannot find, in Figure 1(b), where the retrieved and new skills go to and come from, respectively.\n- (Minor) The text can be improved. The paper seems to have several missing citations and incorrect references (e.g., I think \"Figure 3(b)\" on page 9 should correctly be \"Figure 4\"). Another issue is that the paper cites the author names of the prior work even where it cites the paper, and vice versa (e.g., \"Subgoal-Learning Zhao et al. (2023)\" on page 7 should correctly be \"Subgoal-Learning (Zhao et al. 2023)\")."
            },
            "questions": {
                "value": "- Is miniF2F split just for comparison with the prior works which use miniF2F-valid and miniF2F-test?\n- Is it possible to discuss why the performance of LEGO-Prover on miniF2F-test is not so good as on miniF2F-valid?\n- Where can I find Zhao et al. (2023) employ 100 attempts of proving in their experiment?\n- Why does Table 1 include cells not having numbers? Can they be filled?\n- Figure 3 (a) shows that the difference between LEGO-prover and the version without the growing skill library is stable even when the number of prover attempts changes. Does this mean the use of the growing skill library is effective only in proving of theorems with short proofs? If not, what other reasons can be considered?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission3246/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission3246/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission3246/Reviewer_Nn2P"
                ]
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission3246/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698527825974,
        "cdate": 1698527825974,
        "tmdate": 1700713508611,
        "mdate": 1700713508611,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "HK88nD5HRB",
        "forum": "3f5PALef5B",
        "replyto": "3f5PALef5B",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission3246/Reviewer_SGTy"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission3246/Reviewer_SGTy"
        ],
        "content": {
            "summary": {
                "value": "In this paper the authors present the LEGO-Prover, a theorem-prover which employs a growing library containing verified lemmas as building blocks to increase the capability of the LLMs (ChatGPT) used in theorem proving. \nThe LEGO-Prover enables LLMs to utilize existing results retrieved from the library and to create new results during the theorem-proving process.\nThe proposed approach is also favourably evaluated experimentally.\n\n========================= Update after rebuttal =================================================\nI am happy to raise my score in the light of the new information provided by the authors during the rebuttal phase and the discussion."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "1) The modularity of the approach allows for breaking proofs into intermediate steps and for building proofs bottom-to-top from simpler lemmas to complex theorems.\n\n2) The related work is analysed in depth.\n\n3) The ablation study seems to point to the fact that the skill library actually makes a difference, even though the authors might actually be overselling it, as at test time, this is only about 1%."
            },
            "weaknesses": {
                "value": "1) The paper refers a lot to the figures, but these are not always explained in detail and they are quite complex to understand, with a lot of different components. Figures can be used as a support for the text, but not as a replacement.\n\n2) The comparison with Thor+expert iteration and Draft, sketch, and Prove might not be completely fair, as these make use of GPT-3 instead of ChatGPT. \n\n3) It would be helpful to have the workings of the LEGO-prover presented in some algorithmic way, in order to have an overview of the whole pipeline.\n\n\nMinor: there is a missing cross-ref on p. 8."
            },
            "questions": {
                "value": "The ablation study seems to point to the usefulness of the skills library in improving the performance of the LEGO-prover. However, what is the computational cost of building and maintaining such a library? This is not discussed in the paper."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission3246/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission3246/Reviewer_SGTy",
                    "ICLR.cc/2024/Conference/Submission3246/Senior_Area_Chairs"
                ]
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission3246/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698753457537,
        "cdate": 1698753457537,
        "tmdate": 1700638588417,
        "mdate": 1700638588417,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "P6fNagT9qd",
        "forum": "3f5PALef5B",
        "replyto": "3f5PALef5B",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission3246/Reviewer_UPjC"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission3246/Reviewer_UPjC"
        ],
        "content": {
            "summary": {
                "value": "This paper presents a framework of using LLMs to build a growable lemma library to solve math problems in the Isabelle proof assistant. The key feature of this framework is that potentially needed lemmas (to solve a target problem) can be conjectured and added to a library, and lemmas in the library can be generalised and deduplicated as the library grows. Impressive performance gain has been shown by maintaining such a skill library."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "4 excellent"
            },
            "strengths": {
                "value": "- Library learning has been an attractive topic in neuro-symbolic learning, and previous experiments have mainly been carried out on synthetic environments like [DreamCoder](https://arxiv.org/abs/2006.08381). To the best of my knowledge, this is the first time effectiveness of maintaining a library has been shown in a mature proof assistant environment. \n- The paper is relatively well-written with clear explanation of its key component and illustrative examples."
            },
            "weaknesses": {
                "value": "I don't see any major weakness in this paper except for that the authors can perhaps write down the pseudo code of their algorithm to make the inter-components interactions more explicit."
            },
            "questions": {
                "value": "- page 4, skill library, request vector stores: does the request vector store simply keep a list of conjectured statements proposed by the decomposer? What if some of them are wrong? When will the evolver attempt to prove them?\n- page 4, 'generating more beneficial new lemmas': could you elaborate a bit on why the evolver can utilize the problem statements to generate more beneficial new lemmas?\n- page 5, 'a minimally solved request (with least amount of time being selected to solve the request)': I don't quite follow the 'least amount of time' part. More explanation is highly appreciated.\n- page 6, 'serve as references': could you shed some light on why references are needed here? \n- as the pipeline is relatively complex, can we expect to have it open-sourced?\n\n\nminor:\n- page 2, related work: though not LLM-based, there has been some prior work on [template-based lemma conjecturing](https://arxiv.org/pdf/2212.11151.pdf)\n- page 5: 'Table. ?? shows'\n- page 8: 'Figure ??, in', 'Fig. ??'"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission3246/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698880249003,
        "cdate": 1698880249003,
        "tmdate": 1699636273049,
        "mdate": 1699636273049,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "fUd5j86dMz",
        "forum": "3f5PALef5B",
        "replyto": "3f5PALef5B",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission3246/Reviewer_oKSy"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission3246/Reviewer_oKSy"
        ],
        "content": {
            "summary": {
                "value": "This paper proposes a new approach to automated theorem proving with LLMs based on building up a library of lemmas useful for proofs. It is instantiated as a system called LEGO-Prover for proofs in Isabelle and is evaluated on the miniF2F dataset. The approach is fairly complex so I've broken down my understanding of it below:\n\nThere are 3 vector stores used:\n- Problem Store: Holds (unsolved) problems from miniF2F. This is where new problems will be drawn from, and is also used at various other points to guide how lemmas are proposed/modified.\n- Request Store: Lemmas that have been proposed but not yet solved.\n- Lemma Store: Lemmas that have been solved.\n\nOuter loop (I'm less clear on this and have also included it in the Questions section):\n- There are 4 LLMs, described below, used in the solving loop.\n- LEGO-Prover makes 100 passes through the miniF2F dataset, and in each pass makes a single attempt at each problem in the dataset \u2013 i.e. it runs the Decomposer LLM once on that problem and Formalizer LLM once on that problem (correct me if I'm wrong).\n- Concurrently with each pass through the dataset, for every 3 Problem Store problems attempted it makes 8 Request Store attempts, where an attempt is either a call to the Request Solver LLM or the Directional Evolution LLM, or perhaps both (please help clarify, thanks).\n\nLLMs (all implemented as variants on GPT3.5):\n- The Decomposer LLM takes the formal statement (from Problem Store), informal statement, and informal proof (which is either given or is produced by the Informal Solver LLM) and outputs an informal step-by-step proof in natural language followed by a list of formal statements of lemmas that would be useful. These lemmas are added to the Request Store, where attempts will be made to solve them later, at which point they'll be moved to the Lemma Store.\n- The Formalizer LLM takes the step-by-step informal proof, the informal and formal problem statements, and the result of querying the Lemma Store for relevant lemmas, and attempts to produce a complete formal proof which itself may use the retrieved lemmas by copying them verbatim (from the prompt) or may riff on them or define new lemmas. Any successfully-proven lemmas during the process are added to the Lemma Store, and unsuccessful ones are added to the Request Store. A sledgehammer/heuristic based autocorrect is used on all failed tactic applications.\n- The Request Solver LLM takes the least recently attempted lemma from the Request Store and attempts to prove it (aided by retrieved relevant lemmas from the Lemma Store). If a newly proven lemma is measured as too similar to an existing one via the difflib Python library, it is discarded.\n- The Directional Evolution LLM takes the last recently evolved lemma and queries the Problem Store for unsolved problems related to this lemma and modifies the lemma along one of four axes (identifying key concepts, parameterizing it, making more or less complex versions of it, or extending the dimensionality of it) in order to make a new lemma more relevant to the problem."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "- The overall idea here is an exciting one \u2013 building up a library of useful lemmas that can help with solving proofs is certainly an appealing and very natural idea; it's quite similar to how humans use automated theorem provers. It also makes sense that having skills that build on one another could lead to solving increasingly complex problems, and I think that this is a promising and exciting direction!\n- I appreciate the analysis of how often the skills are used verbatim versus modified (4.3.2) as well as the analysis of where the various skills came from (evolver vs prover etc).\n- The ablations are clarifying and helpful\n- The version with the human-written step by step proof was helpful to include for understanding how good the pipeline could get if that part were ground truth\n- The legos and other icons used in the paper are very nice\n\nWhile I've given a negative review and spend much of the review giving thoughts on ways to improve, I do want to note that I really do believe that this kind of skill library learning approach could be very powerful and is in the long run an important direction in this field even if I'm not recommending this work for acceptance (at least, as it currently is) for reasons discussed below."
            },
            "weaknesses": {
                "value": "**1. Comparison to baseline is not very strong**\n- In my understanding, the best-performing prior work **Subgoal-Learning (Zhao et al., 2023)** does not get the human written informal proof, so the natural comparison is between this baseline and **LEGO-Prover (model proof)**. The improvement on miniF2F-valid is from 48% to 52.4%, which is a 4.4% improvement. This is decent, but not huge given the complexity of the method and amount of additional LLM queries required (which could have been used just running more iterations of the other approach, for example).\n- Additionally, there's no comparison on miniF2F-test for **LEGO-Prover (model proof)** which seems important to include if following the above interpretation as the main result.\n- I also find one of the main results in the abstract misleading: the 48% to 57% improvement is actually between the baseline (which gets 100 attempts) and **LEGO-Prover-Star** which is a combination of **LEGO-Prover (model proof)** and **LEGO-Prover (human proof)** which in my understanding *each* get 100 attempts. This doesn't seem like a fair comparison since there's a combined 200 attempts used in **LEGO-Prover-Star**. (I'm open to revising this if there's an explanation I'm missing or I'm misunderstanding the setup here of course).\n\n**2. Comparison to ablation is not very strong**\n- The ablation of the skill library changes the 50-attempt solution rate of the method on the validation set from 47.1% to 50.4%. This 3.3% solution rate gain is not much for the complexity of the proposed method. I like the idea of the skill library and I do believe that by experimenting with variations on the approach the authors can achieve greater results, but as-is the library doesn't seem to add much.\n- The library version must also involve far more and far larger queries to the LLM, given all of the lemmas included in prompts and the fact that for every 3 problem solving attempts there are 8 evolving attempts. Simply using all those extra tokens for more attempts at solving the original problems would likely provide a lot of benefit and could conceivably close the 3.3% gap (this could of course be disproven through an experiment, and would be a valuable thing to include).\n\n**3. Could use more details at certain points, and overall readability**\n- It took me a very long time to understand the method; in part this is just due to the many moving pieces, but I think the explanation itself could also be improved and I'll do my best to lay out some of my confusions/thoughts which I hope will help the authors.\n    - I think that presenting the top level algorithm loop first would greatly improve this: that LEGO-Prover makes 100 passes through the miniF2F dataset and in each pass makes a single attempt at each problem in the dataset using the Solver (which is composed of two pieces: Decomposer and Formalizer). And that *concurrently*, for every 3 problems attempted it makes 8 attempts at solving any pending Lemmas that are proposed but unsolved (and also it calls the Directional Transformer to evolve them? Though I'm unclear on how much that is called relative to the Request Solver). A very high level schematic and brief description early on could be helpful for this \u2013 as is, I found myself trying to understand the 4 pieces (Decomposer, Formalizer, Request Solver, Directional Transformer) somewhat independently only to find later that there's this larger 100 pass cycle split into two concurrent processes, which came as a surprise around page 6 (until then I was just unsure when the lemmas got evolved/proved during this whole process), though perhaps I've missed some earlier discussion.\n    - A bit more clarity could also be used in this top level loop, which I'll leave questions on in the Questions section.\n    - Figure 2 was quite difficult to understand (though I appreciate how nice the visuals are). I left some notes in the \"minor\" section around tweaks that could help with that.\n    - Figure 1b is meant to be an overview but I also struggled to understand it, and it doesnt include a depiction of the Request Solver (which seems important \u2013 when are the lemmas solved?). These figures all make sense to me now having read the paper, but they didn't help as much as I would hope for understanding the idea at a glance. This isn't a huge negative, but it would have been nice to get more of a feel for the overall setup from these splash figures.\n\nminor suggestions:\n- In the related work on skill libraries it'd be worth mentioning DreamCoder (Ellis et al 2021)\n- At a glance it's difficult to see that Fig 2 is actually two subfigures \u2013 spacing them out more and/or making a thicker/different line between the two would help readability.\n- I'd suggest that Fig 2 should not reuse \"skill library\" in all 3 places, it should separately be lemma store, request store, and problem store. It was quite confusing that things labelled as \"retrieved skill\" and \"formal statement\" and \"request\" and \"similar skill\" (using labels in top right of each box) are all coming out of the skill library in different situations. Alternatively, something like color coding the different parts of the store and using color to show which is used in each place. This would just generally help for readers who glance at the figures before reading through the whole setup.\n- The main text having a table containing just the system messages from the prompt (can abbreviate away the \"expert mathematician\" bit) would be immensely helpful if space permits \u2013 looking to the appendix for those was key for my understanding. This would immediately clear up a lot of things, such as how the decomposer is producing two different outputs.\n- Section 3.3 has a \"Table ??\" where the reference must have broken; likewise there is a \"Figure ??\" and a \"Fig. ?? (a)\" near the end of 4.2\n- at the bottom of page 5, the phrase \"As depicted in Fig. 7\" should be moved a few sentences ahead \u2013 Fig 7 has the prompt, which is only relevant to the latter sentence \"Finally, the request solver prompts the LLM to generate the proof for the request.\"\n- Missing period at end of first paragraph of section 2"
            },
            "questions": {
                "value": "- Table 1: is it correct that the `LEGO-Prover*` entry effectively has more than 100 attempts since its merging all solutions from 100 human proof attempts and 100 model proof attempts?\n- Table 1: where is the entry for LEGO-Prover (model proof) miniF2F-test?\n- What exactly happens in the ablation: does it call the informal solver, then the decomposer (but without creating helper lemmas, just getting a step-by-step proof), then the formalizer directly (without retrieving helper lemmas)? And is the autocorrect sledgehammer approach used in the ablation as well? Does it get human or model informal proofs?\n    - I could imagine two reasonable ablations, one that includes first generating a step-by-step proof and one that just directly produces the final proof. Both would be quite informative, though I think only the step-by-step one would be essential.\n- Is it right that on each of the 100 passes, LEGO-Prover runs the Decomposer once then the Formalizer once on each problem?\n- I know that for every 3 Problem Store problems attempted it makes 8 Request Store attempts (or \"Evolver\" attempts). Based on the Evolver section that could either mean using Directional Transformer or the Request Solver or both \u2013 is one or the other picked in some ratio, or are both used?\n- Presumably sometimes the skills aren't used at all and just happen to be retrieved mistakenly as relevant by the vector store. Are these cases counted as \"used to formulate new lemmas\" in your analysis, since it's hard to disentangle them without some sort of similarity analysis?\n- \"Moreover, the learned skill library contains 22532 skills encompassing many useful high-level lemmas broadly applicable to various problems, as is shown in our case study and ablation study.\" To prove the point of the library having many broadly applicable lemmas, and to better understand the usefulness of the lemmas in general, it'd be helpful to see an analysis of lemma usage frequency in *correct solutions* to problems \u2013 for example how often is the most frequently-used lemma used?\n    - A more detailed analysis, not necessary for this submission in my opinion but which certainly would strengthen it: have a histogram with number of uses on the x-axis so you can see this distribution of usage frequency for all of the lemmas. \n\nvery minor:\n- Fig 3c: I think some labels might be mixed up: The skill resulting form parameterize() doesn't look like it fits the prompt for \"parameterize\" which is \"If the problem involves specific numbers, generalize it by replacing these with variables.\" Instead it just seems like a fairly different skill that no longer involves sums of squares and is now checking for less-than-or-equal-to (assuming this is `\\<le>`) instead of equality. Meanwhile the \"identify key concepts\" example looks closer to parameterization."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission3246/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission3246/Reviewer_oKSy",
                    "ICLR.cc/2024/Conference/Submission3246/Senior_Area_Chairs"
                ]
            }
        },
        "number": 5,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission3246/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699558154932,
        "cdate": 1699558154932,
        "tmdate": 1700582942239,
        "mdate": 1700582942239,
        "license": "CC BY 4.0",
        "version": 2
    }
]