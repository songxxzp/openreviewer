[
    {
        "id": "qlSlHg0YZw",
        "forum": "maRYffiUpI",
        "replyto": "maRYffiUpI",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission1668/Reviewer_DhCg"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission1668/Reviewer_DhCg"
        ],
        "content": {
            "summary": {
                "value": "This paper investigates data quality for code generation and finds that making the code more structured and readable leads to improved code generation performance. The authors build a data-cleaning pipeline to transform existing programs by 1.) renaming variables, 2.) modularizing and decomposing complex code into smaller helper sub-functions, and 3.) inserting natural-language based planning annotations. Experiments on two algorithmic code generation benchmarks indicate that fine-tuning on the transformed programs improves the code generation performance compared to fine-tuning on the original dataset."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": ". A nice idea to enhance code quality for code generation.\n\n. A series of experiments were carried out to evaluate the effectiveness of the proposed method. \n\n. The paper is easy to follow."
            },
            "weaknesses": {
                "value": "1. The proposed code transformations (i.e., renaming, modularizaing, and annotations) are a bit simple, and rely heavily on the capability of ChatGPT (GPT-3.5-TURBO).  It is unknown whether the proposed method can be utilized for other, more powerful LLM-based code generation systems. For example, in Section 4.2.2, the authors acknowledge that the poor performance obtained on the planning dataset may stem from the model's inability to generate accurate annotations, indicating that the effectiveness of the proposed model depends on LLMs. \n2. The authors propose two steps of data cleaning (i.e., renaming, modularizaing) to the original source code. However, the authors did not validate the quality of the transformed code (the authors only tested whether the transformed code can be consistent to the original data). For example, whether the variable names actually became clearer and more readable after cleaning, and whether the model accurately segmented the code into modules. Hence, it is unknown whether such simple transformation process can enhance the quality of the training data.\n3. As observed from the experimental results, the improvement of the proposed method could be insignificant and inconsistent. Some negative instances can occasionally be observed such as the $CL-7B + D_{modular}$ in in-context learning and the $CL-7B + D_{rename}$ in fine-tuning on the CODE-CONTESTS dataset. Unfortunately, the authors did not provide an explanation for the decline in these results, which may undermine the method's validity.\n4. Code generation could be achieved by prompting a general LLM such as ChatGPT directly as well. Also, it has been found that by improving the prompts, the code generation performance can be improved. The authors may discuss this approach to accurate code generation: Liu et al., Improving ChatGPT Prompt for Code Generation, https://arxiv.org/abs/2305.08360"
            },
            "questions": {
                "value": ". How is the quality of the transformed code? \n\n. Does the effectiveness of the proposed model depend on LLMs such as ChatGPT?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission1668/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698657574119,
        "cdate": 1698657574119,
        "tmdate": 1699636094914,
        "mdate": 1699636094914,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "waxiGu5uTK",
        "forum": "maRYffiUpI",
        "replyto": "maRYffiUpI",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission1668/Reviewer_FtQG"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission1668/Reviewer_FtQG"
        ],
        "content": {
            "summary": {
                "value": "The paper shows that improving the \u201cquality\u201d of a code dataset can improve the performance of a CodeLlama7B model fine-tuned on that dataset. Specifically, for every source file in a dataset, the authors propose to use a __second__ instruction-tuned language model (gpt-3.5-turbo) to perform three types of transformations in order:\n1) rename variables to have semantically meaningful names,\n2) \u201cmodularize\u201d the code by breaking up large chunks of code into smaller functions,\n3) prepend a \u201cplan\u201d before the code that summarizes the role of each individual function.\n\nThe authors use their synthetic dataset to a) provide few-shot examples to CodeLlama7B for in-context learning, b) fine-tune CodeLlama7B. Through this process, they show modest improvements in pass@k on the APPS and CodeContest data sets."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "2 fair"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "- The proposed idea is simple and an interesting approach to re-format data using a neural approach. Especially given the fact that the domain is code, transformations can be verified using an oracle - which in this case is a set of test cases. \n\n- The paper validates that by fine-tuning an LLM on a smaller good quality dataset, it is possible to achieve better/equal results than fine-tuning on a larger lower quality dataset - something that has been pointed out by many other papers in different context. \n\n- The approach can be used as inspiration for other domains where the LLM is capable of editing an existing solution but incapable of generating an entirely new solution. However, the efficacy of this approach might be significantly impacted by the presence/absence of an oracle."
            },
            "weaknesses": {
                "value": "- The experiment section of the paper reports numbers on the subsets of two datasets. It would be nice to clearly outline the filtering criteria that are used for each dataset. I have certain questions regarding this in the \u201cClarifications section\u201d.\u00a0\n\n- In many of the tables, there has been no reference or explanation to numbers that show a negative effect on results. For example, on the Code-Contest dataset, D_rename works worse than the baseline. It would be nice if the authors could be candid about this in their writing.\n\n- Additionally, I believe that the CL-7B + D_distill number is missing in table 4(a). Can you please include that number in the rebuttal ?\n\n- Overall, the effect of planning information is a mixed bag, and the conclusions are slightly confusing. For example, from the sentence, \u201cUpon inspection of the generated solutions, we find that often the generated plans are imprecise or incorrect, highlighting that planning still remains a bottleneck.\u201d \u2013 I am confused by this statement because I am unsure if this is because of the drawbacks of CodeLlama or a drawback of the paper\u2019s approach. Overall I am unsure if D_planning actually supports the paper\u2019s claim.\u00a0\u00a0\n\n- The improvements on Code-Contests seem to be not as effective as would be expected."
            },
            "questions": {
                "value": "1. Comments on Fig 1:\n    - In the renaming step, the variable `n` is not renamed everywhere. I understand that the actual LLM output can have mistakes, but maybe for an explanatory diagram this could be avoided.\n    - Instead of \u201ca -> root_u,\u00a0 b -> root_v, \u2026\u201d as the text above the arrow, it would be clearer to show the natural language instruction that you provided (\u201cRename the variables in the program to be\u2026\u201d). As it stands currently, it looks like the renaming (\u201ca -> root_u,\u00a0 b -> root_v, \u2026\u201d) is the __input__ to the model. Same comment for the modularization and planning steps too.\n\n2. \u00a0It\u2019s not immediately obvious how the natural language \u201cplans\u201d are used (my initial understanding was that they are provided as a docstring for each function). Would be nice to clarify in Fig 1 that they are __prepended__ to the program as a comment.\n\n3. In the APPs benchmark, do you consider all problems from \u201ccodeforces\u201d, \u201ccodechef\u201d and \u201catcoder\u201d ? Or is there some further filtering done after that ? If further filtering has been done, can you please clarify what procedure has been followed?\n\n4. What does this line \u201cThese cases are sometimes due to incorrect programs but more \u2026. while only a single test solution is provided\u201d mean ?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission1668/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission1668/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission1668/Reviewer_FtQG"
                ]
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission1668/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698803469417,
        "cdate": 1698803469417,
        "tmdate": 1700693008376,
        "mdate": 1700693008376,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "uxoSd1oQlk",
        "forum": "maRYffiUpI",
        "replyto": "maRYffiUpI",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission1668/Reviewer_MNi4"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission1668/Reviewer_MNi4"
        ],
        "content": {
            "summary": {
                "value": "This work explores applying a proposed data-cleaning pipeline (1: renaming variables, 2: refactoring into helper functions, and 3: inserting natural language comments to guide generation) to two major datasets (APPS and CodeContests). Fine-tuning a CodeLLAMA 7B model on these cleaned datasets dramatically improves fine tuning efficiency (requiring 8x less data to match the same performance) and improves accuracy a decent amount (often 1.2x-1.3x). They don't find the 3rd form of refactoring (introducing planning-based comments) to yield improvements, and through an additional experiment they narrow this down to be due to the inability of the model to generate good plans (as opposed to its ability to follow the plans)."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "4 excellent"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "- This is a beautifully written paper, quite easy to follow and at just the right level of detail.\n - APPS and CodeContests are two very standard datasets so those were a great choice.\n - The experiment in Table 4b around ground truth plans is a very nice little experiment, I appreciate the inclusion of that\n- The data efficiency results in Figure 3 are quite good, showing 8x less finetuning data is needed to achieve the same Pass@1 when finetuning on the refactored programs.\n- I appreciate the smaller scale observations/insights on LLM prompting, which I think are generally nice thing to include in these sorts of conference papers for the community, e.g. \"Finally, in accordance with existing literature on prompting LLMS, we found that using simple and precise, low-level instructions improves the performance and accu- racy of the models in performing the operatons. Thus, for complex data cleaning operations, we find improvements by breaking it down and performing multiple operations iteratively.\"\n - The main results (Table 3 and 4a) are decent (not incredible, but reasonable in my opinion)."
            },
            "weaknesses": {
                "value": "- The improvements in Table 3 are okay, not huge but still noticeable.\n- The planning results are also modest, but this is interesting in its own right, and the analysis of how ground truth plans would help considerably is a good way to isolate much of the problem to the plan creation rather than plan execution.\n- While most of the paper was easy to read, I was quite unclear on the distillation dataset baseline \u2013 see the Questions section for details\n- For more minor / easily fixed weaknesses see Questions section"
            },
            "questions": {
                "value": "- In table 3 theres one missing entry \u2013 Pass@1 APPS Interview Distill. Where is it?\n\n- I don't understand the \"distill\" baseline dataset laid out at the end of 3.2, and referenced at various points\n    - My best guess is that you're doing synthetic data generation to generate a new dataset by prompting with few-shot examples from the modular dataset? Is it generating both the test cases *and* the solutions to them? Or are the test cases taken from somewhere and then its just generating solutions? \n\n- Two relevant pieces of work on synthetic data generation of code for LLMs are the Self Taught Reasoner (STaR) (Zelikman et al 2022) and Language Models Can Teach Themselves to Program Better (Haluptzok et al 2022). Those would be relevant to reference under the \"Synthetic data for LLMS\" section of Related Work, and could also relate to the distillation (though as mentioned before, I understand the distill baseline less).\n\nLow level confusing things:\n- Given that the 30% relative improvement is in Table 4, it's confusing that the caption of Table 3 brings up the 30% statistic (led to me spending a while trying to figure out which two numbers divide to get 30%, which is none in table 3)\n- Note: missing period in last paragraph of Section 1 right before \"Next\"\n- Typo at end of 2.1 with random sentence ending: \"steps quite effectively. effective in generating high-quality outputs.\"\n- The sentence \"We obtain three *parallel* datasets at the end of our cleaning process, one for each of renaming, modularization, and planning\" and in particular the world \"parallel\" is a bit misleading since at least to me it suggests that each dataset comes from applying a single transformation to the original dataset independent of the others, but actually the 3 transformations build on each other. This is clarified by Table 2 but would be helpful to have in the text as well.\n- Table 4 isn't actually labelled \"Table 4\" anywhere (since there's no shared caption)"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission1668/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission1668/Reviewer_MNi4",
                    "ICLR.cc/2024/Conference/Submission1668/Senior_Area_Chairs"
                ]
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission1668/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698992135477,
        "cdate": 1698992135477,
        "tmdate": 1700610618358,
        "mdate": 1700610618358,
        "license": "CC BY 4.0",
        "version": 2
    }
]