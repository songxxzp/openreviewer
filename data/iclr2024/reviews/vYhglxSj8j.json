[
    {
        "id": "W8PZQcCjvr",
        "forum": "vYhglxSj8j",
        "replyto": "vYhglxSj8j",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4589/Reviewer_dD56"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4589/Reviewer_dD56"
        ],
        "content": {
            "summary": {
                "value": "This paper proposes a new inference framework for modularised code generation using a large language model. Existing LLM tends to generate monolithic code blocks while a complex coding task usually needs to be broken down into multiple sub-tasks with each addressed by a sub-module. Motivated by the modular programming discipline, this paper proposes to iteratively ask LLM to generate code solutions with sub-modules and add the potentially valid sub-modules to the prompts for LLM\u2019s generation at the next round. The sub-module selection is conducted by test case filtering and clustering.  The proposed framework yielded nontrivial improvements over the direct generation baselines."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "In general, this paper follows the self-revision practice to improve the quality of code generated by LLM in a trial-and-error manner. However, instead of solely focusing on the functional correctness of the code, this paper raises the concern about LLM\u2019s ability to decompose a complex coding task into multiple sub-tasks so as to generate reliable and reusable sub-modules. Although both task decomposition and chain-of-thoughts have been widely studied in different NLP applications, they are delicately adapted to fit the modular programming discipline in order to benefit code generation. Empowering LLM to produce modular code is not only helpful in improving the code\u2019s reliability but also important for reducing the cost of subsequent manual maintenance. So this work\u2019s originality and significance are considerable to me."
            },
            "weaknesses": {
                "value": "+ Sub-module filtering by public tests: given that the objects to be filtered are sub-modules generated by LLMs but we actually have no idea how the LLMs will decompose the target task/module into what sub-tasks/sub-modules. Then how can we compose the tests for the unknown sub-modules?\n\n+ Four schemes for deciding the number of clusters are investigated. However, different tasks are of different complexity and it is difficult to decompose them into a fixed number of sub-tasks. Then is it possible that LLMs may generate some sub-modules which are never used in the task-level solution? If yes, then what are the effects of those sub-modules?\n\n+ Kmeans are selected for clustering by why? Will density-based clustering like DBSCAN work better given it doesn\u2019t need to specify the number of clusters as a prior?\n\n+ As shown in Figure 5 and Figure 7, I failed to observe a consistent pattern to help me decide the optimal round of self-revision for CodeChain. The authors explained that the performance degradation at the 5th round is because of overfitting to the public test sets but this claim lacks support.\n\n+ The title of the y-axis is missing in charts like Figures, 6, 7"
            },
            "questions": {
                "value": "In table 2, why is the result of GPT4 (All: 34.75) is even bettrer than Self-repair+GPT4 with GPT4 as the feedback source (33.30)?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission4589/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4589/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4589/Reviewer_dD56"
                ]
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4589/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698639518176,
        "cdate": 1698639518176,
        "tmdate": 1699636437175,
        "mdate": 1699636437175,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "fA9YanDVuj",
        "forum": "vYhglxSj8j",
        "replyto": "vYhglxSj8j",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4589/Reviewer_hL3y"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4589/Reviewer_hL3y"
        ],
        "content": {
            "summary": {
                "value": "This paper proposes a modular code generation approach for complex programming tasks. CodeChain extracts and clusters generated sub-modules, selects representative implementations and instructs the LLM to generate new solutions using these selected modules. Experimental results show that CodeChain significantly improves modularity and correctness, achieving relative pass@1 improvements of 35% on APPS and 76% on CodeContests. The framework works well with both OpenAI LLMs and open-sourced LLMs like WizardCoder. The paper also includes comprehensive ablation studies that provide insights into CodeChain's performance."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "* SoTA performance on code generation benchmarks\n* CodeChain works well across LLMs (GPT-3.5, GPT-4 and WizardCoder)\n* The paper is well-written and is easy to understand.\n* The authors provided extensive ablation."
            },
            "weaknesses": {
                "value": "* Correctness/Soundness: \n(1) Programs generated by CodeChain are with high levels of modality and reusability on Likert scale judging by GPT-4 prompt. It is unclear how this evaluation align with human preference.\n(2) The effectiveness of sub-module generation is unclear. \n(3) The analysis on the chain of self-revisions sees a slight performance drop in the 5th iteration, which hints at the limitation of self-revise prompting.\n\n* Novelty/Originality: \n1. Using CoT to generate demonstrations and choosing representative demonstrations has been explored in [1]. The novelty of this work lies in employing this idea for code generation, which is incremental.\n2. Missing citation: [2] explores a similar idea of decomposing source code into components. \n3. The idea of utilizing LLMs' ability to self-revise has been studied in [3,4] and more. \n\n* Writing could be improved: There are multiple references to an Appendix section (e.g., Appendix F) without clarifying which figure/prompt is being referred to.  \n\nReferences\n[1] Automatic Chain of Thought Prompting in Large Language Models, ICLR 2023\n[2] Outline, Then Details: Syntactically Guided Coarse-To-Fine Code Generation, ICLM 2023\n[3] Large Language Models Can Self-Improve, ICLR 2023\n[4] CRITIC: Large Language Models Can Self-Correct with Tool-Interactive Critiquing"
            },
            "questions": {
                "value": "In section 3.2, the author mentioned, \"We append the instruction with a one-shot demonstration.\", which part of the referenced figure (Figure 3) or the appendix (Appendix F) is the one-shot demonstration? How is this demonstration being constructed?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission4589/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4589/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4589/Reviewer_hL3y"
                ]
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4589/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698825490448,
        "cdate": 1698825490448,
        "tmdate": 1699636437076,
        "mdate": 1699636437076,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "8WSTKY7VT3",
        "forum": "vYhglxSj8j",
        "replyto": "vYhglxSj8j",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4589/Reviewer_sbrc"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4589/Reviewer_sbrc"
        ],
        "content": {
            "summary": {
                "value": "The paper proposes CodeChain a method for prompting LLMs to generate modular code and reuse the generated submodules in subsequent iterations of prompting. The generated submodules are extracted and clustered to find representative and reusable components for iterations of self-revision. Experimental results on the APPS and CodeContests demonstrates that CodeChain significantly improves pass@1 metric when compared to several prior approaches."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "* The CodeChain prompting technique proposed in the paper is intuitive and easy to utilize. Designing a prompting strategy for inducing and leverage modular functions seems novel. \n* The experimental results on the selected benchmarks show the effectiveness of the prompting strategy relative to several prior methods.\n* Studies on the impact of different clustering strategies, embedding choices and revision sampling are informative.\n* Overall CodeChain seems like a good prompting strategy which is simple and effective."
            },
            "weaknesses": {
                "value": "* The clustering strategy seems to add only a small performance improvement to the overall approach. Randomly picking the modules also seems to do reasonably well (Table 3). One experiment that would be helpful is adding all submodules instead of randomly picking the generated modules to include in future revisions. Would this eliminate the need for clustering. \n\n* It is unclear how much the prompting strategy is sensitive to specific wording of the prompt and alternative formulations. Did the authors try multiple variants of the prompt and if so what was the variance and sensitivity of the results. Is it possible that there are prompts which could instruct the model to do revisions in a single shot? Could this improve direct generation? \n\n * The evaluation largely relies on two benchmarks. It would be good to see the evaluation extend to some of the appropriate subsets in https://github.com/bigcode-project/bigcode-evaluation-harness"
            },
            "questions": {
                "value": "* The authors observe that the training datasets do not filter for modularity. Have the authors tried filtering the training dataset for modular code and do light-weight fine-tuning with parameter efficient tuning methods?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission4589/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4589/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4589/Reviewer_sbrc"
                ]
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4589/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698993478979,
        "cdate": 1698993478979,
        "tmdate": 1700651500716,
        "mdate": 1700651500716,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "RGm0ocLeUJ",
        "forum": "vYhglxSj8j",
        "replyto": "vYhglxSj8j",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission4589/Reviewer_3rJJ"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission4589/Reviewer_3rJJ"
        ],
        "content": {
            "summary": {
                "value": "This paper proposes the CodeChain approach for code generation in LLM (Large Language Model) sub-modules, aiming to enhance the modularity and accuracy of the resulting code."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "The paper is well-structured and presents its arguments in a clear fashion. \n\nThe prompt method described is uncomplicated yet efficacious. \n\nThe experimental evaluation encompasses both closed-source and open-source models, providing a comprehensive analysis."
            },
            "weaknesses": {
                "value": "It is unclear whether the method can improve the quality of code generation specifically for Codellama models.\n\nThe potential of CodeChain to bolster problem-solving capabilities in other domains, such as mathematics, is not established."
            },
            "questions": {
                "value": "See Weaknesses"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission4589/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4589/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission4589/Reviewer_3rJJ"
                ]
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission4589/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1699544806923,
        "cdate": 1699544806923,
        "tmdate": 1699636436937,
        "mdate": 1699636436937,
        "license": "CC BY 4.0",
        "version": 2
    }
]