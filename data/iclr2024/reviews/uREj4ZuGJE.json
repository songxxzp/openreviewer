[
    {
        "id": "4jwNTRQQ33",
        "forum": "uREj4ZuGJE",
        "replyto": "uREj4ZuGJE",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission9031/Reviewer_DLaD"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission9031/Reviewer_DLaD"
        ],
        "content": {
            "summary": {
                "value": "This paper enables LLM to handle long contexts by compressing the context into shorter memories. To achieve this, another encoder LLM (in addition to the original decoder LLM) is fine-tuned. The memories compressed by the encoder LLM are used to reconstruct the original context and generate future sentences."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "2 fair"
            },
            "strengths": {
                "value": "- The paper tackles a timely and important problem of LLM.\n- The proposed method is simple and intuitive.\n- The paper is well-written in general."
            },
            "weaknesses": {
                "value": "**Comparison with summarization**\n\nThe paper compresses the contexts into black-box memories. Instead, one can simply apply a summarization model (e.g., GPT-4) to summarize the context and feed it to the model. While Figure 2 claims that black-box memory can be more compressive than words, this claim is not supported by the experiments. Besides, summarization has a merit in that it can be applied to black-box API models, unlike this method, which is only applicable to open-source white-box models.\n\n---\n**Still need quadratic complexity**\n\nThe model still needs to forward the entire context to compress the memories, which requires quadratic complexity over the context length. The paper partly addresses this issue using multiple spans of memories in Figure 6, but the results are preliminary. Presenting this divide-and-conquer approach as the primary method and providing a deeper analysis would extend the method to be applied for extremely long contexts. Additionally, it's worth noting that there are several concurrent submissions considering the divide-and-conquer concept [1-3].\n\n[1] Unlimiformer: Long-Range Transformers with Unlimited Length Input\\\n[2] Walking Down the Memory Maze: Beyond Context Limit through Interactive Reading\\\n[3] Hierarchical Context Merging: Better Long Context Understanding for Pre-trained LLMs\n\n---\n**Ohter long context works**\n\nThough concurrent, discussing other techniques for long context LLM in the related work section would help readers grasp the positioning of this paper. I can see many works on OpenReview and arXiv, such as [4-5], to name a few.\n\n[4] LongLoRA: Efficient Fine-tuning of Long-Context Large Language Models\\\n[5] Functional Interpolation for Relative Positions improves Long Context Transformers\n\n---\n**Editorial comments**\n\n- Using a different color for linkcolor would help readers better recognizing the link to the tables.\n- Putting tables/figures at top instead of here would help readers to better skim the experiments."
            },
            "questions": {
                "value": "My main concerns/questions are:\n1. Additional validation of the multiple-span approach. Especially, checking the generated examples and practical benchmarks, such as QA, instead of relying solely on perplexity. I wonder if this multiple-span approach would work really well, even though the model is fine-tuned with only a single span.\n2. Comparison with the summarization baseline, which simply compresses the context into words instead of black-box memories."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "6: marginally above the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission9031/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission9031/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission9031/Reviewer_DLaD"
                ]
            }
        },
        "number": 1,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission9031/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698289625844,
        "cdate": 1698289625844,
        "tmdate": 1700626701614,
        "mdate": 1700626701614,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "G2LgN2uqah",
        "forum": "uREj4ZuGJE",
        "replyto": "uREj4ZuGJE",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission9031/Reviewer_kMU9"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission9031/Reviewer_kMU9"
        ],
        "content": {
            "summary": {
                "value": "In this paper, the authors propose a new approach for compressing the context of LLMs:\n\n* The architecture involves an encoder, based on existing LLMs, and a decoder which is also a LLM. The encoder takes in the context, and a set of special memory tokens. The output embeddings of the memory tokens are used as the compressed representation of the context. This representation is passed to the decoder before the target token embeddings.\n\n* The paper proposes three training schemes: the autoencoding pretraining, text continuation pretraining and instruction fine-tuning. The autoencoding pretraining trains the decoder to reconstruct the encoder inputs, with only the compressed memory as the conditioning. The text continuation involves continuing the context passed to the encoder. Finally the model is fine-tuned for instruction following using the Prompt-with-Context dataset also proposed in the paper.\n\n* Finally there are series of analyses on how compression ratio affects the performance, and memory encoding behavior of this autoencoder."
            },
            "soundness": {
                "value": "3 good"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "The problem, namely how to compress context and form memory for LLMs, is an important topic, and the solution proposed in this paper is sound. This exact formulation is novel, as well as the training techniques and the dataset. The analysis on how compression ratio affects the performance on the reconstruction task, and the analysis on how different text format could affect memorization is also very insightful. Finally, the paper is generally easy to follow, with important information provided in both the main text and appendix."
            },
            "weaknesses": {
                "value": "I found the baseline somewhat lacking. There are a few other papers targeting the exact or adjacent problems, such as Gisting, Recurrent memory transformer, compressive transformer, auto compressor. However, the paper did not compare with any of them, making it hard to judge the tradeoffs between different methods. It'll be nice to at least compare to one of the existing methods, such as gisting, especially as it claims to achieve up to 26x compression. Further, it'll be nice to have ablation studies on various design choices, such as embedding the input tokens into the same space as the decoder for the encoder. More details on weakness will be in the \"Questions\" section. I'm willing to increase the score if the aforementioned weaknesses are addressed."
            },
            "questions": {
                "value": "1. I likely have missed something in the paper. It's unclear to me whether the authors initialized the encoder LLM from the same checkpoint as the decoder LLM? If that's the case, how did the author address the difference in autoregressive attention in the decoder (and the base LLM, such as LLAMA)  and bidirectional attention potentially used for the encoder.\n2. Why not use an encoder-decoder language model such as T5 for this?\n3. As mentioned above, does it matter for the encoder's input embeddings to be in the same space as the decoder's input embeddings?\n4. What's the actual size of each of the pretraining tasks, in terms of number of examples or number of tokens consumed.\n5. I would imagine the autoencoding task to be relatively easy to \"learn\". How many steps or number of examples does it take for the model to converge?\n6. Are the two pretraining tasks interleaved or done in a sequential order?\n7. For the instruction fine-tuning, have you tried passing the prompt to the encoder instead of the decoder, and what's the effect?\n8. Do you initialize the encoder from the same LLM checkpoint as the decoder?\n9. Could you provide some intuition on why the loss in the rightmost image in Figure 4 shows a U shaped trend.\n10. Could you also provide some explanation on why the first row of table 1 shows a PPLX increase even though there's no compression going on.\n11. Regarding the claim that pretrained ICAE suffers less from hallucination than non-pretrained model, I would like to clarify that both variants are trained on the same instruction fine-tuning set right?\n12. Have you tried full model fine-tuning? In other words, what's the impact of lora on the final quality?"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "5: marginally below the acceptance threshold"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            },
            "first_time_reviewer": {
                "value": "Yes",
                "readers": [
                    "ICLR.cc/2024/Conference/Program_Chairs",
                    "ICLR.cc/2024/Conference/Submission9031/Senior_Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission9031/Area_Chairs",
                    "ICLR.cc/2024/Conference/Submission9031/Reviewer_kMU9"
                ]
            }
        },
        "number": 2,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission9031/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698523290125,
        "cdate": 1698523290125,
        "tmdate": 1699637137454,
        "mdate": 1699637137454,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "5iLM05uXEV",
        "forum": "uREj4ZuGJE",
        "replyto": "uREj4ZuGJE",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission9031/Reviewer_fbEw"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission9031/Reviewer_fbEw"
        ],
        "content": {
            "summary": {
                "value": "This work proposes a to generate compact representation using memory slots to represent the original context. The proposed approach\nis ICAE also discusses an auto-encoding object (with lora) to pretrain the llm to generate good memory slots. The authors present several interesting experiments poking at the ability of model to do good compression as well as being able to use the compressed vectors."
            },
            "soundness": {
                "value": "4 excellent"
            },
            "presentation": {
                "value": "4 excellent"
            },
            "contribution": {
                "value": "3 good"
            },
            "strengths": {
                "value": "* Well packaged paper that addresses the prompt compression using detailed experiments.\n* Originality: I was happy to see the discussion on auto-encoding ability, as well experimentation on what length of memory slots worked vs not. Also, it was interesting to see the Lora approach to generate memory slots. I hadn't seen that in previous work.\n* Quality: Very thorough experiments on different approaches\n* Clarity: Well presented\n* Significance: Per the experiments, it looks like we should be able to cut-down ~1/4 of the prompt by using dense-encodings instead of raw text without much degradation in performance. This is a pretty good first step to see if we reduce this further more, e.g. 1/10 or so (perhaps with a larger model)."
            },
            "weaknesses": {
                "value": "* I wish the authors were more forthcoming on how this builds on top of existing work. For e.g. the authors only gloss over Chevalier et al. (2023) in passing which covers what the authors proposing to a large extent. Nevertheless, the biggest difference in this work seems to be the thorough experiments which was missing in the other work.\n\n* I encourage the authors to think more on how these memory-slots/dense-encodings can be freely interspersed with raw text. For e.g. it would be a step function improvement if one could write a prompt like \"use these docs [m1], [m2].. [mk] to answer the following questions [m1'], [m2'] [m3'].. [mk']\""
            },
            "questions": {
                "value": "1. In table 5, in rows 2, 3, 4 and 5 is column#2 (i.e. \"system 2\") also fine-tuned on the pwc dataset? I presume so, but I do want to check. Without this, it would be a very slightly unfair comparison if \"system 1\" got to see the pwc-train set but \"system 2\" did not."
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 3,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission9031/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698622024140,
        "cdate": 1698622024140,
        "tmdate": 1699637137335,
        "mdate": 1699637137335,
        "license": "CC BY 4.0",
        "version": 2
    },
    {
        "id": "kkQxfllgG8",
        "forum": "uREj4ZuGJE",
        "replyto": "uREj4ZuGJE",
        "signatures": [
            "ICLR.cc/2024/Conference/Submission9031/Reviewer_anmc"
        ],
        "nonreaders": [],
        "readers": [
            "everyone"
        ],
        "writers": [
            "ICLR.cc/2024/Conference",
            "ICLR.cc/2024/Conference/Submission9031/Reviewer_anmc"
        ],
        "content": {
            "summary": {
                "value": "This paper proposes the in-context autoencoder (ICAE) to compress a long context into memory slots and use them for shorter prompts. ICAE requires only a small number of additional parameters by the LoRA approach with a fixed LLM. ICAE is first pre-trained with autoencoding and language modeling objectives on unsupervised text corpus, and then instruction fine-tuned with the Prompt-with-Context (PwC) dataset, newly introduced in the paper."
            },
            "soundness": {
                "value": "4 excellent"
            },
            "presentation": {
                "value": "3 good"
            },
            "contribution": {
                "value": "4 excellent"
            },
            "strengths": {
                "value": "The idea of compression with autoencoding is intuitive and well combined with existing LLMs. The assumption that better LLMs would allow more compact context compression is quite interesting in connection with human memorization and validated in the paper. ICAE can be incorporated into any LLMs and has diverse potential applications, including long context modeling and CoT reasoning."
            },
            "weaknesses": {
                "value": "One drawback is that ICAE should be anyway pre-trained, despite few additional parameters and fewer training steps than LLM pre-trainings. Compression will be extremely beneficial if we use the same context multiple times. However, otherwise, it might only incur overhead."
            },
            "questions": {
                "value": "What is the format of memory slots, and how are they generated from the model? I could not find where it is described, but they should be vectors on the embedding space to be fed into the decoder as input. Are they representations before the final softmax layer to get the next word probability distribution? It might be meaningless, but what will we see if we map each memory slot vector to the most likely word?\n\nIf I understand correctly, since memory tokens are fixed for any context input, memory slots can be generated in parallel.  What memory tokens e_m have learned?\nIs it correct that memory slots are order-dependent because they use the same causal attention of language models? If yes, is it optimal because we have access to all information when we create memory slots? \n\nBased on the fact that the amount of information varies depending on the content of the context, not solely depending on its length, is it possible to have an adaptive size of memory slots for more compact compression?\n\nI agree that AE and LM objectives are straightforward for pre-training ICAE. I wonder if you have tried different objectives. Assuming we can pre-train ICAE from scratch instead of further pre-training from a pre-trained LLM, what will be the best way? Still the same objectives?\n\nIn Section 3.3.1, you mentioned the scalability in terms of context length. Are models trained separately for the sequence lengths? How does ICAE generalize well to different (L, k) combinations that are different from the one used for training?\n\nYou mentioned that the maximal token length is 512 in the Data paragraph in Section 3.1.  However, most samples are longer than 512 tokens, according to Figure 10. Did you truncate them by 512?\n\nIn Table 5, do you have the result of System 1 - Llama2-7b-chat (without ICAE) and System 2 - GPT-4 for reference?\n\nWhat value of N did you use for the text continuation training?\n\nTraining requires 8 A100 GPUs with 80GB. Can you describe the approximate training cost (time and money)?\n\n(minor) the first paragraph in Section 3.3.3: Table 6(Right) -> Figure 6 (Right)"
            },
            "flag_for_ethics_review": {
                "value": [
                    "No ethics review needed."
                ]
            },
            "rating": {
                "value": "8: accept, good paper"
            },
            "confidence": {
                "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
            },
            "code_of_conduct": {
                "value": "Yes"
            }
        },
        "number": 4,
        "invitations": [
            "ICLR.cc/2024/Conference/Submission9031/-/Official_Review",
            "ICLR.cc/2024/Conference/-/Edit"
        ],
        "domain": "ICLR.cc/2024/Conference",
        "tcdate": 1698883309245,
        "cdate": 1698883309245,
        "tmdate": 1699637137214,
        "mdate": 1699637137214,
        "license": "CC BY 4.0",
        "version": 2
    }
]