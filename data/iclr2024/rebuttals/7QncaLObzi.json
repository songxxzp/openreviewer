[
    {
        "title": "Binary Hyperbolic Embeddings"
    },
    {
        "review": {
            "id": "UxZ3dqoGjl",
            "forum": "7QncaLObzi",
            "replyto": "7QncaLObzi",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1849/Reviewer_4fSp"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1849/Reviewer_4fSp"
            ],
            "content": {
                "summary": {
                    "value": "This paper find a way, which builds a metric connection between hyperboic space and hamming space, to binary the hyperbolic embedding for fast retrieval with comparable mAPs as SOTA methods. Richful experiments validate the effectiveness of the proposed approach."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "althrough hyperbolic embeddings can yield competitive retrieval performance (w.r.t. mAP@10) against other SOTA approaches, but with low computations for search. This paper proves that slow hyperbolic distance computation is equivalent to fast Hamming distance\ncomputation, meanwhile maintain its good retrieval performance."
                },
                "weaknesses": {
                    "value": "(1) Some of the derivation details, such as Eq.(6-9) in Proposition 2 and Eq. (11) with symbols not specified, are confusing and incorrect.\n(2) Further explanations are needed on how to satisfy some preset conditions in proof or derivations.\n(3) Refer to Questions."
                },
                "questions": {
                    "value": "(1) What is the main difference between Hyperbolic embedding and learning to hashing? \n(2) It's interesting to provide more experiments and analysis about the fastness and goodness of Hyperbolic embedding and learning to hashing."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission1849/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1849/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1849/Reviewer_4fSp"
                    ]
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1849/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1697937059431,
            "cdate": 1697937059431,
            "tmdate": 1700635140116,
            "mdate": 1700635140116,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "12ImYJmSnL",
                "forum": "7QncaLObzi",
                "replyto": "UxZ3dqoGjl",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1849/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1849/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "### Reponse to Reviewer 4fSp\n\nWe thank the reviewer for their positive comments on the performance and feedback on improving the understandability of the theory part.\n\n**In response to W1: Some of the derivation details, such as Eq.(6-9) in Proposition 2 and Eq. (11) with symbols not specified.**\n\nWe thank the reviewer for the clarification suggestion, and we have added the notation explanations to the corresponding text.\n\n**In response to W2: Further explanations are needed on how to satisfy some preset conditions in proof or derivations.**\n\nFor Proposition 1, the distance approximation preset condition requires constants $K_1$ and $K_2$, $K_2$ is usually set such that no point pairs would fall into that range. In practice, the model's performance is rather insensitive to $K_1$, even removing the approximation on $K_1$ side rarely harms the performance.\n\nFor Proposition 2, the distance equivalence is based on a code book $\\mathbf{U}$ satisfying $\\langle\\mathbf{Ux}^b, \\mathbf{Uy}^b \\rangle = \\langle\\mathbf{x}^b, \\mathbf{y}^b \\rangle$, in our case, our binarization blockwisely satisfied this, but in general any codebook, e.g. orthogonal codebook, can utilize Proposition 2. \n\n**In response to Q1: What is the main difference between Hyperbolic embedding and learning to hashing?**: \n\nIn our case, we do not need to learn to achieve a performance that is comparable with full precision baseline, while hashing requires learning and solving a NP-hard discrete optimization problem, or its relaxed version at the cost of optimality.\n\n**In response to Q2: It's interesting to provide more experiments and analysis about the fastness and goodness of Hyperbolic embedding and learning to hashing.**\n\nFor the same length of binary-code, learning to hash is slightly faster than us because hash-codes can be directly used for hamming distance, while in our case, extra bit shifts will be carried out for distance calculation. However, as shown in the following table, at equal bit length the accuracy of our approach is notably higher.\n\n|          | 16bits | 32bits | 64bits | 128bits | 256bits | 512bits |\n|----------|--------|--------|--------|---------|---------|---------|\n| OrthoCos [2] | 0.4937 | 0.5166 | 0.5608 | 0.5622  | 0.5577  | 0.5472  |\n| biHalf [3]   | 0.5242 | 0.6155 | 0.6957 | 0.7161  | **0.7396**  | 0.7347  |\n| Ours     | **0.6474** | **0.6769** | **0.7072** | **0.7198**  | 0.7297  | **0.7401**  |"
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1849/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700738042961,
                "cdate": 1700738042961,
                "tmdate": 1700738042961,
                "mdate": 1700738042961,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "su75keRcRq",
            "forum": "7QncaLObzi",
            "replyto": "7QncaLObzi",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1849/Reviewer_AY1W"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1849/Reviewer_AY1W"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes a hyperbolic space as a vector-based information retrieval. To keep the benefit of hyperbolic space while making the retrieval fast and reliable, the paper shows that hyperbolic distance computation can be replaced with the Hamming distance computation with proper binary encoding. Through the experiments with three datasets, the proposed method achieves less storage with a faster search while having competitive performance against Euclidean embeddings."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "- The proposed method is well justified through the theoretical analysis. The experimental results support the theory.\n- This paper is well-written and easy to follow."
                },
                "weaknesses": {
                    "value": "- In experiments, it is written that prototypes and embeddings are learned with different curvatures. Different curvature means different hyperbolic space. Measuring the distance between two points in different spaces doesn\u2019t make sense to me. Although I understand that having prototypes not located near the boundary would benefit the overall performance empirically, this approach cannot be justified in theory.\n- I suspect that the paper is written in a hurry. Here are some editorial comments about the manuscript.\n    - There are some capitalization errors here and there (e.g., euclidean, poincare)\n    - Use proper latex command for citations (\\citet and \\citep).\n    - Use the vector image for better quality (Figure 1)\n    - Typo in equation (11) and above. I guess the argument for function f is v, not x.\n    - It would be good to provide additional background on metric equivalence for a wider audience."
                },
                "questions": {
                    "value": "- Is adaptive quantization not considered in this work? since the data points are likely to be located near boundaries, appropriate adaptive quantization may improve the performance.\n- How many bits are needed to achieve the same performance as the full precision method (Table 2)?\n- Is the comparison with the other methods fair? It is noted that C++ implementation is used for the proposed method. What about the other methods? Are they also implemented in C++? if not, can we say this is a fair comparison?\n- How are the hyperbolic embeddings obtained? For example, how does the embedding of CIFAR-100 is obtained from ResNet? Are the Euclidean embeddings transformed via exponential mapping?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1849/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698289117024,
            "cdate": 1698289117024,
            "tmdate": 1699636115094,
            "mdate": 1699636115094,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "9C51rMDhAM",
                "forum": "7QncaLObzi",
                "replyto": "su75keRcRq",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1849/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1849/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We express our gratitude to the reviewer for their affirmative remarks on the theoretical soundness of our work and its congruence with experimental results.\n\n**In response to W1: Differences in Curvatures for Prototypes and Embeddings**: \n\nWhile our empirical data demonstrate effectiveness, we acknowledge the lack of rigor in our description. The performance degradation at the Poincar\u00e9 ball's edge is attributed to numerical instability. Hence, we propose restricting the prototype's radius rather than using varying curvatures for embedding. This adjustment leads to the subsequent analysis, highlighting performance enhancement due to the adoption of a more robust CLIP backbone.\n\n|              | $r = \\sqrt{10^3}$ | $c = \\sqrt{10^2}$ | $c = \\sqrt{10}$ | $r = 1$ | $r = \\sqrt{0.1}$ |\n|--------------|-------------------|-------------------|-----------------|---------|-------------------|\n| $c_2 = 0.001$ | 0.653             | 0.676             | 0.735           | 0.742   | 0.734             |\n| $c_2 = 0.01$  | undefined         | 0.731             | 0.736           | 0.745   | 0.738             |\n| $c_2 = 0.1$   | undefined         | undefined         | 0.744           | **0.745** | 0.744             |\n| $c_2 = 1$     | undefined         | undefined         | undefined       | 0.700   | 0.733             |\n| $c_2 = 10$    | undefined         | undefined         | undefined       | undefined   | 0.527             |\n\n**In response to Q1: Potential of Adaptive Quantization in Enhancing Performance**: \n\nWe fully agree with the comments, and we would be excited to see further research in this direction. We will include it in the conclusions.\n\n**In response to Q2: Bit Requirement for Parity with Full Precision Methods**: \n\nGenerally, we observe that 256 bits suffice to achieve performance comparable to full precision methods. Refer to rows 9 and 11 in Table 2 for further details.\n\n**In response to Q3: Fairness of Comparison with Other Methods**:\n\nWe ensure fairness in our comparative analysis, both in terms of software and hardware. We utilized the **same codebase** (C++ standard libraries) with **identical compilation options** and performed evaluations on the **same hardware**, specifically the Nvidia A6000 GPU for training and a AMD EPYC 7402P Processor (single-core, single-threaded only) for evaluation.\n\n**In response to Q4: Procedure for Obtaining Hyperbolic Embeddings**:\n\nThe Euclidean embeddings are indeed transformed through exponential mapping, followed by a linear layer for dimensional adjustment. This method was applied, for example, to derive embeddings for CIFAR-100 from ResNet."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1849/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700726121894,
                "cdate": 1700726121894,
                "tmdate": 1700728577592,
                "mdate": 1700728577592,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "QMbCiNjy4Q",
            "forum": "7QncaLObzi",
            "replyto": "7QncaLObzi",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1849/Reviewer_5iHW"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1849/Reviewer_5iHW"
            ],
            "content": {
                "summary": {
                    "value": "- The authors prove the approximate equivalence between hyperbolic distance and Hamming distance, allowing fast binary operations for similarity search with hyperbolic embeddings.\n\n- The authors propose a method to binarize vectors in the Poincar\u00e9 ball model of hyperbolic space by quantizing each dimension and converting it to binary codes.\n\n- The authors show experimentally that binary hyperbolic embeddings can achieve 4.7x speedup compared to full-precision Euclidean embeddings, while maintaining better retrieval performance.\n\n- Across image and video datasets, the authors demonstrate that hyperbolic embeddings are much more robust to aggressive quantization/binarization compared to Euclidean embeddings."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "The key contribution is enabling fast and compact binary codes for similarity search using hyperbolic embeddings, through an approximate equivalence to Hamming distance. This makes hyperbolic embeddings viable for large-scale retrieval applications."
                },
                "weaknesses": {
                    "value": "- The proof of equivalence between hyperbolic and Hamming distance is approximate, and its accuracy depends on the linear approximation parameters. More analysis could be provided on the tightness of this approximation.\n\n- The quantization and binarization scheme is simple and applied in a dimension-wise manner. More sophisticated methods like product quantization could potentially improve accuracy.\n\n- Only the Poincar\u00e9 ball model is evaluated. Extending the binary encoding ideas to other hyperbolic models like Lorentz could increase generality.\n\n- The image and video datasets used are standard but small-scale.\n\n- The ResNet and 3D ResNet backbones used are a bit dated.\n\n- There is no comparison to other binary encoding methods like binary autoencoders or binary hashing.\n\n- The speedup measurements use a C++ implementation. For fairer comparison, all methods should be benchmarked in the same codebase/hardware.\n\n- The impact of factors like codebook design and learning hyperparameters could be investigated more thoroughly via ablation studies"
                },
                "questions": {
                    "value": "- The linear approximation of the hyperbolic distance has two parameters, K1 and K2. Could you provide some analysis on the tightness of this approximation and how it impacts the equivalence with Hamming distance?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "details_of_ethics_concerns": {
                    "value": "None"
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1849/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698782543234,
            "cdate": 1698782543234,
            "tmdate": 1699636115027,
            "mdate": 1699636115027,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "qovFcwzj3G",
                "forum": "7QncaLObzi",
                "replyto": "QMbCiNjy4Q",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1849/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1849/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer 5iHW (Part 1)"
                    },
                    "comment": {
                        "value": "We appreciate the reviewer's summary of the efficiency and compactness of our proposed method. We also thank the reviewer's suggestions for improving the paper, and we address them accordingly as follows:\n\n**In response to W1: More analysis on linear approximation**:\n\nWe would love to show 1) the tightness of several $K_1, K_2$ and 2) despite the different tightness levels, the approximation does not change the rank of the retrieval output.\n\n1) The linear approximation mainly contributes to theoretical completeness. In practice, using different $K_1$ and $K_2$ yields negligible difference compared with the none-approximated version. More specifically, $K_2$ has no effect on the distance calculation as none of the point pairs falls into that range. Varying $K_1$ does change the distance measure, while the effect is imperceptible, because both 1) the approximated distance and 2) the actual hyperbolic distance is very big compared to the euclidean counterparts.\n\n3) The approximation is monotonically increasing with respect to hyperbolic distance $\\|\\mathbf{x}-\\mathbf{y} \\|$, that means, nearby samples in poincare ball is still nearby under approximated distance metric and far-away samples are still far away. \n\n**In response to W2: More sophisticated methods like product quantization**:\n\nWe add the product quantization result for comparison:\n\n|                      | CIFAR100 |        |        | ImageNet1K |        |        |\n|:--------------------:|:--------:|:------:|--------|:----------:|:------:|--------|\n|                      |  128bit  | 256bit | 512bit |   128bit   | 256bit | 512bit |\n| Product Quantization |   0.521  |  0.537 | 0.550  |    0.357   |  0.415 | 0.457  |\n|         Ours         |   0.720  |  0.729 | 0.740  |    0.559   |  0.607 | 0.608  |\n\n\n**In response to W3: Other hyperbolic models like Lorentz**, \n\nwe thank the review's consideration for a broader impact. The reason that we did not consider other hyperbolic models it that they do not satisfy that each dimension is 1) symmetical and 2) ranges is in $(-r, r)$.\n\nAlthough we do not binarize other hyperbolic models, they can still use our binarization via isometry defined in hyperbolic geometry [ref1], with a single coordinates transformation. In particular, we give one example on how Lorentz model transform to Poincar\\'e model [ref2] in one line:\n\n* $(x_0,x_1,...,x_n)\\mapsto (\\frac{x_1}{1+x_0}, \\frac{x_2}{1+x_0},...,\\frac{x_n}{1+x_0})$\n\nNote that the above Lorentz $\\mapsto$ Poincar\\'e transformation is a isometry, meaning that the distance between Lorentz embeddings are equal to the distance between the resultant Poincar\\'e embeddings. Therefore any Lorentz embedding based retrieval can benifit from our Poincar\\'e binarization.  \n\n\n**In response to W4: The image and video datasets used are standard but small-scale.**\n\nFollowing the reviewer's guidance, we have added the Quick Draw dataset for a large-scale experiment. In Quick Draw, we embed the raw 50 Million images with a simple MLP backbone plus Euclidean/Hyperbolic Head.\n\nThe train/test split is split into a 1% training set and a 99% test set using the scikit-learn library with a random seed of 42. As the hierarchy information is not available for this dataset, we simply regard all the classes as the children of the \"Root\". The embedding dimensionality is 64, and we use 4 bits binarization. We perform retrieval on two randomly picked subsets (one small scale and one large scale) of the test set.\n\n|                        | QuickDraw-50K | QuickDraw-10M |\n|------------------------|------------|-----|\n| Euclidean Binarization | 0.2445     |   0.0407  |\n| Ours                   | 0.3149     |   0.0712  |\n\nThe results above highlight that our approach generalizes to large scale settings. Thank you."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1849/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700739366010,
                "cdate": 1700739366010,
                "tmdate": 1700739366010,
                "mdate": 1700739366010,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "Lduu3AvG30",
                "forum": "7QncaLObzi",
                "replyto": "QMbCiNjy4Q",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1849/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1849/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer 5iHW (Part 2)"
                    },
                    "comment": {
                        "value": "**In response to W5: The ResNet and 3D ResNet backbones used are a bit dated.** \n\nWe have updated ResNet to CLIP and 3D ResNet to 3D-SWIN-Transfomer [ref3], leading to the updated results in the paper:\nThe results show that with updated backbones, our binary hyperbolic embeddings outperform other geometries.\n\n**In response to W6: There is no comparison to other binary encoding methods like binary auto-encoders or binary hashing.**\n\nWe obtained the following results when compared with hashing on CIFAR-100:\n\n|          | 64bits | 128bits | 256bits | 512bits |\n|----------|--------|---------|---------|---------|\n| OrthoCos[ref2] | 0.5650 | 0.5622  | 0.5577  | 0.5472  |\n| biHalf[ref3]   | 0.6957 | 0.7161  | **0.7396** | 0.7347  |\n| Ours     | **0.7072** | **0.7198**  | 0.7297  | **0.7401**  |\n\n\nNote that in our evaluation protocols, the query and database set are both used as the test set, while in standard hashing setting the database set is the entire training set. Across both datasets, for both 64 and 128 bit settings, we obtain noticeably higher performance. Moreover, hashing requires learning and solving a NP-hard discrete optimization problem, which we can avoid due to our binarization strategy.\n\n**In response to W7: For fairer comparison, all methods should be benchmarked in the same codebase/hardware**: \n\nTo ensure fair comparison we benchmarked the performance using the same codebase, which is C++ std libraries, under the same compilation options, we also used the same hardware for all the evaluation, which is the Nvidia A6000 GPU. We will include this information in Section 4.1.\n\n**In response to W8-1: The impact of factors like codebook design could be investigated more thoroughly via ablation studies**: \n\nOur main contribution is to show that hyperbolic embeddings can be binarized to get the best out of the compactness of hyperbolic space and the speed of XOR operations. We consider codebook designs as fruitful future directions and we will include it in the conclusions.\n\n**In response to W8-2: learning hyperparameters could be investigated more thoroughly via ablation studies.**\n\nIn the experiments, we examined three hyper-parameters, 1) dimensionality of embedding space, 2) the number of quantization bits, 3) curvature of hyperbolic space. To elimiate the ambiguity, in addition to those existing hyper-parameters, we also introduce the embedding radius limitation as another hyper-parameter instead of the original \"curvature to generate prototypes\". Note that increase of performance is due to using a stronger CLIP backbone.\n\n|              | $r = \\sqrt{10^3}$ | $c = \\sqrt{10^2}$ | $c = \\sqrt{10}$ | $r = 1$ | $r = \\sqrt{0.1}$ |\n|--------------|-------------------|-------------------|-----------------|---------|-------------------|\n| $c_2 = 0.001$ | 0.653             | 0.676             | 0.735           | 0.742   | 0.734             |\n| $c_2 = 0.01$  | undef             | 0.731             | 0.736           | 0.745   | 0.738             |\n| $c_2 = 0.1$   | undef             | undef             | 0.744           | **0.745** | 0.744             |\n| $c_2 = 1$     | undef             | undef             | undef           | 0.700   | 0.733             |\n| $c_2 = 10$    | undef             | undef             | undef           | undef   | 0.527             |\n\n\n[ref1] Cannon, James W., et al. \"Hyperbolic geometry.\" Flavors of geometry 31.59-115 (1997): 2.\n[ref2] Radford, Alec, et al. \"Learning transferable visual models from natural language supervision.\" ICML2021. \n[ref3] Liu, Ze, et al. \"Video swin transformer.\" CVPR2022."
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1849/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700739487745,
                "cdate": 1700739487745,
                "tmdate": 1700740642406,
                "mdate": 1700740642406,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "9QaqT8Gj25",
            "forum": "7QncaLObzi",
            "replyto": "7QncaLObzi",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1849/Reviewer_d3do"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1849/Reviewer_d3do"
            ],
            "content": {
                "summary": {
                    "value": "This paper investigates the topic of hyperbolic embeddings. \nThe authors introduce a novel technique for producing binary hyperbolic embeddings, aiming to reduce the storage and computational costs of conventional hyperbolic embeddings. \nThey show that the hyperbolic distance computation can be approximately equivalent to the scaled binary Hamming distance computation. \nThrough several experiments, the authors demonstrate the efficacy of the proposed approach in comparison to other embedding methods."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "S1. **Innovative Approach:** \nThe idea of combining binary representations with hyperbolic geometry for embeddings presents a new avenue in the research area.\n\nS2. **Efficiency:** \nBinary embeddings can be more space-efficient and faster to compute, which is crucial for large-scale applications where memory and computational resources are limited.\n\nS3. **Theoretical Insights:** \nThis work does not solely rely on empirical findings; it incorporates theoretical insights to provide foundational support for the proposed binary embedding."
                },
                "weaknesses": {
                    "value": "W1. **Unclear How to Incorporate Hierarchical Knowledge:**\nThe experiments (e.g., Table 3) demonstrate the potential benefits of incorporating hierarchical knowledge, suggesting that the proposed embeddings can effectively leverage such information. However, the lack of a detailed explanation or illustration of how hierarchical knowledge is integrated into the embedding process could hinder the reproducibility and understanding of the method.\n\nW2. **Clarity In Proposition 2:**\nIn reviewing the proof of Proposition 2, I was confused about the formula of the hamming distance, i.e., \n$d_{\\mathbb{H}}(\\boldsymbol{x}^b, \\boldsymbol{y}^b) = nd - {\\Vert \\boldsymbol{x}^b \\oplus \\boldsymbol{y}^b \\Vert}_0$. \n\nBased on my understanding, it should be $d_{\\mathbb{H}}(\\boldsymbol{x}^b, \\boldsymbol{y}^b) = {\\Vert \\boldsymbol{x}^b \\oplus \\boldsymbol{y}^b \\Vert}_1$. Could you provide an illustration of this formula?\n\nMoreover, I have identified a potential gap in the logical progression from Equation (8) to Equation (9). The transition between these equations is a critical step in the proof, and it appears that additional clarification or intermediate steps are needed to fully substantiate the authors' claims.\n\nW3. **Generalizability Concerns**\nI noticed that in Sections 4.3 to 4.5, the experimental results are presented using a single dataset. While the results are promising, they do not fully demonstrate the robustness and general applicability of the proposed method across diverse data scenarios.\nIt would be highly beneficial if the authors could expand their experimental evaluation to include all three datasets mentioned in the supplementary material. This would not only reinforce the validity of the claims made but also demonstrate the method's performance across different types of data and tasks."
                },
                "questions": {
                    "value": "Regarding W1:\n\nQ1: It would be beneficial if the authors could include a step-by-step illustration or a more detailed algorithmic description that explicitly shows how hierarchical information is processed and incorporated into the embeddings. Or, if there are any pre-processing steps or specific transformation techniques used to encode hierarchical knowledge into the binary embeddings, these should be clearly described.\n\nRegrading W3:\n\nQ2: Could the authors extend their experimental evaluation to include additional datasets as presented in the supplementary material?\n\nIn addition, I also found some typos when reviewing the paper. I enumerate some of them below:\n\nIn Page 4, Equation (7) should be $\\approx {\\Vert \\boldsymbol{U} \\boldsymbol{x}^b \\Vert}^2 + {\\Vert \\boldsymbol{U} \\boldsymbol{y}^b \\Vert}^2 - 2{\\langle \\boldsymbol{U} \\boldsymbol{x}^b, \\boldsymbol{U} \\boldsymbol{y}^b \\rangle}$.\n\nIn Page 7, Table 2: Bits $n \\times d \\rightarrow$ Bits $d \\times n$.\n\nIn Page 8, Table 3: The authors' names of the methods are duplicated."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "details_of_ethics_concerns": {
                    "value": "No."
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1849/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699018346204,
            "cdate": 1699018346204,
            "tmdate": 1699636114965,
            "mdate": 1699636114965,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "L7O4MyjCQn",
                "forum": "7QncaLObzi",
                "replyto": "9QaqT8Gj25",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1849/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1849/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We thank the reviewer for their positive feedback regarding the innovation, efficiency, and technical insights.\n\n**In response to W1/Q1**\n\nThe hierarchical knowledge acts as supervision for the embedded learning. Specifically, we use the hierarchy over all classes to embed each class as a point in the Poincar\u00e9 ball following [ref1]. Then, we optimize the image or video representations to be close to their class prototype in hyperbolic space. We further clarify this in Section 3.2.\n\n**In response to W2**\n\nWe regret the confusion caused by symbol $\\oplus$. We would like to show that your description of the hamming distance $d_{\\mathbb{H}}(\\mathbf{x}^b,\\mathbf{y}^b)=\\||\\mathbf{x}^b \\oplus \\mathbf{y}^b\\||_1$ \n\nis equivalent to our description given as \n\n$d_{\\mathbb{H}}(\\mathbf{x}^b,\\mathbf{y}^b)= nd -\\||\\mathbf{x}^b \\oplus' \\mathbf{y}^b\\||_0$.\n\nFor binary representations $\\mathbf{x}^b, \\mathbf{y}^b \\in \\{0, 1\\}^{nd}$, it holds that $\\||\\mathbf{x}^b \\oplus \\mathbf{y}^b\\||_1 = \\||\\mathbf{x}^b \\oplus \\mathbf{y}^b\\||_0$. If we denote $\\oplus$ as the element-wise XOR operation and $\\oplus'$ as the element-wise XNOR operation, it holds that $\\||\\mathbf{x}^b \\oplus \\mathbf{y}^b\\||_0=nd-\\||\\mathbf{x}^b \\oplus' \\mathbf{y}^b\\||_0$. Combining these two steps, we have the equivalence $\\||\\mathbf{x}^b \\oplus \\mathbf{y}^b\\||_1=nd-\\||\\mathbf{x}^b \\oplus' \\mathbf{y}^b\\||_0$.\n\nDespite the equivalence, we agree that $\\oplus$ is more commonly used as an XOR operator than XNOR; hence, we will follow the reviewer's suggestion and adapt the equation for more consistency with existing conventions.\n\n**In response to W3/Q2**\n\nIn the revision, we have added the corresponding part of the results on different datasets to the appendix and will keep updating them. Those results are consistent across different datasets, proving the generalization capability of our model. \n\nTo draw more interest regarding this question, inspired by reviewer **5iHW** , we show the capability of our proposed model on a large-scale dataset, \"Quick, Draw!\", which has **50 million sketch images** from 345 classes. We demonstrate the effectiveness of our binarization as follows:\n\nThe train/test split is split into a 1% training set and a 99% test set using the scikit-learn library with a random seed of 42. \nAs the hierarchy information is not available for this dataset, we simply regard all the classes as the children of the \"Root\".\nThe embedding dimensionality is 64, and we use 4 bits binarization. We perform retrieval on two randomly picked subsets (one small scale and one large scale) of the test set.\n\n|                        | 50K database | 10M database |\n|------------------------|------------|-----|\n| Euclidean Binarization | 0.2445     |   0.0407  |\n| Ours                   | 0.3149     |   0.0712  |\n\n\nWe also thank the reviewer for pointing out the typos; we have fixed them in the updated version.\n\n[ref1] Ganea, Octavian, Gary B\u00e9cigneul, and Thomas Hofmann. \"Hyperbolic entailment cones for learning hierarchical embeddings.\" ICML, 2018."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1849/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700738438648,
                "cdate": 1700738438648,
                "tmdate": 1700740615763,
                "mdate": 1700740615763,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]