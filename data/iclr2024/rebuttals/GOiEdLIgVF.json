[
    {
        "title": "Saliency-Guided Hidden Associative Replay for Continual Learning"
    },
    {
        "review": {
            "id": "0w5eKt7xoj",
            "forum": "GOiEdLIgVF",
            "replyto": "GOiEdLIgVF",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6396/Reviewer_8orT"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6396/Reviewer_8orT"
            ],
            "content": {
                "summary": {
                    "value": "This paper introduces Saliency-Guided Hidden Associative Replay for Continual Learning (SHARC), a method that attempts to tackle the catastrophic forgetting problem in continual learning by incorporating associative memory into replay-based strategies. The memory selectively stores essential feature map channels determined using saliency methods like Grad-CAM. Experiments on several benchmarks show improvements over some existing replay-based CL methods under task-incremental and class-incremental learning settings."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "- The paper's endeavor to draw inspiration from insights into human brain function for addressing CL is commendable.\n\n- The proposed method improves several existing replay-based CL methods."
                },
                "weaknesses": {
                    "value": "1. The working mechanism of associative memory is confusing. \n- It is unclear how the queries are obtained during both training and inference. \n- The concept of queries, which appears to be image crops in Fig. 2, contradicts the notion presented in the paper, where specific feature map channels are retained.\n- The practicality of recalling precisely the same image when given a query is questionable, as queries pertain to new classes, while the memory contents relate to old classes. This discrepancy, unless old queries are also stored, fundamentally undermines the approach. Storing old queries, however, introduces extra complexities that appear inconsistent with the intended advantages of using associative memory.\n\n\n2. The reliance on gradient-based saliency methods to evaluate the importance of feature map channels may not align with the underlying feature selection mechanisms in the human brain.\n\n\n3. The related work is noticeably lacking in depth. \n- The paper lacks a comprehensive overview of both regularization-based and dynamic architecture-based continual learning methods. Notably, there is a complete absence of references to the latter category.\n- The review neglects to consider replay-based continual learning methods that store lightweight features or generate pseudo features for old classes [1-3], which should be addressed, discussed, and compared.\n- The absence of a thorough examination of other continual learning methods employing brain-inspired memory systems, such as [4-5], leaves a critical gap that requires addressing through comprehensive review, discussion, and comparison.\n\n\n4. In terms of comparisons: \n- It is unclear whether methods without SHARC in Tables I and II are also pre-trained on ImageNet. \n- The authors are encouraged to extend the comparison to include more recent methods introduced in 2022 or 2023.\n\n\n5. The claim that \"existing work Sun et al. (2015) has proved that hidden representation learned by convolutional neural networks is highly sparse in the hidden space\" is inadequately supported, as the referenced work by Sun et al. (2015) predominantly focuses on face representations rather than general representations acquired through CNNs, rendering the argument questionable.\n\n\nReference\n\n[1] Generative feature replay for class-incremental learning. CVPRW 2020.\n\n[2] Self-sustaining representation expansion for non-exemplar class-incremental learning. CVPR 2022.\n\n[3] Fetril: Feature translation for exemplar-free class-incremental learning. WACV 2023.\n\n[4] Learning Fast, Learning Slow: A General Continual Learning Method based on Complementary Learning System. ICLR 2022\n\n[5] Sparse Coding in a Dual Memory System for Lifelong Learning. AAAI 2023"
                },
                "questions": {
                    "value": "- What is the value of K? Is it the same as the number of classes in order to perform the Grad-CAM? Will K change under the class-incremental setting?\n\n- What are the two multiplication operations in Eq. (4), respectively?\n\n- Is A\u2019 a feature map after discarding the non-salient channels?\n\n- Can you provide more explanations for the sentence \u201cWe only need to keep track of the channel index which is only a 1d vector and cheap to store\u201d?\n\n- What is the \u201cpartial cue\u201d that is used to retrieve feature maps in the associative memory?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission6396/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission6396/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission6396/Reviewer_8orT"
                    ]
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6396/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698135390904,
            "cdate": 1698135390904,
            "tmdate": 1699636709282,
            "mdate": 1699636709282,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "q9xLjpyYDc",
                "forum": "GOiEdLIgVF",
                "replyto": "0w5eKt7xoj",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6396/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6396/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Related Work and Comparison(Part1)"
                    },
                    "comment": {
                        "value": "Thank you for your time and dedication to this review process. We are grateful for the opportunity to benefit from your expertise, and we believe your contributions will enhance the overall quality of the SHARC.  \n\n>*\"The paper lacks a comprehensive overview of both regularization-based and dynamic architecture-based continual learning methods. Notably, there is a complete absence of references to the latter category.\"*\n\n**A1.**\nArchitect-based: \n\n* DER: Dynamically Expandable Representation for Class Incremental Learning CVPR 2021 \\\n* Progressive Neural Networks 2016 \\\n* Lifelong Learning with Dynamically Expandable Networks 2017 \\\n* Progress & Compress: A scalable framework for continual learning PMLR 2018 \\\n* DyTox: Transformers for Continual Learning With DYnamic TOken eXpansion CVPR 2022 \n\nRegularization-based:\n\n* Uncertainty-based Continual Learning with Adaptive Regularization NerulPS 2019 \\\n* CPR: Classifier-Projection Regularization for Continual Learning ICLR 2020 \\\n* Adversarial Targeted Forgetting in Regularization and Generative-Based Continual Learning Models IJCNN 2021 \\\n* Continually Learning Self-Supervised Representations with Projected Functional Regularization CVPRW 2022\n\n>*\"The absence of a thorough examination of other continual learning methods employing brain-inspired memory systems, such as [4-5], leaves a critical gap that requires addressing through comprehensive review, discussion, and comparison.\"*\n\n**A2.**\n[4] CLSER \\\nThe method described in quote [4], called CLSER, has already been extensively discussed in this paper. We applied our own method, known as SHARC, to the CLSER framework and conducted evaluations on three datasets: CIFAR-10, CIFAR-100, and TinyImageNet. The results clearly demonstrate a significant improvement in performance, particularly when the buffer size is relatively smaller.\n\n[5] SCoMMER \\\nWhen comparing our method to CLSER, we observe that our method achieves similar results to SCoMMER on the CIFAR-100 dataset. However, our method surpasses SCoMMER by one percentage point in accuracy when the buffer size is set to 200. Conversely, SCoMMER underperforms CLSER on the CIFAR-10 dataset. In contrast, our SHARC method achieves an even higher accuracy, approximately three percentage points higher than CLSER, particularly when the buffer size is 500. This stark contrast fully illustrates the robustness of our method across different datasets and underscores its superiority.\n\n>*\"It is unclear whether methods without SHARC in Tables I and II are also pre-trained on ImageNet.\"*\n\n**A3.**\nIn our approach, SHARC, we adopt a consistent starting point by replacing the original network structure, such as ER, MER or GEM, with a trained and partially parameterized ResNet. This ResNet serves as the backbone for processing all image data in our framework.\n\nOne notable advantage of SHARC is its flexibility in accommodating different methods. Regardless of the specific method employed in combination with SHARC, the main differentiating factors lie in the fixed structure of the original methods and their respective optimal training parameters. By adhering to this consistent framework, we ensure that the primary distinctions among the methods stem from their unique configurations and parameter choices.\n\nThis approach allows for a fair and meaningful comparison of different methods within the SHARC framework, as the focus shifts toward analyzing the impact of their specific configurations and parameter settings on overall performance. By isolating these factors, we can better understand the strengths and weaknesses of each method and make informed decisions when applying them to different datasets or problem domains."
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6396/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700742322395,
                "cdate": 1700742322395,
                "tmdate": 1700742666215,
                "mdate": 1700742666215,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "cFyqbtdnub",
            "forum": "GOiEdLIgVF",
            "replyto": "GOiEdLIgVF",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6396/Reviewer_vmux"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6396/Reviewer_vmux"
            ],
            "content": {
                "summary": {
                    "value": "Paper proposes a novel Continual Learning (CL) method, SHARC, inspired by biological memory (selective memory retention of salient experience). It has 2 novel contributions to the CL problem: saliency selection of feature channels and Associative Memory (AM) to improve memory efficiency and mitigate forgetting. The empirical experiments for the Task-IL and the Class-IL settings show significant improvement over the SOTA replay CL methods like GEM, A-GEM, ER, etc."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "4 excellent"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "Paper's position is that the biological inspired architecture for CL is more memory efficient and can outperform the current replay methods which either stores the entire representation or approximately generate the training data for older classes. This motivation is supported by the strong experimental results."
                },
                "weaknesses": {
                    "value": "1. The novelty of the paper is limited as it combines existing methods such as \"saliency\" and \"associative memory\" for the CL problem. In image retrieval literature, there are several prior works which combine both mechanisms. See references below. As such, the real novelty lies only in the application of these 2 mechanism to the CL problem.\n\n2. (Minor) Experiments only include replay-based CL methods. As mentioned in the paper's related works, replay methods are among the strongest in CL. However, this design leaves a big unknown about how well the proposed method compare against other approaches, like regularization-based and dynamic architecture-based. Only DER++ which has regularization and rehearsal is included.\n\n3. (minor) The implementation details about how SHARC combine with the other baseline methods are not given. However, this is somewhat mitigated by the inclusion of anonymous codes. I did not inspect the codes, however.\n\nGe, S. S., Li, M., & Lee, T. H. (2016). Dynamic saliency-driven associative memories based on network potential field. Pattern Recognition, 60, 669-680.\nKuo, D. W., Cheng, G. Y., Cheng, S. C., & Lee, S. L. (2012, October). Detecting salient fragments for video human action detection and recognition using an associative memory. In 2012 International Symposium on Communications and Information Technologies (ISCIT) (pp. 1039-1044). IEEE."
                },
                "questions": {
                    "value": "1. (Section 5.2) How does the proposed method combine with the 6 replay-based methods? Does the SHARC Memory Replay module directly replace the respective methods' original replay mechanism? What about the SHARC prediction head? How does it combine with the other methods?\n\n2. By \"combining\" SHARC with other methods, what's the network size increased? In general, we can expect improved performance for many tasks simply by increasing the network size. So it's important to know the increase of network size, after combining with SHARC."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "details_of_ethics_concerns": {
                    "value": "No concerns"
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6396/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698388492184,
            "cdate": 1698388492184,
            "tmdate": 1699636708917,
            "mdate": 1699636708917,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "CesHzL2lgB",
                "forum": "GOiEdLIgVF",
                "replyto": "cFyqbtdnub",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6396/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6396/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Implementation Details(Part1)"
                    },
                    "comment": {
                        "value": "Thank you for your time and dedication to this review process. We are grateful for the opportunity to benefit from your expertise, and we believe your contributions will enhance the overall quality of the SHARC.\n\n>*\"The implementation details about how SHARC combines with the other baseline methods are not given. However, this is somewhat mitigated by the inclusion of anonymous codes. I did not inspect the codes, however.\"*\n\n**A1.** \nFirst, we start by replacing the backbone in the original method with a pre-trained and parameter-frozen ResNet. This allows us to leverage the pre-trained weights and architecture of ResNet, which is a popular convolutional neural network. By doing this, we obtain the feature map from the modified ResNet.\n\nNext, we incorporate a simple MLP as the prediction head. The MLP takes the feature map as input and performs the task of making predictions based on the extracted features.\n\nWhen a batch of data is entered into the system, the first step is to obtain the feature importance using our modified Grad-CAM which is a technique that highlights the important regions in an image that contribute to the predictions made by the model. By applying Grad-CAM on the modified ResNet, we obtain a feature map based on the input data.\n\nAfter obtaining the feature map, we update the gradients on the current minibatch using this modified Grad-CAM. This step helps us to fine-tune the model based on the specific data in the current batch.\n\nNext, we utilize Grad-CAM masks to mask the feature maps of the images within the batch. Grad-CAM masks allow us to focus on the most relevant parts of the feature maps, enabling us to extract more meaningful information.\n\nOnce the feature maps are masked, we process and recover them using BayesPCN. Finally, the recovered feature maps are stored in the episodic memory, which serves as a repository for important information that can be later accessed and utilized for various purposes.\n\n>*\"How does the proposed method combine with the 6 replay-based methods? Does the SHARC Memory Replay module directly replace the respective methods' original replay mechanism? What about the SHARC prediction head? How does it combine with the other methods?\"*\n\n**A2.** \nFirst, we start by replacing the backbone in the original method with a pretrained and parameter-frozen ResNet. This allows us to leverage the pre-trained weights and architecture of ResNet, which is a popular convolutional neural network. By doing this, we obtain the feature map from the modified ResNet.\n\nNext, we incorporate a simple MLP as the prediction head. The MLP takes the feature map as input and performs the task of making predictions based on the extracted features.\n\nWhen a batch of data is entered into the system, the first step is to obtain the feature importance using our modified Grad-CAM which is a technique that highlights the important regions in an image that contribute to the predictions made by the model. By applying Grad-CAM on the modified ResNet, we obtain a feature map based on the input data.\n\nAfter obtaining the feature map, we update the gradients on the current minibatch using this modified Grad-CAM. This step helps us to fine-tune the model based on the specific data in the current batch.\n\nNext, we utilize Grad-CAM masks to mask the feature maps of the images within the batch. Grad-CAM masks allow us to focus on the most relevant parts of the feature maps, enabling us to extract more meaningful information.\n\nOnce the feature maps are masked, we process and recover them using BayesPCN. Finally, the recovered feature maps are stored in the episodic memory, which serves as a repository for important information that can be later accessed and utilized for various purposes.\n\nIn summary, we made several modifications to the original methods. Firstly, we replaced the backbone of the network with a different architecture. This change allows us to leverage the strengths of the new backbone and potentially improve the performance of the network. Additionally, we modified the form of the data in the episodic memory. This alteration enables us to store and retrieve information in a more efficient and effective manner. By adapting the data structure to better suit our needs, we can enhance the overall performance of the network. Furthermore, we introduced BayesPCN as the associative memory network to achieve strong memory recall performance.\n\nOverall, these changes contribute to improving the performance and memory capabilities of the network, allowing it to handle complex tasks better and make more accurate predictions."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6396/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700740539300,
                "cdate": 1700740539300,
                "tmdate": 1700741721978,
                "mdate": 1700741721978,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "bYGILTkfH0",
                "forum": "GOiEdLIgVF",
                "replyto": "cFyqbtdnub",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6396/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6396/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Implementation Details(Part2)"
                    },
                    "comment": {
                        "value": ">*\"By \"combining\" SHARC with other methods, what's the network size increased? In general, we can expect improved performance for many tasks simply by increasing the network size. So it's important to know the increase of network size, after combining with SHARC.\"*\n\n**A3.** \nTake the method \"erbpcn\" as an example. In the specific case of theta=0.2, where only 20% of the original image is retained, if we were to deposit all the complete images inside the episodic memory, it would require approximately 7.5 million parameters. However, with our SHARK method, the episodic memory is represented by a single feature map, resulting in a reduction to only about 1.3 million parameters. This optimization effectively drops about 6 million parameters, and the computation involved is only 17% of the original.\n\nComparatively, the ResNet18 architecture, which is commonly used as a backbone in deep learning models, consists of around 11 million parameters. In contrast, the associative memory network that we introduced contains only about 4 million parameters. By adopting our approach, we achieve a memory consumption reduction of approximately 11% compared to the original tasker, while also obtaining higher accuracy.\n\nThese results clearly demonstrate the efficiency and accuracy of our method. By optimizing the episodic memory representation and introducing the associative memory network, we significantly reduce the parameter count and computational load while still achieving superior performance.\n\n>*\"The novelty of the paper is limited as it combines existing methods such as \"saliency\" and \"associative memory\" for the CL problem.\"*\n\n**A4.**\nIn response to the reviewer's comment on the perceived limited novelty of the paper due to the combination of existing methods - saliency and associative memory - for the Continual Learning (CL) problem, we would like to highlight the unique contributions of our work:\n\n1. **Innovative Integration for CL**: While it's true that both saliency methods and associative memory have been individually explored in the image retrieval literature, their integration in the context of Continual Learning (CL) represents a significant advancement. Continual Learning, with its unique challenges such as catastrophic forgetting and memory efficiency, requires a nuanced approach. Our work is not just a simple combination of these two methods; it's an innovative adaptation to address the specific needs and challenges of CL.\n\n2. **Context-Specific Adaptation**: The application of these mechanisms to CL is not trivial. It required significant adjustments and innovations to make them suitable for the dynamic and evolving nature of CL. This adaptation includes the development of a novel method for efficient and selective memory encoding and retrieval, which is critical for managing the complex data streams inherent in CL.\n\n3. **Unique Problem-Solving Approach**: The problem set in CL is fundamentally different from traditional image retrieval. In CL, the model continuously learns from a stream of data while retaining previously acquired knowledge. This poses unique challenges, such as avoiding catastrophic forgetting, which are not present in conventional image retrieval scenarios. Our method addresses these challenges by leveraging saliency and associative memory in a novel way, specifically tailored for CL.\n\n4. **Enhanced Performance and Efficiency**: The integration of saliency-guided memory encoding and associative memory retrieval in our SHARC framework enhances memory efficiency and reduces the computational overhead, which is a significant contribution to the field of CL. This efficiency is crucial in CL where models need to be highly adaptive yet resource-efficient.\n\n5. **Extending Beyond Existing Literature**: While prior works have explored these mechanisms separately, our work synergizes them in a novel framework specifically for CL. This not only advances the state-of-the-art in CL but also opens up new avenues for future research in combining these techniques for other complex learning scenarios.\n\nIn summary, while our work builds upon existing methods, its novelty lies in the unique integration and adaptation of these methods to address the specific challenges of Continual Learning. This is not merely an application of existing techniques to a new problem but a thoughtful and innovative reimagining of these techniques to create a solution that is greater than the sum of its parts."
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6396/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700740624192,
                "cdate": 1700740624192,
                "tmdate": 1700742062799,
                "mdate": 1700742062799,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "C7pPs1vM3a",
            "forum": "GOiEdLIgVF",
            "replyto": "GOiEdLIgVF",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6396/Reviewer_prAb"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6396/Reviewer_prAb"
            ],
            "content": {
                "summary": {
                    "value": "The paper introduces a novel framework called Saliency-Guided Hidden Associative Replay for Continual Learning (SHARC) to address the challenge of catastrophic forgetting in continual learning. \n\nIn this paper, we provide a plugin to enhance the performance of replay-based continual learning methods to improve storage efficiency.\n\nThe paper proposes the SHARC framework, which combines associative memory with replay-based strategies. SHARC encodes and archives salient data segments using sparse memory encoding. By leveraging associative memory paradigms, SHARC introduces a content-focused memory retrieval mechanism, promising quick and accurate recall.\n\n The associative memory creates an additional memory footprint and consumes a lot of computing resources for updating it.\n\nThe paper presents extensive experimental results that demonstrate the effectiveness of SHARC for various continual learning tasks."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "The proposed method can be seamlessly adapted to any replay-based approach, improving their performance in various continual learning scenarios. \n\nThe experimental results provide evidence of the effectiveness of SHARC in improving the performance of replay-based methods."
                },
                "weaknesses": {
                    "value": "Lack of detailed network and hyper-parameter configuration, especially, for associative memory networks.\n\nThe lack of recent baselines in the experiment, most of the baselines used were proposed two or three years ago.\n\nThe associative memory A(x,\u03c9) is implemented as a recurrent or feed-forward neural network. The associative memory creates an additional memory footprint, and consumes a lot of computing resources for updating it.\n\nThe experiments in this paper do not seem to be reasonable. The method in this paper introduces an additional associative memory network to store more information for replay, which definitely makes the original method perform better."
                },
                "questions": {
                    "value": "How much memory and computing resources does associative memory take up? Wouldn't it be better if those extra storage resources were used to store more exemplars? Please make a comparison."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6396/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698579323286,
            "cdate": 1698579323286,
            "tmdate": 1699636708795,
            "mdate": 1699636708795,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "Ev5AejVCfE",
                "forum": "GOiEdLIgVF",
                "replyto": "C7pPs1vM3a",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6396/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6396/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Detailed Experiment Settings and Model Capacity Explanation(Part1)"
                    },
                    "comment": {
                        "value": ">*\u201cLack of detailed network and hyper-parameter configuration, especially, for associative memory networks.\u201c*\n\n**A1.** \nBy expanding on the previous list of hyperparameters, we aim to offer a more comprehensive illustration of the parameter settings for our associative memory network. This additional information will enable a deeper analysis and evaluation of the different methods employed. We believe that a thorough parameterization is essential for replicability, comparability, and overall confidence in the results obtained. With this in mind, we present the following comprehensive parameterization for your consideration.\n\nFor the different methods, we use the same parameter settings for our associative memory network:\n\nBpcn_args:\n#### Model Configs\n\n| Parameter         | Value      |\n|-------------------|------------|\n| memory_strength   | 1          |\n| n-models          | 1          |\n| n-layers          | 2          |\n| h-dim             | 256        |\n| sigma-prior       | 1.0        |\n| sigma-obs         | 0.01       |\n| beta-forget       | 0.1        |\n| beta-noise        | 0.1        |\n| scale-layer       | store_true |\n| bias              | store_true |\n| n-elbo-particles  | 1          |\n\n#### Training Configs\n\n| Parameter             | Value      |\n|-----------------------|------------|\n| weight-lr             | 0.0001     |\n| activation-lr         | 0.01       |\n| activation-optim      | adam       |\n| T-infer               | 500        |\n| n-proposal-samples    | 1          |\n| n-repeat              | 1          |\n| resample              | store_true |\n\nMethods_args:\n\n| Method   | Theta | Learning Rate | Minibatch Size | Batch Size | Number of Epochs | Samples per Task | Number of Tasks |\n|----------|-------|---------------|----------------|------------|------------------|------------------|-----------------|\n| er_bpcn  | 200   | 0.1           | 10             | 10         | 1                | 10000            | 5               |\n| er_bpcn  | 500   | 0.1           | 10             | 10         | 1                | 10000            | 5               |\n| er_bpcn  | 1000  | 0.1           | 10             | 10         | 1                | 10000            | 5               |\n\n\n\n| Method   | Theta | Learning Rate | Number of Epochs | Beta | Gamma | Minibatch Size | Batch Size | Batch Number | Samples per Task | Number of Tasks |\n|----------|-------|---------------|------------------|------|-------|----------------|-------------|--------------|------------------|-----------------|\n| mer_bpcn | 200   | 0.1           | 1                | 1    | 1     | 10             | 10          | 1            | 10000            | 5               |\n| mer_bpcn | 500   | 0.1           | 1                | 1    | 1     | 10             | 10          | 1            | 10000            | 5               |\n| mer_bpcn | 1000  | 0.1           | 1                | 1    | 1     | 10             | 10          | 1            | 10000            | 5               |\n\n\n\n| Method   | Theta | Learning Rate | Gamma | Minibatch Size | Batch Size | Number of Epochs | Samples per Task | Number of Tasks |\n|----------|-------|---------------|-------|----------------|------------|------------------|------------------|-----------------|\n| gem_bpcn | 200   | 0.1           | 0.5   | 10             | 10         | 1                | 10000            | 5               |\n| gem_bpcn | 500   | 0.1           | 0.5   | 10             | 10         | 1                | 10000            | 5               |\n| gem_bpcn | 1000  | 0.1           | 0.5   | 10             | 10         | 1                | 10000            | 5               |\n\n\n\n| Method    | Theta | Learning Rate | Minibatch Size | Batch Size | Number of Epochs | Samples per Task | Number of Tasks |\n|-----------|-------|---------------|----------------|------------|------------------|------------------|-----------------|\n| agem_bpcn | 200   | 0.1           | 10             | 10         | 1                | 10000            | 5               |\n| agem_bpcn | 500   | 0.1           | 10             | 10         | 1                | 10000            | 5               |\n| agem_bpcn | 1000  | 0.1           | 10             | 10         | 1                | 10000            | 5               |\n\n\n\n| Method     | Theta | Alpha | Beta | Learning Rate | Minibatch Size | Batch Size | Number of Epochs | Samples per Task | Number of Tasks |\n|------------|-------|-------|------|---------------|----------------|------------|------------------|------------------|-----------------|\n| derpp_bpcn | 200   | 0.1   | 0.5  | 0.1           | 10             | 10         | 1                | 10000            | 5               |\n| derpp_bpcn | 500   | 0.1   | 0.5  | 0.1           | 10             | 10         | 1                | 10000            | 5               |\n| derpp_bpcn | 1000  | 0.1   | 0.5  | 0.1           | 10             | 10         | 1                | 10000            | 5               |"
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6396/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700739576848,
                "cdate": 1700739576848,
                "tmdate": 1700741549452,
                "mdate": 1700741549452,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "KbpXGOtvGL",
                "forum": "GOiEdLIgVF",
                "replyto": "C7pPs1vM3a",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6396/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6396/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Detailed Experiment Settings and Model Capacity Explanation(Part2)"
                    },
                    "comment": {
                        "value": "| Method     | Theta | Reg Weight | Stable Model Update Freq | Stable Model Alpha | Plastic Model Update Freq | Plastic Model Alpha | Learning Rate | Minibatch Size | Batch Size | Number of Epochs | Samples per Task | Number of Tasks |\n|------------|-------|------------|-------------------------|--------------------|--------------------------|---------------------|----------------|----------------|------------|------------------|------------------|-----------------|\n| clser_bpcn | 200   | 0.15       | 0.1                     | 0.999              | 0.3                      | 0.999               | 0.1            | 10             | 10         | 1                | 10000            | 5               |\n| clser_bpcn | 500   | 0.15       | 0.1                     | 0.999              | 0.3                      | 0.999               | 0.1            | 10             | 10         | 1                | 10000            | 5               |\n| clser_bpcn | 1000  | 0.15       | 0.1                     | 0.999              | 0.3                      | 0.999               | 0.1            | 10             | 10         | 1                | 10000            | 5               |\n\n  \n\n\n>*\"The experiments in this paper do not seem to be reasonable. The method in this paper introduces an additional associative memory network to store more information for replay, which definitely makes the original method perform better.\"*\n\n**A2.**\nThe role of our associative memory network is to reduce the memory consumption of whole images by converting them into individual feature maps and depositing them into episodic memory after going through our GradCAM method. This reduction in memory usage is significant. \n\nHowever, it is important to note that even with the introduction of an associative memory network, the amount of information we introduce is much less compared to methods such as ER and MER, which store images directly into episodic memory. \n\nThe reduction in information is due to the transformation of the original image into a feature map representation. Unlike the complete image, which includes all the pixel-level details and color information, a feature map represents a condensed version that highlights specific visual features and patterns. This reduction in information allows for more efficient storage and processing, making it an effective strategy for reducing memory consumption in our associative memory network.\n\nIn addition, our associate memory, or BayesPCN, is a compact network architecture comprising only a few layers of Multi-Layer Perceptron (MLP). While BayesPCN plays a crucial role, it is important to note that the memory it provides is relatively limited when compared to the vast amount of information present in the complete image dataset.\n\n>*\"How much memory and computing resources does associative memory take up? Wouldn't it be better if those extra storage resources were used to store more exemplars? Please make a comparison.\"*\n\n**A3.**\nTake the method ER with SHARC as an example. In the specific case of theta=0.2, where only 20% of the original image is retained, if we were to deposit all the complete images inside the episodic memory, it would require approximately 7.5 million parameters. However, with our SHARC method, the episodic memory is represented by a single feature map, resulting in a reduction to only about 1.3 million parameters. This optimization effectively drops about 6 million parameters, and the computation involved is only 17% of the original.\n\nComparatively, the ResNet18 architecture, which is commonly used as a backbone in deep learning models, consists of around 11 million parameters. In contrast, the associative memory network that we introduced contains only about 4 million parameters. By adopting our approach, we achieve a memory consumption reduction of approximately 11% compared to the original tasker, while also obtaining higher accuracy.\n\nThese results clearly demonstrate the efficiency and accuracy of our method. By optimizing the episodic memory representation and introducing the associative memory network, we significantly reduce the parameter count and computational load while still achieving superior performance."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6396/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700740171364,
                "cdate": 1700740171364,
                "tmdate": 1700741631278,
                "mdate": 1700741631278,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "PSuwnVNdHr",
            "forum": "GOiEdLIgVF",
            "replyto": "GOiEdLIgVF",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6396/Reviewer_WbsA"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6396/Reviewer_WbsA"
            ],
            "content": {
                "summary": {
                    "value": "In conventional replay-based continual learning methods, raw/ entire data are stored and recalled during replay which is biologically implausible and memory intensive. This work presents a biologically plausible framework where partial salient data are stored and complete data are retrieved during replay. It utilizes sparse memory encoding to store partial information and a content-based memory retrieval mechanism to recover complete information. It enables efficient memory storage and archives better recall accuracy than generative models. This work has potential to perform effectively in highly memory-constrained applications."
                },
                "soundness": {
                    "value": "1 poor"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "This paper presents bio-inspired perspectives to store hidden sparse representations and associate memory based recall. This resembles how humans and animals learn by compressing information.\n\nInnovative approach of storing and retrieving rehearsal data for memory efficient replay and mitigating catastrophic forgetting.\n\nSaliency based approach to store sparse information which leads to increased memory efficiency.\n\nAssociate memory based retrieval offers fast and efficient recall and higher noise tolerance. This is an innovative approach to reduce memory footprint and computational overhead in continual learning.\n\nMemory-forgetting mechanism to remove more data from old tasks than new tasks.\n\nSeveral SOTA methods show improved performance when combined with proposed method, SHARC"
                },
                "weaknesses": {
                    "value": "Lack of experiments on high dimensional and large scale datasets e.g., ImageNet-1K. Many algorithms do not scale for large numbers of classes and high-dimensional inputs. It is 2023 and people have been using ImageNet for continual learning for at least 7 years. I'm assuming this is because they are starting with an ImageNet pre-trained backbone, but that is also a problem given the datasets studied. Mini-imageNet is not an appropriate test set using an ImageNet pre-trained backbone. MNIST and CIFAR are also extremely inappropriate. This is throwing a comparatively very powerful network at toy problems, where training its output layer alone likely yields extremely high results.\n\nThe model is only tested for an extreme edge case in continual learning (class incremental learning). Other distributions need to be studied, IID, etc. Given the neuroinspiration, this is especially important, but it conflates the goals of continual learning (knowledge accumulation over time) with the test (learning classes one at a time). An ideal continual learner should be robust to any data orderings including class incremental learning and IID.\n\nLimited representation learning. It keeps the feature backbone frozen and trains the classifier head and associative memory network. Thus the model has limitations in learning representations in hidden layers which might be necessary for learning new tasks.\nIt is unclear how model depth impacts retrieval performance, for example when we want to store and retrieve information in the earlier layers close to input.\n\nGiven ImageNet-1K pretrained backbone, selected datasets e.g., MNIST, CIFAR-10 / 100, and mini-ImageNet seem less challenging for a continual learner. It is also unclear how ImageNet-1K (224x224) pretrained network is used for small datasets consisting of lower resolution images (32x32).\n\nSince SHARC requires training associate memory unlike comparison methods. Comparing methods based on the same bounded compute (same amount of training updates) will be fairer.\n\nSometimes SHARC under-performs some baselines (Table 2 and Table 4). It is unclear if SHARC provides consistent performance gain across CL settings / methods/ datasets/ buffer sizes. It is claimed that DER++ equipped with SHARC achieves a 45.5% improvement in accuracy on S-CIFAR-100 but results in Table 2 do not support this claim.\n\nThe experiments and evaluation leave a great deal to be desired. Using an ImageNet-1K pre-trained backbone is fine, but then the experiments would need to be appropriate, for example, learning a dataset like iNaturalist or Places-365, and then trying multiple different distributions, including incremental class learning. Also, more experimental comparisons against recent methods and benchmarking in a fair way where all models are compared with the same setup would be more sound. \n\nThe method needs to demonstrate some sort of efficiency or other value in some sense.\n\nThe method is interesting, but the evaluation and experimental confounds mean the paper is not ready for publication. I encourage the authors to redesign their experiments, eliminate confounds, study multiple distributions, and to study much larger and more appropriate datasets. It requires relatively few resources to train an ImageNet-1K model and can be done with cloud computing for very little money."
                },
                "questions": {
                    "value": "In Fig.1, spatial information was retrieved but in the main experiment channel information was recovered. If you mask out spatial information, can you apply similar associate memory to retrieve complete information?\n\nWhat happens if you train more layers of DNN besides the final layer?\n\nWhat is the computational overhead for training associate memory? Does associate memory increase inference cost?\n\nHow do you initialize the last layer before continual learning begins?\n\nHow do you use ImageNet-1K (224x224) pretrained network for small datasets consisting of lower resolution images (32x32)?\n\nBesides Fig.1, do you have results to support the claims about fast and efficient recall and noise tolerance?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6396/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698737941628,
            "cdate": 1698737941628,
            "tmdate": 1699636708667,
            "mdate": 1699636708667,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "p2jw3HP6EJ",
                "forum": "GOiEdLIgVF",
                "replyto": "PSuwnVNdHr",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6396/Reviewer_WbsA"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6396/Reviewer_WbsA"
                ],
                "content": {
                    "comment": {
                        "value": "The authors have not provided a rebuttal, but I did review the comments from the other reviewers. My rating is unchanged."
                    }
                },
                "number": 1,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6396/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700669374455,
                "cdate": 1700669374455,
                "tmdate": 1700669374455,
                "mdate": 1700669374455,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "mWSExZrekk",
            "forum": "GOiEdLIgVF",
            "replyto": "GOiEdLIgVF",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6396/Reviewer_3N7Y"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6396/Reviewer_3N7Y"
            ],
            "content": {
                "summary": {
                    "value": "The paper introduces the Saliency-Guided Hidden Associative Replay (SHARC) framework, which combines associative memory with replay-based strategies to address catastrophic forgetting in Continual Learning. Firstly, SHARC archives only the most salient segments of data through sparse memory encoding, making it memory-efficient. Secondly, this paper proposes a content-centric memory retrieval module inspired by associative memory, enabling swift and impeccable recall capabilities. Extensive experimental results demonstrate the efficacy and superiority of the proposed SHARC framework for various continual learning tasks ."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "The paper introduces the novel Saliency-Guided Hidden Associative Replay (SHARC) framework, which combines associative memory with replay-based strategies to address catastrophic forgetting in Continual Learning. \nThe proposed SHARC framework demonstrates its effectiveness through extensive experimental results on various continual learning tasks, showcasing its superiority in mitigating forgetting and achieving better recall. \nThe structure of SHARC is sparsity, which is hardware-friendly and can lead to memory cost reduction instantly."
                },
                "weaknesses": {
                    "value": "The paper does not provide a comprehensive comparison with existing replay-based methods for Continual Learning, making it difficult to assess the superiority of the proposed framework.\nWhile the paper introduces a content-focused memory retrieval mechanism, it lacks detailed explanation and analysis of how this mechanism works and its impact on recall performance."
                },
                "questions": {
                    "value": "It would be beneficial to include a comprehensive comparison with existing replay-based methods for Continual Learning to highlight the advantages and limitations of the proposed framework.\nCould the authors provide a more detailed explanation and analysis of the content-focused memory retrieval mechanism introduced in the SHARC framework? This would help in understanding how this mechanism works and its impact on recall performance."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 5,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6396/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699024573209,
            "cdate": 1699024573209,
            "tmdate": 1699636708524,
            "mdate": 1699636708524,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "kBMdTnozIY",
                "forum": "GOiEdLIgVF",
                "replyto": "mWSExZrekk",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6396/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6396/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Additional Experiment and Methodology Explanation"
                    },
                    "comment": {
                        "value": ">**Q1.** *The paper does not provide a comprehensive comparison with existing replay-based methods for Continual Learning, making it difficult to assess the superiority of the proposed framework.*\n\n**A1.**\nThank you for your suggestion. Additional results have been added to the general response **above**.\n\n>**Q2.** *While the paper introduces a content-focused memory retrieval mechanism, it lacks detailed explanation and analysis of how this mechanism works and its impact on recall performance.*\n\n**A2.**\nAssociative memory is based on attractor dynamics, which refers to neuronal network dynamics dominated by groups of persistently active neurons. Generally, such persistent activation is associated with an attractor state of the dynamics, often in the form of a fixed point. This type of network can be used to implement associative memory by allowing the network's attractors to correspond to the vectors we want to store. This approach supports memory for specific items and differs from semantic memory in that it stores items quickly but does not represent the semantic structure of the data. Instead, attractor dynamics resembles working and episodic memory. Like episodic memory, it acts as an associative memory, returning stored values when triggered with the right cues. \nThe Hopfield network, originally proposed in 1982 (Hopfield, 1982), is a recurrent neural network that implements associative memory using fixed points as attractors. The function of the associative memory is to recognize previously learned input vectors, even in cases where some noise has been added. To achieve this function, every neuron in the network is connected to all the others (see Fig. 2.4(a)). Each neuron outputs discrete values, normally 1 or -1, according to the following equation:\nx_i(t+1) = sign(\u03a3_{j=1}^{N} w_{ij}x_j(t))  \nwhere x_i(t) is the state of the i-th neuron at time t, and N is the number of neurons. The Hopfield network has a scalar value associated with the state of all neurons x, referred to as the \"energy\" or Lyapunov function:\nE(x) = -1/2 \u03a3_{i=1}^{N} \u03a3_{j=1}^{N} w_{ij}x_i x_j   \nIf we want to store Q patterns x_p, p=1,2,...,Q, we can use the Hebbian learning rule (Hebb, 1962) to assign the values of the weights as follows:\nw_{ij} = \u03a3_{p=1}^{Q} x_p^i x_p^j  \nThis is equivalent to setting the weights to the elements of the correlation matrix of the patterns. Upon presentation of an input to the network, the activity of the neurons can be updated (asynchronously) according to Eq. (2.22) until the energy function has been minimized (Hopfield, 1982). Hence, repeated updates would eventually lead to convergence to one of the stored patterns. However, the network may possibly converge to spurious patterns (different from the stored patterns) as the energy in these spurious patterns is also a local minimum."
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6396/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700742749719,
                "cdate": 1700742749719,
                "tmdate": 1700742749719,
                "mdate": 1700742749719,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]