[
    {
        "title": "Synapse: Trajectory-as-Exemplar Prompting with Memory for Computer Control"
    },
    {
        "review": {
            "id": "8zycPyL01T",
            "forum": "Pc8AU1aF5e",
            "replyto": "Pc8AU1aF5e",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1312/Reviewer_bu8M"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1312/Reviewer_bu8M"
            ],
            "content": {
                "summary": {
                    "value": "This paper studies the problem of data driven computer control using large language models (LLM's). It adds three components to improve capabilities of current approaches. It abstracts from the state of the environment by parsing it via an LLM such that only information necessary for the task is kept. It conditions on complete trajectories of similar tasks. It keeps a memory from which similar example trajectories are sampled.  The method is compared against strong baselines on two current benchmarks in the field of data-driven computer control. It shows improved task success rate on both, while often needing less data. Ablations on each component of the method show that the state abstraction procedure is the main reason for the improved performance."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "The method is mostly explained well and it is easy to follow the explanation. Experiments and results are presented well.\n\nImproved task success rate on two benchmarks in the field of data driven computer control.\n\nCompetitive baselines from a variety of recent approaches in the domain of data driven computer control.\n\nAblations investigate the effect of each component of the method. \n\nThe state abstraction approach allows the method to be tested on tasks that were infeasible for prior methods."
                },
                "weaknesses": {
                    "value": "- From the results in the MindAct task it seems that adding any trajectories helps but it does not matter which ones.\n\n- Have you studied the effect on performance on the MiniWob++ environment for different amount of tasks in the memory. The comparison to RCI does not seem fair at the moment (Figure 3)?\n\n- It would be helpful to have an illustrating example of the result of the state abstraction procedure (i.e. a figure of a (state,observation)-pair) as well as an example prompt (maybe in the Appendix). Figure 1 only shows that some <body> and <h1> tag got removed but it's not yet clear to me what the result of the state abstraction procedure looks like. Its also not clear to me where the examples from the state abstraction prompt come from. Are they designed a-priori? If yes how and how difficult is that? Are the same examples reused for all states or also taken from the memory?\n\n- The text states (last paragraph of 4.3) that failed trajectories are displayed in Appendix C, but Appendix C only refers to the supplementary material?\n\n- In the original paper of MindAct, they used 3 in-context exemplars for GPT3.5  but Synapse uses 5, so the comparison favours Synapse. In general I would maybe add a sentence that clarifies that results are SOTA, conditioned on the fact that GPT3.5 was used as the underlying LLM."
                },
                "questions": {
                    "value": "- Have you considered building up the memory from scratch by adding successful trajectories over the course of training?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission1312/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1312/Reviewer_bu8M",
                        "ICLR.cc/2024/Conference/Submission1312/Senior_Area_Chairs"
                    ]
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1312/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698757450200,
            "cdate": 1698757450200,
            "tmdate": 1700472230391,
            "mdate": 1700472230391,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "Q1i8OTecmc",
                "forum": "Pc8AU1aF5e",
                "replyto": "8zycPyL01T",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1312/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1312/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer bu8M (1/2)"
                    },
                    "comment": {
                        "value": "We sincerely thank the reviewer for reading our paper and providing valuable insights.\n\n> **Q1.** From the results in the MindAct task it seems that adding any trajectories helps but it does not matter which ones.\n\n**A1.** It seems that there are some misunderstandings in our Mind2Web results. Let us elaborate on the results here.\n\n- In `SYNAPSE w/ state abstraction`, we simply adopt state abstraction principles to direct generation (with fewer top-ranked elements in clean observations), which outperforms the MCQ-formatted prompting used in MindAct. Here, we use the same exemplars as those used in the MindAct, but the format is changed from selecting an answer from multiple choices to directly generating the action, and we do not recursively select one answer from five candidates until only one is left in the top-50 elements. Instead, we directly generate the action based on abstracted states with the top-5 elements.\n- The `SYNAPSE w/ state abstraction + TaE` variant integrates TaE prompting on top of state abstraction, where we replace the original prompting format with trajectories. The results show the benefits of using trajectories as exemplars. In both these two variants, we use **static** few-shot exemplars, i.e., the exemplars are the same for all tasks during evaluation. This is the standard paradigm of few-shot learning, where we provide examples of input and output for LLMs. The performance lift does not result from \"adding any trajectories\". It is due to the change in the exemplar format.\n- In `SYNAPSE w/ state abstraction + TaE + memory`, we encode the training set as the memory and apply similarity search to match trajectories from similar tasks, which continues to improve performance. This also showcases that adding relevant trajectories as exemplars can be beneficial compared to \"adding any trajectories\".\n\nWe have updated the caption of Table 1 to clarify these details.\n\n> **Q2.** Have you studied the effect on performance on the MiniWob++ environment for different amount of tasks in the memory. The comparison to RCI does not seem fair at the moment (Figure 3)?\n\n**A2.** It is noteworthy that RCI solves 54 tasks with exemplars from 54 tasks, while Synapse solves 64 tasks with exemplars from 48 tasks, including challenging ones that RCI cannot solve, such as book-flight. The average number of exemplars per task for RCI and Synapse is 1.32 and 3.45, respectively. However, the number of exemplars for each task varies. For simple tasks, we use a similar number of exemplars as in RCI. To solve complex tasks (e.g., book-flight), we use more exemplars, which lowers the average data efficiency. For example, in book-flight, we include 5 exemplars for better robustness. Moreover, RCI relies on self-correction and our method does not. They proposed several self-correction modules (task/state/agent grounding), and their success rate will decrease by around 50% without either one of them, according to their paper [1]. Also, one of the benefits of our method is that we can leverage more exemplars in-context because of state abstraction."
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1312/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700246883821,
                "cdate": 1700246883821,
                "tmdate": 1700246883821,
                "mdate": 1700246883821,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "DEAlJ7HocC",
                "forum": "Pc8AU1aF5e",
                "replyto": "8zycPyL01T",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1312/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1312/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer bu8M (2/2)"
                    },
                    "comment": {
                        "value": "> **Q3.** It would be helpful to have an illustrating example of the result of the state abstraction procedure (i.e. a figure of a (state,observation)-pair) as well as an example prompt (maybe in the Appendix). Figure 1 only shows that some `<body>` and `<h1>` tag got removed but it's not yet clear to me what the result of the state abstraction procedure looks like. Its also not clear to me where the examples from the state abstraction prompt come from. Are they designed a-priori? If yes how and how difficult is that? Are the same examples reused for all states or also taken from the memory?\n\n**A3.** We have reorganized Sec. 3.2 to clarify the state abstraction procedure and included more examples in Appendix C for illustrations. Fig. 1 aims to show that raw states can be very long-winded, which we omitted in  `<h1>\u2026` , while clean observations are much more concise with only task-relevant information, like `<input id=\"where\" type=\"text\">`.\n\nIn MiniWoB++, there are two types of state abstraction prompts:\n\n- For scenarios where the context can handle multiple states, we utilize state-observation pairs \u27e8state, observation\u27e9. These pairs are collected alongside the trajectories. The states are obtained from the environment, while the cleaned observations are provided by humans. To further reduce human efforts, we can also automatically infer cleaned observations given trajectories using LLMs [2].\n\n- In scenarios with complex states where explicit abstraction is not applicable, we implicitly abstract states by pairing task descriptions and state-parsing code, denoted as \u27e8task, code\u27e9. Similarly, the task descriptions are already given by the environment. The code here is collected via zero-shot sampling from LLMs (GPT-4) plus validation. This data collection pipeline can also be augmented with LLMs to reduce human effort.\n\nThe state abstraction prompts are retrieved from the memory, together with action generation prompts (trajectories).\n\nIn fact, one of the advantages of trajectory-as-exemplars over other methods is that it is simple and scalable to convert human demonstrations into exemplars (as they are already trajectories), without much human effort in designing promptings like multi-choice question-answering or high-level semantic plans in natural language.\n\n> **Q4.** The text states (last paragraph of 4.3) that failed trajectories are displayed in Appendix C, but Appendix C only refers to the supplementary material?\n\n**A4.** We have added trajectories of both successful (terminal and book-flight) and failed (text-transform and Mind2Web) cases in Appendix C.\n\n> **Q5.** In the original paper of MindAct, they used 3 in-context exemplars for GPT3.5 but Synapse uses 5, so the comparison favours Synapse. In general I would maybe add a sentence that clarifies that results are SOTA, conditioned on the fact that GPT3.5 was used as the underlying LLM.\n\n**A5.** The comparisons are fair because Synapse also uses three in-context exemplars, the same number of exemplars as MindAct. The $k=5$ refers to the number of elements after state abstraction. The reviewer's misunderstanding may come from our abuse of the notation $k$ for both top-$k$ memory retrieval and top-$k$ state abstraction. We have updated the notation for memory to top-$n$ to avoid misunderstanding.\n\nTo investigate how Synapse performs on other language models, we added the Mind2Web experiments on CodeLlama-7B in Table 1, where Synapse outperforms MindAct with a 2.5x average step success rate across three levels of generalization (cross-task, cross-website, and cross-domain). These results are consistent with the results with GPT-3.5 as the underlying LLM.\n\n> **Q6.** Have you considered building up the memory from scratch by adding successful trajectories over the course of training?\n\n**A6.** Thank you for this suggestion. It would be interesting to explore this aspect. However, in this work, we mainly investigate the design choices around few-shot exemplars, including state abstraction, trajectory-as-exemplar, and exemplar memory. Therefore, we initialize the memory with existing exemplars and fix it during experiments. In fact, Synapse complements existing methods that build up memory during the agent's interaction with the environment [3]. Specifically, our method can guide the collection of exemplars and the format to store them. It is definitely interesting to integrate trajectory exemplars into open-ended learning agents. Another direction for future work is to query human intervention and add their demonstrations into the memory when the similarity score is low, i.e., the agent is faced with unfamiliar situations.\n\n[1] Kim et al. \"Language models can solve computer tasks.\" NeurIPS 2023.\n\n[2] He et al. \"Annollm: Making large language models to be better crowdsourced annotators.\" *arXiv preprint arXiv:2303.16854* (2023).\n\n[3] Wang et al. \"Voyager: An open-ended embodied agent with large language models.\" arXiv preprint arXiv:2305.16291 (2023)."
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1312/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700247475706,
                "cdate": 1700247475706,
                "tmdate": 1700247475706,
                "mdate": 1700247475706,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "tLsBteh1va",
                "forum": "Pc8AU1aF5e",
                "replyto": "8zycPyL01T",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1312/Reviewer_bu8M"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1312/Reviewer_bu8M"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your detailed replies. \n\nA1: Maybe \"adding\" was not a very precise formulation but I think my main point is that the relative performance improvement from switching to trajectories as exemplars is large while the performance improvement to choosing trajectories dynamically via the memory is marginal.\n\nA2: I think this makes it clear to me that the comparison is fair. I would maybe add a sentence that the difference in exemplars per task between RCI and Synapse comes from using more exemplars for difficult tasks that RCI cannot solve. \n\nA3: It could be valuable to have some overview of human effort required by different approaches (maybe in the Appendix) to  make it clear on how much engineering each of the approaches relies on. The validation part when GPT-4 is required to produce code is done by humans or by running the code on some tests? \n\nA4: I think, that makes it very clear how large the reduction in the state representation is due to abstraction. \n\nA5: Yes, I mixed up these two values, thanks. \n\nA6: Thanks. \n\nSince my main concerns have been resolved, I will update my rating."
                    }
                },
                "number": 10,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1312/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700470873070,
                "cdate": 1700470873070,
                "tmdate": 1700472159954,
                "mdate": 1700472159954,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "ElJSw0BJhH",
            "forum": "Pc8AU1aF5e",
            "replyto": "Pc8AU1aF5e",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1312/Reviewer_mGYB"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1312/Reviewer_mGYB"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes a new technique to prompt language models with example trajectories for computer control tasks. It utilizes language models to abstract clean states for long-context conditioning, and design a retrieval module to improve generalization."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. The writing and presentation is clear in general\n2. The proposed method surpassed baselines like CC-Net, RCI on various benchmark like MiniWoB++ and Mind2Web"
                },
                "weaknesses": {
                    "value": "1. Some details are not well explained, see questions."
                },
                "questions": {
                    "value": "1. SYNAPSE uses state abstraction to make sure LLM can learn from compact information while ensuring the context length is well utilized. However, in the experiments, SYNAPSE sets k=5 for retrieval. How does the performance change if k grows? And why longer context is not helping here?\n\n2. Table 1 seems confusing. It's non-standard to use \"SYNAPSE w/ state abstraction, SYNAPSE w/ trajectory-as-exemplar, SYNAPSE w/ training set as memory\" to indicate gradually adding \"state abstraction, trajectory-as-exemplar, training set as memory\" 3 components. If you want to demonstrate a component *A* is useful, better to write it in \"SYNAPSE w/o *A*\", as SYNAPSE is a method that combines all components\n\n3. For Table 1 training set as memory experiments, do you add all the training data for 3 scenarios (\"cross-task, cross-web, and cross-domain)? Or only the corresponding training data (e.g. cross-task but same web when evaluated on cross-task setting).\n\n4. For tasks that need code to abstract state information, how can you examine if a code can successfully extract desired information? if examined from task success, it can be because of the suboptimal execution of policy.\n\n5. For the cross-domain tasks, retrieval doesn't seem to help, can you give a better explanation about this result? The retrieval number is set to 5, which is a small number. Is it because the retriever doesn't return the desired examples? Maybe showing some retrieved examples can be more intuitive.\n\n6. \"The action generation starts from prompting LLMs with successful trajectories to warm up LLMs\nwith the dynamics of the current environment\". Is it describing prompting with retrieved trajectories? Or that's some other warmup procedure? If it's cross-task/cross-web/cross-domain setting, how's current environment defined?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1312/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699373153321,
            "cdate": 1699373153321,
            "tmdate": 1699636058594,
            "mdate": 1699636058594,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "tRcrYqGpsW",
                "forum": "Pc8AU1aF5e",
                "replyto": "ElJSw0BJhH",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1312/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1312/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer mGYB (1/2)"
                    },
                    "comment": {
                        "value": "We sincerely thank the reviewer for reading our paper and providing valuable insights.\n\n> **Q1.** SYNAPSE uses state abstraction to make sure LLM can learn from compact information while ensuring the context length is well utilized. However, in the experiments, SYNAPSE sets k=5 for retrieval. How does the performance change if k grows? And why longer context is not helping here?\n\n**A1.** As suggested by the reviewer, we have added Fig. 7 in the appendix to ablate the performance with different $k$ (the number of elements in the observation after abstraction). The performance drops as $k$ grows, even though the recall@$k$ becomes higher (the probability of the correct element appearing in the observation). There are two possible explanations: i) more irrelevant information poses challenges in selecting correct ones [1,2], ii) current LLMs struggle to handle long context, e.g., the performance gets worse as the input context grows longer [3].\n\n> **Q2.** Table 1 seems confusing. It's non-standard to use \"SYNAPSE w/ state abstraction, SYNAPSE w/ trajectory-as-exemplar, SYNAPSE w/ training set as memory\" to indicate gradually adding \"state abstraction, trajectory-as-exemplar, training set as memory\" 3 components. If you want to demonstrate a component A is useful, better to write it in \"SYNAPSE w/o A\", as SYNAPSE is a method that combines all components\n\n**A2.** Synapse integrates the three components\u2014state abstraction, trajectory-as-exemplar, and memory in a specific sequence. State abstraction shrinks the length of states and thereby trajectories, which is the prerequisite for trajectory-as-exemplar prompting. Similarly, the memory stores exemplary trajectories as basic units. We believe that the current results of gradually adding components are enough to validate the effectiveness of the three components.\n\n> **Q3.** For Table 1 training set as memory experiments, do you add all the training data for 3 scenarios (\"cross-task, cross-web, and cross-domain)? Or only the corresponding training data (e.g. cross-task but same web when evaluated on cross-task setting).\n\n**A3.** The Mind2Web dataset is split into a training set and three test sets: Cross-Task, Cross-Website, and Cross-Domain, to evaluate generalizability over tasks from the same websites, unseen websites from similar domains, and completely unseen domains in the training set, respectively. We only store the training set in the memory. All three cross-* test sets are not stored in the memory. We have added these details in Sec. 4.1, and provided detailed descriptions of these dataset splits in Appendix B.2.\n\n> **Q4.** For tasks that need code to abstract state information, how can you examine if a code can successfully extract desired information? if examined from task success, it can be because of the suboptimal execution of policy.\n\n**A4.** If the code execution raises an error, we ask the LLM to perform zero-shot\nstate abstraction, i.e., directly abstracting state information without any exemplars. For simplicity, we did not introduce any success detection or self-correction to examine what components caused the failure, which is not our core contribution. When the task fails, we directly stop and mark the task as a failure. This detail has been updated in Sec. 3.2."
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1312/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700245848314,
                "cdate": 1700245848314,
                "tmdate": 1700245848314,
                "mdate": 1700245848314,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "yGqLsGImab",
                "forum": "Pc8AU1aF5e",
                "replyto": "ElJSw0BJhH",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1312/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1312/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer mGYB (2/2)"
                    },
                    "comment": {
                        "value": "> **Q5.** For the cross-domain tasks, retrieval doesn't seem to help, can you give a better explanation about this result? The retrieval number is set to 5, which is a small number. Is it because the retriever doesn't return the desired examples? Maybe showing some retrieved examples can be more intuitive.\n\n**A5.** After carefully examining the results, we found that there is a minor calculation error. The results have been updated in Table 1. However, the conclusion that memory does not help much in cross-domain tasks still holds. We also added experiments on CodeLlama-7B to validate the conclusion. We have added Table 2 in Sec. 4.5 to visualize the distance between retrieved exemplars and the tasks for cross-task, cross-website, and cross-domain test sets. As shown in Table 2, as the distance becomes larger, i.e., less similarity, the performance gain ($\\Delta$Step SR) becomes worse. As discussed in Sec. 4.5, this might be attributed to the LLM being influenced by exemplars from completely unrelated domains.\n\nThe number of few-shot exemplars is actually 3, the same as used in the baseline. We noticed that we abused the notation $k$ for both the top-$k$ parameter in memory retrieval and the top-$k$ parameter in Mind2Web state abstraction, and we have updated the notation for memory retrieval to top-$n$ to avoid misunderstanding. Intuitively, deciding the number of exemplars is a tradeoff between performance and context limits. Adding more exemplars can lead to better performance, but it also uses more tokens. As discussed in A1, current LLMs have limited context and struggle to perform well when the context is long. Three-shot learning is a suitable balance, ensuring a fair comparison with the baseline and taking into account both sides of the issue.\n\n> **Q6.** \"The action generation starts from prompting LLMs with successful trajectories to warm up LLMs with the dynamics of the current environment\". Is it describing prompting with retrieved trajectories? Or that's some other warmup procedure? If it's cross-task/cross-web/cross-domain setting, how's current environment defined?\n\n**A6.** We only prompt with retrieved exemplary trajectories. There is no other warmup procedure. The environment here refers to the observation and action space. In cross-task/cross-website/cross-domain settings, these spaces remain consistent. To avoid misunderstanding, we have deleted this expression from the paper.\n\n[1] Gur et al. \"A real-world webagent with planning, long context understanding, and program synthesis.\" arXiv preprint arXiv:2307.12856 (2023).\n\n[2] Deng et al. \"Mind2Web: Towards a Generalist Agent for the Web.\" NeurIPS 2023.\n\n[3] Liu et al. \"Lost in the middle: How language models use long contexts.\" arXiv preprint arXiv:2307.03172 (2023)."
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1312/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700246135970,
                "cdate": 1700246135970,
                "tmdate": 1700246135970,
                "mdate": 1700246135970,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "NM6dRxDVIt",
            "forum": "Pc8AU1aF5e",
            "replyto": "Pc8AU1aF5e",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1312/Reviewer_z7sh"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1312/Reviewer_z7sh"
            ],
            "content": {
                "summary": {
                    "value": "This paper presents a prompting-based method (SYNAPSE) for computer control that takes in states and outputs actions in a discrete, human-computer-interaction-like action space. The paper is motivated by gaps in existing computer control methods: in-context learning, which struggles with long-horizon tasks and generalization and often needs post-hoc correction; and trained/fine-tuned methods, which are data- and compute-inefficient.\n\nSYNAPSE consists of three components: a state abstraction procedure in which an LLM is used to extract important information from the raw state, thereby significantly reducing token length; \"trajectories as exemplars\" (TaE) prompting, in which full, relevant trajectories (sequences of clean states and actions) are added to the prompt for generating each new action; and exemplar memory in which trajectories and their associated tasks are encoded and stored, to be used as exemplar trajectories when a related task is being planned. \n\nExperiments are conducted on MiniWoB++ and Mind2Web. The MiniWoB++ experiments show SYNAPSE's major data efficiency (and moderate performance) gains over BC+RL and finetuning baselines, as well as performance and simplicity gains over ICL baselines. The Mind2Web experiments demonstrate the same, along with its generalization capability across tasks, websites, and domains. SYNAPSE beats SOTA on various tasks from MiniWoB++, including notably difficult ones for which human-level performance is not achieved by prior work."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "#### Quality\n- Method is intuitive and effective\n- Experimental setup is useful. It is useful to have one standard benchmark with extensive comparison to baselines and one realistic benchmark on which more qualitative advantages like generalization are shown. \n- Results are promising - the similarity to human performance on MiniWoB++ and the significant increases on generalization show the power of SYNAPSE's TaE and exemplar memory components. \n- Ablations are useful as well to concretely break down each component of the approach. \n- Overall a well-constructed, well-executed paper. \n\n#### Clarity\n- Very well written!\n- Figures are especially useful compared to a lot of papers. Tables as well. Overall, results are not only promising but well-communicated. \n\n#### Originality\nThe paper positions itself well in prior work. As far as I am aware, the specific three components used here have not been combined elsewhere. \n\n#### Significance\nThe performance on existing computer control benchmarks is impressive, especially when comparing to human baselines. Figure 4 particularly tells a story of a significant improvement in capability. The results on MiniWoB++ show only some improvement, so it's unclear how significantly SYNAPSE distinguishes itself, but the results on Mind2Web show a lot of improvement margin."
                },
                "weaknesses": {
                    "value": "#### Quality\n- The same ideas (gaps in prior work, the three components and their descriptions, the benchmarks being used) are repeated several times throughout the paper. While I very much agree that some amount of repetition is crucial to get a reader to understand what you are saying, in this case it's not just two or three times but four or five, or even if it's three, there's lots of detail every time. It feels as though the repetition is there to fill up space, even if that's not really the case. It gets tiring to read the same high-level concepts over and over. \n\n#### Clarity\n- I don't quite understand what \"step success rate\" is as opposed to \"success rate\" - it's brought up several times as the metric for Mind2Act, but not defined as far as I'm aware.\n- It doesn't seem to be made clear what exactly the state abstraction entails. In figure 1, the only difference between \"raw state\" and \"clean state\" is `<body><h1>\u2026</h1></body>\u201d --> <input id=\u201dwhere\u201d type=\u201dtext\u201d>`. There aren't clear examples in the main text, but intuition about this would be very useful. \n- Not clear how SYNAPSE's history-in-prompt approach is significantly different from Mind2Act's (or lots of other works') to the point of being novel. \n- From both Fig 1 and the text, it's unclear when new trajectory exemplars and example state abstractions are generated - is it per task (that's what I'd think) or per step? \n- Fig 3: might help to have clearer visual distinction of SYNAPSE and the human baseline, especially since the colors aren't always visible. Lines/shading/callout boxes could help. \n\n#### Originality\nThough the approach is technically unique and clearly effective, there are some originality concerns in terms of what the paper claims. For example, the paper positions itself against works like Inner Monologues and SayCan by saying that they focus on high-level planning; however, though RCI uses *even higher* level planning, SYNAPSE is still working with a discrete, abstract action space. Meanwhile, the low-level BC/RL/motion planning+control used for the robotics papers cited are operating in a much more granular, potentially continuous, action space. For another example, the paper spends considerable space discussing how it is unique compared to other prompting-based methods in helping the LLM understand the current state. However, MindAct gives trajectory-so-far back to the LLM when prompting for the next step. SYNAPSE gives observation as well, thereby informing the LLM in more detail about the current state, this just isn't a very original idea. It's an important step past MindAct, but not a big one, especially relative to how much it's discussed as a unique contribution. \n\n\nNits:\n- Page 5, last paragraph: `Obseravtion` is a misspelling"
                },
                "questions": {
                    "value": "- What exactly is step success rate vs. success rate?\n- It is inherently interesting that this approach does not need self-correction unlike other prompting-based approaches, but does that offer any significant performance/efficiency gain?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1312/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699431015141,
            "cdate": 1699431015141,
            "tmdate": 1699636058517,
            "mdate": 1699636058517,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "3FlbWzRDAF",
                "forum": "Pc8AU1aF5e",
                "replyto": "NM6dRxDVIt",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1312/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1312/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer z7sh (1/3)"
                    },
                    "comment": {
                        "value": "We sincerely thank the reviewer for reading our paper and providing valuable insights.\n\n> **Q1.** The same ideas (gaps in prior work, the three components and their descriptions, the benchmarks being used) are repeated several times throughout the paper. While I very much agree that some amount of repetition is crucial to get a reader to understand what you are saying, in this case it's not just two or three times but four or five, or even if it's three, there's lots of detail every time. It feels as though the repetition is there to fill up space, even if that's not really the case. It gets tiring to read the same high-level concepts over and over.\n\n**A1.** As suggested by the reviewer, we have improved the presentation in the revised version to reduce repetition and include more details about our methods and experiments in response to the questions from reviewers.\n\n> **Q2.1.** I don't quite understand what \"step success rate\" is as opposed to \"success rate\" - it's brought up several times as the metric for Mind2Act, but not defined as far as I'm aware.\n\n**A2.1.** In Mind2Web, each step of a task is evaluated separately against the human-annotated ground truth. The step success rate (Step SR) relates to how well the action at each step is performed, whereas the success rate (SR) reflects the success of the entire task, also known as the episode success rate. For example, to complete the task \"Show me the reviews for the nearest auto repair business.\", the agent has to execute several steps, including typing the search query and clicking through to find the reviews. If all steps in the task are successful, then the task is considered successful. The definition of these metrics has been added in Sec. 4.1.\n\n> **Q2.2.** It doesn't seem to be made clear what exactly the state abstraction entails. In figure 1, the only difference between \"raw state\" and \"clean state\" is `<body><h1>\u2026</h1></body>\u201d --> <input id=\u201dwhere\u201d type=\u201dtext\u201d>`. There aren't clear examples in the main text, but intuition about this would be very useful.\n\n**A2.2.** We have reorganized Sec. 3.2 to clarify the state abstraction procedure and included more examples in Appendix C for illustrations. Fig. 1 aims to show that raw states can be very long-winded, which we omitted in  `<h1>\u2026` , while clean observations are much more concise with only task-relevant information, like `<input id=\"where\" type=\"text\">`."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1312/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700243668469,
                "cdate": 1700243668469,
                "tmdate": 1700243668469,
                "mdate": 1700243668469,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "bE7xSvFIVP",
                "forum": "Pc8AU1aF5e",
                "replyto": "NM6dRxDVIt",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1312/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1312/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer z7sh (2/3)"
                    },
                    "comment": {
                        "value": "> **Q2.3.** Not clear how SYNAPSE's history-in-prompt approach is significantly different from Mind2Act's (or lots of other works') to the point of being novel.\n\n**A2.3.** Directly providing trajectories (with multiple states-action pairs) results in very long contexts, as a single webpage state is already very complex. However, current LLMs can only process limited context, and the performance becomes worse as the context becomes longer. As a result, existing computer agents such as RCI and MindAct do not and **CANNOT** utilize **trajectories** as historical information. Instead, their history only consists of **actions**. In comparison, our state abstraction shrinks the length of each state, which is a prerequisite for trajectory-as-exemplar (TaE) prompting.\n\nIt is clear that TaE prompting **provides more information** for decision-making. More importantly, TaE prompting uses an interleaved observation-action format, which offers the following advantages over previous prompting schemes.\n\n- **Temporal abstraction**. The interleaved prompt scheme implicitly prompts the LLM to generate multiple actions and query new states only when necessary, as shown in Fig. 2. This significantly improves the success rate of long-horizon tasks in MiniWoB++. In contrast, RCI and MindAct cannot prompt LLMs to generate temporally abstracted actions.\n- **Lower cost and latency** (compared to MindAct). MindAct introduces accumulated error and much higher cost and latency. Specifically, it first filters the top-50 elements with a ranking model. After that, it recursively samples five elements and prompts the LLM to select one from the five until only one is left. As a result, MindAct uses an average of 10x more tokens compared to Synapse in the three test sets of Mind2Web.\n- **Simplified action parsing**. TaE prompting is more effective in prompting LLMs to generate actions in a specific format, which allows easily parsing actions from LLM responses, leading to fewer action parsing errors than other prompting approaches. Additionally, we can set the stop token to \"Observation\" when querying actions so that the LLM does not generate other information.\n- **Simplified data collection**. Compared to high-level semantic plans or multi-choice questions that are human-crafted in natural language, our approach makes data collection simpler and scalable. The exemplary trajectories can be converted directly from human demonstrations, and the state abstraction prompts can also be inferred from the action with minimal human effort.\n\nIn short, our approach is straightforward and very effective, rendering it universally applicable to current agents without much effort.\n\n> **Q2.4.** From both Fig 1 and the text, it's unclear when new trajectory exemplars and example state abstractions are generated - is it per task (that's what I'd think) or per step?\n\n**A2.4.** The trajectory exemplars are used per task. We explained the pipeline of Synapse at the beginning of Sec. 3. Given a task, Synapse retrieves trajectories of similar tasks from memory, which will be fixed during the task execution. We have also added some illustrative trajectories in Appendix C.\n\n> **Q2.5.** Fig 3: might help to have clearer visual distinction of SYNAPSE and the human baseline, especially since the colors aren't always visible. Lines/shading/callout boxes could help.\n\n**A2.5.** Although we agree with the reviewer, it is difficult to adjust the plot. The box plot of Synapse is almost visible because our method is robust and has relatively low variance."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1312/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700244215828,
                "cdate": 1700244215828,
                "tmdate": 1700244215828,
                "mdate": 1700244215828,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "RvAc1eyqJ3",
                "forum": "Pc8AU1aF5e",
                "replyto": "NM6dRxDVIt",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1312/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1312/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer z7sh (3/3)"
                    },
                    "comment": {
                        "value": "> **Q3.1.** Though the approach is technically unique and clearly effective, there are some originality concerns in terms of what the paper claims. For example, the paper positions itself against works like Inner Monologues and SayCan by saying that they focus on high-level planning; however, though RCI uses even higher level planning, SYNAPSE is still working with a discrete, abstract action space. Meanwhile, the low-level BC/RL/motion planning+control used for the robotics papers cited are operating in a much more granular, potentially continuous, action space.\n\n**A3.1.** The action spaces we used in MiniWoB++ and Mind2Web align with baseline LLM-powered computer agents [1,2]. The difference we want to highlight is not the granularity of planning or action space. Instead, we propose a prompting scheme that is more effective for action grounding, while Inner Monologues, SayCan, and RCI focused on prompting schemes for better high-level plan generation. Specifically, the robotics methods (Inner Monologues and SayCan) need low-level BC/RL policies to ground high-level plans generated by LLMs into motor control actions because using LLMs for direct robot control is challenging (and unnecessary). The planning granularity of RCI is similar to Inner Monologues and SayCan, but applied in computer control. Therefore, it also requires additional grounding steps to translate high-level plans into executable keyboard-mouse actions. However, the low-level computer actions are highly semantic and can be generated with LLMs, which is quite different from motor control in robotics. However, the suitable prompting scheme here remains unexplored. We have updated this discussion in Sec. 2.\n\n> **Q3.2.** For another example, the paper spends considerable space discussing how it is unique compared to other prompting-based methods in helping the LLM understand the current state. However, MindAct gives trajectory-so-far back to the LLM when prompting for the next step. SYNAPSE gives observation as well, thereby informing the LLM in more detail about the current state, this just isn't a very original idea. It's an important step past MindAct, but not a big one, especially relative to how much it's discussed as a unique contribution.\n\n**A3.2.** While we appreciate the reviewer\u2019s feedback, we respectfully have a different view. We believe our approach is a unique and original contribution to the field due to the reasons discussed in **A2.3**.\n\n> **Q4.** Page 5, last paragraph: Obseravtion is a misspelling\n\n**A4.** Thank you for pointing this out. This typo has been corrected.\n\n> **Q5.** It is inherently interesting that this approach does not need self-correction unlike other prompting-based approaches, but does that offer any significant performance/efficiency gain?\n\n**A5.** Our non-self-correction approach outperforms self-correction baselines, which means that ours has better robustness and lower latency. In fact, Synapse is orthogonal to self-correction methods. We did not add self-correction because it is not our core contribution, and our approach already achieves SOTA performance without it. In contrast, RCI proposed several self-correction modules (task/state/agent grounding), and their average success rate will decrease by around 50% without either one of them, according to their paper [1].\n\n[1] Kim et al. \"Language models can solve computer tasks.\" NeurIPS 2023.\n\n[2] Deng et al. \"Mind2Web: Towards a Generalist Agent for the Web.\" NeurIPS 2023."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1312/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700244861374,
                "cdate": 1700244861374,
                "tmdate": 1700244861374,
                "mdate": 1700244861374,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]