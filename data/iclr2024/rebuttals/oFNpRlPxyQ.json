[
    {
        "title": "MSPipe: Minimal Staleness Pipeline for Efficient Temporal GNN Training"
    },
    {
        "review": {
            "id": "1HAp7lpOj4",
            "forum": "oFNpRlPxyQ",
            "replyto": "oFNpRlPxyQ",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4465/Reviewer_a7Lb"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4465/Reviewer_a7Lb"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes a pipeline scheduling framework, MSPipe, for memory-based TGNN training. The authors discuss the minimal number of staleness iterations and utilize the scheduler to delay memory fetching and prevent resource contention. Experiments validate that the proposed method achieves significant speedup with less accuracy degradation."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1. This paper proposed a formulation for TGNN training pipeline and discussed the bottlenecks of the memory module and temporal dependencies. They designed a minimal staleness algorithm and lightweight staleness mitigation method for speeding up TGNN training with less accuracy loss. They also analyzed theoretical convergence to prove the robustness of the proposed method.\n\n2. The structure of the paper is clear and easy to follow.\n\n3. The experimental results are quite extensive."
                },
                "weaknesses": {
                    "value": "1. The scale of the figures should be corrected. Especially in Figure 12. And some of the figures are out of text bound.\n\n2. In Experiments, as different datasets have different distributions of \\delta t, how can we find an optimal hyperparameter of \\lambda? This parameter selection should be discussed.\n\n3. Although the authors discuss the optimization and asynchronous training from previous work, the proposed method is still easy. The contribution seems insufficient."
                },
                "questions": {
                    "value": "Please see above."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4465/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698596464795,
            "cdate": 1698596464795,
            "tmdate": 1699636422161,
            "mdate": 1699636422161,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "Z2dsuiSvCv",
                "forum": "oFNpRlPxyQ",
                "replyto": "1HAp7lpOj4",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer a7Lb"
                    },
                    "comment": {
                        "value": "Thank you for your detailed review. We would like to address the weakness you raised and clarify any potential misunderstandings.\n\n> Weakness1: correct the scale of figures especially Figure 12.\n\nWe appreciate the detailed review. We have fixed all the scale problems in the paper and the latest version of the paper is updated.\n\n\n\n> Weakness2: as different datasets have different distributions of \\delta t, how can we find an optimal hyperparameter of \\lambda? This parameter selection should be discussed.\n\nWe want to modestly point out that we have indeed included a hyperparameter analysis in Section 4.4 of our paper. Due to space limitations, we only include the results of the LastFM dataset. However, we find that all the datasets exhibit a similar trend to the results shown for the LastFM dataset. Therefore, the insights into the optimal selection of \u03bb across different datasets are applicable to most datasets:\n\n- Specifically, selecting a larger value of \u03bb (e.g., \u03bb > 0.8) tends to improve the model performance. This suggests that retaining a greater proportion of the original stale memory representations and applying a smaller amount of mitigation from similar ones is beneficial.\n- On the other hand, choosing a smaller value of \u03bb (e.g., \u03bb < 0.5) can lead to oversmoothing of node memories by other nodes, thereby degrading the model performance.\n\n\n\n> Weakness3: Although the authors discuss the optimization and asynchronous training from previous work, the proposed method is still easy. The contribution seems insufficient\n\nWe respectfully disagree with the reviewer\u2019s assessment of the contribution of our study, and would like to put forth a few points to assert that our contribution is sufficient:\n\n- MSPipe is a novel framework specifically designed to accelerate the TGNN training process. To the best of our knowledge, we are the first to address the bottlenecks of the memory module and provide effective system-algorithm co-design methods to accelerate the TGNN training process, as discussed in Section 2. The comprehensive contributions of MSPipe are summarized in Section 1.\n- The recent surge of advancements in TGNNs underscores the significance of TGNN training within the research community. Notably, the superior model accuracy achieved by memory-based TGNNs [1] further demonstrates the significance of our contribution to accelerating the training process.\n- MSPipe offers accelerated model development speed, saving valuable time for researchers and engineers who would otherwise be waiting for lengthy training processes. MSPipe exhibits superior performance, such as a 2.45\u00d7 speedup, compared to the existing state-of-the-art framework TGL. It surpasses TGL even with more advanced optimizations from the SOTA static GNN framework while maintaining the model's performance.\n- The training paradigms, bottlenecks, challenges, and dependencies in previous asynchronous training works are entirely different from TGNN training (as detailed in Appendix B). Consequently, these methods cannot be directly applied to expedite TGNN training, highlighting the importance of our contribution to the TGNN training field.\n\nIn conclusion, considering the significance and distinctive nature of TGNN research, and the lack of exploration in accelerating TGNN training, we firmly believe that our study brings valuable contributions, novelty, and sufficient advancements to the field.\n\n[1] Farimah Poursafaei, et.al. Towards better evaluation for dynamic link prediction. In Neural Information Processing Systems (NeurIPS) Datasets and Benchmarks, 2022."
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4465/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700040737791,
                "cdate": 1700040737791,
                "tmdate": 1700040737791,
                "mdate": 1700040737791,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "IXRyFNk2g6",
                "forum": "oFNpRlPxyQ",
                "replyto": "1HAp7lpOj4",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Gentle reminder of Reviewer a7Lb"
                    },
                    "comment": {
                        "value": "Thank you again for the feedback on our paper. We hope that our responses have addressed your inquiries and concerns. If this is not the case, please inform us and we would be glad to engage in further discussion."
                    }
                },
                "number": 13,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4465/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700469452319,
                "cdate": 1700469452319,
                "tmdate": 1700469452319,
                "mdate": 1700469452319,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "KlH8eogRb7",
            "forum": "oFNpRlPxyQ",
            "replyto": "oFNpRlPxyQ",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4465/Reviewer_Vi4E"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4465/Reviewer_Vi4E"
            ],
            "content": {
                "summary": {
                    "value": "This paper, MSPipe, targets a timely problem: acceleration of (distributed) TGN training. MSPipe considers the 'memory update' procedure in the TGN training, which is the main bottleneck of the TGN training acceleration, and proposes two main ideas. In the baseline optimization, MSPipe overlaps the subgraph sampling and feature fetching. On top of it, first, it uses a staleness-based method to break the TGN memory dependency. Additionally, online scheduling minimizes the staleness bound. Second, using the similarity among vertices, it proposes a staleness mitigation method, which reduces the impact of staleness. With overlapping optimization, staleness-based strategy, and staleness mitigation, MSPipe provides a significant speedup from 1.50 to 2.45x."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "+ Adequately analyzed the training pipeline of TGNN training and accelerated it. While not very novel, this provides a reasonable and well-designed solution.\n+ Proposes some staleness mitigation strategy\n+ Provides significant throughput gain\n+ Various sensitivity studies in the appendix."
                },
                "weaknesses": {
                    "value": "- Novelty is limited.\n- Some accuracy results does not make sense.\n- There is no discussion on GPU memory usage.\n- Baseline subgraph training methods are outdated compared to caching-based subgraph sampling acceleration works (e.g., SALIENT++).\n\nMSPipe provides an adequate training breakdown of TGNN training and targets to overlap the memory update procedure in TGN training. However, the staleness-based methods are widely used in GNN training. Even though MSPipe suggests that those works differ, the core idea is not very different: breaking the dependency, which is popularly used for GNN frameworks and algorithms.\nIn addition, when using a staleness-based strategy, the GPU memory usage should be reported, but there is a lack of such a discussion. The staleness mitigation method is interesting and valid but needs more details, and most importantly, it shows somewhat nonsense results in the LASTFM dataset. Overall, MSPipe is interesting and efficient, but some points should be addressed.\nWhile MSPipe points out that it differs from staleness-based works such as PipeGCN and Sancus"
                },
                "questions": {
                    "value": "- In the LASTFM dataset, why does MSPipe achieve such high accuracy compared to TGL? Does the staleness mitigation strategy can outperform the AP of the baseline TGL?\n- Staleness-based strategies require more memory at the expense of the throughput increase. For example, in Fig. 1(c), when breaking the dependency, the intermediate GPU-memory usage may be twice as much more than the baseline training. Could the authors (theoretically) analyze and report the empirical memory usage overhead?\n- Recent works (e.g., SALIENT++, MLSys2023) propose caching-based methodologies to minimize the sampler overhead. Is MSPipe still a valid option when using such methods?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission4465/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission4465/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission4465/Reviewer_Vi4E"
                    ]
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4465/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698820333449,
            "cdate": 1698820333449,
            "tmdate": 1700395122331,
            "mdate": 1700395122331,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "tygXL63KVS",
                "forum": "oFNpRlPxyQ",
                "replyto": "KlH8eogRb7",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer Vi4E"
                    },
                    "comment": {
                        "value": "Thank you for your detailed review. We would like to address the weakness you raised and clarify any potential misunderstandings.\n\n> Weakness 1: The staleness-based methods are widely used in GNN training. Even though MSPipe suggests that those works differ, the core idea is not very different: breaking the dependency. Address the novelty and difference with static GNN.\n\nWe respectfully disagree with the reviewer\u2019s assessment of the novelty of our works and would like to put forth a few points to assert that our study indeed has novelty:\n\n- The concept of 'staleness' has been extensively researched in various domains for many years, and recent publications continue to explore its utility in different settings. All the staleness methods can be thought of as some sort of \u2018*breaking the dependency*\u2019. The novelty of many staleness studies comes from analyzing and applying staleness to a particular problem or setting, as different problems and settings introduce different challenges and require specific theoretical considerations.\n- As discussed in Section 2 and Appendix B, there are multiple staleness-based methods applied in static GNN training. However, the training paradigms, bottlenecks, challenges, and dependencies in these static GNN frameworks are entirely different from TGNN training (as detailed in Appendix B). Consequently, these methods cannot be directly applied to accelerate TGNN training. To the best of our knowledge, we are the first to address the bottlenecks of the memory module and provide effective system-algorithm co-design methods to accelerate the TGNN training process, accompanied by detailed theoretical analysis.\n\nIn conclusion, considering the nature of staleness research and the limited exploration in TGNN training, we firmly believe that our study brings value and novelty to the TGNN training field.\n\n> Weakness 2, Question1: Accuracy in LastFM. Does the staleness mitigation strategy can outperform the AP of the baseline TGL in LastFM?\n\nThe reasons why our staleness mitigation strategy outperforms the AP of the baseline TGL in the LastFM dataset is due to the unique characteristics of the LastFM datasets:\n\n- The LastFM dataset exhibits a larger average time gap ($\\frac{t_{max} - t_{min}}{E}$, where $t_{max}$ and $t_{min}$ represent the largest and smallest timestamps, respectively, and $E$ denotes the number of events) compared to other datasets, as discussed by Cong et al. [1]. Specifically, LastFM has an average time gap of 106, whereas Reddit's average time gap is 4, Wiki's average time gap is 17, MOOC's average time gap is 3.6, and GDELT's average time gap is 0.1.\n- Consequently, even without staleness in the baseline method, the node memory in the LastFM graph tends to become significantly outdated [2], as discussed in Section 3.3. Our staleness mitigation strategy eliminates the outdated node representation by aggregating the memories of the recently active nodes with the highest similarity. This approach helps mitigate the impact of the large time gap present in LastFM datasets, ultimately leading to an improvement in AP compared to the baseline methods.\n\nAccording to your feedback, we have added the analysis of accuracy in LastFM datasets in the Appendix E.3.1, which aims to provide further clarity and enhance the comprehensiveness of our study.\n\n[1] Weilin Cong, et. al. Do we really need complicated model architectures for temporal networks? In Proceedings of International Conference on Learning Representations, 2023.\n\n[2] Emanuele Rossi, et. al. Temporal Graph Networks for Deep Learning on Dynamic Graphs. In Proceedings of International Conference on Learning Representations, 2021."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4465/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700040600992,
                "cdate": 1700040600992,
                "tmdate": 1700040600992,
                "mdate": 1700040600992,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "AekXmeWSjj",
                "forum": "oFNpRlPxyQ",
                "replyto": "KlH8eogRb7",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer Vi4E"
                    },
                    "comment": {
                        "value": "> Weakness 3, Question2: Analyze the GPU memory usage and report empirical memory usage overhead.\n\nWe appreciate the reviewer's inquiry, and we would like to politely clarify that our method does not introduce twice the memory overhead compared to TGL. Here is the theoretical analysis and empirical results supporting this claim:\n\n1. In MSPipe, we introduce staleness in the memory module to enable the pre-fetching of features and memory in later iterations. However, unlike PipeGCN and Sancus, where staleness is introduced during GNN training, our TGNN training stage doesn\u2019t have staleness. Each subgraph is executed sequentially, so no additional hidden states are incurred during GNN computation.\n\n2. The additional memory consumption in MSPipe arises from the prefetched subgraph, which includes node/edge features and memory vectors. We can compute an upper bound for this memory consumption as follows:\n\n   - Let the subgraph in each iteration have a batch size of $B$, node and edge feature dimensions of $H$, node memory dimension of $M$, and an introduced staleness bound of $K$. For each graph event, we have a source node, destination node, and neg_sample node, totaling 3 nodes per sample. \n   - During subgraph sampling, we use the maximum neighbor size of $N=10$ to compute the memory consumption, which represents an upper bound. Assuming the data format in Float32 (i.e., 4 bytes), the additional subgraph memory consumption is: $$3 \\times 4 KB(N+1)(H+M) + 12 KB(N+1) = 12KB(N+1)(H+M) + 12KB(N+1)$$ , where the first term represents the feature and memory usage, $(N+1)$ is the total number of nodes, and $(H+M)$ is the sum of the feature and memory dimensions. The second term represents the node ID usage.\n\n3. Moreover, we conduct empirical experiments on all the models/datasets with the`\n   torch.cuda.memory_summary()`API. The experiment results are listed in the tables blow the text  and we added them in Table 10-12 in Appendix E.7.\n\n   - As observed in the Table 10-12, the additional memory usage from MSPipe strictly remains below our analyzed upper bound.\n\n   - Moreover, the additional memory only introduces an average of 47% more consumption compared to TGL methods. It is important to note that the actual additional memory consumption may be even lower than 47% since PyTorch tends to allocate more memory than it will ultimately use.\n\nBased on the above analysis, our findings indicate that MSPipe effectively accelerates training performance while only introducing a manageable memory overhead.\n\n***\n**Tables:** GPU memory usage of different models. \n- The 'TGL' and 'MSPipe' rows represent the memory usage from TGL and MSPipe respectively under the same experiment settings in the paper.\n- The 'Addition' row represents the additional memory usage from MSPipe to TGL by introducing staleness. \n- The 'Theory' row represents the upper bound of additional memory usage by introducing staleness.\n\n**TGN model**\n\n| Scheme  | REDDIT(MB) | WIKI(MB) | MOOC(MB) | LastFM(MB) | GDELT(GB) |\n| ------- | ---------- | -------- | -------- | ---------- | --------- |\n| TGL     | 348.16     | 202.75   | 312.72   | 264.19     | 8.12      |\n| MSPipe  | 507.06     | 303.10   | 428.00   | 352.26     | 11.34     |\n| Addtion | 158.90     | 100.35   | 115.28   | 88.06      | 3.22      |\n| Theory  | 193.88     | 129.25   | 162.52   | 162.52     | 4.42      |\n\n**JODIE model**\n\n| Scheme  | REDDIT(MB) | WIKI(MB) | MOOC(MB) | LastFM(MB) | GDELT(GB) |\n| ------- | ---------- | -------- | -------- | ---------- | --------- |\n| TGL     | 166.86     | 152.77   | 172.77   | 183.25     | 6.62      |\n| MSPipe  | 278.54     | 238.30   | 286.50   | 266.98     | 9.42      |\n| Addtion | 111.68     | 85.54    | 113.73   | 83.73      | 2.8       |\n| Theory  | 193.88     | 129.25   | 162.52   | 162.52     | 4.42      |\n\n**APAN model**\n\n| Scheme  | REDDIT(MB) | WIKI(MB) | MOOC(MB) | LastFM(MB) | GDELT(GB) |\n| ------- | ---------- | -------- | -------- | ---------- | --------- |\n| TGL     | 229.38     | 215.04   | 196.61   | 208.90     | 7.4       |\n| MSPipe  | 337.92     | 292.50   | 308.16   | 313.34     | 10.17     |\n| Addtion | 108.54     | 77.46    | 111.55   | 104.45     | 2.77      |\n| Theory  | 193.88     | 129.25   | 162.52   | 162.52     | 4.42      |"
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4465/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700040643371,
                "cdate": 1700040643371,
                "tmdate": 1700054539370,
                "mdate": 1700054539370,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "pRbIZHEIBl",
                "forum": "oFNpRlPxyQ",
                "replyto": "KlH8eogRb7",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer Vi4E"
                    },
                    "comment": {
                        "value": "> Weakness 4, Question3: Is MSPipe still a valid option when using SALIENT++?\n\nWe would like to assert that MSPipe is still a valid option for TGNN training even considering the usage of SALIENT++, which is a follow-up work to SALIENT (used in our experiment):\n\n1. SAILENT++ focuses on reducing the communication overhead caused by partitioned vertex feature storage by using a feature cache. However, in our experiments, neither TGL nor MSPipe employs partitioned vertex feature storage since the feature storage requirements of all the datasets could be accommodated in the CPU's main memory. Therefore, there was no need to apply partitioned vertex features, and comparing our approach with SALIENT is sufficient.\n2. The design of SALIENT++ is not applicable to the memory module, which serves as the main bottleneck in TGNN training, even if we were to partition the memory module to fit its setting. SALIENT++ introduces a cache for feature fetching while the feature storage in the main memory will not be updated throughout the training. However, in the case of TGNN training, the memory module needs to be updated every iteration. Consequently, it is crucial to maintain strict consistency between the node memory cache on different GPUs and the memory module. However, SALIENT++ does not address this issue.\n3. SALIENT++ specifically designs a feature cache for the multi-hop subgraph sampler to reduce communication overhead arising from the neighborhood explosion problem in multi-layer GNNs. However, as discussed in our paper, memory-based TGNN utilizes a single-layer structure. In this case, the main bottlenecks stem from the memory module rather than subgraph sampling and feature fetching, thereby reducing the potential benefits of SALIENT++.\n\nBased on the above reasons, SALIENT++ mainly focuses on different settings that do not address the main challenges in TGNN training, and it is not appropriate to compare MSPipe with SALIENT++. Instead, we compare our approach to SALIENT."
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4465/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700053840842,
                "cdate": 1700053840842,
                "tmdate": 1700053840842,
                "mdate": 1700053840842,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "eczrnikwUh",
                "forum": "oFNpRlPxyQ",
                "replyto": "pRbIZHEIBl",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4465/Reviewer_Vi4E"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4465/Reviewer_Vi4E"
                ],
                "content": {
                    "title": {
                        "value": "Thanks for the response"
                    },
                    "comment": {
                        "value": "Thank you for the detailed response. \n* On the novelty, I think I am already on the same page with the authors. \nIndeed, analyzing the given problem to apply the staleness is meaningful.\nI agree that it is novel to some degree, but not greatly. \nGiven a large body of previous and concurrent work on GNN subproblem + staleness, the proposed work is more of a timely one, rather than being very novel.\n* Thanks for providing the theoretical and empirical memory usage. The additional memory usage is less than what I thought, but still a huge overhead, especially for modern GNNs where the memory capacity is often the system bottleneck. If the paper is accepted, I hope the authors place this in the main body, not the appendix. \n* The discussion for the LastFM data lacks enough support, but seems to make much sense. \n\nConsidering that the response addresses much of the initial concerns, I have raised my rating to 6."
                    }
                },
                "number": 10,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4465/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700396290299,
                "cdate": 1700396290299,
                "tmdate": 1700396290299,
                "mdate": 1700396290299,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "mcWxiEUEif",
            "forum": "oFNpRlPxyQ",
            "replyto": "oFNpRlPxyQ",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4465/Reviewer_juas"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4465/Reviewer_juas"
            ],
            "content": {
                "summary": {
                    "value": "In the training process of memory-based TGNN, memory modules are used to store the temporal information computed by the RNN. These vectors, once computed on the GPU, are stored in the CPU memory, which introduces significant overhead, resulting in underutilization of the GPU. This work introduces staleness into the memory modules to break the time dependency, achieved through the minimal staleness algorithm. The algorithm determines the minimal staleness bound, denoted as 'k'. During the computation at the current i-th iteration, the results from the (i-k)-th iteration are used instead of the (i-1) iteration's results, allowing the training phases to be pipelined. This enables the GPU to seamlessly execute computations without waiting for data preparation, maximizing the TGNN training throughput. Additionally, this work proposes a similarity-based staleness mitigation method to further enhance the model's accuracy."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. Overall, the two optimization methods are reasonable.\n2. The experiment result is promising. It can be observed that the first optimization method, introducing staleness to break temporal dependencies, can improve training throughput and acceleration ratio. Furthermore, the algorithm identifies the minimal staleness bound 'k,' and experiments confirm its optimality in the trade-off between accuracy and throughput. The second optimization method, introducing a staleness mitigation approach, can enhance the model's precision. \n3. The method is novel. Inspired by PipeGCN's breakthrough in breaking the inter-layer dependencies of GNN, this work introduces, for the first time, a method to break the time dependencies of memory modules during TGNN training and provides detailed theoretical derivations."
                },
                "weaknesses": {
                    "value": "1. Section 3.2 \"Minimal-staleness bound k\" should be the main contribution of this work, but the presentation is unclear. The process of determining the minimum k involves presenting three formulas corresponding to three constraints. The rationale behind the first two formulas is questionable, and it is not explained why these formulas satisfy the constraints.\n2. When conducting ablation studies, increasing the influence of GPU samplers is necessary, as TGL uses a CPU sampler, while MSPipe employs a GPU sampler. In addition to the four scenarios in Table 2, it is necessary to add scenarios where MSPipe uses a CPU sampler."
                },
                "questions": {
                    "value": "1. In Section 3.2, titled \"Resource-aware online pipeline schedule\", it discusses pipeline scheduling after determining the Minimal-staleness bound, denoted as 'k.' In this section, Figure 6 is referenced for illustration. However, Figure 6(a) clearly does not satisfy the formula for determining the minimum 'ki' as outlined in Equation 1. Nevertheless, it does satisfy the constraints mentioned in the text, highlighting a contradiction between the formula and the stated constraints.\n2. The figure numbering is disordered: Fig. 7 appears before Fig. 6 in the text. The same figures appear multiple times: Fig. 4 (a) and Fig. 6 (a).\n3. The typo in Eqn.5: $j$ in second line should be $j+1$."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4465/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698832483903,
            "cdate": 1698832483903,
            "tmdate": 1699636421992,
            "mdate": 1699636421992,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "C2L2V6y8Wv",
                "forum": "oFNpRlPxyQ",
                "replyto": "mcWxiEUEif",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer juas"
                    },
                    "comment": {
                        "value": "Thank you for your detailed review. We would like to address the weakness you raised and clarify any potential misunderstandings.\n\n> Question 1: Figure 6(a) does not satisfy the formula for determining the minimum 'ki' but it satisfied the constrained in Eqaution5.\n\nWe want to clarify a potential misunderstanding of Figure 6(a):\n\n- You are right that Figure 6(a) does not represent the minimum '$k_i$' value and Figure 6(b) shows the minimum '$k_i$'  by our minimal staleness optimization. The purpose of including both Figure 6(a) and Figure 6(b) was to compare the pipeline schedule with different minimum '$k_i$'  values. Figure 6(a) serves as a baseline, while Figure 6(b) illustrates how the memory fetching stage can be delayed (indicated by the green dashed line) when applying the minimal staleness '$k_i$'  optimization.\n\nTo address the reviewer's concern, we have updated the latest version of the submission to include only Figure 6(b), removing Figure 6(a) to avoid any confusion.\n\n\n\n> Weakness 1: The rationale behind the first two formulas is questionable, and it is not explained why these formulas satisfy the constraints.\n\nWe would like to assert that our formulas and constraints are reasonable:\n\n1. The explanation of these formulas and constraints can be found in Section 3.2. The first two formulations represent the start time of the sample stage and feature fetching stage. The sample stage, being the initial stage, can start immediately after the completion of the sample stage in the previous iteration. For the feature fetching stage, as feature fetching and memory fetching contents for PCIe bandwidth, therefore, the feature fetching stage needs to wait for the completion of the memory fetching stage. For the other stages, there\u2019s no resource contention between different stages so this is why the first two formulas differ from the other stages (the third formula) in our approach.\n2. **Why the formulation in Equation 5 is reasonable:** We first compute the starting time and end time of different stages in different iterations. The computed starting time represents the earliest possible start time for each stage. As discussed in the paper, Our aim was to parallelize the stages between iterations to maximize throughput while considering two constraints: avoiding resource competition and preventing simultaneous execution of the same stage from different iterations. Figure 4(a) illustrates how the starting time of each stage adheres to these constraints. As there is plenty of bubble time between stages, it may be possible to delay the execution of some stages to obtain a smaller staleness bound.\n3. **Why the formulations in Equation 5 satisfy the constraints:** Based on the starting time and end time obtained from Equation 5, we iterate through the stages in different iterations to identify opportunities for execution delay, which can lead to a smaller staleness bound. As discussed in the paper, the first constraint aims to delay the memory fetch stage until the memory update stage from $k_i$ iterations has finished. Simultaneously, the second constraint ensures that the delayed memory fetch stage does not impede the subsequent GNN training stage, allowing uninterrupted execution of GNN training stages on the GPU.\n\nWe hope this clarification addresses your concerns and provides a clearer understanding of the rationale behind the first two formulas and how they satisfy the constraints outlined in our approach.\n\n\n\n> Weakness 2: Increasing the influence of GPU samplers is necessary.\n\nThe impact of the GPU sampler is relatively minor compared to the gains achieved through our pipeline mechanism and minimal staleness scheduling.\n\n- We want to point out that we have already included a thorough analysis of the influence of GPU sampler in Table 5 in Appendix C.3.\n- Table 5 shows that our sampler is 24.3% faster than TGL\u2019s CPU sampler for 1-hop most recent sampling, which accounts for only 3.6% of the total training time.\n\nTherefore, the performance gain is primarily attributed to our pipeline mechanism and resource-aware minimal staleness schedule but not to the acceleration of the sampler.\n\n\n\n> Question 2: Fig. 7 appears before Fig. 6 in the text. The same figures appear multiple times: Fig. 4 (a) and Fig. 6 (a):\n\nThanks for pointing out the format problem. As suggested, we have fixed the figure order and deleted Figure 6(a) to avoid misunderstandings.\n\n\n> Question 3: Typo in Eqn5\n\nThanks for your detailed review. We have fixed this typo in the latest version."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4465/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700040463080,
                "cdate": 1700040463080,
                "tmdate": 1700040463080,
                "mdate": 1700040463080,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "yX1UM99ET2",
                "forum": "oFNpRlPxyQ",
                "replyto": "mcWxiEUEif",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Gentle reminder of Reviewer juas"
                    },
                    "comment": {
                        "value": "Thank you again for the feedback on our paper. We hope that our responses have addressed your inquiries and concerns. If this is not the case, please inform us and we would be glad to engage in further discussion."
                    }
                },
                "number": 12,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4465/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700469420178,
                "cdate": 1700469420178,
                "tmdate": 1700469420178,
                "mdate": 1700469420178,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "2a2I0O2HLW",
            "forum": "oFNpRlPxyQ",
            "replyto": "oFNpRlPxyQ",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4465/Reviewer_6Ut8"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4465/Reviewer_6Ut8"
            ],
            "content": {
                "summary": {
                    "value": "Memory based TGNNs are an important subclass of TGNNs that rely on message passing to update node memory between events. However message updates suffer from a staleness problem. Since temporal edges are used as ground truth in self-supervised TGNNs, updates to node memory need to be delayed to avoid the information leak problem i.e., the updated memory of a node cannot be utilized for training during the current batch, instead the memory updates are applied at the end of each training iteration. Thus memory based TGNNs have temporal dependencies which affect training accuracy. In order to solve this problem, the authors propose a TGNN training framework called MSPipe which consists of a minimal staleness algorithm that 1) schedules the training pipeline by satisfying a minimal staleness bound condition and (2) exploits a  staleness mitigation method that leverages the memories of recently updated nodes with the highest similarity in order to reduce the staleness error. They provide experimental results comparing MSPipe  to existing TGNN  frameworks TGL and SALIENT."
                },
                "soundness": {
                    "value": "1 poor"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "1 poor"
                },
                "strengths": {
                    "value": "The paper formalizes the pipeline for memory-based TGNN training and proposes a staleness aware algorithm that ensures efficient training while minimizing the memory staleness bound.\n\nExperimental results show good runtime speedup with little decrease in accuracy."
                },
                "weaknesses": {
                    "value": "The prime motivations behind this paper (eliminating staleness while improving training time)  are not valid.\n\n--- The paper proposes a pipeline scheduling framework to improve the runtime of TGL. As mentioned by the authors, the main factor that leads to inefficient TGN training is the dependency on the execution order of memory fetching and updating. The assumption that the memory update should be applied at the end of each training iteration is not valid. As shown in Fig. 2, both memory update and GNN training can naively be executed in parallel. The cost of a memory update can easily be overlapped with (absorbed by) GNN training, as GNN training is the main overhead. Therefore, there is no need to use stale memory. \n\n--This work is to improve previous work TGL. There seems to be a major design flaw. \u00a0They proposed to fetch a stale version of the node memory to overlap part of the mini-batch generation overhead with the actual training. However, there\u2019s no need to use stale memory at all, because updated node memory is firstly computed in the previous GNN training iteration, which can be directly used in the next iteration. The sampler can simply include the information of \u201cwhich node memory should be fetched from the global pool and which node memory should be used as in previous iteration\u201d in the mini-batch data. \n\nExperiments require improvements for soundness. \n\n-- The runtime breakdown shown in Table 1 seems doubtful. The sample overhead is larger than expected, considering that the authors have implemented a GPU-based most recent neighbor sampler and only one-hop neighbors are required for each node.\n-- MSPipe calculates a minimal staleness bound $k_i $ for each iteration $i$. However, there is a lack of experiments that demonstrate the variation of $k_i$ with respect to $i$. \n-- Fig. 11 depicts a fixed staleness bound value derived by MSPipe for one dataset, which can be confusing."
                },
                "questions": {
                    "value": "This work is to improve previous work TGL. There seems to be a major design flaw. \u00a0They propose to fetch a stale version of the node memory to overlap part of the mini-batch generation overhead with the actual training. However, there\u2019s no need to use stale memory at all, because updated node memory is firstly computed in the previous GNN training iteration, which can be directly used in the next iteration. The sampler can simply include the information of \u201cwhich node memory should be fetched from the global pool and which node memory should be used as in previous iteration\u201d in the mini-batch data."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "1: strong reject"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission4465/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission4465/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission4465/Reviewer_6Ut8"
                    ]
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4465/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699426380873,
            "cdate": 1699426380873,
            "tmdate": 1699636421929,
            "mdate": 1699636421929,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "V8ZDV5s7yZ",
                "forum": "oFNpRlPxyQ",
                "replyto": "2a2I0O2HLW",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your detailed review. However, we would like to address the weakness you raised and clarify any potential misunderstandings.\n\n\n\n> Weakness 1: \u201cThe cost of a memory update can easily be overlapped with (absorbed by) GNN training, as GNN training is the main overhead. Therefore, there is no need to use stale memory.\u201d\n\nWe respectfully disagree with the statement and would like to assert that the cost of a memory update (as the main overhead)  can not be overlapped by TGNN training. We highlight two reasons why it is  infeasible to hide the memory update overhead with TGNN training:\n\n1. TGNN training stage cannot fully overlap with the memory update stage because the memory update stage can only be applied after the memory updater updates the memory within the TGNN training stage, as discussed in Section 2. Furthermore, the computation overhead of the memory updater may be larger than the embedding modules [1]. Consequently, the available space for the memory update stage to overlap with the TGNN training stage becomes even smaller.\n2. We have already overlapped the memory update stage as much as possible with the TGNN training stage. TGNN training can be decomposed into three steps in total: memory updater computes the updated memory -> TGNN layer computes the embeddings -> get loss and backward (including all-reduce). The latter two stages can indeed be parallelized with the memory update stage and this is what we already implement in our experiment, which is aligned with TGL[2]. However, even with these overlaps, the memory update stage still takes up to 31.7% of the time indicated in Table 1, making it impossible to completely hide the overhead.\n\nTherefore, our design to utilize stale memory is necessary in order to effectively hide the overhead resulting from the memory module.\n\n[1] Xuhong Wang, et al. Apan: Asynchronous propagation attention network for real-time temporal graph embedding. In Proceedings of the 2021 international conference on management of data.\n\n[2] Hongkuan Zhou, et a.Tgl: A general framework for temporal gnn training on billion-scale graphs. VLDB 2022.\n\n\n\n> Weakness2: \u201cDesign flaw. The sampler can simply include the information of \u201cwhich node memory should be fetched from the global pool and which node memory should be used as in previous iteration\u201d in the mini-batch data.\u201d\n\nWe would like to point out that the suggested design, despite being conceptually plausible, is not feasible due to technical constraints in a distributed training system. Therefore, it should not be considered as evidence to deny our contributions. Here are the detailed reasons:\n\n1. During distributed training, the updated node memories are distributed among various GPUs. In order to determine and fetch the desired node memory for the next iteration, additional communication overhead would be required to find the corresponding memory residing on another GPU. This would introduce unnecessary complexity and hinder the efficiency of the training process.\n2. Based on the memory update algorithm in TGN, the same target node is involved multiple times in a training batch and receives multiple updated node memories. The final updated memory is chosen based on either the most recent update or the mean update. If we don't write back to the CPU memory and compute the most recent or mean value, it would introduce more overhead for the distributed GPUs to synchronize with each other and determine the most recent or mean value. This would negatively impact the overall training performance, making it impossible to achieve the same throughput as MSPipe which can seamlessly execute the TGNN training stage.\n3. In addition to the overhead mentioned above, the node memory that will be used in the next iteration still needs to be updated to the memory stored in the CPU main memory, otherwise, the global memory store will get outdated very soon. The presence of unnecessary node memories in the GPU's memory would introduce extra memory overhead when they are no longer needed in future iterations."
                    },
                    "title": {
                        "value": "Response to Reviewer 6Ut8"
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4465/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700040239564,
                "cdate": 1700040239564,
                "tmdate": 1700040756403,
                "mdate": 1700040756403,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "RCagwVxHIp",
                "forum": "oFNpRlPxyQ",
                "replyto": "2a2I0O2HLW",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "> Weakness 3: \u201cruntime breakdown for sample is larger than expected.\u201d\n\nWe would like to assert that the runtime breakdown of MSPipe is indeed reasonable:\n\n1. We have thoroughly addressed the effect of the GPU sampler in our submission, providing a detailed analysis of our GPU sampler and a comprehensive time breakdown comparison with TGL's CPU sampler. We found that our sampler is 24.3% faster than TGL\u2019s CPU sampler for 1-hop most recent sampling, which accounts for only 3.6% of the total training time. Therefore, the performance gain is primarily attributed to our pipeline mechanism and resource-aware minimal staleness schedule but not to the acceleration of the sampler. These findings are presented in Appendix C.3 and Table 5.\n2. The temporal sampler needs an additional operation to follow the temporal order during sampling than the static GNN sampler. Therefore it may have a larger overhead than a static GNN sampler. Moreover, comparing the sampling overhead with a static GNN sampler is unnecessary in MSPipe.\n\n\n\n> Weakness 4: \u201cdemonstrate the variation of ki with respect to i\u201d\n\nWe understand the desire for a comprehensive experiment. We have included an experiment about the $k_i$ with respect to $i$ in Figure 20 in Appendix E.4. As we can see in Figure 20, the number of staleness $k_i$ will soon converge to a steadily minimal staleness value. This is because of the periodic manner of the GNN training as the computation time of different training stages is quite steady.\n\n\n\n> Weakness 5: \u201cFig. 11 depicts a fixed staleness bound value derived by MSPipe for one dataset, which can be confusing.\u201d\n\nWe apologize for the confusion in Figure 11 and please allow us to clarify:\n\n1. The purpose of Figure 11 was to highlight that MSPipe is capable of identifying the minimal staleness bound that achieves the highest training throughput without compromising model accuracy, surpassing random selection. Due to the space limit, we only presented the MOOC dataset in the main section, while the results for all other datasets were included in Figure 17 in Appendix E3.3.\n2. As explained before, the number of staleness $k_i$ will soon converge to a steady minimal staleness value. To represent this minimal staleness bound, we utilize a fixed value that corresponds to the steady state. This choice allows us to showcase the minimal staleness bound effectively.\n\nAccording to your feedback, we have modified the presentation of the experiment to make the purpose of Figure 11 more clear."
                    },
                    "title": {
                        "value": "Response to Reviewer 6Ut8"
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4465/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700040273261,
                "cdate": 1700040273261,
                "tmdate": 1700040348955,
                "mdate": 1700040348955,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "zosNZTDRSo",
                "forum": "oFNpRlPxyQ",
                "replyto": "2a2I0O2HLW",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4465/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Gentle reminder to Reviewer 6Ut8"
                    },
                    "comment": {
                        "value": "Thank you again for the feedback on our paper. We hope that our responses have addressed your inquiries and concerns. If this is not the case, please inform us and we would be glad to engage in further discussion."
                    }
                },
                "number": 11,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4465/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700469339696,
                "cdate": 1700469339696,
                "tmdate": 1700469339696,
                "mdate": 1700469339696,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]