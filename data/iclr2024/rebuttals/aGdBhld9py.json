[
    {
        "title": "Neural Priority Queues for Graph Neural Networks (GNNs)"
    },
    {
        "review": {
            "id": "THBQRbElGw",
            "forum": "aGdBhld9py",
            "replyto": "aGdBhld9py",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2536/Reviewer_1rbd"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2536/Reviewer_1rbd"
            ],
            "content": {
                "summary": {
                    "value": "The paper deals with GNN memory extensions, mainly for the purpose of algorithmic learning, but also extends it to one real-world benchmark. The data structure that is introduced is supposed to mimic a priority queue that all nodes concurrently interface with. Notably, all operations are implemented in a differentiable manner, making it possible to learn end-to-end."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "The paper makes use of differentiable data structures in GNNs. The results seem promising for the purpose of algorithmic reasoning, and there is evidence that it could also be helpful for other tasks."
                },
                "weaknesses": {
                    "value": "First, the major weaknesses\n\n1. Poor reproducibility\nThe paper does provide barely any information that would make it possible to implement the proposed architecture. While mathematical formulas are provided, there is considerable room for interpretation regarding the actual implementation. These include, but are not limited to: Where are linear layers applied, and what uses MLPs? What is the baseline GNN architecture? How are the models trained (there is absolutely zero information on that)? What are the model sizes (especially for the LRGB dataset, is the parameter limit adhered to)? What hardware was used, and how long did the training take? To be clear, these are just some exemplary questions, the authors should provide enough information to make their results as reproducible as possible. Sadly, this makes the empirical results questionable as they cannot be verified. No code was provided, which would have largely alleviated this problem. \n\n2. The main claim of alignment with priority queues is not well-supported\n\tThe paper claims that the architecture aligns with neural priority queues (at least this is the implication): \n\u201cIn this paper, we present Neural Priority Queues, a differentiable analogue to algorithmic priority queues, for GNNs.\u201d\nI don\u2019t see why this is the case. I understand that the architecture can be reduced to priority queues, but this does not mean that it aligns with them. In fact, the supposed priority queue has no notion of \u201cpriority\u201d. Nodes attend to a set of values and choose which one they want to pop. A real priority queue only pops the element with the highest priority, which is not enforced or incentivized here. The reduction only claims that one could learn to store both keys and values in v, and then attend to the element with the highest priority, without any evidence that the learning dynamics even allow for this. Overall, just because the data structure is expressive enough to mimic a priority queue in theory, it doesn\u2019t mean that it is one. Indeed, one could take any data store and let nodes attend to it. To support the claim that this is a neural priority queue, the authors should test if it can learn the behavior of one, potentially even without the whole GNN around it. For example, an analysis of attention coefficients and what elements in the queue are popped would help here. Even then, it is debatable if this should be called a \u201cneural priority queue\u201d.\n\n3. Weak contextualization, missing related work, and almost no good baselines in the evaluation.\nThe paper is missing highly relevant related architectures, and the related work section does not provide much information. Some claims need a citation, and others are, at the very least, misleading. For example: \n\u201cHowever, gated memory leads to very limited persistence. Furthermore, these works have solely focused on dynamic graphs, and extending these to non-dynamic graphs would involve significant effort.\u201d\nThe first sentence is not backed up, and the second hints at the claim that memory-augmented GNNs have only been developed for dynamic graphs, but what about works like: https://memari-workshop.github.io/papers/paper_32.pdf ?\nHere is a whole survey on memory-augmented architectures for GNNs with many more examples (albeit viewed through the lens of neuroscience): https://arxiv.org/pdf/2209.10818.pdf\nWhile the missing related work and their citations are concerning on their own, this also has an impact on the empirical evaluation, where none of these baselines are used in the comparison. The fact that some other architectures use gating does not provide a good reason not to compare to them. Further, the experiments could also contextualize the results better by providing architectures that allow to attend to values of other nodes (e.g., graph transformers or virtual nodes that represent storage). As it stands, there is only a comparison between \u201cneural PQs\u201d and the same GNN without them (with maybe the exception of the oracle PQ). Whether the performance boost is due to the smart usage of some data structure is unclear. On another note, the work seems to build heavily on the work of Grefenstette et al., which introduces differentiable data structures such as deques, stacks, and queues. Before introducing a new variation of these data structures (the \u201cpriority\u201d queue), it would make sense to use the existing ones in the GNN framework to further show that the proposed data structure works better for neural algorithmic reasoning. In fact, exactly this has already been done before (https://www.researchgate.net/profile/Fpj_Nijweide/publication/365623739_Differentiable_Data_Structures_for_Neural_Algorithmic_Reasoning/links/637b9e4537878b3e87ccdff9/Differentiable-Data-Structures-for-Neural-Algorithmic-Reasoning.pdf), so why is it missing here?\n\nMinor weaknesses\n\n4. Non-standard evaluation for CLRS\nThe authors claim that they diverge from the graph sizes used in CLRS for testing (256 instead of 64) \u201cto better test the generalisation ability, and because baseline MPNN model already gets around 91.5% test performance with 64 nodes.\u201d\nI don\u2019t see why an accuracy of 91.5% should be considered too good for testing, and other algorithms in CLRS are far from this accuracy. The generalization abilities are never mentioned in the evaluation after this, and this does not justify why no results on the standard test graph size of 64 are provided. This makes me curious: Do \u201cneural PQs\u201d not perform well for small graphs and only generalize better? \nFurther, for the evaluation of all 30 algorithms, a graph size of 128 is used (without any justification). Is there actually a reason for this? The authors should probably provide performance scores on graphs of sizes 64, 128, and 256.\n\n5. Claims about long-range information exchange\nThe authors claim that because their models perform well on one (!) dataset from LRGB, this has to be due to long-range information exchange. However, a recent paper (https://www.researchgate.net/publication/373642031_Where_Did_the_Gap_Go_Reassessing_the_Long-Range_Graph_Benchmark) has shown that, although being called long-range graph benchmark, there is no evidence to support that these problems actually require long-range information. This makes these claims problematic. Further, the authors only use a single dataset from LRGB.\n\n6. The paper is sometimes hard to follow\nThe authors use many mathematical formulas with even more variables and briefly mention what some of these do, but the descriptions are hard to follow. Some variables or functions are barely introduced/explained. Figure 4 shows the push operation, but elements are popped first. This is also confusing to me.\nMoreover, there are many variations of the \u201cneural PQ\u201d that are not motivated or explained (at least in the main paper). A thorough evaluation of the different techniques is not provided. \nFurther, the \u201cOracle PQ\u201d is not introduced very well, for example, this sentence is not clear to me:\n\u201cThe Oracle Neural PQ forces the push and pop operation to be determined by the algorithmic PQ\u201d\nWhat is the \u201calgorithmic PQ\u201d?\n\n7. Desiderata not clear\nThe authors do not mention what they understand under \u201cMemory Persistence\u201d, the first desiderata. This is not a standard terminology in the community, and a definition/criterium when this \u201cmemory persistence\u201d is fulfilled is required. At the moment, the authors only claim that it holds for their architecture, all without mentioning what it is. Desiderata 3 (Reducibility to Priority Queues) kind of hints at the fact that the architecture is not necessarily aligned with priority queues (as mentioned before). \n\nIn summary, this paper presents an interesting idea with promising results, but due to the aforementioned reasons, I cannot vouch to accept it. The work is not reproducible, the main claim of a differentiable priority queue is not well supported, and there is almost no mention of relevant related work. The other weaknesses only add to the image of a paper that needs to be considerably improved until it is ready for acceptance. Of course, I\u2019m happy to discuss all points with the authors and to increase my score if the weaknesses can be fixed. Until then, my score is a reject."
                },
                "questions": {
                    "value": "In addition to the questions raised by the weaknesses above, I have the following:\n1. What about the scalability and theoretical complexity of the approach? Can you give some runtime bounds? Are there challenges when applying the architecture to larger graphs?\n2. How many of the underlying algorithms in CLRS-30 actually make use of a priority queue? Is it just Dijkstra? Why do others perform better or worse then?\n3. What are the performances on graph size 64?\n4. For the early-stopping discussion (Table 1), what is the size of graphs in the validation set?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2536/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698683397998,
            "cdate": 1698683397998,
            "tmdate": 1699636190063,
            "mdate": 1699636190063,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": []
    },
    {
        "review": {
            "id": "uvVkC9tkXU",
            "forum": "aGdBhld9py",
            "replyto": "aGdBhld9py",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2536/Reviewer_t69k"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2536/Reviewer_t69k"
            ],
            "content": {
                "summary": {
                    "value": "The paper proposes a neural Priority Queue (PQ), as a differentiable analogue of algorithmic PQ. The proposed neural PQ is equipped with a memory module. Experimental studies show the performance of neural PQ on CLRS benchmark."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "S1. The paper proposes a neural network to mimic algorithmic PQ, where the neural architecture has a memory module.\n\nS2. Experiments are conducted on a wide range of algorithms which needs PQ."
                },
                "weaknesses": {
                    "value": "W1. The motivation of why we need a neural PQ is unclear. \n\nW1.1 (Effectiveness) In many algorithms, PQ is used for best-first search or heuristic search.  However, as a neural network, the neural PQ may not always correctly mimic each push/pop operation of algorithmic. It\u2019s unclear to which degree, the neural PQ can be an effective alternative of algorithmic PQ, regarding fulfilling corresponding best-first/heuristic search.\n\nW1.2 (Efficiency) The paper does not present any complexity analysis. It seems compared with algorithmic PQ, the complexity of neural PQ cannot have many advantages. \n\nThe reviewer understands the authors want to design neural data structures. However, the research motivation is questionable. Compared with algorithmic data structures, neural data structures do not have their advantages in practice, especially for classical algorithm design. \n\nW2. There is only one baseline, which makes the experiments less solid.\n\nW3. For long-range reasoning, the authors only compared with a baseline model MPNN. If the authors want to emphasize the contribution of neural PQ on reasoning, they should compare more approaches that are specifically designed for reasoning."
                },
                "questions": {
                    "value": "Q1. As the paper mention, the proposed neural PQ can be used for graph reasoning. What\u2019s the difference between conducting reasoning by neural PQ and existing differentiable reasoning approaches (e.g., Neural LP, RNNLogic, Query2Box )?\n\n[NIPS\u201917] Differentiable Learning of Logical Rules for Knowledge Base Reasoning \n\n[ICLR\u201921] Rnnlogic: Learning Logic Rules For Reasoning On Knowledge Graphs \n\n[ICLR\u201920] Query2box: Reasoning over knowledge graphs in vector space using box embedding \n\nQ2. What\u2019s the evaluation metric of Table 1, 2, 3? And why does that metric reflect the effectiveness of the neural data structures?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission2536/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2536/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2536/Reviewer_t69k"
                    ]
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2536/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698729402088,
            "cdate": 1698729402088,
            "tmdate": 1699636189984,
            "mdate": 1699636189984,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": []
    },
    {
        "review": {
            "id": "fezEfzV9QE",
            "forum": "aGdBhld9py",
            "replyto": "aGdBhld9py",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2536/Reviewer_mXBj"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2536/Reviewer_mXBj"
            ],
            "content": {
                "summary": {
                    "value": "This paper introduces a method named NPQ, which extends the message-passing framework by incorporating external memory modules."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "The exploration of the neural algorithmic reasoning task using memory modules is an innovative and intriguing approach."
                },
                "weaknesses": {
                    "value": "1. The explanation and benefits of the memory module are unclear.\nThe paper utilizes the memory module for reasoning the graph algorithm, but it lacks a comprehensive introduction of the memory modules, making it difficult to understand.\n\n2. The evaluation of the proposed method is somewhat lacking.\nThe evaluation of the NPQ method is only conducted using the baseline MPNN. Generally, existing methods like [1] have proposed simulating the graph algorithms bellman-ford. Therefore, when evaluating the effectiveness of the proposed method, these existing methods should also be taken into account.\n\n\n\n\n[1] Neural bellman-ford networks: A general graph neural network framework for link prediction."
                },
                "questions": {
                    "value": "Please check the weakness"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "details_of_ethics_concerns": {
                    "value": "None"
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2536/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698751947186,
            "cdate": 1698751947186,
            "tmdate": 1699636189913,
            "mdate": 1699636189913,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": []
    },
    {
        "review": {
            "id": "jOjvjvsvS7",
            "forum": "aGdBhld9py",
            "replyto": "aGdBhld9py",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2536/Reviewer_rwJQ"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2536/Reviewer_rwJQ"
            ],
            "content": {
                "summary": {
                    "value": "This paper focuses on extending GNNs with external memory for algorithmic reasoning. The authors propose a Neural Priority Queue framework that retains message passing GNNs and has flexible designs for priority queues. They also discuss several desirable property for the memory modules, which motivates their specific designs. The experiments for algorithmic reasoning on CLRS-30 dataset show the superiority of their method."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. Overall, the paper is well-written and clear. The motivation for adding memory modules for GNNs is also sound.\n2. The empirical experiments seem comprehensive. Especially for Dijkstra's algorithm, it is good to see the experiments are extended to larger graphs compared with previously used graphs with 64 nodes. This result can help us better understand the performance gap. \n3. It's interesting to see the author also have some experiments about long-range reasoning. To me, the potential advantage of adding memory modules is indeed to help capture long-range information. Although, I think it might be better to have 1 or 2 more datasets on long-range reasoning."
                },
                "weaknesses": {
                    "value": "1. Some equations and descriptions in Sec 5.2 are a bit confusing. I understand that $s_{pop}^{(i)}$ in Eq (14) is the proportion to pop the values in the queue. The requested fraction $p_j^{(i)}$ is calculated based on $s_{pop}^{(i)}$ and the granted fraction $q$ is based on $p$. In this sense, I would suggest somehow re-arrange the equations to make the flow more clear. For example, move Eq (14) to right before Eq (22) or move the specific pop Eq (22) and (23) to right after Eq (14). Otherwise, it's a bit confusing how to get $p$ and how it relates to Eq (15) at the first glance. \n2. For the limitation of requiring intermediate supervision in previous work, it's not very clear. Could you explain more in detail and also elaborate more on how your framework can avoid this? In the current draft, I didn't quite get it fully by reading just a few lines on the top of Page 4."
                },
                "questions": {
                    "value": "1. In Sec 6.1, the authors show that Oracle PQ performs worse than the proposed method. I am curious what the reason is for that. In my view, the oracle PQ may contain most of the information required to be successful in Dijkstra's algorithm, and by adding an MPPNP with access to the Oracle PR, it should provide very good performance. Please correct me if my understanding is not true. And I would appreciate it if you could provide more insights regarding this. I feel it could be more interesting than the only numerical results."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission2536/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2536/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2536/Reviewer_rwJQ"
                    ]
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2536/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699025431321,
            "cdate": 1699025431321,
            "tmdate": 1699636189845,
            "mdate": 1699636189845,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": []
    }
]