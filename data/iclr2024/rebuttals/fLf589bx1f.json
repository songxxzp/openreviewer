[
    {
        "title": "$\\mathcal{B}$-Coder: On Value-Based Deep Reinforcement Learning for Program Synthesis"
    },
    {
        "review": {
            "id": "qLd4lwPOZX",
            "forum": "fLf589bx1f",
            "replyto": "fLf589bx1f",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1982/Reviewer_3d3T"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1982/Reviewer_3d3T"
            ],
            "content": {
                "summary": {
                    "value": "In this paper, the authors introduce a value-based method for code generation with pretrained LLMs. In their opinion, their method fills a vacuum, due to the fact that all present LLM-based code-generation systems are policy-based in order to easily leverage pre-trained LLMs. The authors get around this difficulty via proposing initialisation and semi-gradient policy-improvement schemes in which the LLMs logits are visualised as Q-values. In addition to this, they propose a conservative Bellman operator in which the \"best action\" is not chosen based on the trained Q-values, but on the logits of the initial pre-trained LLM, which in their view stabilises training and alleviates the usual convergence problems of value-based RL.\nThe authors test their framework on a standard code-generation benchmark (the APPS benchmark) and use a relatively straightforward reward design. They report performance superior to, or competitive with, with an exhaustive set of baselines."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "- The authors are correct in that value-based methods for code-generation were absent from the literature, and that the gap should be filled.\n- Their solution for doing so is quite novel and elegant, especially the idea of visualising the LLM's logits as Q-values, and use them for both initialisation and policy improvement.\n- They consider an exhaustive set of baselines.\n- They show performance superior to, or competitive with, baselines, and on a programming benchmark notorious for its high difficulty."
                },
                "weaknesses": {
                    "value": "- While the framework is novel, its comparison with baselines gives mixed results: in some cases, it does not actually come out on top. This contradicts the authors' claim that value-based method should be more suited to code generation: all of the baselines are policy-based.\n- The authors filter programs at evaluation time using a different reward than the one used during training. This makes it hard to interpret their performance numbers. Could it be the filtering that is mostly responsible for them?\n- The authors' method needs to be applied to a pre-trained LLM, which is used not only for initialisation but also for training. This is only possible with LLMs whose checkpoints are publicly available. In the case of the largest LLMs available today, even with a checkpoint available, considerable computational resources would be needed to apply the method.\n- The paper has a bit of an idiosyncratic structure, with e.g. a whole section dedicated only to the reward filtering at evaluation time, a very small Related Work section, and no outline of the paper's contents in the introduction, which makes it a bit hard to read.\n- Some more proof-reading is needed as typos can be found here and there."
                },
                "questions": {
                    "value": "Main question and concern: why do the authors use a filtering procedure at evaluation time based on a different reward model $\\tilde{r}(s,a)$ than the environmental reward $r(s,a)$ they use for training? Given that the real reward $r$ can be easily and cheaply computed (a point which the authors themselves make in the introduction), I cannot see the need for such a procedure, and the authors do not elaborate on it. The authors should either:\n - Justify this choice.\n - Recompute their performance numbers with filtering based on $r$ at evaluation time.\n - Re-train their method with the modelled reward $\\tilde{r}$ from the outset.\n\nOther concerns/questions/recommendations:\n- Could the mixed performance numbers be due to the conservative Bellman operator, which keeps the policy close to the initial checkpoint? Did the authors consider alternative definitions for $q(a|s)$, or to update it at some point during training?\n - Value-based methods, including DQN, can suffer from the so-called \"Deadly Triad\" of deep RL. Can the authors elaborate on how they avoid this pitfall?\n- It seems that the authors add a value head $V^r_\\theta(s)$ (besides its LM head) to their LLM. How is that done, and can it be done with a generic LLM?\n- In figure 2, it seems that the pass@1 metric is actually at its best at very beginning of training and that it never recovers afterwards. Is the figure only meant to be illustrative, or are those the real training curves?\n- Can the authors outline their paper's content and structure at the end of the intro?\n- In figure 3, it would be helpful to explicitly define what $\\ell$ and $p$ stand for.\n- Why is the Nucleus Sampling outlined at the end of section 3? In my opinion it would make more sense to have in section 5, since it appears to be part of the evaluation protocol. Or is it also used during training?\n- It would be helpful if the authors defined (e.g. in a caption) what \"Intro\", \"Inter\", \"Comp\", and \"All\", mean in tables 1 and 2. While the text does mention it, it would be helpful to readers to be more explicit.\n- Why do the authors not consider $k=1000$ in table 2, as they do in table 1?\n- The study on generalisation of the reward model (notwithstanding my concerns on its use, detailed above) would better be moved to an appendix.\n\n# Post rebuttal edit:\nThe authors have exhaustively addressed my concerns and revised their paper as I suggested. I shall therefore raise my score to 8."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "details_of_ethics_concerns": {
                    "value": "No concerns."
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission1982/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1982/Reviewer_3d3T",
                        "ICLR.cc/2024/Conference/Submission1982/Senior_Area_Chairs"
                    ]
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1982/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698420473240,
            "cdate": 1698420473240,
            "tmdate": 1700734956625,
            "mdate": 1700734956625,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "3ULoVq8N5F",
                "forum": "fLf589bx1f",
                "replyto": "qLd4lwPOZX",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1982/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1982/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to reviewer 3d3T [Part 1/3]"
                    },
                    "comment": {
                        "value": "Thank you very much for your time in reviewing our work and your valuable comments! We are glad that you found our approach novel and elegant! We are enthusiastic about improving our paper by incorporating your constructive suggestions.\n\n### Weaknesses and Main Question\n\n> its comparison with baselines gives mixed results: in some cases, it does not actually come out on top. This contradicts the authors' claim that value-based method should be more suited to code generation\n\nWe believe the mixed results are largely influenced by the degree of reward engineering involved. Our approach intentionally uses **minimal reward engineering**, as shown in our Eq. (2), while the baselines use quite complex reward designs. A comparison is available in Table 5, Appendix C. Ablation studies in baseline papers, such as Table 2 in CodeRL, Figure 3(a) in PPOCoder, and Table 5 in RLTF, demonstrate that their reward designs contribute significantly to the performance.\n\nWe were restraint on reward engineering because we seek to offer a clearer discussion on the design of value-based methods without blending in too much reward factors. This trade-off was made to enhance our focus on algorithmic insights. As the reviewer has highlighted, the fact that all baseline methods are policy-based adds value to our initial attempt of value-based training.\n\n> Main question and concern: why do the authors use a filtering procedure at evaluation time based on a different reward model $\\tilde{r}(s, a)$ than the environmental reward $r(s, a)$ they use for training? Given that the real reward $r$ can be easily and cheaply computed\n\nWe would like to response to the main question first, to clarify our choice of a different reward function $\\tilde{r}(s, a)$ instead of the ground truth reward. \n\nThe primary reason is the **availability of test cases**, which provide true rewards. During model training or evaluation, test cases are often available and required, as both training and test datasets are typically constructed with them. This context is what we meant by `real reward $r$ can be easily and cheaply computed'. However, **in practical scenarios, test cases are not always available**, making it challenging to obtain real rewards.\n\n**An example scenario.** When **deploying a fine-tuned model for end-user applications**, users often provide natural language descriptions of their needs but may not include test cases (which can also be challenging for beginners or casual users). This situation is quite common and **real rewards are unobtainable**.\n\n**$\\tilde{r}$ in such scenarios.** Our reward model $\\tilde{r}$ doesn't require test cases from end users, and hence is applicable. Moreover, in many applications, such as GitHub Copilot, the model must offer a single best response, not a range of options. Thus, the ability to **rank programs without test cases (true rewards)** is not only realistic but also advantageous.\n\n**Additional benefits.** As discussed in Section 4, $\\tilde{r}$ requires no additional training and adds minimal computational overhead, as $Q$ and $V$ are already evaluated during program generation. In contrast, the critic sampling strategy used in CodeRL and RLTF requires (i) training a separate repair model and (2) available test cases (i.e. true rewards) for post-processing, which is less desired due to aforementioned reasons.\n\n**Remark on training with $\\tilde{r}$.** Recall that our reward model $\\tilde{r}$ is obtained from $Q$ using Eq (19), without additional training. Using $\\tilde{r}$ to train $Q$ from outset is in fact creating a chicken-and-egg problem. Besides, complex reward engineering during training is also something we tried to avoid. \n\n\nWe hope our explanation addresses the reviewer's major concern and clarifies our choice.\n\n> The authors filter programs at evaluation time using a different reward than the one used during training. This makes it hard to interpret their performance numbers. Could it be the filtering that is mostly responsible for them?\n\nWe hope our response to the main question helps address the concern about the use of a different reward. Ranking indeed improves performance as we expected. However, both initialization and conservative updates contribute significantly to the final performance. The comparison with CodeRL and RLTF with post-processing, i.e. critic sampling, is also available in Table 2. And we would like to highlight that our reward ranking is a more realistic post-processing strategy as explained above, and our model was trained with minimal reward designs."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1982/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700598440174,
                "cdate": 1700598440174,
                "tmdate": 1700598578716,
                "mdate": 1700598578716,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "KrSlXTm8D1",
                "forum": "fLf589bx1f",
                "replyto": "qLd4lwPOZX",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1982/Reviewer_3d3T"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1982/Reviewer_3d3T"
                ],
                "content": {
                    "comment": {
                        "value": "I thank the authors for their exhaustive answers to my questions, as well as their receptiveness to my other suggestions for improving the paper.\n\nI can fully see their point about the unavailability of test case-based rewards in a realistic deployment setting. Still, I would suggest that an evaluation of their method with filtering based on environmental rewards $r(s,a)$ (or anyway the same reward function used for training it and carry out policy improvement) be added at least to the appendix. It might not be representative of a realistic deployment situation, but in my opinion it would be an insightful sanity check, also for any future readers.\n\nAlso, have the authors already posted the revised version of their paper? I can still only see the initial version. I would like to read the revised one before I make any decisions on whether to update my score."
                    }
                },
                "number": 12,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1982/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700659367678,
                "cdate": 1700659367678,
                "tmdate": 1700659548154,
                "mdate": 1700659548154,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "YNkKz2KWAr",
                "forum": "fLf589bx1f",
                "replyto": "qLd4lwPOZX",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1982/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1982/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your prompt response and further suggestions.\n\n> Still, I would suggest that an evaluation of their method with filtering based on environmental rewards $r(s, a)$ be added at least to the appendix.\n\nCertainly, we will carry out the suggested experiments and include them in the Appendix in future revision.\n\n> Also, have the authors already posted the revised version of their paper? I can still only see the initial version.\n\nWe are delighted to upload an initial revision as per the reviewer's request. In this preliminary revision, we have made the majority of the changes suggested by all the reviewers. The changes have been highlighted in blue. Specifically, we have made the following adjustments in line with Reviewer 3d3T's recommendations:\n\n1. ``The paper has a bit of an idiosyncratic structure, with e.g. a whole section dedicated only to the reward filtering at evaluation time, a very small Related Work section, and no outline of the paper's contents in the introduction, which makes it a bit hard to read.''\n\n    - The introduction and related work sections have been revised for a more balanced structure.\n\n    - The reward section has been restructured as a subsection under our methodology section. To optimize space within this subsection, certain background paragraphs have been relocated to Appendix C, while other, less crucial details have been moved to Appendix E.\n\n\n2. ``the authors do not elaborate on it. The authors should either: Justify this choice. ...''\n\n    - In Section 4.5, we added a paragraph to further elaborate on the deployment setting and to justify our choice.\n\n\n3. ``Can the authors outline their paper's content and structure at the end of the intro?''\n\n    - We have added an outline of our paper's structure to the end of our introduction section.\n\n4. ``In figure 3 (now figure 2 after revision), it would be helpful to explicitly define what and $\\ell$ and $p$ stand for''\n\n    - The captions have been updated for explicit definitions.\n\n5. ``Why is the Nucleus Sampling outlined at the end of section 3? In my opinion it would make more sense to have in section 5''\n\n    - The sampling details have been relocated to Section 5.\n\n6. ``It would be helpful if the authors defined (e.g. in a caption) what \"Intro\", \"Inter\", \"Comp\", and \"All\", mean in tables 1 and 2.''\n\n    - The caption of Table 1 has been updated. While Table 2 remains unchanged at present, we plan to enhance our writing for conciseness, creating space for an updated caption for Table 2.\n\n7. ``The study on generalisation of the reward model (notwithstanding my concerns on its use, detailed above) would better be moved to an appendix.''\n\n    - We have reduced the length of the 'reward model' subsection and moved some less important content to Appendix, to accommodate the reviewer's suggestions, which allowed us to maintain the 'reward model generalization' experiments in their current place. We hope that the reviewer finds this arrangement sensible after our clarification on choice of $\\tilde{r}$. However, if the reviewer still believes these experiments would be better suited to the appendix, we are happy to make those revisions.\n    \n    \nThank you once again for your thorough review and valuable insights! We hope that this initial revision adequately addresses the reviewer's concerns regarding the paper's overall structure and flow, even though it may still contain typographical and grammatical errors. We are committed to continuously refining our paper to improve its presentation."
                    }
                },
                "number": 15,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1982/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700725643321,
                "cdate": 1700725643321,
                "tmdate": 1700726437814,
                "mdate": 1700726437814,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "xRF61M81Mq",
                "forum": "fLf589bx1f",
                "replyto": "YNkKz2KWAr",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1982/Reviewer_3d3T"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1982/Reviewer_3d3T"
                ],
                "content": {
                    "comment": {
                        "value": "I thank the authors for taking the time to post a preliminary revision of their paper; It is much more readable and better structured now.\nAll my concerns have been addressed and the paper has been revised as I suggested. I shall therefore raise my score to an 8."
                    }
                },
                "number": 16,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1982/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700735061071,
                "cdate": 1700735061071,
                "tmdate": 1700735061071,
                "mdate": 1700735061071,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "v4xdti95hK",
            "forum": "fLf589bx1f",
            "replyto": "fLf589bx1f",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1982/Reviewer_F9ov"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1982/Reviewer_F9ov"
            ],
            "content": {
                "summary": {
                    "value": "This paper derives a value-based approach for fine-tuning LLM's for code generation, motivated by the success of value-based methods in domains with similar constraints on data and reward modeling. The authors build on top of the Dueling DQN family of algorithms and design architectures and pretraining schemes for the Q/A/V functions that carefully incorporate the pretrained LLM policy in a way that provides mathematical guarantees that certain properties are met, such as ranking human solutions highly, leading to a policy function that is identical to the original LLM policy, and minimizing initial Bellman error. They then use a conservative Bellman operator based off greedy decoding, and show that they can derive a reward model from an inverse conservative Bellman operator without any additional training needed. Their approach is called Bellman-Coder. Experiments show that Bellman-Coder performs comparably to related work, and is often the best. In addition, the reward model generalizes to new domains and models."
                },
                "soundness": {
                    "value": "4 excellent"
                },
                "presentation": {
                    "value": "4 excellent"
                },
                "contribution": {
                    "value": "4 excellent"
                },
                "strengths": {
                    "value": "- The paper is very well-written. The authors do an excellent job of discussing related work, motivating the design of a value-based approach for code generation, explaining the challenges behind designing a value-based approach, and describing how their design tackles these challenges. The technical sections are presented with care to make sure readers don't get lost in symbols, and I found them easy to understand (at least at a medium-to-high level) despite not being a RL expert. The experiments are presented well. Everything about the writing and clarity is excellent.\n- The paper's approach is original and very high quality. It does appear that no prior work has leveraged value-based methods for code generation to the degree of success the authors present. Making progress on value-based methods for code generation seems like a significant research direction to pursue, given the importance of code generation as a primary application area of AI and the promise of value-based methods in other areas (as motivated by the authors). The only uncertainty of the significance might be due to the limited performance gains, but this is easily understandable given this paper seems to be the first to attempt it, and the uphill battle of designing such a method given the comparable ease of using a LLM as an off-the-shelf policy for policy-based methods. The authors took the harder route, and seem to have managed to get it to work comparably.\n- I'd like to emphasize how high quality the mathematical derivations seem. The authors seem to have a very valuable expertise in RL and have put it to good use in making this method work. The ablations in figure 2 attest to the effectiveness of their formulation, with some caveats."
                },
                "weaknesses": {
                    "value": "The primary weakness of the paper is that the results are not much better than prior work. However, given how difficult the perceived approach seems to be, I think this is okay. \n\nI am not very up-to-date with the different techniques and evaluation metrics for RL code generation, so I can't comment too much on whether the evaluation is missing anything. But taking a quick look at related work, the authors seem to use the same benchmarks."
                },
                "questions": {
                    "value": "In figure 2, why don't the approaches train for the same number of iterations? In the same vein, what do the dots signify on the dashed lines, and why do their distances change? \n\nis it true that the reward model coming for free in section 4 is possible for any Bellman operator? what are the preconditions necessary for this? I ask because the \"further comments\" right before Proposition 3.1 made me think that the conservativeness of the Bellman operator defined was needed, but it sounds like in section 4 that it works for any Bellman operator. (I do not have much expertise in this area)\n\nThe related work paragraph in section 1 only discusses work on supervised LLM training and RL alternatives for sequence generation. given the amount of highly related work discussed in other sections of the introduction, it seems like this paragraph should be renamed to something more precise. \n\nAlphaGo is described has having lots of off-policy data, but how does AlphaZero relate to the taxonomy of Figure 1? Isn't AlphaZero pretty much the same approach, but with all on-policy data?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission1982/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1982/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1982/Reviewer_F9ov"
                    ]
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1982/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698767884500,
            "cdate": 1698767884500,
            "tmdate": 1699636129749,
            "mdate": 1699636129749,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "3qciWqe784",
                "forum": "fLf589bx1f",
                "replyto": "v4xdti95hK",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1982/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1982/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you very much for your time in reviewing our work and for your positive assessment! We are glad that you found our work original and of very high quality, and our paper well-written! We are enthusiastic about improving our paper by incorporating your valuable comments.\n\n> Figure 2.\n\nWe apologize for any ambiguity and inconsistency in the figure. The extended training of the other two veins was to demonstrate the challenges of value-based training, even when allowing more training episodes. Our evaluation points were randomly selected, leading to the varying distances between points. Despite these factors, we believed the overall trend was clear enough to demonstrate the impact of different components. \n\n\n\n> is it true that the reward model coming for free in section 4 is possible for any Bellman operator? what are the preconditions necessary for this?\n\nYes, this is indeed possible for any operator that is a contraction. Being a contraction ensures a unique fixed point $Q$ upon convergence, which in turn allows an one-to-one correspondence with the reward function $\\tilde{r}$. We will amend the comments preceding Proposition 3.1 to more clearly indicate that the property of being a contraction is a sufficient condition for Proposition 4.1.\n\n\n> The related work paragraph should be renamed to something more precise\n\nWe certainly agree with the reviewer's point that the name *``related work''* is not quite fitting. We will rename it, for example, to *''RL in sequence generation''* or *''RL vs supervised fine-tuning''*.\n\n> how does AlphaZero relate to the taxonomy of Figure 1? Isn't AlphaZero pretty much the same approach, but with all on-policy data?\n\n\nThank you for pointing out this aspect. The statement from the AlphaZero paper: *``Self-play games are always generated by using the latest parameters for this neural network''*, initially suggested to us the exclusive use of on-policy data. However, further examination led us to a pseudocode in their supplementary materials [1]. The code snippet suggests that they use a replay buffer, which is designed to re-use historical data in RL. \n\nFor a training step $j$, data generated by $\\pi_i$, where $i < j$, are also considered as **off-policy data** because they do not follow the state-action distribution $\\rho_{\\pi_j}(s, a)$ of the current policy $\\pi_j$. Therefore, we believe that AlphaZero also uses a substantial amount of off-policy data, through experience replay.\n\n\n\n```\ndef train_network(config: AlphaZeroConfig, storage: SharedStorage,\n                  replay_buffer: ReplayBuffer):\n  network = Network()\n  optimizer = tf.train.MomentumOptimizer(config.learning_rate_schedule,\n                                         config.momentum)\n  for i in range(config.training_steps):\n    if i % config.checkpoint_interval == 0:\n      storage.save_network(i, network)\n    batch = replay_buffer.sample_batch()\n    update_weights(optimizer, network, batch, config.weight_decay)\n  storage.save_network(config.training_steps, network)\n```\n\n[1] AlphaZero Supplementary Materials. https://www.science.org/doi/10.1126/science.aar6404#supplementary-materials"
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1982/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700598223953,
                "cdate": 1700598223953,
                "tmdate": 1700601720404,
                "mdate": 1700601720404,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "F9ypqWoS3f",
                "forum": "fLf589bx1f",
                "replyto": "3qciWqe784",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1982/Reviewer_F9ov"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1982/Reviewer_F9ov"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your response and for addressing my questions!"
                    }
                },
                "number": 13,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1982/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700668490549,
                "cdate": 1700668490549,
                "tmdate": 1700668490549,
                "mdate": 1700668490549,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "Wx9Om7UI3i",
            "forum": "fLf589bx1f",
            "replyto": "fLf589bx1f",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1982/Reviewer_R5vH"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1982/Reviewer_R5vH"
            ],
            "content": {
                "summary": {
                    "value": "this work proposes a value-function based training/inference procedure for program synthesis. rather than training a model (a policy) that ingest context (e.g. given as natural language comments) and generates tokens of code, this work leverages a value function Q(s,a) = V(s) + A(s,a), where V and A are implemented as neural networks.\n\nIn order to make Q learning work, this paper proposes two \"tricks\", one being a good Q-value initialization, the other being a conservative bellman update. Without these tricks, the training procedure would either not converge at all or improve very slowly. \n\nOverall, this paper insists that they want to tackle the task of program generation by training a value function, and overcome a lot of challenges to make it work."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "## quality: good\nthe overall quality of the paper is good, in that it even worked at all, and the lack of adhoc tricks.\n\n### that it even worked at all\n\nThe biggest strength of this paper is that it has shown that code generation _can be_ done with a value network, despite the large number of state x action pairs needs to be considered, the unavailbility of a good initial Q function, and the volatility of the Q function \"blowing up\". Evaluation shown that the proposed method is on par with the policy based methods in terms of pass@k metrics.\n\nThe knowledge that value-based approach for code generation can be done _at all_ is a great merit, and cannot be under stated.\n\n### lack of ad-hoc \"tricks\"\n\nI find all the \"tricks\" presented in this work well founded and easy to understand. The reward hacking part is minimal and frankly very reasonable. Thus I am convinced this approach would work on different program synthesis domains just as well."
                },
                "weaknesses": {
                    "value": "## significance\n\nlack of evidence on why we need to do this to begin with\n\nThe following statement from the conclusion section is a very good motivation \" it is recognized being sample-inefficient (see e.g. Nachum et al., 2017), meaning poorly using off-policy data, even data previously generated\". Does this work actually demonstrate this with an experiment? I believe it should, to show (in a table) that the proposed method can \"learn more with less\", with x axis showing the amount of training data, and y-axis some performance metric. In case I have misread the paper and this is indeed one of the experiments, it should be top and foremost contribution this paper needs to claim. Currently this paper reads akin to \"we did it because we can\" but lacks the justification -- in the form of an experiment -- that this is something valuable to begin with.\n\nI could think of many other benefits of having a value function, for instance, sometimes people might want a top-k ranked programs, which could be tricky to do based on only policy, but very intuitive with a value based model.\n\nIf the authors are able to justify their work with some experimental evidence, showing the advantages of a value-based modeling, this work will be that much better.\n\n## clarity\nthis paper would benefit from a Figure1 that outline the overall \"workflow\" of the method. During reading of the paper, the phrase \"which is yet another difficulty one must overcome to train a value function .... we introduce technique X to tackle this problem.\" The number of tricks quickly adds up, making the paper difficult to follow.\n\nI feel the paper is overboard with definition and philosophy of \"what is policy-based\" and \"what is value-based / RL\". I believe these things have a very technical definition that the community can all agree with. The clean story could've been \"off-policy learning through value iteration for generation would be good, as it use less data. here's how to do it, here's an experiment showing how well we can do as a function of amount of human data required\".\n\nDefining program synthesis as \"generating program from natural language\" is imprecise, as there are other works of \"program synthesis\" that generates program from input-output examples alone, or those that work with constraint solvers that generates programs from correctness specifications. A better wording could benefit here, as I instinctively reacted poorly by the opening definition of program synthesis, thinking it is way too narrow."
                },
                "questions": {
                    "value": "## time to take sample?\n\nThe \"go to\" solution of program synthesis in the presence of given input-output examples (test cases) is to simply generate a vast number of programs, test all of them against spec through execution, and pick the ones that passed the test cases.\n\nThus, suppose I am a practitioner, the metric that I really care about is, given a synthesis problem, complete with natural language descriptions and a set of input-output test cases, and a time budget of 1 minute, can my synthesizer find a correct program?\n\nThis allows different methods to be compared head to head. A \"dumb\" enumerator -- for instance, a bigram generator -- might actually be reasonable of it can generate vast numbers of programs quickly, and a \"smart\" enumerator might actually be non-performative due to the time it takes to sample a full program to even check.\n\nThus, I would like to ask for the times it take to sample a full program on average, when compared against some of the other policy based methods."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1982/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698813538437,
            "cdate": 1698813538437,
            "tmdate": 1699636129670,
            "mdate": 1699636129670,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "XnguqfQy47",
                "forum": "fLf589bx1f",
                "replyto": "Wx9Om7UI3i",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1982/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1982/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to reviewer R5vH [Part 1/4]"
                    },
                    "comment": {
                        "value": "Thank you very much for your time in reviewing our work and for your positive assessment! We are glad that you found our work of good quality, and showing the feasibility of value-based approach is a great merit. We are enthusiastic about improving our paper by incorporating your valuable comments.\n\n---\n\nWe would like to address the clarity and significance questions in a somewhat mixed order, as beginning with the technical definitions would help us better explain our motivations. We outline our responses as follows, \n\n1. Our response to (a) clarifies the technical distinctions between (on-policy) policy-based and (off-policy) value-based methods, highlighting the data inefficiency of the former due to their inability to reuse historical data, a limitation rooted in their technical nature.\n\n2. Our response to (b) lists empirical evidence from RL literature and public RL benchmarks.\n\n3. Our response to (c) provides a demonstrative example to validate the intuition discussed in (a).\n\n4. The rest are responses to the reviewer's other concerns.\n\n---\n\n> (a) I feel the paper is overboard with definition and philosophy of \"what is policy-based\" and \"what is value-based / RL\". I believe these things have a very technical definition that the community can all agree with.\n\nAs pointed out by the reviewer, we do realize that our description was quite verbal, which could create ambiguity and confusion. Our intended focus is on the algorithm's capability to **re-use previously generated data**, as being unable to reuse old/historical data (costly to collect) is very inefficient. Mathematically, this can be characterized by determining whether the objective function requires **data to be drawn from the distribution induced by the current policy**, as demonstrated in the following examples:\n\n| Algorithm | Category     | On/Off-Policy | Objective                                                                                                          |\n|-----------|--------------|---------------|-----------------------------------------------------------------------------------------------------------|\n| vanila PG | policy-based | on-policy     | $ L(\\pi) = -\\mathbb{E}_{\\color{blue} \\tau\\sim\\pi} [R(\\tau)] $                                                      |\n| PPO       | policy-based | on-policy     | $ L(\\pi) = -\\mathbb{E}_{\\color{blue} \\tau \\sim {\\pi_k}} [ \\frac{\\pi(s, a)}{\\pi_k(s, a)}\\hat{A}(s, a) ] $    |\n| DQN       | value-based  | off-policy    | $ L(Q) = \\mathbb{E}_{\\color{blue} (s, a, s', r)\\sim D} [(Q-\\mathcal{B}^*Q)(s, a)]^2 $                              |\n| Ours      | value-based  | off-policy    |  $L(Q) = \\mathbb{E}_{\\color{blue} (s, a, s', r)\\sim D} [(Q-\\mathcal{B}^q Q)(s, a)]^2 $                             |\n\nwhere $R(\\cdot)$ is cumulative trajectory-wise returns, $k$ denotes the current gradient/update step, $\\tau \\sim \\pi$ or $\\tau \\sim \\pi_k$ indicates the trajectories $\\tau$ are rollouts collected by the **current policy** $\\pi$ or $\\pi_k$, whereas $D$ could be an **arbitrary dataset**.\n\nThis technical difference was not precisely reflected in our current writing, as commented by the reviewer. We are gratefully for the reviewer's suggestion on technical definitions, which will largely help us to improve our paper's clarity.\n\n**Remarks on practical aspect.** (on-policy) policy gradient methods, in principle, cannot reuse previously generated, as they won't follow the current policy's (state-action) distribution. This is undesirable as generating samples with Transformers are known to be expensive.\n\nPPOCoder indeed has some discussion on this aspect. To briefly recap, they generate synthetic programs at $k=0$ (prior to fine-tuning), and subsequently fine-tune their model using both human and synthetic programs drawn from this mixed distribution. It was observed in PPOCoder (Figure 3(e)) that *an increase in synthetic programs negatively impacts fine-tuning performance*. This is partly because the mixed distribution doesn't align with the fine-tuned policy's state-action distribution. \n\nHowever, with more data, an ideal objective is generally expected to either improve or at least maintain a policy's performance, not decrease it. In general, the use of (growing) historical off-policy data is the key to the better sample efficiency observed in off-policy value-based methods."
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1982/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700599709173,
                "cdate": 1700599709173,
                "tmdate": 1700604337249,
                "mdate": 1700604337249,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "QMvx9cil7e",
                "forum": "fLf589bx1f",
                "replyto": "Wx9Om7UI3i",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1982/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1982/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to reviewer R5vH [Part 3/4]"
                    },
                    "comment": {
                        "value": "**A demonstrative experiment.** \n\n- **An illustrative MDP.** (An illustrative figure of this MDP can be found [anonymously here](https://www.dropbox.com/scl/fi/u9q95izjbphnfsngo2jit/mdp.pdf?rlkey=g11cvr12sp2kbsjudf8fju6ln&dl=0).)\n    Consider a chain MDP, where there are $n+1$ states $s_0, \\ldots, s_n$ with two actions LEFT and RIGHT, where LEFT at $s_i$ proceed to the previous state $s_{i-1}$ with reward $r=1$, and RIGHT always proceed to the next state with  $r=-1$ except moving to the terminal state $s_n$, which has $r = k\\times H$, where $k \\geq 2$ and $H$ is the episode length. The optimal strategy should be always choosing RIGHT.\n\n- **Dataset.** We collect a dataset $D$ with an uniform policy with $\\pi(\\text{LEFT}|s) = \\pi(\\text{RIGHT}|s) = 0.5$ for all $s$. We will next use this dataset to simulate two scenarios: (1) dataset is on-policy: we optimize an uniform policy using this dataset, corresponding to optimizing an policy using on-policy dataset (as both are uniform); (2) we optimize a better policy $\\pi_{new}(\\text{RIGHT}|s)=0.75$ using this uniform dataset, corresponding to optimizing **an (new/improved) policy** using **old/historical dataset**.\n\n- **Training results.** (The training curves can be found [anonymously here](https://www.dropbox.com/scl/fi/usfy2awkn0tt2abkb0dih/training_curves.pdf?rlkey=64wkmw5lxdg4uv5b9yhs9vmss&dl=0).) (1) data is on-policy: Using $D$ to fine-tune an uniform policy, both PG and ours are able to improve the performance. (2) data is off-policy: We use $D$ to fine-tune a policy of $\\pi_{new}(\\text{RIGHT}|s)=0.75$. While the canonical PG loss is $ -\\mathbb{E}_{\\color{blue} \\tau\\sim\\pi} [R(\\tau)]$, reusing the old data (in program synthesis works) are often done by directly using the dataset's empirical distribution and the pseudo loss [7], i.e. \n\n    $L(\\pi) = -\\frac{1}{|D| H}\\sum_{\\color{blue} \\tau \\in D}\\sum_{t=1}^H [\\log \\pi(a_t|s_t) R(\\tau_{\\geq t})]$. \n\n    PG only performs better than the dataset average performance but **lower than the average returns of $\\pi_{new}$**, while ours could improves from $\\pi_{new}$.\n\n- **Remark on this observation.** For a pair $(s, a)$, let's first define ''dataset average returns'', $\\overline{R}(s, a) := \\frac{1}{|D| H} \\sum_{\\tau\\sim D} \\sum_{t=1}^H [ \\mathbb{I}(s_t=s) \\mathbb{I}(a_t=a) R(\\tau_{\\geq t})]$, where $\\mathbb{I}$ is an indicator function. In the case (2) described above, for a state $s$, optimizing $L(\\pi)$ is equivalent to finding $\\arg\\max_a \\overline{R}(s, a)$. It in fact has nothing to do with the initial policy's performance $J(\\pi_{new})$ but is only determined by the dataset $D$, i.e. finding the actions with higher ``dataset average returns''.\n\n    Figure ([anonymously available here](https://www.dropbox.com/scl/fi/es0bekguugaoinpxo7isn/policies.pdf?rlkey=3td8423cjw6jfm0yp8167r7ap&dl=0)) validates that PG consistently converges to the actions with higher average ``dataset average returns'' $\\overline{R}(s, a)$, instead of the optimal action, even when initialized from a near-optimal policy $\\pi_{new}$. This demonstrates that training a new/improved policy using old/historical data can lead to a decrease in policy performance (which also explains the observation found by PPOCoder)."
                    }
                },
                "number": 10,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1982/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700600289751,
                "cdate": 1700600289751,
                "tmdate": 1700601386201,
                "mdate": 1700601386201,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "EyxLakLzIE",
                "forum": "fLf589bx1f",
                "replyto": "Wx9Om7UI3i",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1982/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1982/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to reviewer R5vH [Part 4/4]"
                    },
                    "comment": {
                        "value": "> I could think of many other benefits of having a value function, for instance, sometimes people might want a top-k ranked programs, which could be tricky to do based on only policy, but very intuitive with a value based model.\n\nThis is indeed one of our considerations. The details, of selecting top-$k$ programs by value functions, are given in Section 4. In addition, for instance, one may also derive beam search strategy that maximizes values rather than likelihood and we certainly agree with the reviewer that having a value function create further opportunities.\n\n> Defining program synthesis as \"generating program from natural language\" is imprecise\n\nThank you for pointing it out. We realize that we were narrowly focused in terms of program synthesis definition, because we were somewhat limited to the specific APPS dataset. It is very true that the program synthesis problem should be more general. We are delighted to revise our definition to be more accurate and encompassing, in line with the reviewer's suggestion.\n\n\n> Time to take sample?\n\nWe take 5 problems from APPS test set (id 0 - 4) as examples and sampled 1000 programs for each, using one RTX 4090 24GB graphics card, with maximum batch sizes that do not create OOM errors. The table below shows the sampling time (in secs) per 1000 programs, in the format of mean$\\pm$std. Our method takes approximately 1.7 to 2.0 times longer to sample. \n\n| Temperature | CodeRL (batch size = 66) | Ours (batch size = 44)|\n|---------|---------|---------|\n| 0.4 | 291.18$\\pm$56.08 | 495.78$\\pm$189.35 |\n| 1.0 | 290.88$\\pm$56.20 | 595.84$\\pm$65.66 |\n\n\n**Remark on faster sampling.** While we originally proposed using $Q$ as logits for sampling, it is also feasible to use the advantage $A$ as logits for sampling, especially when the goal is to generate as many outputs as possible without evaluating $Q$ and $V$ values. This would not require evaluating $V$, and therefore, we would expect similar sampling times. Under the same setting, sampling with advantage $A$ takes $275.79$ seconds and $322.78$ seconds for temperatures of $0.4$ and $1.0$, respectively, which are similar to CodeRL as we expected.\n\n\n---\n\n[1] Nachum, Ofir, et al. \"Bridging the gap between value and policy based reinforcement learning.\" Advances in neural information processing systems 30 (2017).\n\n[2] Gu, Shixiang, et al. \"Q-Prop: Sample-Efficient Policy Gradient with An Off-Policy Critic.\" International Conference on Learning Representations. 2016\n\n[3] Haarnoja, Tuomas, et al. \"Soft actor-critic: Off-policy maximum entropy deep reinforcement learning with a stochastic actor.\" International conference on machine learning. PMLR, 2018.\n\n[4] Fujimoto, Scott, Herke Hoof, and David Meger. \"Addressing function approximation error in actor-critic methods.\" International conference on machine learning. PMLR, 2018.\n\n[5] Burda, Yuri, et al. \"Exploration by random network distillation.\" Seventh International Conference on Learning Representations. 2019.\n\n[6] Harutyunyan, Anna, et al. \"Hindsight credit assignment.\" Advances in neural information processing systems 32 (2019).\n\n[7] https://rail.eecs.berkeley.edu/deeprlcourse/deeprlcourse/static/slides/lec-5.pdf"
                    }
                },
                "number": 11,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1982/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700600315312,
                "cdate": 1700600315312,
                "tmdate": 1700600431103,
                "mdate": 1700600431103,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "BDU2kPKgOX",
                "forum": "fLf589bx1f",
                "replyto": "EyxLakLzIE",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1982/Reviewer_R5vH"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1982/Reviewer_R5vH"
                ],
                "content": {
                    "title": {
                        "value": "keeping the score"
                    },
                    "comment": {
                        "value": "thanks for the response! the work remains favorable after the response, and is a stronger form than what it was, especially the illustrative experiment.\n\nhad there been more time we would loved to see the full experiment demonstrating the effectiveness of value-based learning, both on the learning side (comapred to policy based) and on the application side (perhaps some experiments on ranking, etc)"
                    }
                },
                "number": 14,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1982/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700721018551,
                "cdate": 1700721018551,
                "tmdate": 1700721018551,
                "mdate": 1700721018551,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "cD3oi8YwqH",
            "forum": "fLf589bx1f",
            "replyto": "fLf589bx1f",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1982/Reviewer_dB3F"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1982/Reviewer_dB3F"
            ],
            "content": {
                "summary": {
                    "value": "The task is to generate code (sequence generation) given a natural language description, and to have that code pass the associated unit tests.\n\nThis is framed as an RL problem, and unlike most prior work it does not use an algorithm from the policy gradient family, but uses a sort of Q learning approach.\n\nThe main focus is on how to overcome the very long and large action space you get by treating each token as an action, and the sparse reward at the end. The main idea is to make good use of pre-trained language models that have been fine-tuned to generate code for given ground truth (description, code solution) pairs. \n\nUsing this is non-trivial however, and the paper takes a creative an impressive approach. \n\nThe main ideas are known but very nicely combined. Some highlights:\n- the pretrained model is used to initialise a sensible Q function before the RL training\n- decomposing Q(s,a) as state value + state-action advantage (dueling dqn)\n- conservative bellman updates to stabilise the rl training loop.\n\nA drawback of the approach is that it takes multiple steps, uses various tricky pre-training and residual fitting steps, and could be difficult to apply in practice. But this is not suprising since using Q learning here is challenging, and it is impressive the authors managed to make it work so well.\n\nDetailed comments:\n\n2.1 Policy: should say \"assigns an action *from the set* $\\Delta(\\mathcal A)$\" and generally this notation here needs checking.\n\nIn figure 2, why is zero training iterations the best? anyway this is a nice ablation / teaser for the paper.\n\nFig 3 is very cool indeed.\n\nGeneral question - since you sample a softened Q as your policy, you could actually apply policy gradients as well. What are the connections here? Could you combine your scheme with a policy gradient type of update?"
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "4 excellent"
                },
                "strengths": {
                    "value": "See the summary."
                },
                "weaknesses": {
                    "value": "See the summary."
                },
                "questions": {
                    "value": "See the summary."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1982/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698996503503,
            "cdate": 1698996503503,
            "tmdate": 1699636129612,
            "mdate": 1699636129612,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "5UPEcc1nLq",
                "forum": "fLf589bx1f",
                "replyto": "cD3oi8YwqH",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1982/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1982/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you very much for your time in reviewing our work and for your positive assessment! We are glad that you found our approach both creative and impressive! We are enthusiastic about improving our paper by incorporating your valuable comments.\n\n> 2.1 Policy: should say \"assigns an action from the set $\\Delta(\\mathcal{A})$\" and generally this notation here needs checking. \n\n\nThank you for bringing this to our attention. We noticed that our notation was indeed inconsistent. In the statement *``assigns an action distribution $\\Delta(\\mathcal{A})$ ..., meaning predicting a token $\\hat{w}_t$''*, the first part refers to a distribution over actions, while the latter suggests a single token. We'll revise our notation accordingly to  ensure better clarity and consistency.\n\n> In figure 2, why is zero training iterations the best? anyway this is a nice ablation / teaser for the paper.\n\nWe hypothesize that it is because the initial checkpoint has been already fine-tuned on the training set, hence having a good performance. Nonetheless, as the reviewer pointed out, we believe it highlights the difficulty of value-based training and the necessity of the proposed components.\n\n\n\n> General question: since you sample a softened $Q$ as your policy, you could actually apply policy gradients as well. What are the connections here? Could you combine your scheme with a policy gradient type of update?\n\n\n\nAs our focus was on value-based learning, we did not incorporate a policy gradient loss in our framework. However, we believe this could be a promising and exciting direction, as one may benefit from both the robustness of policy optimization and sample-efficiency of value-based learning, with careful designs.\n\n**Can PG loss be combined?** Yes, as suggested by the reviewer, it is certainly feasible to optimize $Q$-function with policy gradient objective through an energy-based policy, by computing $\\nabla_\\theta \\log \\pi_Q(a|s) = \\nabla_\\theta [Q_\\theta(s, a)/\\alpha - \\log \\sum_u \\exp (Q_\\theta(s, u)/\\alpha)] $ (which is tractable due to a discrete vocabulary) and then plugging it into policy gradient.\n\n\n**Connection.** This question leads us to an earlier work [1], which exactly explores the combination of policy-based and value-based learning, by leveraging energy-based policies. This could also be considered as an actor-critic framework with a shared network ($s \\to \n \\text{shared net} \\to Q \\xrightarrow{\\mathrm{softmax}} \\pi$ ), which is feasible when $\\mathcal{A}$ is discrete. And the shared network can be optimized by the combination of policy gradient and temporal difference losses, applied to $\\pi$ and $Q$ respectively. \n\n We are thankful to the reviewer for this inspirational question, which creates an exciting opportunity. And we will include further discussion on this combination, along with relevant works, into our revision.\n\n[1] O'Donoghue, Brendan, et al. \"Combining policy gradient and Q-learning.\" International Conference on Learning Representations. 2016.\""
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1982/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700598093115,
                "cdate": 1700598093115,
                "tmdate": 1700598093115,
                "mdate": 1700598093115,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]