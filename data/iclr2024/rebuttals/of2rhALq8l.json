[
    {
        "title": "AffineQuant: Affine Transformation Quantization for Large Language Models"
    },
    {
        "review": {
            "id": "B1guzAPsxD",
            "forum": "of2rhALq8l",
            "replyto": "of2rhALq8l",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1842/Reviewer_MkcQ"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1842/Reviewer_MkcQ"
            ],
            "content": {
                "summary": {
                    "value": "This work develops a quantization method that uses an affine matrix transformation to quantize the weights of a transformer. By doing so, the objective function has more parameters to be optimized and can achieve lower quantization error when the weight matrix is compressed to a low-bit representation (2-bit). \n\nRecommendation: The presentation and results are currently misleading. I might miss something, but currently, the method has no practical benefit. If the authors can explain to me what I am missing, I am happy to raise my score significantly (2-4 points). I will also raise my score by 2 points if the presentation of 2-bit results is dropped in favor of an analysis of information density (scaling curves that show Pareto fronts in terms of performance per bit of total memory footprint)."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "The results from affine quantization are strong compared to baselines."
                },
                "weaknesses": {
                    "value": "- The paper misleadingly highlights 2-bit quantization when the same paper shows higher information density for 4-bit quantization (4-bit + 7B params > 2-bit + 13B params, etc.). This is a mistake that is propagated in the literature. I will not accept work that presents quantization results like this because it is very misleading.\n- It is unclear what the benefit of the method is. To use the quantization in practice, the inverse affine transformation matrix is needed to convert the input tensor. However, by having to store this matrix, the size of the model is doubled, which negates FLOPs and memory benefits. Am I missing something?"
                },
                "questions": {
                    "value": "- How does the process work at inference time? If you optimize with the affine matrix during quantization, you surely need it during inference time.\n- How fast is inference for this method compared to baselines?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission1842/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1842/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1842/Reviewer_MkcQ"
                    ]
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1842/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698709001941,
            "cdate": 1698709001941,
            "tmdate": 1700698819986,
            "mdate": 1700698819986,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "Q8CZX2Pxtm",
                "forum": "of2rhALq8l",
                "replyto": "B1guzAPsxD",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1842/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1842/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "**W1: When the paper shows that 4-bit quantization has a higher information density, the results emphasizing 2-bit quantization are misleading.**\n\n**Reply:** We admit the conclusion that 4 bit quantization has a higher information density than 2 bit quantization. To prevent any potential misinterpretation, we have removed references to the 2 bit quantization results from the abstract and the body of the paper, replacing them with the 4/4 bit results that incur no additional overhead. Our experimental results continue to outperform after modifying the quantization configuration.\n\n**W2: In practice it is necessary to store affine matrices, which doubles the model size and thus negates the FLOPs and memory benefits of quantization.**\n\n**Reply:** The modified AffineQuant doesn't need to store matrices because it can be fused into the weight and bias of LayerNorm and Linear. Specifically, we optimize only the diagonal elements of the affine matrix, enabling integration with the weight and bias of LayerNorm. Additionally, we apply the affine matrix between v and out\\_proj, as well as between q,k output activations, allowing fusion with the weight and bias of the q, k, v, out_proj Linear layer. We take the linear layer v and the previous LayerNorm as an example and formally,\n$$\n\\begin{align}\n\\gamma^{'}&=\\gamma\\cdot diag(A_{qkv})^{-1}, \\tag 1 \\\\\\\\\n\\beta^{'}&=\\beta\\cdot diag(A_{qkv})^{-1}, \\tag 2 \\\\\\\\\nW_{v}^{'} &= diag(A_{qkv})W_{v}A_{vo}^{-1}, \\tag 3 \\\\\\\\\nbias_{v}^{'} &= bias_{v}A_{vo}^{-1}. \\tag 4\n\\end{align}\n$$\nWhere $\\gamma$, ${\\gamma}^{'}$, $\\beta$, ${\\beta}^{'}$ are the LayerNorm parameters before and after the affine transformation. $diag(\\cdot)$ is the diagonal matrix fetching operation. $A_{qkv}$ is the optimal affine matrix at the Linear layer $q$,$k$,$v$. $W_v$, $bias_v$ are the weights and bias of the Linear layer $v$. $A_{vo}^{-1}$ is the inverse of the optimal affine matrix between $v$ and out projection.\n\nTherefore, AffineQuant does not incur additional FLOPs as well as memory overhead. Meanwhile, we compare the 4/4 bit quantization performance of LLaMA1&2 models on WikiText2 and C4 datasets in the following table.\n\n|            | Methods     | WikiText2 | C4    |\n| ---------- | ----------- | --------- | ----- |\n| LLaMA-7B   | OmniQuant   | 11.26     | 14.51 |\n|            | AffineQuant | 10.28     | 13.64 |\n| LLaMA-13B  | OmniQuant   | 10.87     | 13.78 |\n|            | AffineQuant | 10.32     | 13.44 |\n| LLaMA-30B  | OmniQuant   | 10.33     | 12.49 |\n|            | AffineQuant | 9.35      | 11.58 |\n| LLaMA2-7B  | OmniQuant   | 14.26     | 18.02 |\n|            | AffineQuant | 12.69     | 15.76 |\n| LLaMA2-13B | OmniQuant   | 12.30     | 14.55 |\n|            | AffineQuant | 11.45     | 13.97 |\n\n**Q1-2: How does the process work at inference time? How fast is inference for this method compared to baselines?**\n\n**Reply:** For the experiments in the table above we optimize the matrix after LayerNorm for diagonal elements only. This allows us to fuse the affine matrix with the LayerNorm weights and bias. For the remaining positions, we apply matrix transformations. After optimization, the matrix can be further fused with the weights and bias of the preceding linear layer. Consequently, AffineQuant can be achieved without introducing any additional overhead to model inference. We utilize the MLC-LLM [2] library to compile the LLaMA model at various scales under only-weight quantization configuration on a single A100, and the resulting inference speeds are presented in the following table.\n\n| LLaMA     | 7B    | 7B    | 7B      | 13B   | 13B   | 13B     | 30B   | 30B   | 30B     | 65B   | 65B   | 65B     |\n| --------- | ----- | ----- | ------- | ----- | ----- | ------- | ----- | ----- | ------- | ----- | ----- | ------- |\n|           | WM    | RM    | token/s | WM    | RM    | token/s | WM    | RM    | token/s | WM    | RM    | token/s |\n| FP        | 12.6G | 14.4G | 69.2    | 24.3G | 27.1G | 52.5    | 60.6G | 66.1G | 23.9    | OOM   | -     | -       |\n| W4A16g128 | 3.8G  | 5.7G  | 155.3   | 7.0G  | 10.0G | 102.7   | 16.7G | 21.7G | 45.2    | 33.0G | 41.0G | 25.2    |\n| W3A16g128 | 3.2G  | 5.1G  | 87.9    | 5.8G  | 8.7G  | 63.7    | 13.7G | 18.7G | 30.3    | 27.0G | 35.1G | 15.7    |\n| W2A16g128 | 2.2G  | 4.1G  | 84.5    | 4.0G  | 7.5G  | 95.2    | 9.2G  | 14.1G | 38.3    | 18.0G | 25.6G | 25.6    |\n\n**Q3: scaling curves that show Pareto fronts in terms of performance per bit of total memory footprint.**\n\n**Reply:** In the Appendix, we provide the PPL vs. weight-memory Pareto-optimal curves for LLaMA1&2 models of different sizes in the 4/4 bit quantization configuration. The results clearly demonstrate that AffineQuant consistently outperforms the current State-Of-The-Art method, OmniQuant, without any additional overhead."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1842/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700622506147,
                "cdate": 1700622506147,
                "tmdate": 1700622506147,
                "mdate": 1700622506147,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "hPaJfwhLz8",
                "forum": "of2rhALq8l",
                "replyto": "Q8CZX2Pxtm",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1842/Reviewer_MkcQ"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1842/Reviewer_MkcQ"
                ],
                "content": {
                    "title": {
                        "value": "Thank you for helping me understand."
                    },
                    "comment": {
                        "value": "Thank you for your rebuttal, this was very helpful. I think what was confusing me is the term \"fused\". Fused operations often load memory in SRAM and are reused. As such, they have no memory and FLOPs advantage. I think a better term for your method would be \"merged\" instead of \"fused\".\n\nOtherwise, the removal of the reference to 2-bit quantization make all claims robust. As such, I no longer see any problem with the paper.\n\nSince everything can be merged into layernorms and other layers this method is actually quite practical and shows strong results. As such, all my concerns are alleviated and I am impressed. I would like this paper to be accepted. I would be happy if this paper would be highlighted as a spotlight."
                    }
                },
                "number": 15,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1842/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700698797130,
                "cdate": 1700698797130,
                "tmdate": 1700698797130,
                "mdate": 1700698797130,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "WHx30xcIpr",
            "forum": "of2rhALq8l",
            "replyto": "of2rhALq8l",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1842/Reviewer_E6YB"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1842/Reviewer_E6YB"
            ],
            "content": {
                "summary": {
                    "value": "The paper introduces \"AffineQuant\", a method to optimize Large-scale Language Models (LLMs) using equivalent Affine transformations in Post-Training Quantization (PTQ). Traditional PTQ techniques often resulted in significant errors, especially in low-bit configurations. AffineQuant expands the optimization scope, reducing these errors. Using a unique gradual mask optimization method aligned with the Levy-Desplanques theorem, invertibility of transformations is ensured. The results show AffineQuant outperforms existing methods, especially in low-bit configurations, making it a promising tool for model compression and deployment."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "- This paper is well-written and successfully exhibit their features.\n- This paper extends current PTQ papers to introduce affine transformation to MRE (minimum reconstruction error) methods. It could be reasonable in the line of quantization papers' history."
                },
                "weaknesses": {
                    "value": "- The paper appears to overlook contemporary quantization methodologies like FlexRound. Notably, FlexRound seems to be a successor in the lineage of MRE-PTQ techniques, such as BrecQ and QDrop, designed for LLM compression. A comparative analysis with these methods would accentuate the novelty and efficacy of the proposed technique. Reference for consideration: https://arxiv.org/abs/2306.00317.\n\n- Regarding Figure 3, my understanding is that the loss of a partial layer during MRE PTQ might not directly correlate with improved model performance, especially in the context of generative AI models.\n\n- I have a few observations concerning Section 4, which details experimental results:\n   1) A significant concern is the sole reliance on PPL scores as a performance metric. While it corresponds to dataset loss, recent LLM compression research suggests that PPL may not fully capture the generative capabilities post-quantization. It might be worthwhile to consider metrics like common-sense reasoning or evaluations using the MMLU dataset.\n   2) Additionally, an increase in PPL scores by over 10 points indicates a significant degradation in the generation capabilities of the quantized model. Thus, contrasting the performance of such models, like the W2A16 results mentioned in the abstract, might not provide meaningful insights. A closer look at the actual generation outputs from these severely quantized models could reveal issues like non-coherent results or repeated verbiage.\nLastly, larger models could yield different outcomes, as they might exhibit distinct patterns of outliers or weight distributions."
                },
                "questions": {
                    "value": "included in weaknesses."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission1842/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1842/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1842/Reviewer_E6YB"
                    ]
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1842/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698758691365,
            "cdate": 1698758691365,
            "tmdate": 1700722018754,
            "mdate": 1700722018754,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "wvidaj6FSs",
                "forum": "of2rhALq8l",
                "replyto": "WHx30xcIpr",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1842/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1842/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "**W1: Comparisons and analyses with FlexRound serve to emphasize AffineQuant's novelty and validity.**\n\n**Reply:** FlexRound [1] is a commendable paper. However, it is orthogonal to our approach. Because,\n\n1. FlexRound proposes an element-by-element division weight rounding scheme designed to break away from the upper or lower rounding of Adaround [2], BRECQ [3]. AffineQuant proposes an affine transformation matrix to make the distribution of weights and activations more suitable for quantization.\n2. FlexRound's rounding scheme can explore more aggressive rounding scenarios for a large magnitude of weight values to achieve the global reconstruction error optimization. AffineQuant proposes the gradual mask to provide stable computation of the inverse of the affine matrix during the optimization process.\n3. The optimized weight rounding values are orthogonal to the optimized weight activation distribution. After using AffineQuant to fuse the optimal affine matrix into the original model, we can use FlexRound to minimize the reconstruction error by performing secondary reconstruction with the optimized model weight rounding values.\n\nAffineQuant focuses on post-training quantization without fine-tuning, making the LoRA fine-tuning experiments in FlexRound not applicable to our approach. Furthermore, FlexRound does not provide clear information on whether it quantizes the input activations of both matmul operations for weight-activation quantization in LLM. In contrast, AffineQuant quantizes all input activations except for the softmax input activation of the second matmul. To compare their performance, we present the results of FlexRound in the 4/16 bit quantization configuration in the table below. It is important to note that AffineQuant, as shown in the table, only updates the diagonal elements of the matrix after LayerNorm to maintain model inference without any additional overhead. We place the comparison experiments in Appendix of the paper.\n\n|                        | PIQA($\\uparrow$) | ARC-e($\\uparrow$) | WinoGrande($\\uparrow$) | BoolQ($\\uparrow$) | ARC-c($\\uparrow$) | HellaSwag($\\uparrow$) | Avg.($\\uparrow$) |\n| ---------------------- | ---------------- | ----------------- | ---------------------- | ----------------- | ----------------- | --------------------- | ---------------- |\n| FP16                   | 77.37            | 52.52             | 66.85                  | 73.12             | 41.38             | 72.99                 | 64.04            |\n| LLaMA-7B, FlexRound    | 77.75            | 50.80             | 66.06                  | 70.73             | 40.27             | 71.97                 | 62.93            |\n| LLaMA-7B, AffineQuant  | 77.53            | 51.85             | 66.93                  | 70.89             | 38.65             | 71.49                 | 62.89            |\n| FP16                   | 79.11            | 59.89             | 70.01                  | 68.53             | 44.54             | 76.23                 | 66.38            |\n| LLaMA-13B, FlexRound   | 78.78            | 59.55             | 70.40                  | 66.39             | 43.77             | 75.52                 | 65.73            |\n| LLaMA-13B, AffineQuant | 78.84            | 59.55             | 69.38                  | 69.48             | 43.52             | 75.18                 | 65.99            |\n\n**W2: Loss of some layers during MRE may not be directly related to improved model performance.**\n\n**Reply:** You raise a very good question. We have done sampling experiments based on this question. Specifically, we maintain consistent matrix initialization while randomly sampling the stability factor $\\alpha$, which influences loss convergence, for LLaMA-7B and OPT-6.7B. Using AffineQuant, we obtain the performance of 4/4 bit quantized models based on the sampled solution. In the Appendix of our paper, we present scatter plots depicting the output loss of the last transformer block and the corresponding model performance. These plots demonstrate a significant positive correlation between loss and model performance, with correlation coefficients of 0.95,0.96 on OPT-6.7B and LLaMA-7B, respectively. Based on this observation, we conclude that the quantization loss of the last transformer block's output exhibits a strong correlation with overall model performance. Thanks again for your constructive comments."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1842/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700622173708,
                "cdate": 1700622173708,
                "tmdate": 1700622173708,
                "mdate": 1700622173708,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "MhxvP7FxCn",
                "forum": "of2rhALq8l",
                "replyto": "WHx30xcIpr",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1842/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1842/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thanks again for your great efforts and constructive advice in reviewing this paper! With the discussion period drawing to a close, we expect your feedback and thoughts on our reply. We put a significant effort into our response, with several new experiments and discussions. We sincerely hope you can consider our reply in your assessment. We look forward to hearing from you, and we can further address unclear explanations and remaining concerns if any.\n\nRegards,\n\nAuthors"
                    }
                },
                "number": 17,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1842/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700702941443,
                "cdate": 1700702941443,
                "tmdate": 1700708264330,
                "mdate": 1700708264330,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "fnbHOZwI2X",
                "forum": "of2rhALq8l",
                "replyto": "MhxvP7FxCn",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1842/Reviewer_E6YB"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1842/Reviewer_E6YB"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for the detailed response. I will revise my score since the author has acknowledged and made corrections regarding the part I thought was the most problematic (the PPL results for 2-bit)."
                    }
                },
                "number": 19,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1842/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700722001717,
                "cdate": 1700722001717,
                "tmdate": 1700722001717,
                "mdate": 1700722001717,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "V4dcRqItSy",
            "forum": "of2rhALq8l",
            "replyto": "of2rhALq8l",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1842/Reviewer_5dxF"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1842/Reviewer_5dxF"
            ],
            "content": {
                "summary": {
                    "value": "Propose affine transformation in PTQ (in line with \"equivalent transformations\" line of work) based on specialized optimization approach involving a \u201cgradual masking\u201d to ensure a viable affine matrix is trained."
                },
                "soundness": {
                    "value": "4 excellent"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "4 excellent"
                },
                "strengths": {
                    "value": "- A more general approach than several proceedings works in the space of \u201cequivalent transformations\u201d, and a nice explanation in Section 3.1\n- strong empirical results"
                },
                "weaknesses": {
                    "value": "- I imagine there is an increased computational cost to the proposed method. Is that the reason why results on larger OPT (ie 66B) or Llama (70B) models were not reported? My understanding is that this is the main tradeoff: a more powerful quantization method, but at an increased computational cost?"
                },
                "questions": {
                    "value": "- In terms of a computation vs quantization performance tradeoff, what do the authors think about just fine-tuning the model after some standard quantization method? I understand how the gradual mask training approach makes this cheaper than fine-tuning the full model, but it still appears expensive enough that it\u2019s difficult to get results on the largest OPT/Llama models. I think this is an interesting method, more of a point of discussion."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1842/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698785129666,
            "cdate": 1698785129666,
            "tmdate": 1699636114131,
            "mdate": 1699636114131,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "NHcX8IKbZh",
                "forum": "of2rhALq8l",
                "replyto": "V4dcRqItSy",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1842/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1842/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "**W1: Is the increased computational cost the reason for not reporting the results of the larger model?**\n\n**Reply:** For OPT-66B and LLaMA-65B models the optimization time is 82h and 78h respectively, which is much reduced compared to LLM-QAT [1] (80 GPU hours of fine-tuning time on LLaMA-7B). The ppl of OPT-66B and LLaMA-65B on WikiText2 are 10.19 and 8.85, respectively. we will report the larger model runtime comparison and the model performance in a future version.\n\n**Q1: What do the authors think about just fine-tuning the model after some standard quantization method in terms of a computation vs quantization performance tradeoff?**\n\n**Reply:** AffineQuant methods, based on post-training quantization, offer significant efficiency and performance advantages over fine-tuning methods. This holds true for both training and inference overhead.\n\n1. In terms of training costs, **Q**uantization **A**ware-**T**raining (QAT) for LLM involves the fine-tuning process to address quantization errors. LLM-QAT [1] requires 80 GPU hours to fine-tune the model for a single A100 on LLaMA-7B. The time taken to generate the data used for fine-tuning the model on LLaMA-7B is not included in this count. In comparison, AffineQuant quantizes LLaMA-7B in just 6.5 hours on a single A100. Similarly, for LLaMA-65B, AffineQuant takes only 78 hours to obtain the quantized model, which is comparable to LLM-QAT on LLaMA-7B. However, LLM-QAT does not report the training cost of the 65B model. Despite the significantly expensive fine-tuning process, LLM-QAT does not demonstrate any advantage over AffineQuant in terms of experimental results. Please refer to the table below for further details.\n\n|                     | Bits  | PIQA($\\uparrow$) | ARC-e($\\uparrow$) | WinoGrande($\\uparrow$) | BoolQ($\\uparrow$) | ARC-c($\\uparrow$) | HellaSwag($\\uparrow$) | Avg.($\\uparrow$) |\n| ------------------- | ----- | ---------------- | ----------------- | ---------------------- | ----------------- | ----------------- | --------------------- | ---------------- |\n| FP16                | -     | 79.3             | 73.0              | 70.0                   | 76.8              | 48.0              | 76.1                  | 70.5             |\n| LLM-QAT+SmoothQuant | 4-4-4 | 55.9             | 35.5              | 50.6                   | 62.4              | 26.4              | 47.8                  | 46.4             |\n| AffineQuant         | 4-4-4 | 69.4             | 42.6              | 55.3                   | 63.7              | 31.9              | 57.7                  | 53.4             |\n\n2. For the inference cost, for the experiments in the table above we optimize the matrix after LayerNorm for diagonal elements only. This allows us to fuse the affine matrix with the LayerNorm weights and bias. For the remaining positions, we apply matrix transformations. After optimization, the matrix can be further fused with the weights and bias of the preceding linear layer. Consequently, AffineQuant can be achieved without introducing any additional overhead to model inference. We utilize the MLC-LLM [2] library to compile the LLaMA model at various scales under only-weight quantization configuration on a single A100, and the resulting inference speeds are presented in the following table.\n\n| LLaMA     | 7B    | 7B    | 7B      | 13B   | 13B   | 13B     | 30B   | 30B   | 30B     | 65B   | 65B   | 65B     |\n| --------- | ----- | ----- | ------- | ----- | ----- | ------- | ----- | ----- | ------- | ----- | ----- | ------- |\n|           | WM    | RM    | token/s | WM    | RM    | token/s | WM    | RM    | token/s | WM    | RM    | token/s |\n| FP        | 12.6G | 14.4G | 69.2    | 24.3G | 27.1G | 52.5    | 60.6G | 66.1G | 23.9    | OOM   | -     | -       |\n| W4A16g128 | 3.8G  | 5.7G  | 155.3   | 7.0G  | 10.0G | 102.7   | 16.7G | 21.7G | 45.2    | 33.0G | 41.0G | 25.2    |\n| W3A16g128 | 3.2G  | 5.1G  | 87.9    | 5.8G  | 8.7G  | 63.7    | 13.7G | 18.7G | 30.3    | 27.0G | 35.1G | 15.7    |\n| W2A16g128 | 2.2G  | 4.1G  | 84.5    | 4.0G  | 7.5G  | 95.2    | 9.2G  | 14.1G | 38.3    | 18.0G | 25.6G | 25.6    |\n\n\n\n[1] Liu et al., LLM-QAT: Data-Free Quantization Aware Training for Large Language Models.\n\n[2] MLC-LLM, https://github.com/mlc-ai/mlc-llm."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1842/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700622023176,
                "cdate": 1700622023176,
                "tmdate": 1700622023176,
                "mdate": 1700622023176,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "wN4SlPCOWd",
                "forum": "of2rhALq8l",
                "replyto": "NHcX8IKbZh",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1842/Reviewer_5dxF"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1842/Reviewer_5dxF"
                ],
                "content": {
                    "title": {
                        "value": "Response"
                    },
                    "comment": {
                        "value": "Thanks for the interesting followup! The comparison to LLM-QAT is informative, this is certainly a regime where there's a significant gap between fine-tuning and this proposed method."
                    }
                },
                "number": 18,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1842/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700716811455,
                "cdate": 1700716811455,
                "tmdate": 1700716811455,
                "mdate": 1700716811455,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "ab2Ws1ZLzu",
            "forum": "of2rhALq8l",
            "replyto": "of2rhALq8l",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1842/Reviewer_gGYu"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1842/Reviewer_gGYu"
            ],
            "content": {
                "summary": {
                    "value": "The paper introduces a method for post-training quantization of Large Language Models (LLMs), specifically focusing on the linear layers. This quantization is uniform, employing fixed bit widths across the layers. The proposed approach involves learning an affine transformation (which is more general than single scaling) of weights before quantization by minimizing the MSE loss. The authors aim to ensure that this matrix remains non-singular, employing the Levy-Desplanques theorem and their proposed Gradual Mask (GM) method. Experiments are conducted on various model variants, including OPT and LLaMA, where the proposed algorithm is comparable or outperforms previous works, especially in low bit-width configurations.\n\n=================================\n\nUpdate: \nThe authors addressed my concerns, and I have increased the given rating correspondingly."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. The paper expands on pre-quantization transformations by introducing invertible affine transformations, which are more versatile than previous methods that rely on simple scaling.\n2. The proposed post-training quantization method for LLMs addresses a timely and pressing need due to the growing popularity of LLMs with their large model sizes.\n3. The method's ability to avoid model retraining is a substantial practical advantage since retraining LLMs can be computationally expensive and time-consuming.\n4. The weight transformation before quantization is not limited to LLMs; it can be applied to linear layers in different models as well.\n5. Inference speed is unaffected, as the additional matrices can be fused with the weight matrices.\n6. The paper provides extensive experimental results, including comparisons across different datasets and NLP models."
                },
                "weaknesses": {
                    "value": "1. A significant weakness of this paper is the lack of clarity in explaining the implementation of the core concept, which involves the use of strictly diagonal matrices and the proposed Gradual Mask (GM). Figure 2 suggests that the GM matrix is element-wise multiplied by the matrix A, but the description implies a different interpretation, where it functions as a learning rate for each element in A. This discrepancy needs further clarification to provide a complete understanding of the method.\n\n2. The hyper-parameters $b$ (bit-width) and $\\alpha$ (stability factor) may introduce significant computational overhead in the pursuit of determining the optimal trade-off between model size and accuracy."
                },
                "questions": {
                    "value": "1. The method employs non-differentiable components in its optimization approach. It would be interesting to understand how the authors address this challenge in practice."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission1842/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1842/Reviewer_gGYu",
                        "ICLR.cc/2024/Conference/Submission1842/Senior_Area_Chairs"
                    ]
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1842/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698820654368,
            "cdate": 1698820654368,
            "tmdate": 1700680190097,
            "mdate": 1700680190097,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "SXgUTWxPOM",
                "forum": "of2rhALq8l",
                "replyto": "ab2Ws1ZLzu",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1842/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1842/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "**W1: The lack of clarity in explaining the implementation of the core concept.**\n\n**Reply:**\n\n1. We apologize for the lack of clarity in the presentation of the concept. As you mentioned, we have modified our description in the newest version:\n2. Gradual Mask (GM) is a learning rate regulator that achieves its purpose by element-wise dot-producting with the matrix A.\n3. Specifically, the impact of the GM matrix on the optimization process can be divided into two aspects. Here, we present the optimization process for the matrix A after incorporating the GM.\n\n$$\n\\begin{align}\n\t \\textbf{Forward:} \\quad & A^{*}_{e} = A\\_{e} \\circ GM\\_{e}, \\tag 1\\\\\\\\\n\t \\textbf{Backward:} \\quad & A\\_{e+1} = A\\_{e} + \\eta \\\\frac{\\\\partial L}{\\\\partial A^{\\*}\\_{e}} \\\\frac{\\\\partial A^{\\*}\\_{e}}{\\\\partial A\\_{e}}, \\tag 2\\\\\\\\\n  &\\quad\\quad~=A\\_{e}+\\eta GM\\_{e}\\\\frac{\\\\partial L}{\\\\partial A^{\\*}\\_{e}}. \\tag 3\n\\end{align}\n$$\n\n\u200b\tWhere $\\circ$ is the Hadamard product. $A_{e}$ and $GM_{e}$ are the matrices $A$ and Gradual Mask (GM) matrix in epoch $e$, respectively. $\\eta$ is the learning rate of matrix $A$. $L$ is the optimization loss. The GM matrix effectively reduces the magnitude of non-principal diagonal elements in matrix $A$ during forward propagation when the stability factor $\\alpha$ is less than $1$. This ensures the existence of a stable inverse matrix of $A^{*}$ in the optimization process during epoch $e$, as per the Levy-Desplanques theorem. In backward propagation, GM affects the learning rate $\\eta$, thereby suppressing the update rate of non-primary diagonal elements in matrix $A$. Consequently, the impact of GM on $\\eta$ ensures that matrix $A$ in epoch $e+1$ maintains strictly diagonally dominant, satisfying the Levy-Desplanques theorem.\n\n**W2: The hyper-parameters $b$ (bit-width) and $\\alpha$ (stability factor) may introduce computational overhead.**\n\n**Reply:** Both the hyperparameter $b$ (bit-width) and $\\alpha$ are determined by the requirements in different application scenarios. We thus conclude that, neither hyperparameter is chosen in a way that introduces additional overhead to the optimization process.\n\n**Q1: How the authors address the non-differentiable components in its optimization approach.**\n\n**Reply:** The gradient approximation is determined from **S**traight-**T**hrough **E**stimator (STE) [1], which is formally represented by the following equation:\n$$\n\\frac{\\partial L}{\\partial x} = \\frac{\\partial L}{\\partial Q(x)}\\frac{\\partial Q(x)}{\\partial x}\\approx \\frac{\\partial L}{\\partial Q(x)}\\textbf{1}_{x},\\tag 4\n$$\n\n$$\n\\textbf{1}_{x} = \\\\left\\\\{ \n    \\begin{array}{ll}\n        1 & 0\\leq \\lfloor \\frac{x}{\\Delta} \\rceil+zp \\leq 2^n-1, \\\\\\\\\n        0 & otherwise. \\\\\\\\\n    \\end{array}\n\\right\\. \\tag 5\n$$\n\nPlease kindly refer to the `round_ste` function in the anonymous link `quantize/quantizer.py` for the precise code implementation.\n\n[1] Bengio~et al., Estimating or propagating gradients through stochastic neurons for conditional computation."
                    }
                },
                "number": 1,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1842/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700621731830,
                "cdate": 1700621731830,
                "tmdate": 1700621731830,
                "mdate": 1700621731830,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "3DR66qmbBx",
                "forum": "of2rhALq8l",
                "replyto": "SXgUTWxPOM",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1842/Reviewer_gGYu"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1842/Reviewer_gGYu"
                ],
                "content": {
                    "comment": {
                        "value": "Are there any guarantees that if matrix $A_e$ is strictly diagonal, then $A_{e+1}$ is strictly diagonal?"
                    }
                },
                "number": 11,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1842/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700640603215,
                "cdate": 1700640603215,
                "tmdate": 1700640603215,
                "mdate": 1700640603215,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "1TD1wUgQq6",
                "forum": "of2rhALq8l",
                "replyto": "ab2Ws1ZLzu",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1842/Reviewer_gGYu"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1842/Reviewer_gGYu"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your response. I believe that incorporating an adaptive $\\alpha$ could further enhance GM's performance. Specifically, I suggest considering bounding $\\alpha$ at each iteration using the initial values of matrix $N$, the learning rate $\\eta$, and the gradient value at epoch $h$. Given that $\\eta$ decreases over epochs, adjusting the parameter $\\alpha$ accordingly might provide additional benefits."
                    }
                },
                "number": 13,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1842/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700679928049,
                "cdate": 1700679928049,
                "tmdate": 1700680437294,
                "mdate": 1700680437294,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "o6nk6Fkj3a",
                "forum": "of2rhALq8l",
                "replyto": "ab2Ws1ZLzu",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1842/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1842/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your suggestion. We will implement adaptive adjustments to the stability factor $\\alpha$."
                    }
                },
                "number": 14,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1842/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700697998737,
                "cdate": 1700697998737,
                "tmdate": 1700698042152,
                "mdate": 1700698042152,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]