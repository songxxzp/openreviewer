[
    {
        "title": "Grounding Language Plans in Demonstrations Through Counter-Factual Perturbations"
    },
    {
        "review": {
            "id": "Urs8L3BGcO",
            "forum": "qoHeuRAcSl",
            "replyto": "qoHeuRAcSl",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6834/Reviewer_i3As"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6834/Reviewer_i3As"
            ],
            "content": {
                "summary": {
                    "value": "This paper introduces a framework that autonomously discovers mode families within robot manipulation trajectories with the help of an LLM. Once these mode families are identified, they serve two key purposes: 1) facilitating learning mode-conditioned policies, and 2) enabling the creation of pseudo-attractors that enhance the robustness of the policies against out-of-distribution states. \n\nThe LLM plays a vital role in the framework by: 1) decomposing tasks into a sequence of modes, and 2) generating relevant state features for each mode as inputs to the mode classifiers. To train these mode classifiers, the authors propose to augment expert-demonstrated trajectories with negative ones generated by counterfactual perturbations. Additionally, they design several loss terms aimed at aligning the trajectories with the mode sequences generated by the LLM. Specifically, the loss terms encourage: 1) consistent state transitions within the same mode family, and 2) matched mode transitions between the success trajectories and those generated by the LLM.\n\nIn a 2D toy example and a robot manipulation domain, quantitative evaluations verify the effectiveness of the proposed method in 1) accurately identifying modes, and 2) learning mode-conditioned policies that are robust against perturbations."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "This work is a good practice to utilize an LLM to facilitate the learning of motion-level robot - by learning task structures and identifying important state features. The paper is well-written: the problem is sufficiently motivated and the framework is clearly-explained. In the experiments, the authors properly conduct comparisons and ablation studies to demonstrate the effectness of the proposed framework."
                },
                "weaknesses": {
                    "value": "My primary concern of the paper pertains to details of the method, specifically the transition feasibility matrix and transition loss. \n\nBased on the definition of transition feasibility matrix $T_{i,j}=max(i-j+1, 0)$, we get $T_{i,j} = 0$ for $i < j$ and $T_{i,j} > 0$ otherwise. But this doesn\u2019t match the illustration in the right subfigure in Figure 3, where there is \u201c-1\u201d in the matrix. More importantly, the usage of the transition feasibility matrix in the transition loss (in Section 3.2) might be problematic. My guess is that $T_{k,l}$ helps penalize mode transitions following the opposite direction for successful trajectories; however, the successful trajectories seem not to contribute to the loss term at all since $\\tau(succ)=0$. I would appreciate more clarifications from the authors on this.\n\nI also think \u201cthis work introduces a groundbreaking framework\u201d in the conclusion section is overclaimed. I agree that this is an interesting work, and could be a solid one if the authors properly addess my concern above. However, I would still regard the contribution as incremental, as it only offers an alternative solution to many of the unsupervised trajectory segmentation approach."
                },
                "questions": {
                    "value": "1. When prompting an LLM to generate keypoints, how to make the correspondence between the generated textual description such as \u201cnut-center\u201d and the continuous positions? Do you need to add the list of available keypoints into the prompt?\n2. Sometimes the demonstrated trajectories do not perfectly follow the LLM-generated mode transitions. Can the learning framework handle these cases?\n3. How much does the LLM-based feature selection contribute to learning the mode classifiers and motion policies? Do you by any chance evaluate the framework using the full state for mode learning?\n4. I wonder in the RoboSuite experiment, how do the proposed method (MMLP-Conditional BC) work in the absence of the pseudo-attractor? It will be great to add these results as well as the authors have a better understanding on how different modules contribute to the robustness against perturbations."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission6834/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission6834/Reviewer_i3As",
                        "ICLR.cc/2024/Conference/Submission6834/Senior_Area_Chairs"
                    ]
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6834/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698034249492,
            "cdate": 1698034249492,
            "tmdate": 1700625520526,
            "mdate": 1700625520526,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "Rrk6xA5NxW",
                "forum": "qoHeuRAcSl",
                "replyto": "Urs8L3BGcO",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal (1/3)"
                    },
                    "comment": {
                        "value": "Dear reviewer i3As, \n\nThanks for your detailed review and feedback! We will first elaborate on our framework and method using two new figures and then respond to your individual questions. \n\n**[What grounding problem are we solving?]** There are at least three kinds of grounding mentioned in the literature: **1. Task grounding** - using language [1] or multi-modal tokens [2] as inputs to an imitation policy to specify tasks/goals. **2. Symbolic grounding** - predicting the Boolean values of symbolic state (e.g. In(can, gripper)=True, On(marbles, spoon)=False, etc) [3, 4, 5] **3. Action grounding** - mapping LLM plan to predefined primitive actions [6, 7, 8] In our work, by grounding we do not mean task grounding, but rather symbolic grounding, where we learn classifiers that map continuous states/observations to discrete modes proposed by LLM. Since we assume each mode is associated with a single policy that\u2019s learned from segmented demonstrations, action grounding can also be achieved as a by-product of learning the classifier, which maps the LLM planned mode sequence to a sequence of policy rollouts.\nWe have created a **new figure -- Fig 7** that we include in the revised paper and is currently on the website in [this section](https://sites.google.com/view/grounding-plans/home#h.xly3b8ysna28) that illustrates our overall method including a visual description of how we ground the LLM knowledge in modes.\n\n**[Clarification of our feasibility matrix and transition loss]** We appreciate the reviewer spotting some inconsistency in our original writing and figure 3. In response, we made a new figure to clarify the feasibility matrix and explain the transition loss in terms of success loss and failure loss.\nWe have created a **new figure -- Fig 8** that we include in the revised paper and is currently on the website in [this section](https://sites.google.com/view/grounding-plans/home#h.pmzm9p2g4j7v) that illustrates both how we use LLMs to generate the classifier state and how this information is used downstream to compute the classifier loss.\n\n**[How do successful trajectories contribute to the loss term?]** In Figure 8 \\(c\\), when the classifier is not well trained, it might predict some invalid transitions for successful trajectories and consequently incur a success loss. We plan to update the loss function in the manuscript and update a new version soon."
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6834/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700518941061,
                "cdate": 1700518941061,
                "tmdate": 1700518941061,
                "mdate": 1700518941061,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "ZtIrAqvvw8",
                "forum": "qoHeuRAcSl",
                "replyto": "Urs8L3BGcO",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal (2/3)"
                    },
                    "comment": {
                        "value": "**[Is this work merely an alternative to unsupervised trajectory segmentation?]** While we agree with the reviewer that the word \"groundbreaking\" might be overclaiming, we respectfully disagree our method is merely a trajectory segmentation method. In our work, the capability to segment trajectories is merely a by-product of having learned the grounding classifier. The typical goal of trajectory segmentation in LfD literature is to discover reusable skills that can be activated open-loop [9, 10, 11]. Their goal is not concerned with performance degradation under external perturbations. In contrast, our goal is to learn the boundaries of these mode abstractions that define the valid domains of the discovered skills, as shown in the new Figure 7(d), so that the learned skills can be planned in a closed-loop fashion that is robust to external perturbations. Given the differences in motivations, our framework has two significant technical differences:\n1. First, since our grounding operator needs to classify/segment not only demonstrated trajectories, but also state space that has not been demonstrated (i.e. need to find mode boundaries), we will need to generate additional data to cover the state space being considered beyond just the demonstration regions. Additionally, in order to learn the boundary we would need executions that succeed by crossing feasible boundaries as well as executions that fail by crossing infeasible boundaries. This additional data generation stage is not considered in typical trajectory segmentation setting that works with only successful demonstrations and not failures. The significantly larger scale of counterfactual data might render non-end-to-end systems such as those using HMM/probabilistic inference impractical [12]. \n2. Second, the aforementioned segmentation methods are not induced by the necessity to predict terminal task failures/success and hence does not necessarily break down demonstrations into minimal abstractions with which planning success can be guaranteed despite perturbations. The key insight is that mode families are a useful construct to help achieve planning success guarantee. The reason that boundary between consecutive mode families have to separate configuration spaces in a particular way is that otherwise the the motion planning won\u2019t guarantee success. Consequently, we can use mode partitions to explain why some but not all perturbations will cause execution failures. Inspired by this idea, we devise a fully differentiable end-to-end explanation pipeline that predicts if a perturbed trajectory is successful or not. Only when the grounding classifier in the pipeline has learned the correct mode partitions, can the overall pipeline differentiating all successful trajectories from failure trajectories. Our explanation-based learning approach is similar to analysis-by-synthesis in other domains. For example, in NeRF only when an accurate 3d representation has been learned can the fully differentiable volumetric rendering pipeline generates images that match groundtruth from all views. To operationalize this idea, our transition loss (both the success loss and failure loss) enforces correct explanation why some perturbations do not fail a successful demonstration but others do, which subsequently enforces our learned classifier to ground continuous boundary states to match those discrete mode families provided by LLM, leading to segmentation of atomic skills useful for replanning under perturbations. To show the importance of our transition loss, we show (1) in 2d polygon domain a clustering-based trajectory segmentation baseline using similarity metric does not lead to correct mode boundaries; and (2) in robosuite domains our loss ablating out the transition loss (effectively an unsupervised trajectory segmentation based only on motion similarity [11]) does not lead to accurate grounding. These new results are documented on an anonymous project website https://sites.google.com/view/grounding-plans/home."
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6834/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700519014283,
                "cdate": 1700519014283,
                "tmdate": 1700519014283,
                "mdate": 1700519014283,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "ipZKlVBsX3",
                "forum": "qoHeuRAcSl",
                "replyto": "Urs8L3BGcO",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal (3/3)"
                    },
                    "comment": {
                        "value": "In particular, in 2d polygon domain, we compare our learned mode classifications with the groundtruth on demonstration trajectories (Therefore the reporting scores are trajectory segmentation accuracies). The following table shows the comparison with ablation model (no counterfactual data) and a simple unsupervised trajectory segmentation baseline by KMeans++ clustering.\n\n| Mode Classifier      | 3-Mode | 4-Mode | 5-Mode |\n| ----------- | ----------- | ----------- | ----------- |\n| Ours      | **0.990**       | **0.967** | **0.970** |\n| No Counterfactual Data   | 0.604  | 0.464 | 0.831 |\n| Trajectory Segmentation Baseline | 0.644 |0.554 | 0.641\n\n\nFor robosuite, We also report the average trajectory segmentation accuracy (compared to ground truth) for each method. \n\n| Mode Classifier      | Can | Lift | Square Peg\n| ----------- | ----------- | ----------- | ----------- |\n| Ours (LLM-reduced State Space)     | **0.83**       | **0.83** | **0.67** |\n| Full State Space | 0.55 | 0.70 | 0.57 |\n| Trajectory Segmentation Baseline  | 0.66        | 0.56 | 0.54 |\n\n**[Correspondence between the generated textual description and the continuous positions]** In robosuite environments, the demonstration state consists of predefined object states corresponding to those keypoints shown in figure 8 (a). We add a full list of available keypoints to the prompt when query LLM to find a subset of features relevant to a task. More prompting examples can be found on the website in [this section](https://sites.google.com/view/grounding-plans/home#h.743770ss0gzs). \n\n**[What if the demos do not perfectly follow the LLM generated plan?]** In this work, we give humans LLM-generated plan for humans to provide demonstrations, so that we assume these successful demonstrations can be mapped to the same discrete plan even these demonstrations might come from a multimodal distribution in the continuous configuration space. In future work we will investigate how to map demonstrations with non-unique discrete structure to partial or nonlinear LLM plan.\n\n**[How important is LLM-based feature selection?]** LLM-based feature selection helps improve data efficiency as also shown independently by [13, 14] For example, the state of distractor objects is not useful for learning a classifier that detects different modes in the demonstrations of picking up a can object. Including distractor objects\u2019 states as inputs require significantly more counterfactual data to learn a classifier that does not pay attention to distractor objects. To corroborate this claim, we run the default full set of features of as state representation to learn the grounding classifier for robosuite tasks. We show that the resulting segmentation does not align well with the ground truth (see [table](https://sites.google.com/view/grounding-plans/home#h.7l0jx2g9td4d)) and plan to add qualitative results on the website in [this section](https://sites.google.com/view/grounding-plans/home#h.7l0jx2g9td4d).\n\n**[How MMLP-conditional BC work in the absence of pseudo-attractor?]**\nWe apologize for the lack of clarity in the original description. The mode-conditioned policy is conditioned in the sense that the pseudo-attractor varies depending on the predicted mode by the system. However, the imitation policy is not conditioned on mode (i.e., without the pseudo-attractor is the same as the BC). We also tried conditioning the imitation learning on the mode (i.e., learning a different BC network for the state-action pairs classified in each mode), however, we found that this did not substantially impact the performance of the policy.\n\n\n[1] Language Conditioned Imitation Learning over Unstructured Data \n\n[2] VIMA: General Robot Manipulation with Multimodal Prompts \n\n[3] Grounding Predicates through Actions\n\n[4] From Skills to Symbols: Learning Symbolic Representations for Abstract High-Level Planning\n\n[5] Learning Temporal Logic Formulas from Suboptimal Demonstrations: Theory and Experiments\n\n[6] SayCan: Grounding Language in Robotic Affordances\n\n[7] Skill induction and planning with latent language\n\n[8] Text2Motion: From Natural Language Instructions to Feasible Plans\n\n[9] TACO: Learning Task Decomposition via Temporal Alignment for Control\n\n[10] LEAGUE: Guided Skill Learning and Abstraction for Long-Horizon Manipulation\n\n[11] Learning Rational Subgoals from Demonstrations and Instructions\n\n[12] Learning grounded finite-state representations from unstructured demonstrations\n\n[13] ELLA: Exploration through Learned Language Abstraction\n\n[14] Learning with Language-Guided State Abstractions"
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6834/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700519088042,
                "cdate": 1700519088042,
                "tmdate": 1700519088042,
                "mdate": 1700519088042,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "5J4rycSpOf",
                "forum": "qoHeuRAcSl",
                "replyto": "ipZKlVBsX3",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6834/Reviewer_i3As"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6834/Reviewer_i3As"
                ],
                "content": {
                    "comment": {
                        "value": "I would like to thank the authors for their efforts to prepare the detailed explanations, figures and extra results.\n\nThe explanations resolve the majority of my concerns and confusions if not all of them. I'm delighted to raise my rating to 8. I would suggest the authors take some time to reflect the work done during the rebuttal in the final submission. Especially, it would be nice if the authors could modify the writing carefully to:\n- clarify on the mode transition matrix\n- define the loss terms correctly with math\n- clarify on the \"Mode-conditioned BC\"\n\nI look forward to reading the final version of this paper!"
                    }
                },
                "number": 10,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6834/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700625491938,
                "cdate": 1700625491938,
                "tmdate": 1700625491938,
                "mdate": 1700625491938,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "mngFnfdezx",
            "forum": "qoHeuRAcSl",
            "replyto": "qoHeuRAcSl",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6834/Reviewer_Mzap"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6834/Reviewer_Mzap"
            ],
            "content": {
                "summary": {
                    "value": "The paper presents a method to learn mode-conditioned policy for sequential manipulation tasks. The method proceeds in four stages: 1) prompting LLMs to generate a plan that contains multiple modes as well as keypoints and features for detecting the mode, 2) gather human demonstrations, augment them with noise, and execute in the environment to obtain success/failure labels, and 3) learning a mode classifier, and 4) learning a mode-conditioned policy. The empirical results are shown on a 2D polygon domain, where an agent needs to sequentially traverse through all the modes and reach a configuration in the final mode, and on three tasks in Robosuite."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "- The paper text is overall clear\n- The presented idea seems to be novel\n- The finding may be of general interest for the ICLR community"
                },
                "weaknesses": {
                    "value": "- It seems that the paper is conflated with two distinct problems: 1) generating modes and key detection features using LLMs and grounding them for sequential manipulation tasks, and 2) learning a robust mode-conditioned policy from a few demonstrations. The paper sufficiently demonstrates (2) but more evidence needs to be shown for (1), and currently the two contributions seem quite disconnected. For example, although in the method section the paper discusses how LLMs may generate reasonable mode families and key detection features for those modes, in experiment section the experiments use manually-defined modes instead of LLM-generated modes and use manually-labeled features instead of relying on automatic mechanism for grounding. Therefore, it is questionable whether the paper should be made relevant to LLMs at all.\n- The clarity of the figures need to be greatly improved. (Figure 1) It\u2019s unclear what the task even is and what the different colored lines represent, and this has to be inferred by the reader. (Figure 3) What does the coloring mean in the center figure? How can we interpret the feasibility matrix? (Figure 4) Again, the readers may need to guess what the task is. (Figure 5) In what order of the color should the agent follows? What does the difference in coloring between each sub-figure mean here?"
                },
                "questions": {
                    "value": "- How are the keypoints and features being grounded in the demonstrations?\n- How is the feasibility matrix generated from LLMs and is it being kept fixed for each task?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission6834/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission6834/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission6834/Reviewer_Mzap"
                    ]
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6834/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698776185934,
            "cdate": 1698776185934,
            "tmdate": 1700722919474,
            "mdate": 1700722919474,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "2PIk0HXtUy",
                "forum": "qoHeuRAcSl",
                "replyto": "mngFnfdezx",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal (1/4)"
                    },
                    "comment": {
                        "value": "Dear reviewer Mzap, \n\nThanks for your detailed review and feedback! Please find our response below:\n\n**[Relevance to LLM]** The major concern of the reviewer is whether LLM is integral to our framework. The reviewer acknowledges that we show sufficiently the robustness of our mode-based policy to external perturbations, but argues that we do not show enough evidence that we solve the grounding problem. We respectfully disagree because solving the grounding problem is a prerequisite for our approach to robustify policy. In the following we first clarify what we mean by grounding, and second we explain LLM's relevance both in terms of the intent and implementation of this work. Lastly, we present more evidence on how not using LLM will adversely affect how well the grounding can be learned.\n\n**[What grounding problem are we solving?]** There are at least three kinds of grounding mentioned in the literature: **1. Task grounding** - using language [1] or multi-modal tokens [2] as inputs to an imitation policy to specify tasks/goals. **2. Symbolic grounding** - predicting the boolean values of symbolic state (e.g. In(can, gripper)=True, On(marbles, spoon)=False, etc) [3, 4, 5] **3. Action grounding** - mapping LLM plan to predefined primitive actions [6, 7, 8] In our work, by grounding we do not mean task grounding, but rather symbolic grounding, where we learn classifiers that map continuous states/observations to discrete modes proposed by LLM. Since we assume each mode is associated with a single policy that\u2019s learned from segmented demonstrations, action grounding can also be achieved as a by-product of learning the classifier, which maps the LLM planned mode sequence to a sequence of policy rollouts. We have created a **new figure -- Fig 7** that we include in the revised paper and is currently on the website, [linked here](https://sites.google.com/view/grounding-plans/home#h.xly3b8ysna28), which illustrates our overall method including a visual description of how we ground the LLM knowledge in modes.\n\n**[The intent is to enable LLM-based discrete planning]** To order to use LLM for high-level planning, existing work [6, 8] typically assume symbolic classifiers and/or action primitives are given, i.e. the symbolic/action grounding part has been manually engineered. What\u2019s left for this top-down approach is to search for a sequence of actions (grounded in language) with high overall feasibility/success rate when applying these actions in the physical space. In contrast, **the intent of our work is to reduce human involvement in engineering the classifiers and the grounded action primitives when using LLM for discrete planning**. Specifically, we take the bottom-up approach to discover action primitives grounded in demonstrations by learning a classifier to map continuous demonstrations to discrete LLM-proposed mode sequence. Since these skills are segmented from successful demonstrations and grounded in modes/physical space, our framework do not need humans to define them a priori or calculating the feasibility of executing them in the physical space as required in the top-down approach. Note that we do not claim to completely automate humans out of the loop as our framework do require humans to provide a few demonstrations as well as prompting the LLM to generate task-relevant features and feasibility matrix. But we do believe that LLM is best used for discrete planning in the symbolic space and there is a role for humans to provide the continuous signals grounded in the physical space (rather than prompting LLM to produce the continuous components such as control signals). Our work enables this view by learning the mapping from continuous physical space to the discrete symbolic space."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6834/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700518506695,
                "cdate": 1700518506695,
                "tmdate": 1700518506695,
                "mdate": 1700518506695,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "YNqyVSGZdr",
                "forum": "qoHeuRAcSl",
                "replyto": "mngFnfdezx",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal (2/4)"
                    },
                    "comment": {
                        "value": "**[The intent requires solving the robust policy learning task to evaluate grounding]** The reviewer might be wondering why we tackle the problem of learning a robust mode-conditioned policy from a few demonstration if the intent is to learn a grounding classifier. To evaluate the utility of grounding in the physical spaces, we need to probe the boundary of the learned classifier. While visualizing boundaries is easy in the 2d polygon domain, it is difficult in the high-dimensional manipulation space. For manipulation, mode families are a useful construct to help achieve planning success [9, 10]. The reason that mode families have boundaries is that otherwise the the motion planning won\u2019t guarantee success. Therefore, **evaluating the effectiveness of classifier's prediction boundary can be proxied by evaluating whether the classified modes can increase the execution success rate** especially under external perturbations. The consideration of external perturbations is distinct from prior work that use pre-defined high-level actions such as \u201cwalk to \\<PLACE\\>\u201d [11], \u201c(pick ball)\u201d [12] \u201copen(obj)\u201d [7]. These high-level actions are sufficient if there are no external perturbations to derail the execution. Otherwise, decomposing these actions further into manipulation modes grounded in the physical space are necessary for (1) replanning/robustifying the actions against adversarial perturbations as well as (2) explaining why some but not all perturbations will cause execution failures. Inspired by this idea, we devise a fully differentiable end-to-end explanation pipeline that predicts if a perturbed trajectory is successful or not. Only when the grounding classifier in the pipeline has learned the correct mode partitions, can the overall pipeline differentiating all successful trajectories from failure trajectories. Our explanation-based learning approach is similar to analysis-by-synthesis in other domains. For example, in NeRF only when an accurate 3d representation has been learned can the fully differentiable volumetric rendering pipeline generate images that match groundtruth from all views.\n\n**[The implementation requires LLM's common sense knowledge]** The main novel contribution is the method with which we learn the grounding classifier rather than how we implement the mode-based policy that improves robustness to perturbations. Our implementation requires LLM to provide common sense knowledge about the discrete task structure that are complementary to low-level continuous demonstrations. Specifically, (1) LLM informs how many modes there are as well as generating a matrix that describes the feasibility of transitioning from one mode to another. Without knowing the number of modes, trajectory clustering or segmentation is a NP-hard problem [13, 14]. (2) LLM reduce the dimensionality of feature space and improve data efficiency as separately investigated in [15, 16]. For example, the state of distractor objects is not useful for learning a classifier that detects different modes in the demonstrations of picking up a can object. Including distractor objects' states as inputs require significantly more counterfactual data to learn a classifier that does not pay attention to distractor objects. (3) LLM is integral to replanning at test time when there is perturbation. The utility of the learned grounding operator lies in its ability to explain when perturbation derails a plan and its capability to map the replanned discrete mode sequence from LLM to continuous policy rollout. We have created a **new figure -- Fig 8** that we include in the revised paper and is currently on the website, [linked here](https://sites.google.com/view/grounding-plans/home#h.7l0jx2g9td4d) that illustrates both how we use LLMs to generate the classifier state and how this information is used downstream to compute the classifier loss.\n\n**[Evidence that we use LLM knowledge to successfully learn grounding]** We present the following results on an anonymous project website https://sites.google.com/view/grounding-plans/home.\n1. To show we have successfully learned grounding in the 2d polygon domain, we compare our learned mode classifications with the groundtruth on demonstration trajectories (Therefore the reporting scores are trajectory segmentation accuracies). The following table shows the comparison with ablation model (no counterfactual data) and a simple trajectory segmentation baseline by KMeans++ clustering.\n\n\n| Mode Classifier      | 3-Mode | 4-Mode | 5-Mode |\n| ----------- | ----------- | ----------- | ----------- |\n| Ours      | **0.990**       | **0.967** | **0.970** |\n| No Counterfactual Data   | 0.604  | 0.464 | 0.831 |\n| Trajectory Segmentation Baseline | 0.644 |0.554 | 0.641\n\nAdditionally, in Table 1 of the paper, the MMLP-Stable\\(p\\) and MMLP-Stable rows show that we can achieve near 100% success rate of reaching the final mode either with or without perturbations through planning in the learned mode partitions."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6834/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700518614572,
                "cdate": 1700518614572,
                "tmdate": 1700518614572,
                "mdate": 1700518614572,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "XfMIyk2klo",
                "forum": "qoHeuRAcSl",
                "replyto": "mngFnfdezx",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal (3/4)"
                    },
                    "comment": {
                        "value": "2. To show we have successfully learned grounding in the robosuite environments, we show figures on the website of segmenting the trajectories into modes similar to the groundtruth that we manually designed. We also report (below and on the website) the average mode classification accuracy (compared to ground truth) for our method. Additionally, we show videos for each robosuite task the performance of BC baseline without and with perturbations and how our mode-based imitation policy can better recover from perturbations as indirect evidence that we have learned useful mode classification.\n\n| Mode Classifier      | Can | Lift | Square Peg\n| ----------- | ----------- | ----------- | ----------- |\n| Ours (LLM-reduced State Space)     | **0.83**       | **0.83** | **0.67** |\n| Full State Space | 0.55 | 0.70 | 0.57 |\n| Trajectory Segmentation Baseline  | 0.66        | 0.56 | 0.54 |\n\n\n3. To show the importance of prompting the LLM for the correct feasibility matrix, we run 2d polygon experiments where the 3-mode and 4-mode tasks are given a generic sequential 5-mode feasibility matrix $F^5$ and the 5-mode task is given a 3-mode feasibility matrix $F^3$. We show the resulting learned mode boundaries does not match the groundtruth. Taking the second mode in the 3-mode task (the first polygon) as an example, while our model recovers 0.946 of the first mode region (measured as the F1 score), the baseline completely mis-identified the first mode (F1 = 0). This will cause issues for robot following mode sequences when they try to recover from perturbations. See also [this section](https://sites.google.com/view/grounding-plans/home#h.12fce10e77be29fa_3) on our website for qualitative evaluations.\n4. To show the importance of prompting the LLM to reduce the feature set, we run the default full set of features as the state representation to learn the grounding classifier for robosuite tasks. In the above table, we also provide the mode classification accuracy for this method compared to ground truth and show that for all three robosuite tasks, it is lower than our method with the LLM-generated features.\n5. We generate feasibility matrices by querying LLMs to generate pairwise connectivities between modes (see our response to \"How is the feasibility matrix generated from LLMs and is it being kept fixed for each task\" below for details). Similarly, prompt LLMs to select a subset of features for training mode classifiers and policies. We include the prompts and LLM responses for robosuite tasks on our website. \n\nWe hope these results on the website are sufficient evidence to show that our approach has learned grounding and how LLM is integral in this process. One can argue that our method does not need LLM as a human can easily generate the feasibility matrix or the reduced feature set for a task. But this argument exactly supports why LLM is a good proxy for a human model as they can do the same task interchangeably. And just like the other LLM-based embodied AI works [6, 7, 8, 11, 12, 15, 16], we are using LLM to reduce human work that humans are good at rather than the other way around.\n\n**[Whether we use manually labelled modes and features to learn the grounding]** There is a misunderstanding that the reviewer thinks we \"use manually-defined modes instead of LLM-generated modes and use manually-labeled features instead of relying on automatic mechanism for grounding\". In fact, we only use manually-defined modes and features to construct a ground-truth mode classifier, which is used to evaluate our mode classifier *learned* using LLM-generated feasibility matrix and subset features as described above in figure 7 and 8. \n\n**[Improve figure readability]** \nWe have made several changes regarding figures in our updated manuscript. First, we introduced two new figures (Fig 7/8) that provide a more clear high-level explanation of the overall method as well as how the LLM is used in the grounding. You can view these figures at the top of our new website (https://sites.google.com/view/grounding-plans/home). These are aimed to replace the existing Figure 1 and Figure 3 where the reviewer had concerns around interpretability of the Figures. For Figures 4/5, we have updated figure captions per the reviewer's request in the new paper draft. We have included version of the Figures with updated captions on the website (very bottom) and plan to make further visual changes to Figure 4 to improve interpretability. \n\n**[How are the keypoints and features being grounded in the demonstrations]** In robosuite environments, the demonstration state consists of predefined object states corresponding to those keypoints shown in figure 8 (a). We add a full list of available keypoints to the prompt when query LLM to find a subset of features relevant to a task. More prompting examples can be found on the website in [this section](https://sites.google.com/view/grounding-plans/home#h.743770ss0gzs)."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6834/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700518754985,
                "cdate": 1700518754985,
                "tmdate": 1700518754985,
                "mdate": 1700518754985,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "VRco3lMj9b",
                "forum": "qoHeuRAcSl",
                "replyto": "mngFnfdezx",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal (4/4)"
                    },
                    "comment": {
                        "value": "**[How is the feasibility matrix generated from LLMs and is it being kept fixed for each task?]** To generate the feasibility matrix, we first prompt LLM to generate the connectivity between each pair of modes. Next, we define the feasibility matrix entry $F[i, j]$ as the negative distance between each pair of modes (i.e., the shortest path) if $j$ is reachable from $i$; otherwise $F[i, j]$ is zero. In the simplest case where all mode transitions form a chain (which is true for our 2d polygon and robosuite tasks), $F[i, j] = 0$ for all $j \\le i + 1$ (i.e., at mode $i$ we can transit to the next mode $i+1$ or to any previous modes $j < i$); and $F[i, j] < 0$ for all transitions that skips modes (e.g., directly make a transition from mode 1 to 3). After generating the feasibility matrix based on the task description (e.g., lift up a block from the table), we fix it for the task. The feasibility matrix is interpretable; therefore, human experts can also modify this matrix manually.\n\n[1] Language Conditioned Imitation Learning over Unstructured Data \n\n[2] VIMA: General Robot Manipulation with Multimodal Prompts \n\n[3] Grounding Predicates through Actions\n\n[4] From Skills to Symbols: Learning Symbolic Representations for Abstract High-Level Planning\n\n[5] Learning Temporal Logic Formulas from Suboptimal Demonstrations: Theory and Experiments\n\n[6] SayCan: Grounding Language in Robotic Affordances\n\n[7] Skill induction and planning with latent language\n\n[8] Text2Motion: From Natural Language Instructions to Feasible Plans\n\n[9] Multi-Modal Motion Planning in Non-Expansive Spaces\n\n[10] Integrated Task and Motion Planning\n\n[11] Language Models as Zero-Shot Planners:\u00a0Extracting Actionable Knowledge for Embodied Agents\n\n[12] PDDL PLANNING WITH PRETRAINED LARGE LANGUAGE MODELS\n\n[13] NP-hardness of Euclidean sum-of-squares clustering\n\n[14] Segmentation of Trajectories on Nonmonotone Criteria\n\n[15] ELLA: Exploration through Learned Language Abstraction\n\n[16] Learning with Language-Guided State Abstractions"
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6834/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700518806055,
                "cdate": 1700518806055,
                "tmdate": 1700518806055,
                "mdate": 1700518806055,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "ChHc3bkNr7",
                "forum": "qoHeuRAcSl",
                "replyto": "bm4Lh84Hck",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6834/Reviewer_Mzap"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6834/Reviewer_Mzap"
                ],
                "content": {
                    "title": {
                        "value": "Thank you for the response"
                    },
                    "comment": {
                        "value": "I would like to thank the authors for their detailed response, additional experiments, new illustrative figures, and real-world experiments. These new results and clarifications have cleared most of my previous concerns and misunderstandings of the paper. I'm happy to raise my recommendation to 6.\n\nWhile the paper presents an interesting and insightful use of LLMs for manipulation tasks, the reason I'm withholding a stronger recommendation is that: because LLMs can serve as good human proxy, they are often most useful when the method can be interpreted as \"in either the training or deployment stage, it effectively acts as humans to reduce actual human engineering\". However, it doesn't seem like the paper falls into either category.\n\n(a) In training stage,  in order to accomplish a new task (either high-level or low-level), the LLM is only used to automate a very small portion of the pipeline, because after the LLM does inference, humans are still required to provide demonstrations, which arguably involves nontrivial effort. With this amount of effort, the human can easily just write the \"ground-truth\" mode decomposition and transition matrix as well.\n\n(b) In deployment stage, the authors claimed that \"LLM is integral to replanning at test time when there is perturbation\". However, the way I understand it is that LLMs are *not* being used in closed loop for replanning. Instead, it is only used in the beginning to decompose the modes and the associated predicates/symbols. After this, it is not being queried at test time, and these mode classifiers are being used for replanning. Can authors clarify this? Regarding this point, the authors should also discuss relevance to works in Task and Motion Planning (TAMP) domain, because the symbolic predicate and the transition matrix effectively encode the \"pre-conditions\" and \"post-conditions\" in TAMP. As shown in [1] (which is also cited in the paper), after the LLM outputs a domain specification, one may use search-based planner to perform closed-loop planning, which handles external disturbances well and can accomplish similar tasks.\n\nDue to the above reasons, while the use of LLMs here is innovative, I believe it dilutes the contributions of learning robust mode-conditioned policies. If the purpose of the paper was to focus more on the LLM aspect, it would be more ideal to demonstrate on a lot larger set of tasks, as the main advantage of LLMs is that they provide generalization to diverse scenarios.\n\nHaving said these, I believe the paper contains useful insights for the community and agree with other reviewers that this is a novel step towards using LLMs for robotics tasks. I also appreciate the authors' efforts during the rebuttal stage to include the new results and improve the paper. Therefore, I'm now leaning toward accepting the paper.\n\n[1] Liu, Bo, et al. \"Llm+ p: Empowering large language models with optimal planning proficiency.\" arXiv preprint arXiv:2304.11477 (2023)."
                    }
                },
                "number": 15,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6834/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700722941744,
                "cdate": 1700722941744,
                "tmdate": 1700722941744,
                "mdate": 1700722941744,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "RaoFE2fgEQ",
                "forum": "qoHeuRAcSl",
                "replyto": "r86t91V2ix",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6834/Reviewer_Mzap"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6834/Reviewer_Mzap"
                ],
                "content": {
                    "title": {
                        "value": "Thank you for the clarification"
                    },
                    "comment": {
                        "value": "Thank you for the clarification.\n\nRegarding (b), I do not fully understand why LLMs are queried again in the deployment stage. Since the LLMs have already outputted the sequence of modes and the transition feasibility matrix (and we have learned the mode classifier), we can simply use the mode classifier and the transition matrix for closed-loop replanning -- no LLM call is necessary. This was what I meant by \"deployment stage\". Is that correct?"
                    }
                },
                "number": 17,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6834/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700728125553,
                "cdate": 1700728125553,
                "tmdate": 1700728125553,
                "mdate": 1700728125553,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "cH1dUxTUu8",
            "forum": "qoHeuRAcSl",
            "replyto": "qoHeuRAcSl",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6834/Reviewer_Rhgd"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6834/Reviewer_Rhgd"
            ],
            "content": {
                "summary": {
                    "value": "The central idea is to leverage mode families (defines a specific type of motion constraint among a set of objects and can be chained together to represent complex manipulation behaviors) from manipulation research, in combination with LLMs for robust and grounded manipulation.  The authors framework Manipulation Modes from Language Plans (MMLP)  learns manipulation mode families from language plans and counterfactual perturbations. Given a small number of human demonstrations for the task and a small language description of the task, MMLP automatically reconstructs the sequence of mode switches required to achieve the task, and learns classifiers and control policies for each individual mode families. MMLP has four stages: prompting LLMs with a short task description to create a multi-step physical plan; generating a vast amount of counterfactual perturbed trajectories based on a small set of successful demonstrations, and subsequently, learning a classifier for each mode family outlined in the plan; and using the learned classifiers to segment all trajectories and derive mode-specific policies. Evaluation is shown using a simple 2D continuous-space domain and Robosuite (Zhu et al., 2020) and a simulated robot manipulation environment."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "- In the sea of prompt-based planning approaches for embodied AI, this work felt creative and novel. MMLP seems to combine best of many worlds e.g. capabilities of LLMs for generating abstract/high-level plans, mode families form manipulation research to ground these plans into motion constraints, and idea of counterfactuals to efficiently learn these mode families and corresponding policies.\n- The use of mode families enables MMLP to be interpretable and robustly generalizable."
                },
                "weaknesses": {
                    "value": "- Well-thought out analysis but weak evaluation: The evaluation seemed a bit on the weaker side. \n    - Even though I liked the systematic comparison with BC-based baselines and ablations on loss analysis, the two eval domains are both really simple and in simulation. The comparison with BC really helps in validating the use of mode families, however, the evaluation doesn't seem to provide me an understanding of how MMLP would compare with other SOTA manipulation planning approaches such text2motion, vima etc. To that end, I think addition of a more broader set of baselines would strengthen the paper. \n    - Real-world eval or eval with more complex tasks is also highly encouraged in the same vain. Currently I don\u2019t have any intuition or understanding about how well would MMLP work in real world. I\u2019d love to understand how MMLP would deal with partial observability as well. Would the addition of a \u201csearch mode\u201d for finding the right object in clutter for instance, make MMLP brittle/ineffective? \n- Opensourcing plans? The authors do not talk about releasing their code, which is important for reproducibility. I encourage the authors to consider and comment on this in their rebuttal.\n- The authors highlight how prompting the LLM to find a suitable state representation for learning the classifier requires skill. It seems like this is the case for generation of perturbations as well. It is not clear to me if same style of perturbations would work for more complex manipulation setting."
                },
                "questions": {
                    "value": "- The loss terms were a bit difficult to parse at the first go \u2014 I\u2019d love a visualization if possible to better understand the loss terms.\n- While it was clear that the LLM generated sub-plans were used to identify number of modes etc., it wasnt clear to me how exactly were additional things obtained from prompting LLM in the first stage of MMLP used as state in the later stages of MMLP. Could the authors explain this more clearly perhaps by adding an example of what \u201cs\u201d looks like for the classifiers?\n- Unclear how the method would work without a simulator to generate success labels for counterfactuals. Is the availability of sim an assumption for MMLP?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "details_of_ethics_concerns": {
                    "value": "NA"
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission6834/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission6834/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission6834/Reviewer_Rhgd"
                    ]
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6834/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698827380552,
            "cdate": 1698827380552,
            "tmdate": 1699636790600,
            "mdate": 1699636790600,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "SxeN7JsyDy",
                "forum": "qoHeuRAcSl",
                "replyto": "cH1dUxTUu8",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal (1/1)"
                    },
                    "comment": {
                        "value": "Dear reviewer Rhgd, \n\nThanks for your detailed review and feedback! Please find our response below:\n\n**[Comparison with LLM-based planning methods such as text2motion/VIMA]** Both text2motion and VIMA solve a different grounding problem than ours and thus would not be the best baselines. Specifically, there are at least three kinds of grounding mentioned in the literature: **1. Task grounding** - using language [1] or multi-modal tokens [2] as inputs to an imitation policy to specify tasks/goals. **2. Symbolic grounding** - predicting the boolean values of symbolic state (e.g., In(can, gripper)=True, On(marbles, spoon)=False, etc) [3, 4, 5] **3. Action grounding** - mapping LLM plan to predefined primitive actions [6, 7, 8] Text2Motion deals with action grounding and VIMA deals with task grounding. In contrast, our work solves symbolic grounding, where we learn classifiers that map continuous states/observations to discrete modes proposed by LLM. Since we assume each mode is associated with a single policy that\u2019s learned from segmented demonstrations, action grounding can also be achieved as a by-product of learning the classifier, which maps the LLM planned mode sequence to a sequence of policy rollouts. That being said, we agree with reviewer's point of adding more baselines, so we are adding a baseline that achieves symbolic grounding through clustering in the 2d polygon domain (see the ablation studies for 2D polygon, linked [here on the website](https://sites.google.com/view/grounding-plans/home#h.8wpp2pzbin0p)) and similarity-based trajectory segmentation in the robosuite domain (see the mode classification comparison table and examples for the new baseline, [here on the website](https://sites.google.com/view/grounding-plans/home#h.7l0jx2g9td4d)). To clarify the grounding, we have created a **new figure: Fig 7** that we include in the revised paper and is currently on the website.\n\n**[Visualization of loss function and state $s$ for classifier]**\nWe have created a **new figure -- Fig 8** that we include in the revised paper and is currently on the website in [this section](https://sites.google.com/view/grounding-plans/home#h.pmzm9p2g4j7v) that illustrates both how we use LLMs to generate the classifier state and how this information is used downstream to compute the classifier loss.\n\n**[Does our approach require a simulator to generate success labels?]** Having a simulator perhaps is required for methods that require per-step dense labeling. Since our approach only requires sparse label at the end of a trajectory, engineering a task success classifier for real-world tasks is not infeasible and hence simulators are not required. For example, for a scooping task where the goal is to transport marbles from one bowl to another bowl, one can engineer a classifier to detect if the perturbed execution still manages to transport at least one marble to the goal location (i.e., the second bowl). \n\n**[How does MMLP work in the real-world setting?]** We are preparing real-world experiments and will show results on the website. https://sites.google.com/view/grounding-plans/home.\n\n**[Opensourcing plans?]** Yes we are opensourcing the code soon!\n\n**[Will the current perturbations work for more complex tasks?]** While figuring out the best perturbations strategies for different tasks with different complexity is not the main focus of this paper, we agree designing perturbations that are sufficient to generate counterfactual outcomes is a requirement for our method to work. In future work, we will investigate how to prompt LLM to generate different perturbation strategies for each task. \n\n[1] Language Conditioned Imitation Learning over Unstructured Data \n\n[2] VIMA: General Robot Manipulation with Multimodal Prompts \n\n[3] Grounding Predicates through Actions\n\n[4] From Skills to Symbols: Learning Symbolic Representations for Abstract High-Level Planning\n\n[5] Learning Temporal Logic Formulas from Suboptimal Demonstrations: Theory and Experiments\n\n[6] SayCan: Grounding Language in Robotic Affordances\n\n[7] Skill induction and planning with latent language\n\n[8] Text2Motion: From Natural Language Instructions to Feasible Plans"
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6834/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700518285080,
                "cdate": 1700518285080,
                "tmdate": 1700518285080,
                "mdate": 1700518285080,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "9K30c6YLyK",
                "forum": "qoHeuRAcSl",
                "replyto": "cH1dUxTUu8",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6834/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Robot experiments"
                    },
                    "comment": {
                        "value": "Dear reviewer, \n\n**[Real-world robot experiments]** We have added some real-world robot experiments that showcase how our grounding classifier can be implemented on real-world setups as well as inputing pixel inputs beyond trajectory inputs. Please find these videos on our website at https://sites.google.com/view/grounding-plans/home#h.apnj3kgovccj. Thank you for your time to review our response!"
                    }
                },
                "number": 12,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6834/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700687391599,
                "cdate": 1700687391599,
                "tmdate": 1700687391599,
                "mdate": 1700687391599,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "HDABC90X6R",
                "forum": "qoHeuRAcSl",
                "replyto": "SxeN7JsyDy",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6834/Reviewer_Rhgd"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6834/Reviewer_Rhgd"
                ],
                "content": {
                    "title": {
                        "value": "Post rebuttal"
                    },
                    "comment": {
                        "value": "Thanks for the clarifications, additional figures, and robot experiments. \n\nGiven that authors are focused on symbol grounding problem, it would be great if they can provide comparisons with other approaches for symbol grounding [3,4] in their final version.\n\nI look forward to reading the final version!"
                    }
                },
                "number": 14,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6834/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700694763981,
                "cdate": 1700694763981,
                "tmdate": 1700694763981,
                "mdate": 1700694763981,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]