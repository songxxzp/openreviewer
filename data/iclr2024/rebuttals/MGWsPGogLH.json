[
    {
        "title": "Turing Complete Transformers: Two Transformers Are More Powerful Than One"
    },
    {
        "review": {
            "id": "Uf1SDM4bj2",
            "forum": "MGWsPGogLH",
            "replyto": "MGWsPGogLH",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission8781/Reviewer_erh8"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission8781/Reviewer_erh8"
            ],
            "content": {
                "summary": {
                    "value": "This paper uses complexity theory to show that the original Transformers are not Turing complete. It then proposes a way to make Transformers Turing complete, called the Find-Replace Transformers. Experiments on several datasets show that Find-Replace Transformers can achieve good performance on composite tasks."
                },
                "soundness": {
                    "value": "1 poor"
                },
                "presentation": {
                    "value": "1 poor"
                },
                "contribution": {
                    "value": "1 poor"
                },
                "strengths": {
                    "value": "Easy to read."
                },
                "weaknesses": {
                    "value": "I would say that this paper is more like a popular science article rather than an academic paper. First, the authors use a lot of space to explain what computational complexity is, why a lower complexity class (automata) cannot solve a problem of higher complexity (context-free language). These are very basic knowledge in computer science and everyone with a basic computer background is familiar with them. In particular, I do not think it deserves spending half a page demonstrating that $\\\\{0^n1^n:n\\in\\mathbb N\\\\}$ is not in the regular language.\n\nSecond, the authors do not present any related work in this area. Actually, studying Transformers using a computation perspective is common in the machine learning community and I can list a large class of works (see below). The authors did not cite or discuss any of the basic works in the community. The results in this paper are well-known given these prior works.\n\n[1] On the turing completeness of modern neural network architectures. ICLR 2019.\n\n[2] Saturated transformers are constant-depth threshold circuits.TACL, 2022.\n\n[3] Transformers learn shortcuts to automata. ICLR 2023.\n\n[4] Tighter bounds on the expressivity of transformer encoders. ICML 2023.\n\n[5] Towards Revealing the Mystery behind Chain of Thought: A Theoretical Perspective. NeurIPS 2023.\n\nThird, the conclusion in this paper is questionable and the proof is quite non-strict. It contradicts to [1], which shows that Transformers are Turing-complete. Similar results hold for autoregressive Transformers [5] (although it was not rigorously proved that autoregressive Transformers are Turing-complete). Moreover, in the submission the authors considered only Transformers with input and output of bounded lengths, which are quite strange since Turing machines do not pose constraints on the tape length. If the length is constrained in Transformers, they clearly do not match Turing machines."
                },
                "questions": {
                    "value": "-"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission8781/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698830818095,
            "cdate": 1698830818095,
            "tmdate": 1699637103470,
            "mdate": 1699637103470,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": []
    },
    {
        "review": {
            "id": "0XokAnTkPi",
            "forum": "MGWsPGogLH",
            "replyto": "MGWsPGogLH",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission8781/Reviewer_5hCM"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission8781/Reviewer_5hCM"
            ],
            "content": {
                "summary": {
                    "value": "- The paper first shows that Transformers with a finite context length cannot be Turing complete.\n- It then proposes Find+Replace Transformers:\n    - The Find Transformer takes in a length-$k$ sequence, and marks tokens as important or not (e.g. by marking tokens with 1 or 0).\n    - For the Replace Transformer, the input sequence is the concatenation of outputs of a set of Find Transformers, and the output is a sequence that should be used to replace a part of the input sequence.\n- Find+Replace Transformers are shown to be Turing complete, since they can implement a tag system which is known to be Turing complete."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "1 poor"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "- The paper provides the necessary background knowledge.\n- The paper shows impressive empirical results on Tower of Hanoi, multiplication, and dynamic programming."
                },
                "weaknesses": {
                    "value": "- The finding that \"Transformers with a finite context length is not Turing complete\" has been known. Prior work's Turing completeness is based on infinite precision and infinite context length. Assuming a finite context length naturally makes the Transformer not Turing complete.\n- The descriptions of the experiment are not detailed enough for reproduction; I'm not sure how the perfect results on multiplication and dynamic programming are achieved, and hence cannot verify its correctness.\n- Many pieces of writing are overly assertive and inaccurate.\n  - Sec 2.1: It's not accurate to say that \"It is unusual to use complexity theory to study transformers\", since there has been a significant body of work on connecting transformers and formal languages and complexity classes, some of which the paper has cited but didn't discuss properly.\n  - Lemma 2.10: \"any autoregressive model\" is inaccurate: it should be \"any autoregressive model with a finite context window. For example, the Turing completeness of RNNs has long been established.\n  - In the discussion on related work in Sec A, the paper states that prior work use either limited number of steps or limited memory -- I'm not sure why this is true, since to my understanding, Perez et al. 2019 and Giannou et al. 2023 both rely on the Transformer being applied recursively and for unlimited times. Please let me know if I'm missing something.\n\n- Missing related work: Selection-Inference: \"selection\" is similar to the Find Transformer, and \"Inference\" is similar to the Replace Transformer.\n  - Selection-Inference: Exploiting Large Language Models for Interpretable Logical Reasoning. By Antonia Creswell, Murray Shanahan, Irina Higgins.\n- Other minor writing points:\n  - Definition 2.9: $\\cup_{n< c} \\Sigma^n \\rightarrow \\Sigma^{n+1}$ is problematic notation: $n$ is being quantified by $c$ and hence should not appear alone on the right hand side.\n  - Section C: the two move data pointer operations don't compile properly. Please use the math environment.\n  - Section 2 can be made much terser with details left to the appendix. There should be more details on the Find+Replace Transformer."
                },
                "questions": {
                    "value": "- To make sure I'm understanding the 2-tag system idea correctly: Find+Replace Transformers are iteratively/repeated applied to apply the reduction rule for 2 symbols in the reduction to the 2-tag system. This repeated application is the key to making a finite context length system Turing complete. Is this understanding correct?\n- How large should we think of $Map(r)$ in general (i.e. in addition to the tag system example in the appendix)?\n- \"Any program in brainfuck can then be executed on a Find+Replace transformer\": even though brainfuck is minimalistic in terms of the vocabulary and compiler size, its execution can be long and exceeds the bounded context length of a Find+Replace transformer."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission8781/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698894488125,
            "cdate": 1698894488125,
            "tmdate": 1699637103359,
            "mdate": 1699637103359,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": []
    },
    {
        "review": {
            "id": "xyp4JGbxIH",
            "forum": "MGWsPGogLH",
            "replyto": "MGWsPGogLH",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission8781/Reviewer_zEM4"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission8781/Reviewer_zEM4"
            ],
            "content": {
                "summary": {
                    "value": "The authors make a formal argument that the class of fixed-length seq-to-seq models is not Turing complete, present a new architecture -- Find and Replace Transformers -- that is Turing complete, and provide experiments indicating that the proposed architecture can be trained to solve difficult reasoning problems such as Towers of Hanoi and 4-digit multiplication."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "The main strength of this paper lies in raising important questions about the transformer architecture, its Turing completeness (or lack thereof, under certain assumptions), and the need to explore alternative architectures beyond standard transformers. This is a fresh perspective, different from most papers working with transformers.\n\nIt also provides various background perspectives on such questions, which make for an interesting read.\n\nLastly, unlike recent theoretical attempts characterizing the representation power of transformers, this work also supports its proposal with experiments (but see concerns about it below)."
                },
                "weaknesses": {
                    "value": "I see 3 main weaknesses in the paper:\n\n1. The paper is written in a somewhat hand-wavy way. The authors are perhaps trying to appeal to broad audience, but this leaves meany important technical details unclear, while spending precious space on generic background material, such as the 2 pages of section 2. I'll state two examples of this:\n\n  *  **Example 1:**  The main proposal --- the find + replace architecture --- is never defined formally and rigorously in section 3. This is especially odd as the paper has at least 15 other formal definitions and claims. This makes it difficult to understand some of the technical details and appreciate the additional power such transformers are supposed to add.\n\n  * E.g., what prevents a **single** transformer from simulating one step of a find + replace transformer by using finitely many heads (one for each Find transformer) and then stacking on top of it a Replace transformer? And if this is a valid simulation (which it appears to be) of a single step of a find + replace transformer, the added computational power must be coming from in-place replacement of k tokens in the input and iterating over this single step, rather than from the find + replace two-transformer architecture.\n\n  * Clarity on this is especially important as otherwise the actual technical finding in the paper won't support even the title-level message or the opening sentence of the abstract --- it won't be the case that *two transformers are more powerful than one*, it would rather be the case that **sequential iteration + the ability to replace in-place** is what adds more power. In fact, this is perhaps not even surprising as the ability to make local edits to a tape and iterate is precisely what Turing machines rely on.\n\n  * **Example 2:** The *experimental setup in section 4 hints that each find transformer (and replace transformer) is trained separately \"on examples of each step of the task\", but this is very unclear --- what are the \"steps\" of a task (such as multiplication)? How was data generated for each step? These are critical pieces to understand about the experimental setup in order to ensure that the empirical success is not a result of \"hand coding\" an algorithm in the proposed find + replace transformer training while simply doing end-to-end (i.e., basic input -> output; no algorithmic help) finetuning or even few-shot prompting for the baseline GPT models.\n\n  * I would strongly suggest that the authors use the available space more for clarifying technical details and less for providing tutorial-style material on complexity theory etc.\n\n2. Another weakness is that the authors don't clearly **place the result in the context of prior papers** that have already formally shown that transformer encoders are not Turing complete. E.g., the Merrill et al (2022) paper cited by the authors in Appendix A.1 already showed that such encoders are in TC^0, which is a subset of P and hence clearly not Turing complete. There is also other work by Angluin et al. and Cheng et al. on studying the representation limits of various formal models of transformers. The current work should be placed clearly in the context of these earlier formal analyses.\n\n3. Lastly, the non-Turing-completeness results (Theorem 2.8, Cor B.1) make the assumption that models have a **finite context of size $k$** at each step. In fact, the proof relies critically on this assumption. But a justification of this is missing. While it's true that language models are typically trained on fixed context lengths, this is not really a limitation of the transformer architecture. In fact, in decoder-only and encoder-decoder models, even practical transformers get to causally attend to the *full* input and partial output so far, not just the last $k$ tokens.\n\n  * First, this limitation of the model should be mentioned upfront in the abstract and introduction, not delayed till definition 2.3. Second, this raises the question of the relevance of the finding to practical transformers. At the least, the overall claim should be clarified to state that *finite-context* transformers aren't Turing complete."
                },
                "questions": {
                    "value": "Please refer to the above \"weaknesses\" section for background on these questions:\n\n1. What's the justification of allowing fixed-context lookup during decoding? (I understand that's how it's done when training a transformer, but generally not when decoding at evaluation time)\n\n2. Is it correct that each step of your multi-transformer architecture can be simulated by a single transformer as above? If not, why?\n\n3. How is the ability to \"replace k tokens in-place\" related to the chain-of-thought style generation? E.g., one way to simulate replacing k tokens in-place is to copy the entire input over as chain-of-thought and replace k tokens in the copy.\n\n4. Can you provide more details of how exactly was your find + replace transformer was trained? What were the steps and how \"hand-coded\" (or not) was the algorithm to solve, say, the Towers of Hanoi or multiplication?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission8781/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698935044202,
            "cdate": 1698935044202,
            "tmdate": 1699637103254,
            "mdate": 1699637103254,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": []
    },
    {
        "review": {
            "id": "7mW6pwHBSc",
            "forum": "MGWsPGogLH",
            "replyto": "MGWsPGogLH",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission8781/Reviewer_bz3o"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission8781/Reviewer_bz3o"
            ],
            "content": {
                "summary": {
                    "value": "The paper proposes a transformer architecture inspired by lambda calculus and other known \"Find and Replace\" Turing-complete mechanisms on an infinite tape. The paper argues that existing LLMs are not Turing complete as they are finite automata, and propose adding an arbitrary length tape on which to operate. The experiments show that \"Find-Replace\" transformers indeed outperform GPT (even though this is theoretically guaranteed for large enough problems due to GPT's modest attention span)."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "As LLMs currently only use memory in form of a token stream consisting of the prompt and (so far) generated tokens, investigating new mechanisms that refer to external memory is certainly something that should be (and is) explored a lot more. The paper has nice exposition of proofs (although they come directly from existing theoretical CS)."
                },
                "weaknesses": {
                    "value": "The main claim that transformers with finite attention span are not computationally universal is both somewhat obvious and previously already stated, (e.g.Schurmaans, \"Memory Augmented Large Language Models are Computationally Universal\": https://arxiv.org/abs/2301.04589). The claim depends on the observation that existing architectures have a limited total token length. But, traditional computers also operate with finite memory, and so potentially more interesting question is what architectures, prompting and fine-tuning techniques are easier to \"program.\" For example, the above referenced Schurmaan's paper also allows a transformer access to external memory, like this submission does. Jojic et al \"GPT is becoming a Turing machine: Here are some ways to program it\": https://arxiv.org/abs/2303.14310 deals with limited memory simply with \"skip attention,\" where GPT is forced to ignore pieces of generated text delineated with special tags (though in that paper, skip attention just reduces the memory needs of their prompting technique to those of a usual computer which only needs the instructions and the latest state in the program to keep executing it).\n\nCurrent LLMs have very limited token memory, but it is getting longer with each new version (not to mention all the work, which authors acknowledged, on LLMs within systems that allow additional API calls, including to external memory), and as I mentioned, every computer has finite memory anyhow. In that sense, strictly speaking, the author's suggested architecture is not practical as it requires an infinite tape. Then the interesting question is if the proposed architecture but with a finite tape (thus being in what authors refer to as M_{FS} and not Turing-complete) is better than other options that are also memory-limited. For example, the above mentioned Jojic et al paper shows solving DP problems with near perfect accuracy with GPT 3, demonstrating the importance of prompt design.\n\nThe experimental section needs to be flashed out more. It is not exactly clear how the Find and Replace transformers were tuned. What 100 million parameter model was tuned and on what?"
                },
                "questions": {
                    "value": "See the above. I'd love to understand experiments better. One could make Find and Replace transformers by hand to execute, say 2-tag system, which, btw, GPT can execute as well, until it runs out of tokens. The handcrafted Find/replace transformers would in fact work better than trained ones on any given task (but would then not be trained transformers but simply a way to express lambda calculus using transformers). One of the issues with trying to trigger LLMs into executing programs is that they were trained on lots of different data and it is not always totally predictable how they will react to a prompt instructing them to execute a program (see Jojic et al). I.e. if we want to reap the benefits of LLMs generalized, association-based, language \"understanding\" and synthesis with the ability to more strictly follow a computational mechanism, what are the tradeoffs? Can an LLM do both (act like ChatGPT to understand the intent, but also executing a program to search for an answer)?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission8781/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699224116623,
            "cdate": 1699224116623,
            "tmdate": 1699637103154,
            "mdate": 1699637103154,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": []
    }
]