[
    {
        "title": "Graph Parsing Networks"
    },
    {
        "review": {
            "id": "wS976dAG4n",
            "forum": "hv3SklibkL",
            "replyto": "hv3SklibkL",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission9196/Reviewer_UKss"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission9196/Reviewer_UKss"
            ],
            "content": {
                "summary": {
                    "value": "This work proposes an efficient graph parsing algorithm to infer the pooling structure that drives graph pooling. The pooling structure is trained end-to-end. It achieves competitive real-world performance and good memory and time efficiency."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. Clear presentation of method.\n\n2. Extensive experiments on both graph and node tasks."
                },
                "weaknesses": {
                    "value": "1. Time complexity. Though the paragraph above Proposition 4 claims that the time complexity of each pooling layer is $O(n^{(k)})$, the computation of edge score $C$ still takes $O(m^{(k)})$ time.\n\n2. Proposition 5 is doubtful. The argmax operator may not produce unique output when the multiset has several equal maximum elements. \n\n3. The performance gain in ablation study is not significant. In Table 4, the performance difference between the origin model and the model with  Mean pool is smaller than the score deviation."
                },
                "questions": {
                    "value": "1. The point 1 and 2 in the Weakness section.\n\n2. The argmax operator in DOM is not differentiable. How to train the whole model end-to-end?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission9196/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698318573709,
            "cdate": 1698318573709,
            "tmdate": 1699637157158,
            "mdate": 1699637157158,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "ezD7lVMcyH",
                "forum": "hv3SklibkL",
                "replyto": "wS976dAG4n",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission9196/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission9196/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer UKss"
                    },
                    "comment": {
                        "value": "Thank you for the thoughtful feedback on our manuscript. We provide the following detailed responses to your major concerns.\n\n> (Weakness 1) Time complexity. Though the paragraph above Proposition 4 claims that the time complexity of each pooling layer is $O(n^{(k)})$, the computation of edge score $C$ still takes $O(m^{(k)})$ time.\n\nThe computation of the edge score $C$ indeed has complexity $\\mathcal{O}(m^{(k)})$. However, it occurs before Algorithm 1, and in the paragraph above Proposition 4, we specifically focused on the time complexity of Algorithm 1 as $\\mathcal{O}(n^{(k)})$. The computation of $C$ is dominated by message passing, which can be computed in parallel on GPU. On the other hand, the parsing algorithm must be executed sequentially. That's why, in our time efficiency tests, even EdgePool with $\\mathcal{O}(m^{(k)})$ complexity runs very slowly when dealing with densely connected graphs.\n\n> (Weakness 2) Proposition 5 is doubtful. The argmax operator may not produce unique output when the multiset has several equal maximum elements.\n\nThank you for pointing this out! Yes, if there are two nodes with common neighbors and their node features are exactly the same, then the output of the argmax operator cannot guarantee uniqueness. Based on your suggestion, we edited Proposition 5 and it's corresponding proof (paragraph 2 in Appendix A.2) in the updated submission, please refer to the red-colored text. Specifically, we suppose the row-wise non-zero entries in $C$ are distinct. In practice, we find that the potential violation of the permutation invariance caused by the argmax operator has a limited impact on model performance.\n\n> (Weakness 3) The performance gain in ablation study is not significant. In Table 4, the performance difference between the origin model and the model with Mean pool is smaller than the score deviation.\n\nIn our ablation study, we aim to verify that the performance improvement is primarily due to the parsing algorithm we proposed and to show that our model is robust to changes in the backbone. After replacing the DeepSets module with a simpler Mean pool, the model continues to deliver strong performance, confirming its robustness to the choice of backbone and supporting our claim.\n\n---\n\n> (Question) The argmax operator in DOM is not differentiable. How to train the whole model end-to-end?\n\nHere we describe the forward and backward passes of our model to clarify the training process:\n- During the forward pass, we first use GNN and MLP to compute the edge scores (Equation 1). Then we run Algorithm 1 to obtain the assignment matrix (Equation 2) and performs the multiset computation to obtain the coarsened graph (Equation 3). The final step is to compute the edge score mask (Equation 4) to ensure the gradients can flow into GNN and MLP.\n- Here, we further present the details of Equation 4 to enhance understanding:\n    - Induce subgraph $\\hat{G}_i^{(k)} \\subseteq G^{(k)}$ from node $v_i$ means: each node $v_i$ in graph $G^{(k+1)}$ is a cluster generated by the $k$-th pooling layer, thus it corresponds to a connected subgraph $\\hat{G}_i^{(k)}$ in $G^{(k)}$.\n    - In order to allow gradients to flow into the MLP used for calculating edge scores, we aggregate the scores of all the edges $\\hat{\\mathcal{E}}\\_i^{(k)}$ in each subgraph $\\hat{G}\\_i^{(k)}$. We then obtain a vector $\\mathbf{y}^{(k)}\\_{i} \\in \\mathbb{R}^{n^{(k+1)}}$ represents the score of clusters.\n    - This vector is then replicated into a mask matrix $\\mathbf{y}^{(k)} \\mathbf{1}^{\\mathrm{T}} \\in \\mathbb{R}^{n^{(k+1)} \\times d}$, which matches the shape of the node feature matrix $\\mathbf{\\hat{X}}^{(k+1)}$. Finally, this mask is element-wise multiplied with the node feature matrix.\n- During the backward pass, Algorithm 1 does not run. Instead, the gradient backpropagation is performed directly. The GNN and MLP can be updated through the gradients of the edge score mask."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission9196/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700239982008,
                "cdate": 1700239982008,
                "tmdate": 1700239982008,
                "mdate": 1700239982008,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "8s53kLSW0r",
                "forum": "hv3SklibkL",
                "replyto": "ezD7lVMcyH",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission9196/Reviewer_UKss"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission9196/Reviewer_UKss"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for the detailed response. However, I think the assumption that the row-wise non-zero entries in $C$ are distinct is too strong for permutation invariance in Proposition 5. When the graph is symmetric, equal entries are very likely to exist. I would still keep my score to 5."
                    }
                },
                "number": 14,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission9196/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700679792517,
                "cdate": 1700679792517,
                "tmdate": 1700679792517,
                "mdate": 1700679792517,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "DF4T857baJ",
            "forum": "hv3SklibkL",
            "replyto": "hv3SklibkL",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission9196/Reviewer_xTBe"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission9196/Reviewer_xTBe"
            ],
            "content": {
                "summary": {
                    "value": "This paper aims to construct a graph pooling method called a graph parsing network (GPN) that can be personalized to every graph and has a good balance of maintaining the node information and high memory efficiency simultaneously. \nThe method is built upon existing GNNs and designs a novel algorithm to construct personalized pooling trees for graphs. The empirical results on graph classification show its effectiveness and efficiency."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "4 excellent"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. The paper is well written, clearly showing its motivation and model structure.\n2. The novel part lies in that it designs a novel algorithm that can adaptively form clusters layer by layer that minimizes loss of information of graph structure and node features, and since it does not have learnable parameters in the graph parsing algorithm. \n3. The empirical results on graph classification and reconstruction demonstrate that the proposed model has a good ability to maintain the graph structure and node feature information."
                },
                "weaknesses": {
                    "value": "1. It seems that GPN works well on small-sized graphs from the experimental results. Discussion on large-sized graphs is expected to be included in the paper. \n2. If the tree is high for some large-sized graph, the performance might be worse due to over-smoothing.\n3. For the model itself involving GNNs, it is not clear how you train this model."
                },
                "questions": {
                    "value": "1. What does a 'different GNN` mean in node classification? $\\mathbf{H}^{(k)}$ in Eq. 3 is the same as '$GNN^\\prime(\\mathbf{X}^{(k)}, \\mathbf{A}^{(k)})$` in eq. 10."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission9196/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission9196/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission9196/Reviewer_xTBe"
                    ]
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission9196/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698640817736,
            "cdate": 1698640817736,
            "tmdate": 1699637157044,
            "mdate": 1699637157044,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "8sduJeh7R9",
                "forum": "hv3SklibkL",
                "replyto": "DF4T857baJ",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission9196/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission9196/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer xTBe"
                    },
                    "comment": {
                        "value": "We sincerely appreciate the reviewer's constructive feedback and positive remarks on our work. We provide the following detailed responses to your major concerns.\n\n> (Weakness 1) It seems that GPN works well on small-sized graphs from the experimental results. Discussion on large-sized graphs is expected to be included in the paper.\n\n> (Weakness 2) If the tree is high for some large-sized graph, the performance might be worse due to over-smoothing.\n\nIt is worth noting that, the PubMed dataset we tested already contains 18,717 nodes, which is not that small-sized. Following your suggestion, in the updated submission (please refer to the red-colored text), we further strengthen the discussion on large graphs in Appendix E. In short, our node classification model architecture already includes residual connections from the encoder to the decoder (see Section 2.3 and Figure 3), which can help mitigate potential over-smoothing issues on large graphs by preserving local information.\n\n> (Weakness 3) For the model itself involving GNNs, it is not clear how you train this model.\n\nSince the Reviewer UKss raised the same question, we kindly request that you refer to *Response to Reviewer UKss - Question*.\n\n---\n\n> (Question) What does a different GNN mean in node classification? $\\mathbf{H}^{(k)}$ in Eq. 3 is the same as $GNN^\\prime(\\mathbf{X}^{(k)}, \\mathbf{A}^{(k)})$ in eq. 10.\n\nIn Equation 3, the multiset computation module directly use the node feature $\\mathbf{H}^{(k)}$, which is encoded by the GNN in Equation 1. While in Equation 10, the input node feature is $\\mathbf{X}^{(k)}$, and we use another GNN' (different from the GNN in Equation 1) to encode it."
                    }
                },
                "number": 1,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission9196/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700239543933,
                "cdate": 1700239543933,
                "tmdate": 1700239543933,
                "mdate": 1700239543933,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "XUJ0GfBwc7",
            "forum": "hv3SklibkL",
            "replyto": "hv3SklibkL",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission9196/Reviewer_4RVW"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission9196/Reviewer_4RVW"
            ],
            "content": {
                "summary": {
                    "value": "This paper presents a novel graph pooling method, namely Graph Parsing Network (GPN), which aims to learn an individual pooling structure for each individual graph in an end-to-end fashion while being memory and time efficient. Specifically, the authors generate the assignment matrix, which is used to transform the larger graph into its compressed smaller graph by mapping nodes of the original graph into certain clusters, per graph. Also, this assignment matrix is generated based on the graph parsing algorithm that infers pooling structures of graphs from their edge scores, i.e., firstly selecting the dominant edges and then expanding them to construct the node assignment matrix for graph pooling. The authors evaluate the performance of the proposed Graph Parsing Network (GPN) on graph classification and node classification tasks as well as the graph reconstruction task, showing its effectiveness and efficiencies."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "* The motivation to adaptively condense different graphs based on their differences in graph structures (i.e., edge importances) is sound.\n* The idea of using a graph parsing algorithm to make an individual pooling structure for each graph is interesting and reasonable.\n* The proposed GPN surpasses existing graph pooling methods on both graph-level and node-level tasks.\n* The proposed GPN is efficient in terms of memory usage and computational time, particularly compared to the node-clustering-based (assignment-matrix-based) graph pooling methods."
                },
                "weaknesses": {
                    "value": "* This work may be similar to the idea of [1] which considers and manipulates edges during graph pooling (i.e., making the cluster assignment matrix with edges), since this work also performs edge-centric graph pooling with the cluster assignment matrix that is generated from edges. \n* Equation (4) lacks details on motivation. I understand that, in order to perform backpropagation with edge scores, edge scores should be added or multiplied with other learnable variables. On the other hand, it is unclear why the edge scores should be multiplied in this way (Equation (4)) and what may be the effect of this multiplication on node features.\n* The authors may further perform the statistical test on the main results (Table 1 and Table 2) since the performance of the proposed GPN is comparable against other performant baselines when considering mean and standard deviations together.\n\n---\n\n[1] Edge Representation Learning with Hypergraphs, NeurIPS 2021."
                },
                "questions": {
                    "value": "* In Equation (10), it may be better to represent the superscript on GNN' according to its layer index, since GNN' is different across different layers. \n* In Figure 5, the proposed GPN is memory efficient compared to the baseline that uses the cluster assignment matrix for graph pooling. However, the GPN also uses the cluster assignment matrix for graph pooling. In this vein, I am wondering why there exists a significant difference in efficiency while both methods are similar in using the cluster assignment matrix."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission9196/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission9196/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission9196/Reviewer_4RVW"
                    ]
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission9196/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698757024970,
            "cdate": 1698757024970,
            "tmdate": 1700377724730,
            "mdate": 1700377724730,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "IjBkAlYt1n",
                "forum": "hv3SklibkL",
                "replyto": "XUJ0GfBwc7",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission9196/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission9196/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer 4RVW"
                    },
                    "comment": {
                        "value": "We sincerely appreciate the reviewer's considerate feedback. Here, we provide detailed responses to your concerns.\n\n> (Weakness 1) This work may be similar to the idea of [1] which considers and manipulates edges during graph pooling (i.e., making the cluster assignment matrix with edges), since this work also performs edge-centric graph pooling with the cluster assignment matrix that is generated from edges.\n\nThank you for mentioning this work. In our updated submission (please refer to the red-colored text), we have introduced it in Introduction (paragraph 3 in Section 1) and Related Works (paragraph 1 in Appendix B).\n\n> (Weakness 2) Equation (4) lacks details on motivation. I understand that, in order to perform backpropagation with edge scores, edge scores should be added or multiplied with other learnable variables. On the other hand, it is unclear why the edge scores should be multiplied in this way (Equation (4)) and what may be the effect of this multiplication on node features.\n\n- Yes, the multiplication is for backpropagation, this approach is similar to [1] (see the last equation in Equation 2).\n\n- In this way (adding the score and then multiplying), the output cluster from graph pooling can be aware of the number of edges assigned to it through its features.\n\n- Here, we present the details of Equation 4 to enhance understanding:\n    - Induce subgraph $\\hat{G}_i^{(k)} \\subseteq G^{(k)}$ from node $v_i$ means: each node $v_i$ in graph $G^{(k+1)}$ is a cluster generated by the $k$-th pooling layer, thus it corresponds to a connected subgraph $\\hat{G}_i^{(k)}$ in $G^{(k)}$.\n    - In order to allow gradients to flow into the MLP used for calculating edge scores, we aggregate the scores of all the edges $\\hat{\\mathcal{E}}\\_i^{(k)}$ in each subgraph $\\hat{G}\\_i^{(k)}$. We then obtain a vector $\\mathbf{y}^{(k)}\\_{i} \\in \\mathbb{R}^{n^{(k+1)}}$ represents the score of clusters.\n    - This vector is then replicated into a mask matrix $\\mathbf{y}^{(k)} \\mathbf{1}^{\\mathrm{T}} \\in \\mathbb{R}^{n^{(k+1)} \\times d}$, which matches the shape of the node feature matrix $\\mathbf{\\hat{X}}^{(k+1)}$. Finally, this mask is element-wise multiplied with the node feature matrix.\n\n> (Weakness 3) The authors may further perform the statistical test on the main results (Table 1 and Table 2) since the performance of the proposed GPN is comparable against other performant baselines when considering mean and standard deviations together.\n\nFollowing you suggestion, we performed t-tests and report the best model and its comparable models (p > 0.05) here:\n\n- Table 1:\n    | **Dataset**   | **Best model** | **Comparable models**                  |\n    |---------------|----------------|-------------------------------------|\n    | **NCI1**      | **GPN**            | -                                   |\n    | **NCI109**    | **GPN**            | -                                   |\n    | **FRANKENSTEIN** | **GPN**          | EdgePool                            |\n    | **PROTEINS**  | **GPN**            | GMT, SPGP, MinCutPool, HoscPool, SEP |\n    | **DD**        | GMT            | SPGP                                |\n- Table 2:\n    | **Dataset** | **Best model** | **Comparable models**             |\n    |-------------|----------------|--------------------------------|\n    | **Film**    | **GPN**            | GCNII, GGCN, NSD               |\n    | **Cora**    | GCNII          | **GPN**, MixHop, H2GCN, GPRGNN, GGCN, NSD |\n    | **CiteSeer**| Geom-GCN       | **GPN**, GCNII, H2GCN, GPRGNN, GGCN, NSD |\n    | **PubMed**  | GCNII          | Geom-GCN                       |\n\n---\n\n> (Question 1) In Equation (10), it may be better to represent the superscript on GNN' according to its layer index, since GNN' is different across different layers.\n\nThe GNN' in Equation 10 is shared across the pooling layers, thus we omitted the superscript.\n\n> (Question 2) In Figure 5, the proposed GPN is memory efficient compared to the baseline that uses the cluster assignment matrix for graph pooling. However, the GPN also uses the cluster assignment matrix for graph pooling. In this vein, I am wondering why there exists a significant difference in efficiency while both methods are similar in using the cluster assignment matrix.\n\nThis is because the clustering-based methods need to store a dense assignment matrix with quadratic memory complexity (see Section 1 and Figure 1), while our model ensures linear memory complexity through the graph parsing algorithm (see paragraph 5 in Section 2.2).\n\n---\n\n[1] Graph U-Nets, ICML 2019"
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission9196/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700239858507,
                "cdate": 1700239858507,
                "tmdate": 1700239858507,
                "mdate": 1700239858507,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "4oISIJXpMx",
                "forum": "hv3SklibkL",
                "replyto": "IjBkAlYt1n",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission9196/Reviewer_4RVW"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission9196/Reviewer_4RVW"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for responding to my comments and addressing them. Regarding Weakness 2, I suggest authors more clearly explain the process and reason (of Equation (4)) for multiplying edge scores with the node features in the paper. Besides this, I do not have any additional major concerns."
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission9196/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700304961397,
                "cdate": 1700304961397,
                "tmdate": 1700304961397,
                "mdate": 1700304961397,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "r4XixpxuoO",
                "forum": "hv3SklibkL",
                "replyto": "nKB0GAeery",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission9196/Reviewer_4RVW"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission9196/Reviewer_4RVW"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your response. The update looks good to me. As the authors address all of my comments and reflect them in the paper, as well as I believe there are no further major concerns (after reading other reviews as well), I have increased the score to Accept."
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission9196/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700377712835,
                "cdate": 1700377712835,
                "tmdate": 1700377712835,
                "mdate": 1700377712835,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "BJzIWValx8",
            "forum": "hv3SklibkL",
            "replyto": "hv3SklibkL",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission9196/Reviewer_H5gS"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission9196/Reviewer_H5gS"
            ],
            "content": {
                "summary": {
                    "value": "This paper deals with graph pooling, i.e., compressing graph information into compact representations. The paper contains a mostly experimental study of various methods. The proposed graph parsing network constitutes a novel contribution, it adaptively learns personalized pooling structures. Experimental results show that the method outperforms state of the art graph pooling methods."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "The proposed approach does seem novel, and it also seems to perform well compared to existing graph pooling networks."
                },
                "weaknesses": {
                    "value": "Graph pooling can elegantly be cast into a compression framework and would hence benefit from an analysis of\nits fundamental limits based on information theory. The pooling of a graph structure (potentially with some side information as\nconsidered) here is a classical information-theoretic problem, i.e., how to best store all the information characterizing the graph\nin a vector of finite length or even better a bitstring of finite length. It may well be that the entire field of graph pooling as\ncurrently considered in the ML literature does not take this perspective, but reading this paper makes it clear that many of the questions\nasked here would benefit from such a perspective.\n\nGenerally, this reviewer finds the paper to be quite ad-hoc and also it uses a lot of jargon, not always defined or consistently used. The language is also confusing in many places."
                },
                "questions": {
                    "value": "none"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission9196/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699113065072,
            "cdate": 1699113065072,
            "tmdate": 1699637156815,
            "mdate": 1699637156815,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "w8cMr87MZV",
                "forum": "hv3SklibkL",
                "replyto": "BJzIWValx8",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission9196/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission9196/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer H5gS"
                    },
                    "comment": {
                        "value": "Thank you for your comments. Here is our response.\n\n> (Weakness 1) Graph pooling can elegantly be cast into a compression framework and would hence benefit from an analysis of its fundamental limits based on information theory. The pooling of a graph structure (potentially with some side information as considered) here is a classical information-theoretic problem, i.e., how to best store all the information characterizing the graph in a vector of finite length or even better a bitstring of finite length. It may well be that the entire field of graph pooling as currently considered in the ML literature does not take this perspective, but reading this paper makes it clear that many of the questions asked here would benefit from such a perspective.\n\nWe didn't mention the \"information theory\" in our paper, and the graph pooling problem we studied is not close to it.\n\n> (Weakness 2) Generally, this reviewer finds the paper to be quite ad-hoc and also it uses a lot of jargon, not always defined or consistently used. The language is also confusing in many places.\n\nOur paper is not ad-hoc. We didn't use jargon in our paper, and we have defined the symbols we used. We didn't use confusing language in our paper."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission9196/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700240039049,
                "cdate": 1700240039049,
                "tmdate": 1700240039049,
                "mdate": 1700240039049,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "3TqoEyEoVm",
                "forum": "hv3SklibkL",
                "replyto": "ezD7lVMcyH",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission9196/Reviewer_H5gS"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission9196/Reviewer_H5gS"
                ],
                "content": {
                    "comment": {
                        "value": "I am happy with the revisions made. Thanks to the authors for their efforts."
                    }
                },
                "number": 12,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission9196/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700583398976,
                "cdate": 1700583398976,
                "tmdate": 1700583398976,
                "mdate": 1700583398976,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]