[
    {
        "title": "ProtoReg: Prioritizing Discriminative Information for Fine-grained Transfer Learning"
    },
    {
        "review": {
            "id": "KDRpdo5gjP",
            "forum": "Op1XmdxFk8",
            "replyto": "Op1XmdxFk8",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission7226/Reviewer_bkLU"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission7226/Reviewer_bkLU"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes a prioritizing discriminative information method to handle the granularity gap challenge in fine-grained transfer learning. It first computes class-discriminative prototypes and then refines the prototypes to gradually capture more fine-grained details as well as aggregate features with corresponding prototypes."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1.\tThis paper points out a key challenge in fine-grained transfer learning, the granularity gap challenge, and proposes a novel ProtoReg approach to address this.\n2.\tExperimental results demonstrate the effectiveness of the proposed ProtoReg method on both inter-dataset and intra-dataset transfer learning.\n3.\tDelicate visualization results are provided as clear illustrations of the motivation and effectiveness of the proposed method.\n4.\tA valid appendix is provided to improve the completeness of this article."
                },
                "weaknesses": {
                    "value": "1.\tMore details of ablation studies should be provided to further clarify the effectiveness of the proposed method. For example, the experiments with configurations \u201cL_ce + L_aggr + L_step\u201d, \u201cL_ce + L_step + Refine\u201d should be conducted to demonstrate the effectiveness of L_step when applied under different conditions.\n2.\tSome details of the proposed method should be stated more clearly. For example, in Equ (2), how \\phi is defined and how the \u201cargmax\u201d value is computed with respect to the classification accuracy should be explicitly declared."
                },
                "questions": {
                    "value": "1.\tCan ProtoReg outperform SOTA methods on other downstream tasks of transfer learning, such as semantic segmentation?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission7226/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698117135834,
            "cdate": 1698117135834,
            "tmdate": 1699636860465,
            "mdate": 1699636860465,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "SUGS3tDHI0",
                "forum": "Op1XmdxFk8",
                "replyto": "KDRpdo5gjP",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer bkLU"
                    },
                    "comment": {
                        "value": "> Q1: More details of ablation studies should be provided to further clarify the effectiveness of the proposed method. For example, the experiments with configurations \u201cL_ce + L_aggr + L_step\u201d, \u201cL_ce + L_step + Refine\u201d should be conducted to demonstrate the effectiveness of L_step when applied under different conditions.\n\nA1: Thank you for your valuable feedback. We conducted additional ablation studies based on your comments and incorporated the corresponding results into Table 4, highlighted in red in the revised manuscript.\n\n|$\\mathcal{L}_{ce}$|$\\mathcal{L}_{aggr}$|$\\mathcal{L}_{sep}$|Refine|Accuracy (%)|\n| --- | --- | --- | --- | --- |\n|O|O|O||71.23|\n|O||O|O|63.79|\n\n\n---\n\n\n> Q2: Some details of the proposed method should be stated more clearly. For example, in Equ (2), how \\phi is defined and how the \u201cargmax\u201d value is computed with respect to the classification accuracy should be explicitly declared.\n\nA2: Thank you for your comments. We have revised the manuscript (section 4.2) to clarify the methodology based on your comments, and the modified contents are indicated in red. In Equation (2), $\\phi$ is randomly initialized. It should be noted that when initializing prototypes in Equation (2), it is independent of $\\phi$ since only the pre-trained feature extractor $\\mathcal{F}_{\\theta}$ is used.\nEquation (3) with \"argmax\" is employed when initializing prototypes using linear classifier weights. Examining Equation (3), \"argmax\" corresponds to $\\phi$ that maximizes validation accuracy on downstream data. Specifically, we train a linear classifier for downstream training data with a frozen feature extractor, measuring validation accuracy every certain epoch (in our case, every 5 epochs for computational efficiency). As validation accuracy typically decreases after increasing (suggesting the start of overfitting on training data), we apply early stopping when validation accuracy starts to decrease and use the corresponding $\\phi$ as the argmax. This approach ensures prototype initialization that incorporates discriminative information of the pre-trained feature extractor without overfitting to downstream training data.\n\n\n---\n\n\n> Q3. Can ProtoReg outperform SOTA methods on other downstream tasks of transfer learning, such as semantic segmentation?\n\n\nA3: In our research, we consider a classification task as the downstream task for transfer learning. Given that the semantic segmentation task involves multiple classes within a single image sample, it is not suitable for our setting. Instead, ProtoReg demonstrates notable performance improvement not limited to fine-grained classification but also on more general datasets like Caltech101 and CIFAR100 (see Table 7 in the Appendix)."
                    }
                },
                "number": 10,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7226/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700203713254,
                "cdate": 1700203713254,
                "tmdate": 1700203713254,
                "mdate": 1700203713254,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "wuhXUoK6u5",
            "forum": "Op1XmdxFk8",
            "replyto": "Op1XmdxFk8",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission7226/Reviewer_BWuH"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission7226/Reviewer_BWuH"
            ],
            "content": {
                "summary": {
                    "value": "The authors proposed prototype-based regularization losses to improve transfer learning for fine-grained classification. To be specific, adaptively evolving prototypes for each class are first introduced. The aggregation loss, which aggregates features with their corresponding prototypes, and the separation loss, which enforces features away from prototypes of different classes, are jointly optimized with the cross-entropy loss for fine-tuning. Comprehensive experiments are conducted to validate the efficacy of the proposed method."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "1 poor"
                },
                "strengths": {
                    "value": "1. The paper is well-written, making it easy to follow.  \n2. Sufficient experimental studies are provided."
                },
                "weaknesses": {
                    "value": "1. The idea of prototype-based loss is not novel for dealing with the limited data scenario. Such an idea could be tracked back to the early few-shot research [1]. The proposed aggregation loss and the separation loss are same as the Eq. (2) in [1].   \n2. The challenge of fine-grained classification I think lies in its limited data for each class, tens of samples for each class in most benchmark datasets (Table 6 A.2). For CIFAR100, hundreds of samples for each class, the proposed method achieves insignificant perform gains compared to CE (Table 7). Therefore, I think the few-shot works are related and should be included in the literature review.\n3. Some experimental results seem unfair. For the results in Figure 1 and Figure 3, the case where ProtoReg succeeds while others fails is picked up. A question arises here: whether the samples that ProtoReg mis-classify are mis-classified by CE? If so, the extra mis-classification by CE would indicate its deficiency. Otherwise, ProtoReg and CE possibly have different shortcuts. The results presented should be more statistical. \n\nMinor:\n1. The pseudo-code did not include the refinement for the prototypes based on linear classifier weights.\n\nReferences:  \n[1] Snell, J., Swersky, K., & Zemel, R. (2017). Prototypical networks for few-shot learning. Advances in neural information processing systems, 30."
                },
                "questions": {
                    "value": "See the above weakness."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission7226/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698741878292,
            "cdate": 1698741878292,
            "tmdate": 1699636860356,
            "mdate": 1699636860356,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "WOraAeg0JJ",
                "forum": "Op1XmdxFk8",
                "replyto": "wuhXUoK6u5",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer BWuH (1/3)"
                    },
                    "comment": {
                        "value": "> Q1: The idea of prototype-based loss is not novel for dealing with the limited data scenario. Such an idea could be tracked back to the early few-shot research [1]. The proposed aggregation loss and the separation loss are same as the Eq. (2) in [1].\n\nA1: Our methodology introduces novelty in the following aspects (This content is identical to the response to the Reviewer Ka1A's question 1. Additionally, in the later sections, we summarized the distinctions from [1] and the resulting effects.):\n\n* **Novel prototype initialization method**: Previous approaches in using prototypes typically adopted class-wise sample mean initialization. We propose initializing prototypes with weights learned from a linear classifier, addressing the lack of discriminative information in fine-grained data. Our approach demonstrates notable performance improvement.\n* **Notable performance enhancement in transfer learning**: Prior works leveraging prototypes have primarily focused on few-shot learning [1, 2] and domain adaptation [3, 4], leaving the effectiveness in transfer learning underexplored. We identify the motivational observation of the granularity gap in fine-grained transfer learning and highlight that prototype-based regularization can be a highly effective solution.\n* **Refinement strategy**: Prior works either did not refine prototypes or required recomputation of the entire feature set, leading to computational inefficiency. We propose a computationally efficient approach that adaptively evolves prototypes to include discriminative information learned during fine-tuning.\n* **Exploration of separated loss components**: Previous works often formulate prototype-based methods using log-likelihood [1, 2] or distance minimization in a metric space [5]. We meticulously explore the disentanglement and the importance of assigning different strengths to each component for the first time (which are discussed in section 5.4.2 and Appendix B.2). The table below further illustrates that our approach, which assigns different strengths to $\\lambda_{aggr}$ and $\\lambda_{sep}$, significantly enhances performance compared to cases where the both strengths are equal to $\\alpha$.\n\n(a) FGVC Aircraft\n\n|$\\alpha$| 15%|\t30%|\t50%|\t100%|\n|---|---|---|---|---|\n|1.0|\t24.57|\t39.96|\t51.25|\t69.31|\n|5.0|\t27.39|\t42.60|\t56.02|\t72.22|\n|10.0|\t30.69|\t45.37|\t56.77|\t73.03|\n|15.0|\t31.62|\t45.64|\t57.82|\t74.14|\n|20.0|\t31.92|\t45.49|\t56.74|\t73.00|\n|25.0|\t31.53|\t45.31|\t56.71|\t71.89|\n|Ours|\t**33.66**|\t**46.83**|\t**59.95**|\t**75.25**|\n\n(b) Stanford Cars\n\n|$\\alpha$| 15%|\t30%|\t50%|\t100%|\n|---|---|---|---|---|\n|1.0|\t26.68|\t55.01|\t72.64|\t85.70|\n|5.0|\t29.74|\t60.44|\t75.41|\t85.57|\n|10.0|\t32.96|\t60.35|\t74.10|\t85.60|\n|15.0|\t33.16|\t59.57|\t74.23|\t85.55|\n|20.0|\t32.67|\t59.00|\t73.46|\t84.83|\n|25.0|\t30.95|\t56.25|\t70.95|\t84.42|\n|Ours|\t**39.95**|\t**65.91**|\t**78.36**|\t**87.74**|\n\n(c) CUB-200-2011\n\n|$\\alpha$| 15%|\t30%|\t50%|\t100%|\n|---|---|---|---|---|\n|1.0|\t46.60|\t61.00|\t70.47|\t79.57|\n|5.0|\t49.78|\t63.36|\t70.95|\t78.34|\n|10.0|\t50.54|\t61.37|\t68.30|\t77.13|\n|15.0|\t49.26|\t59.11|\t66.67|\t76.04|\n|20.0|\t47.14|\t58.10|\t65.93|\t75.77|\n|25.0|\t46.41|\t56.85|\t64.67|\t74.80|\n|Ours|\t**57.09**|\t**67.48**|\t**74.53**|\t**81.22**|\n\nIn direct comparison with [1], the differences are evident. \n* [1] lacks prototype refinement and relies on episodic training for few-shot learning, which doesn't align with the transfer learning setting where the entire dataset of all classes is typically utilized at once. Prototype refinement enables adaptation to the changing feature space during fine-tuning and allows for the adaptive evolution of prototypes.\n* In prototype initialization, while [1] uses sample mean, we introduce a novel approach using linear classifier weights to maximize the inclusion of discriminative information. This novel approach allows for the initialization of prototypes that effectively incorporate discriminative information even in fine-grained scenarios.\n* While [1] employs maximum log-likelihood optimization, we demonstrate significant performance improvement by disentangling through aggregation and separation, assigning different strengths to each term. The above experimental results demonstrate that significant performance improvement is achievable by simply separating aggregation and separation and assigning different weights to each.\n\n\nReferences  \n[1] Snell et al., \"Prototypical networks for few-shot learning.\", NeurIPS 2017  \n[2] Hou et al., \"A closer look at prototype classifier for few-shot image classification.\", NeurIPS 2022  \n[3] Pan et al., \"Transferrable prototypical networks for unsupervised domain adaptation.\", CVPR 2019  \n[4] Tanwisuth et al., \"A prototype-oriented framework for unsupervised domain adaptation.\", NeurIPS 2021  \n[5] Yang et al., \"Robust classification with convolutional prototype learning.\", CVPR 2018"
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7226/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700203451347,
                "cdate": 1700203451347,
                "tmdate": 1700203451347,
                "mdate": 1700203451347,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "Cfkij9FVp6",
                "forum": "Op1XmdxFk8",
                "replyto": "wuhXUoK6u5",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer BWuH (2/3)"
                    },
                    "comment": {
                        "value": "> Q2: The challenge of fine-grained classification I think lies in its limited data for each class, tens of samples for each class in most benchmark datasets (Table 6 A.2). For CIFAR100, hundreds of samples for each class, the proposed method achieves insignificant perform gains compared to CE (Table 7). Therefore, I think the few-shot works are related and should be included in the literature review.\n\nA2: Thank you for your valuable feedback. However, the challenge in fine-grained classification we addresses goes beyond simply having limited data for each class. To demonstrate this, we equalized the number of samples per class on the FGVC Aircraft and CIFAR100 benchmark datasets (both datasets have a total of 100 classes). Specifically, to align with the fewer data in the FGVC Aircraft dataset (averaging 33 samples per class), we adjusted the sampling rate for CIFAR100 to include an average of 33 samples per class as well. \n\n\n| Methods         | Aircraft | CIFAR100 |\n| --------------- | -------- | -------- |\n| CE              | 66.01    | 66.87    |\n| ProtoReg (self) | 75.25    | 68.12    |\n| ProtoReg (LP)   | 77.89    | 68.39    |\n\nThe experiment results reveal that, even in a setting where the number of classes and samples per class are equal, fine-tuning with cross-entropy faces more difficulty and is sub-optimal in the fine-grained dataset. While there is a notable performance improvement by ProtoReg in CIFAR100 as well, the impact is more pronounced in the fine-grained dataset.\n\nFurthermore, few-shot learning works typically experiment with highly limited data scenarios, such as 5-way 1-shot or 5-way 5-shot. In contrast, our transfer learning scenario involves using a much larger number of classes and samples at once, like 100-way 33-shot (Aircraft) or 555-way 35-shot (NABirds). Therefore, we believe comparisons with few-shot learning works are not fair. Even in settings with a low sampling rate, such as 15%, the number of classes is still considerably larger compared to few-shot settings, ranging from 100 to 555.\n\n> Q3. Some experimental results seem unfair. For the results in Figure 1 and Figure 3, the case where ProtoReg succeeds while others fails is picked up. A question arises here: whether the samples that ProtoReg mis-classify are mis-classified by CE? If so, the extra mis-classification by CE would indicate its deficiency. Otherwise, ProtoReg and CE possibly have different shortcuts. The results presented should be more statistical.\n\nA3: In response to your comment, we have conducted additional experiments (related to Figure 1 and Figure 3) that provide more statistical analysis. We added the results in the revised manuscript, highlighted in red (Appendix B.10 and B.11)\n\n[statistical analysis for Figure 1]  \nIn Figure 1, we included visual results to highlight our motivation. Below, we present quantitative metrics related to image retrieval: mAP @K and Recall @K. mAP calculates the average precision of search results, with mAP @K focusing on the average precision within the top K results. A higher mAP @K indicates increased accuracy and consistency in retrieval. Conversely, recall @K measures the ability to retrieve actual positive instances within the top K results, with higher values indicating better capability in finding relevant items. Experimental results demonstrate that using ProtoReg leads to a significant improvement in both metrics compared to CE.\n\n- mAP @K\n\n|K|CE|ProtoReg (self)|ProtoReg (LP)|\n| --- | --- | --- | --- |\n|1|0.640|0.699|**0.738**|\n|3|0.701|0.754|**0.787**|\n|5|0.690|0.742|**0.781**|\n\n\n- Recall @K\n\n|K|CE|ProtoReg (self)|ProtoReg (LP)\n|---|---|---|---|\n|1|0.640|0.699|**0.738**|\n|3|0.548|0.631|**0.689**|\n|5|0.461|0.553|**0.612**|\n\n\n[statistical analysis for Figure 3]  \nFor OOD test data (Waterbirds), we compared methodologies A and B by calculating ratios for four cases: 1) A correct and B incorrect, 2) A incorrect and B correct, 3) both incorrect, and 4) both correct. The results for top-K predictions are presented based on the values of K. ProtoReg (self) and ProtoReg (LP) significantly outperform CE, winning by 11.65% and 16.88%, respectively. A noteworthy observation is that when ProtoReg makes a mistake, CE tends to make the same mistake in almost all cases. Out of the 31.12% errors made by ProtoReg (self), only 2.71% are correctly predicted by CE, while the remaining 28.41% are also misclassified for CE. We believe this percentage is sufficiently low to demonstrate CE's deficiency.\n\n- ProtoReg (self) vs CE\n\n| K   | ProtoReg (self) win |CE win| Both wrong | Both correct|\n| --- | -------- | --- | --- | --- |\n| 1   |**11.65**|2.71|28.41|57.23|\n| 3   |**9.04**|1.42|14.34|75.20|\n| 5   |**7.77**|0.86|10.32|81.05|\n\n\n- ProtoReg (LP) vs CE\n\n|K|ProtoReg (LP) win|CE win|Both wrong|Both correct|\n|---|---|---|---|---|\n|1|**16.88**|2.76|23.18|57.18|\n|3|**11.75**|1.40|11.63|75.22|\n|5|**10.22**|1.16|7.87|80.76|"
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7226/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700203606457,
                "cdate": 1700203606457,
                "tmdate": 1700203606457,
                "mdate": 1700203606457,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "g0CTVSlRz1",
                "forum": "Op1XmdxFk8",
                "replyto": "wuhXUoK6u5",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer BWuH (3/3)"
                    },
                    "comment": {
                        "value": "> Q4. The pseudo-code did not include the refinement for the prototypes based on linear classifier weights.\n\nA4: When refining prototypes initialized based on linear classifier weights, the prototypes are made learnable and updated through backpropagation. Refinement takes place seamlessly after loss.backward() in the optimizer.step(), without the need for additional pseudo-code."
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7226/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700203646355,
                "cdate": 1700203646355,
                "tmdate": 1700203646355,
                "mdate": 1700203646355,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "wI4Ubz2JYI",
                "forum": "Op1XmdxFk8",
                "replyto": "g0CTVSlRz1",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7226/Reviewer_BWuH"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7226/Reviewer_BWuH"
                ],
                "content": {
                    "title": {
                        "value": "I appreciate the authors for their efforts. However, I am not fully convinced by their responses."
                    },
                    "comment": {
                        "value": "1. The connection between prototypes and weights of a linear classifier has already been explored in [1, 2]. So, the authors highlighted \u201cnovel prototype initialization method\u201d and \u201crefinement strategy\u201d are marginal contributions.\n\nAlso, I do not agree the claim \u201cPrior works leveraging prototypes have primarily focused on few-shot learning [1, 2] and domain adaptation [3, 4], leaving the effectiveness in transfer learning under-explored\u201d. Basically, domain adaptation is a subcategory of transfer learning, and one branch of few-shot learning adopts transfer learning-based techniques [2]. \n\n2. I think the presented results, demonstrating the proposed method's notable performance improvement on CIFAR-100 with less data compared to the original CIFAR-100, support my argument. The amount of data indeed introduces a distinct aspect.\n\nYes, few-shot learning works typically involves working with extremely limited data and are supposed to work better in less challenging scenarios with relatively limited data. \nTherefore, I suggest including these works in the literature review, especially given the fact that the proposed methods are based on prototypes.\n\nOverall, I think the work makes marginal contributions, and thus I keep my score.\n\n\nReferences\n\n[1] Snell, J., Swersky, K., & Zemel, R. (2017). Prototypical networks for few-shot learning. Advances in neural information processing systems, 30.\n\n[2] Medina, C., Devos, A., & Grossglauser, M. (2020). Self-supervised prototypical transfer learning for few-shot classification. arXiv preprint arXiv:2006.11325."
                    }
                },
                "number": 13,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7226/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700631996706,
                "cdate": 1700631996706,
                "tmdate": 1700631996706,
                "mdate": 1700631996706,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "7diMonYGhi",
            "forum": "Op1XmdxFk8",
            "replyto": "Op1XmdxFk8",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission7226/Reviewer_Ka1A"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission7226/Reviewer_Ka1A"
            ],
            "content": {
                "summary": {
                    "value": "This paper focuses on the problem of fine-tuning a pre-trained model for a fine-grained downstream task. The authors point out that there is a granularity gap between the information learned by the pre-trained model and the fined-grained downstream task, and then propose a fine-tuning approach by utilizing prototypes to prioritize the discriminative information. The experimental results show that the method is able to effectively improve the performance of the fine-grained classification tasks."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1. The topic this paper pays attention to is important. As fine-tuning a pre-trained model for a particular task has been a standard learning paradigm in computer vision, it is valuable to study how to deal with the case where the downstream task is fine-grained, which has not been studied deeply.\n2. The motivation of this paper is clear. I agree with the authors' viewpoint that there is a granularity gap between the level of information learned by the pre-trained model and the semantic details required for a fine-grained downstream task, which is the main problem to solve in fine-trained transfer learning.\n3. The proposed method based on prototype aggregation is straightforward and not difficult to realize.\n4. The English writing of this paper is generally good."
                },
                "weaknesses": {
                    "value": "1. The novelty of this paper is not so significant. The idea of exploiting prototypes to represent and adjust the feature distribution according to label information from samples has been studied in a lot of works. Although the idea of utilizing such mechanism to fine-tune a pre-trained model for downstream fine-grained tasks is new, I do not recognize significant difference between the key idea of this work and the previous ones. It does has some novelty, but I am not sure whether it is sufficient to meet the criterion of ICLR.\n2. Although the motivation of solving the problem of granularity gap is interesting, I do not quite understand how the proposed mechanism with prototypes helps to eliminate such \"gap\" under the perspective of transfer learning. In more detail, it seems that this method can also be used to train a randomly initialized model for the fine-grained task, because I do not see a mechanism to \"preserve\" useful information from the original pre-trained model but only recognize the mechanism to make change to the model.\n3. A minor problem: the last sentence of the comments of Figure 1 is confusing. Maybe the word \"suffer from\" is not correctly used."
                },
                "questions": {
                    "value": "1. Considering the 2nd drawback listed above, please explain whether there is a mechanism to discover and  preserve useful information from the pre-trained model.\n2. It is a common scene for real data that each class may have multiple prototypes. How do the authors deal with such a case?\n3. Please explain why two different prototype updating strategies are used according to their initialization methods? What is the motivation or consideration of their designs, respectively?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "details_of_ethics_concerns": {
                    "value": "I have no ethics concerns about this paper."
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission7226/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission7226/Reviewer_Ka1A",
                        "ICLR.cc/2024/Conference/Submission7226/Senior_Area_Chairs"
                    ]
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission7226/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698835764456,
            "cdate": 1698835764456,
            "tmdate": 1700408356982,
            "mdate": 1700408356982,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "rQ7RlD1xka",
                "forum": "Op1XmdxFk8",
                "replyto": "7diMonYGhi",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer Ka1A (1/3)"
                    },
                    "comment": {
                        "value": "> **Q1: The novelty of this paper is not so significant. The idea of exploiting prototypes to represent and adjust the feature distribution according to label information from samples has been studied in a lot of works. Although the idea of utilizing such mechanism to fine-tune a pre-trained model for downstream fine-grained tasks is new, I do not recognize significant difference between the key idea of this work and the previous ones.**\n\nA1: Our methodology introduces novelty in the following aspects:\n\n* **Novel prototype initialization method**: Previous approaches in using prototypes typically adopted class-wise sample mean initialization. We propose initializing prototypes with weights learned from a linear classifier, addressing the lack of discriminative information in fine-grained data. Our approach demonstrates notable performance improvement.\n* **Notable performance enhancement in transfer learning**: Prior works leveraging prototypes have primarily focused on few-shot learning [1, 2] and domain adaptation [3, 4], leaving the effectiveness in transfer learning underexplored. We identify the motivational observation of the granularity gap in fine-grained transfer learning and highlight that prototype-based regularization can be a highly effective solution.\n* **Refinement strategy**: Prior works either did not refine prototypes or required recomputation of the entire feature set, leading to computational inefficiency. We propose a computationally efficient approach that adaptively evolves prototypes to include discriminative information learned during fine-tuning.\n* **Exploration of separated loss components**: Previous works often formulate prototype-based methods using log-likelihood [1, 2] or distance minimization in a metric space [5]. We meticulously explore the disentanglement and the importance of assigning different strengths to each component for the first time (which are discussed in section 5.4.2 and Appendix B.2). The table below further illustrates that our approach, which assigns different strengths to $\\lambda_{aggr}$ and $\\lambda_{sep}$, significantly enhances performance compared to cases where the both strengths are equal to $\\alpha$.\n\n(a) FGVC Aircraft\n\n|$\\alpha$| 15%|\t30%|\t50%|\t100%|\n|---|---|---|---|---|\n|1.0|\t24.57|\t39.96|\t51.25|\t69.31|\n|5.0|\t27.39|\t42.60|\t56.02|\t72.22|\n|10.0|\t30.69|\t45.37|\t56.77|\t73.03|\n|15.0|\t31.62|\t45.64|\t57.82|\t74.14|\n|20.0|\t31.92|\t45.49|\t56.74|\t73.00|\n|25.0|\t31.53|\t45.31|\t56.71|\t71.89|\n|Ours|\t**33.66**|\t**46.83**|\t**59.95**|\t**75.25**|\n\n(b) Stanford Cars\n\n|$\\alpha$| 15%|\t30%|\t50%|\t100%|\n|---|---|---|---|---|\n|1.0|\t26.68|\t55.01|\t72.64|\t85.70|\n|5.0|\t29.74|\t60.44|\t75.41|\t85.57|\n|10.0|\t32.96|\t60.35|\t74.10|\t85.60|\n|15.0|\t33.16|\t59.57|\t74.23|\t85.55|\n|20.0|\t32.67|\t59.00|\t73.46|\t84.83|\n|25.0|\t30.95|\t56.25|\t70.95|\t84.42|\n|Ours|\t**39.95**|\t**65.91**|\t**78.36**|\t**87.74**|\n\n(c) CUB-200-2011\n\n|$\\alpha$| 15%|\t30%|\t50%|\t100%|\n|---|---|---|---|---|\n|1.0|\t46.60|\t61.00|\t70.47|\t79.57|\n|5.0|\t49.78|\t63.36|\t70.95|\t78.34|\n|10.0|\t50.54|\t61.37|\t68.30|\t77.13|\n|15.0|\t49.26|\t59.11|\t66.67|\t76.04|\n|20.0|\t47.14|\t58.10|\t65.93|\t75.77|\n|25.0|\t46.41|\t56.85|\t64.67|\t74.80|\n|Ours|\t**57.09**|\t**67.48**|\t**74.53**|\t**81.22**|\n\n\nReferences  \n[1] Snell et al., \"Prototypical networks for few-shot learning.\", NeurIPS 2017  \n[2] Hou et al., \"A closer look at prototype classifier for few-shot image classification.\", NeurIPS 2022  \n[3] Pan et al., \"Transferrable prototypical networks for unsupervised domain adaptation.\", CVPR 2019  \n[4] Tanwisuth et al., \"A prototype-oriented framework for unsupervised domain adaptation.\", NeurIPS 2021  \n[5] Yang et al., \"Robust classification with convolutional prototype learning.\", CVPR 2018"
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7226/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700203008545,
                "cdate": 1700203008545,
                "tmdate": 1700203008545,
                "mdate": 1700203008545,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "Fk8H54q2oM",
                "forum": "Op1XmdxFk8",
                "replyto": "7diMonYGhi",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer Ka1A (2/3)"
                    },
                    "comment": {
                        "value": "> **Q2: Although the motivation of solving the problem of granularity gap is interesting, I do not quite understand how the proposed mechanism with prototypes helps to eliminate such \"gap\" under the perspective of transfer learning. In more detail, it seems that this method can also be used to train a randomly initialized model for the fine-grained task, because I do not see a mechanism to \"preserve\" useful information from the original pre-trained model but only recognize the mechanism to make change to the model.**\n\nA2: We want to clarify that our approach aims not to \"preserve\" pre-trained information but to focus downstream task-specific details within the pre-trained knowledge. This focus becomes crucial when a significant granularity gap exists, as lower granularity task-specific details might be subtle compared to higher granularity pre-trained information, potentially hindering the transfer of task-specific knowledge. \n\nIn the case of a randomly initialized model, the initialized prototypes do not contain any class-discriminative information. Applying ProtoReg to such meaningless prototypes **1) without refinement** would hinder the learning of discriminative information as the downstream model focuses on the meaningless information. However, ProtoReg **2) with prototype refinement** during fine-tuning, the prototypes get updated using discriminative features learned from downstream data. While this ensures that the prototypes contain some discriminative information, it still falls short of fully utilizing the discriminative information within the pre-trained model.\n\nThe experiment results below support our argument by demonstrating the performance of applying ProtoReg to a randomly initialized model (with and without prototype refinement). In some cases, ProtoReg brings about a certain degree of performance improvement. However, the significant drop in performance when refinement is not used indicates the importance of prototypes incorporating discriminative information from the pre-trained model.\n\n\n|Methods|Aircraft|Cars|CUB200|NABirds|\n| --- | --- | --- | --- | --- |\n|CE|34.44|43.70|33.03|47.84|\n|ProtoReg (self)|40.23|39.06|39.56|50.55|\n|ProtoReg (self), w/o refine|4.14|9.77|30.24|20.44|\n|ProtoReg (LP)|11.01|0.87|0.50|0.22|\n|ProtoReg (LP), w/o refine|9.18|1.53|2.09|21.64|\n\n[Additional explanation of the mechanism]  \nIn ProtoReg (LP), the pre-trained encoder is frozen while training classifier weights. The learned classifier weights represent decision boundaries for downstream features obtained from the pre-trained model. These boundaries are drawn based on information distinguishing different classes (these information is with low granularity particularity when the data is fine-grained) in the downstream data. Consequently, explicitly setting prototypes containing discriminative information and aggregating features toward them enables to focus more on low granularity discriminative information. Similarly, ProtoReg (self) employs the use of sample mean to represent discriminative information for each class.\n\n---\n\n> **Q3: A minor problem: the last sentence of the comments of Figure 1 is confusing. Maybe the word \"suffer from\" is not correctly used.**\n\nA3: We have made the revision in the manuscript, replacing \"suffer from\" with the more appropriate phrase \"faces challenges in.\" The changes have been highlighted in red. Thank you for pointing that out.\n\n---\n\n> **Q4: Considering the 2nd drawback listed above, please explain whether there is a mechanism to discover and preserve useful information from the pre-trained model.**\n\nA4: The question has been answered in the response to Q2. Please kindly refer to that for further details."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7226/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700203161598,
                "cdate": 1700203161598,
                "tmdate": 1700203161598,
                "mdate": 1700203161598,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "6hDGpSByRG",
                "forum": "Op1XmdxFk8",
                "replyto": "7diMonYGhi",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer Ka1A (3/3)"
                    },
                    "comment": {
                        "value": "> **Q5: It is a common scene for real data that each class may have multiple prototypes. How do the authors deal with such a case?**\n\nFor ProtoReg (self), instead of using the sample mean when assuming multiple prototypes, we can employ K-means clustering on class-specific features and use the centroids of each cluster as prototypes. However, determining the optimal number of prototypes practically is challenging. We experimentally confirmed that the current approach, using a single prototype per class, is sufficient and achieves the best performance. This is because using multiple prototypes per class may interfere with aggregation.\n\nFor ProtoReg (LP), as it relies on the weights of a linear classifier corresponding to the decision boundary, various class-discriminative information are integrated and encoded into a single vector.\n\n---\n\n> **Q6: Please explain why two different prototype updating strategies are used according to their initialization methods? What is the motivation or consideration of their designs, respectively?**\n\nFor our motivation and considerations, we aim to illustrate through the following toy example:\n\nConsider a 2D feature space with two classes, each having two samples, totaling four samples.\n\nClass 1: (-0.1, 0.9), (0.1, 1.1)\n\nClass 2: (1.1, 0.1), (0.9, -0.1)\n\nFor ProtoReg (self), prototypes obtained through sample mean are:\n\nPrototype 1: (0, 1.0)\n\nPrototype 2: (1.0, 0)\n\nFor ProtoReg (LP), the decision boundary maximizing the margin is y=x, and classifier weight vectors are perpendicular to the decision boundary. Therefore, prototypes are:\n\nPrototype 1: (-$\\frac{1}{\\sqrt{2}}$, $\\frac{1}{\\sqrt{2}}$)\n\nPrototype 2: ($\\frac{1}{\\sqrt{2}}$, -$\\frac{1}{\\sqrt{2}}$) (prototypes are l2-normalized for simplicity)\n\nIn summary, there is a discrepancy between prototypes based on the two initialization methods. Thus, when updating prototypes initialized with linear classifier weights using sample mean, distortion occurs. To prevent this, when initializing with linear classifier weights, prototypes are set to be learnable and updated through backpropagation. On the other hand, when initializing with the sample mean, prototypes are not set to be learnable, and they are updated using the sample mean of the updated features. The reason for not making the sample mean learnable is to utilize features obtained across different iterations comprehensively, ensuring stable training (as a mini-batch may have few or no samples of a specific class)."
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7226/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700203307331,
                "cdate": 1700203307331,
                "tmdate": 1700203307331,
                "mdate": 1700203307331,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "n9TiyYCelA",
                "forum": "Op1XmdxFk8",
                "replyto": "rQ7RlD1xka",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7226/Reviewer_Ka1A"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7226/Reviewer_Ka1A"
                ],
                "content": {
                    "comment": {
                        "value": "I have read the responses from the authors and thanks to the authors for their efforts. However, I am sorry that these explanations cannot persuade me to change my rating about this paper.\n\nOn one side, the novelty of this paper is a little weak compared with the criterion of ICLR in my opinion. I do not understand why the authors assert that prior works either did not refine prototypes in their response. Indeed, most methods based on prototype learning have to adjust the prototypes for learning better feature representation of each class. On the other side, since this method does not intend to preserve information from the original model, I do not think it is appropriate to be regarded as a transfer learning work.\n\nBased on the consideration above, I have to keep my rating."
                    }
                },
                "number": 11,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7226/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700408263056,
                "cdate": 1700408263056,
                "tmdate": 1700408263056,
                "mdate": 1700408263056,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "hVgigYkKtz",
            "forum": "Op1XmdxFk8",
            "replyto": "Op1XmdxFk8",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission7226/Reviewer_HTua"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission7226/Reviewer_HTua"
            ],
            "content": {
                "summary": {
                    "value": "This paper pointed out an issue in fine-grained transfer learning, called the \"granularity gap\" , i.e., less-discriminative information is also transferred with the discriminative information from a pre-trained model to the downstream model and harmful to the performance of the downstream task. A method called ProtoReg is thus proposed to prioritize fine-grained discriminative information via crafted prototypes, consisting of several main steps including prototype initialization, prototype refinement, and prototype aggregation and separation. Overall, the proposed method sounds technical convincing. Although \u2018simple\u2019 is a strong advantage claimed by the authors, the proposed ProtoReg might also come up with some critical drawbacks, e.g., tending to overfit the fine-grained information due to the clustering nature of the proposed method. Besides, the improvement in the performance is not well convincing since the comparing methods are not very up-to-date and basically not focusing on fine-grained problem."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "The key idea behind the proposed method is reasonable and the method itself is simple to implement."
                },
                "weaknesses": {
                    "value": "\u00b7 Class-wise prototype generation could lead to overfitting issues.\n\u00b7 Presentations on some key technical contents are not very clear, e.g., why and how exactly the equation (4) is formed.\n\u00b7 Experiments are not well supportive, e.g., the comparing methods are not very up-to-date and basically not focusing on fine-grained problem."
                },
                "questions": {
                    "value": "\u00b7 How to ensure the generality of the proposed method? To be specific, the discriminative is a relative concept. While the representative prototypes could preserve the main fine-grained information over each class, it does not necessarily preserve marginal fine-grained characteristics of the data, e.g., according to the theory of distributional clustering.\n\u00b7 Computational overhead should be also reported. Although the proposed method is simple to implement, its clustering nature (repeating to compute the 'similarity' between two data points) can make the complexity very high."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission7226/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699035174616,
            "cdate": 1699035174616,
            "tmdate": 1699636860103,
            "mdate": 1699636860103,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "aoXAV6N9YO",
                "forum": "Op1XmdxFk8",
                "replyto": "hVgigYkKtz",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer HTua (1/3)"
                    },
                    "comment": {
                        "value": "> **Q1: Class-wise prototype generation could lead to overfitting issues.**\n\nA1: The essence of transfer learning lies in tuning the model to optimize for the downstream task. Therefore, focusing on discriminative information for a specific downstream task cannot be considered as leading to overfitting. On the contrary, our method is better understood as preventing the downstream model from being biased towards non-discriminative information by focusing on discriminative information.\n\nIf prototypes are fixed to specific vectors, the clustering nature might cause features to collapse towards the prototypes, leading to potential overfitting. However, as prototypes are progressively refined to better encompass discriminative information, our method demonstrates robustness against overfitting to fine-grained information or specific prototypes. Numerous experimental results demonstrate that our method is much more robust against overfitting compared to CE:\n\n* Table 1: Significant performance improvements in the limited data regime which is more vulnerable to overfitting, e.g., using only 15% of the training data.\n* Table 5: As training epochs increase, while CE saturates in test accuracy, ProtoReg continues to show a consistent improvement in test accuracy.\n* Figure 13: Training accuracy saturates much more slowly than CE, and validation accuracy consistently improves.\n\n---\n\n> **Q2: Why and how exactly the equation (4) is formed?**\n\nA2: Thank you for the constructive comments. The following is our response to why and how the equation (4) is formed.\n\nThe intuitive approach to obtaining a representative representation for each class is to use the classwise sample mean. Inspired by the widely demonstrated effectiveness of utilizing the sample mean [1], we utilized it not only for initialization but also for refinement.\n\nMoreover, when utilizing downstream data for fine-tuning, features are trained to progressively encode task-discriminative information. As a result, refining prototypes by averaging over samples across progressively shifted feature spaces becomes beneficial for stable training, given the gradual shift towards task-discriminative feature spaces. \n\nFurthermore, the approach is computationally efficient as it directly stores computed features at each iteration, contrasting with the alternative of recomputing the entire set of features at the end of each epoch. Appendix B.7 addresses this point, and Table 10 demonstrates that our approach is robust against overfitting and computationally efficient compared to alternatives.\n\nThe detailed process of refinement using Equation (4) is as follows:\n\n* For a downstream task with $N$ classes, $N$ different memory banks (queues) are prepared to hold features of each class.\n* After each iteration, each feature is enqueued into the corresponding memory bank based on its class label.\n* After an epoch of training, each memory bank contains $N_i^{train}$ features, where $N_i^{train}$ is the number of training samples in class $i$.\n* After each epoch, class prototypes are updated based on the sample mean of their corresponding memory bank features.\n* The memory banks are cleared to hold features for the next epoch.\n\nIn response to your comment, we have revised the manuscript to enhance the clarity regarding Equation 4, emphasizing it in red. (section 4.3)\n\nReference  \n[1] Snell et al., \"Prototypical networks for few-shot learning.\", NeurIPS 2017"
                    }
                },
                "number": 1,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7226/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700202506116,
                "cdate": 1700202506116,
                "tmdate": 1700549529149,
                "mdate": 1700549529149,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "nMpKyLE5oy",
                "forum": "Op1XmdxFk8",
                "replyto": "hVgigYkKtz",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer HTua (2/3)"
                    },
                    "comment": {
                        "value": "> **Q3: The comparing methods are not very up-to-date and basically not focusing on fine-grained problem.**\n\nComparison methods, BSS [1], SN [2], and Co-tuning [3] conducted experiments on Aircraft, Cars, and CUB200, all of which are fine-grained datasets we also experimented with. This ensures a fair comparison. Moreover, although showing substantial improvement on fine-grained transfer by addressing issues due to the granularity gap, our method is not restricted to fine-grained problems. Extending beyond fine-grained problems, we show performance improvements on general datasets such as Caltech101 and CIFAR100 (refer to Table 7 in the Appendix). Additionally, we added comparisons with the two latest works published in 2023, Robust FT ([4], CVPR 2023), and DR-Tune ([5], ICCV 2023), where our methodology substantially outperforms them.\n\nThe table below provides a summary of the experimental results, with these results highlighted in red in Table 1 of the revised manuscript.\n\nAircraft\n|Methods|  15%   | 30% | 50% | 100% |\n| --- | --- | -------- | -------- | -------- |\n|Robust FT|23.91|37.84|49.09|65.08|\n|  DR-Tune   |24.42|40.89|50.65|68.80|\n|ProtoReg (self)|33.66|46.83|59.95|75.25|\n|ProtoReg (LP)|**34.35**|**50.41**|**61.45**|**77.89**|\n\nCars\n|Methods|  15%   | 30% | 50% | 100% |\n| --- | --- | -------- | -------- | -------- |\n|Robust FT|25.07|52.63|70.10|84.29|\n|  DR-Tune   |26.80|56.04|73.55|84.80|\n|ProtoReg (self)|39.95|65.91|78.36|87.74|\n|ProtoReg (LP)|**42.52**|**69.32**|**81.62**|**89.60**|\n\nCUB200\n|Methods|  15%   | 30% | 50% | 100% |\n| --- | --- | -------- | -------- | -------- |\n|Robust_FT|43.34|57.66|68.35|78.53|\n|  DR_Tune   |44.84|58.49|69.62|79.10|\n|ProtoReg (self)|57.09|67.48|74.53|81.22|\n|ProtoReg (LP)|**59.08**|**69.49**|**76.30**|**82.38**|\n\nNABirds\n|Methods|  15%   | 30% | 50% | 100% |\n| --- | --- | -------- | -------- | -------- |\n|Robust_FT|39.00|55.17|65.46|74.86|\n|  DR_Tune   |41.37|57.07|66.99|76.16|\n|ProtoReg (self)|50.75|63.68|70.84|78.40|\n|ProtoReg (LP)|**52.42**|**64.83**|**72.33**|**79.51**|\n\nReferences  \n[1] Chen et al., \"Catastrophic forgetting  \nmeets negative transfer: Batch spectral shrinkage for safe transfer learning.\", NeurIPS 2019  \n[2] Kou et al., \"Stochastic normalization.\", NeurIPS 2020  \n[3] You et al., \"Co-tuning for transfer learning.\", NeurIPS 2020  \n[4] Xiao et al., \"Masked images are counterfactual samples for robust fine-tuning.\", CVPR 2023  \n[5] Zhou et al., \"DR-Tune: Improving fine-tuning of pretrained visual models by distribution regularization with semantic calibration.\", ICCV 2023  \n\n---\n\n> **Q4: How to ensure the generality of the proposed method? To be specific, the discriminative is a relative concept. While the representative prototypes could preserve the main fine-grained information over each class, it does not necessarily preserve marginal fine-grained characteristics of the data, e.g., according to the theory of distributional clustering.**\n\n\nWe believe that, for generality, class-common information within fine-grained details is crucial. To ensure class discriminability, it should not merely represent marginal fine-grained characteristics specific to certain data within a class, but rather the main fine-grained information common across the majority of data.\n\nRegarding the generality from the dataset perspective, we would like to clearly emphasize the following: our goal is to prioritize discriminative information. Prioritizing discriminative information can also lead to performance improvement in general classification tasks (Table 7). In fine-grained downstream tasks, as this discriminative information tends to be fine-grained with low granularity (pose challenges for vanilla fine-tuning due to granularity gap), explicitly focusing on them results in more significant performance improvement."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7226/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700202769604,
                "cdate": 1700202769604,
                "tmdate": 1700202769604,
                "mdate": 1700202769604,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "hlSjPqEz6x",
                "forum": "Op1XmdxFk8",
                "replyto": "hVgigYkKtz",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7226/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer HTua (3/3)"
                    },
                    "comment": {
                        "value": "> **Q5: Computational overhead should be also reported. Although the proposed method is simple to implement, its clustering nature (repeating to compute the 'similarity' between two data points) can make the complexity very high.**\n\nIn response to you comment, we added a subsection on computational overhead in Appendix B.12 of the revised manuscript, highlighted in red.\nThe similarity computation is implemented with a single matrix multiplication, resulting in minimal computational overhead. Specifically, using l2-normalized feature matrix $F \\in \\mathbb{R}^{B \\times d}$ and l2-normalized prototypes matrix $C \\in \\mathbb{R}^{K \\times d}$ (where B is batch size, d is feature dimension, and K is the number of classes), the cosine similarity between each sample and prototype is computed in a single matrix multiplication via $FC^T \\in \\mathbb{R}^{B \\times K}$. The element (i, j) indicates the cosine similarity between the i-th sample and the j-th class prototype.\n\nThe table below demonstrates the relative time comparison against CE when experiments are conducted on the same device.\n\n| Method          | Relative Time |\n| --------------- |:-------------:|\n| CE              |       1       |\n| ProtoReg (self) |     1.03      |\n| ProtoReg (LP)   |     1.12      |\n\nProtoReg (self) has a negligible computational overhead of only 3%, while ProtoReg (LP) has a 12% overhead due to the linear probing process for prototype initialization. In both cases, the overhead is sufficiently low, considering the significant performance improvement they offer."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7226/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700202864727,
                "cdate": 1700202864727,
                "tmdate": 1700202864727,
                "mdate": 1700202864727,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]