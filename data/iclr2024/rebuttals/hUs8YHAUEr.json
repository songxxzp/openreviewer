[
    {
        "title": "Enhancing Large Language Models in Coding Through Multi-Perspective Self-Consistency"
    },
    {
        "review": {
            "id": "Pev718ZXIq",
            "forum": "hUs8YHAUEr",
            "replyto": "hUs8YHAUEr",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1679/Reviewer_F87r"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1679/Reviewer_F87r"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes to improve language models' code generation via multi-perspective self-consistency. \n\nSpecifically, the multi-perspective is defined as sampling generations from 1) solutions; 2) specifications; 3) test cases. Then the authors propose to construct a graph based on those samples, and use inter-consistency and intra-consistency (via solving an optimization problem) to improve the final generations.\n\nThe authors did experiments on a few language models and show their method outperform several baselines."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "- The authors did a thorough exploration on what factors could potentially affect code generation performances in LLMs, and it's interesting to see that all three perspectives, solution, specification, and test cases all play important roles in improving the final performance. \n\n- The experiments are done on a fairly comprehensive set of code generation models, including GPT, Code Llama and WizardCoder.\n\n- For intra-consistency, the authors also did a comprehensive study over what kind of measure functions can help the most."
                },
                "weaknesses": {
                    "value": "- Novelty: [1] already proposed to construct a graph and explore more fine-grained consistency via MAX-SAT solving (although for natural language based reasoning tasks). The similarities and differences should be better discussed in the current paper.\n\n[1] Jung et al. Maieutic prompting: Logically consistent reasoning with recursive explanations. EMNLP 2022.\n\n- Generalizability: although framed as \"multi-perspectives\", this current paper only explores a single use-case of code generation, and with very specific perspectives: solution, specification, and test cases. It would be interesting to show if this method can be generalized to other tasks (e.g., math tasks, commonsense reasoning, or symbolic reasoning).\n\n- Added complexity and ad-hoc design choices: The current framing adds a lot of complexity to the existing baselines, and many of the design choices are not well justified. In practice it would be difficult to deploy such a method to ensure optimal performance. E.g., \n1) designing the perspectives: for each task, how much manual effort is needed to design those perspectives? (and writing the prompts for each perspective?) How sensitive is the final performance w.r.t. the prompts written for each perspective?\n2) constructing the graph: each edge needs to be specifically designed (section 3.2), why those choices and how much difference does it make if designed differently? For intra-consistency, similarly the authors designed many different measures, and based on the experiment results the best measure varies depending on the task. How would one pick which measure to use in practice?\n3) solving the optimization: depending on the number of nodes and edges, the solving part could be very expensive; even with the iterative algorithm, it might take many rounds to reach convergence. This point needs to be better discussed.\n4) choice of parameters: what is the value of \\alpha in experiments? From Figure 4, on human-eval the performance varies a lot depending on \\alpha. The final reported performance seems to be the \\alpha that achieves the best performance. But without a training/dev set, how could one pick \\alpha in an unsupervised way?\n\n- Fair evaluation: Table 2 shows the proposed method yields some gains over several baselines. But digging deeper, a fair comparison should be made between methods that use *the same number of generated samples*. MPSC uses many more samples (200 solutions, 100 specifications, 500 test cases) while most of the baselines only use solutions (200 samples only). In addition, MPSC-label is not a fair comparison given it uses human labels.\n1) if given the same number of samples, i.e., baselines with 800 samples vs MPSC, how does the performance compare?\n2) what is the variance of the proposed method, given that more samples from different perspectives are drawn?\n3) how does the proposed method compare with [2]? [2] also uses test cases to improve language models' code generation.\n4) Table 4 shows the test cases give the most gains, so maybe a simple baseline could be added: use the generated test cases to filter out incorrect generated solutions, and then apply self-consistency on the filtered set.\n\n[2] Chen et al. Teaching Large Language Models to Self-Debug. 2023."
                },
                "questions": {
                    "value": "- How is the value of \\alpha chosen for each task? Is it chosen based on the final performance (which means the test data is known when you pick \\alpha)?\n\n- How does the proposed method work on the best model experimented (GPT-4)? Does it still give gains?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1679/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698463079589,
            "cdate": 1698463079589,
            "tmdate": 1699636096179,
            "mdate": 1699636096179,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "APL5wce7Zl",
                "forum": "hUs8YHAUEr",
                "replyto": "Pev718ZXIq",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer F87r (1/2)"
                    },
                    "comment": {
                        "value": "We really appreciate your feedback and suggestions, but we have some different opinions on the comments. We provide explanations to address your concerns and questions. We sincerely hope you can reconsider the review after reading our responses.\n\n> [1] already proposed to construct a graph and explore more fine-grained consistency via MAX-SAT solving\n\nThanks for your suggestions about the missing related work.\n\nAcknowledging that both MPSC and Maieutic Prompting are post-hoc methods aimed at enhancing the reasoning abilities of LLM, it is crucial to highlight the distinctions between them.\n\nThe primary difference lies in motivation. Maieutic Prompting addresses the inconsistency between the explanation and label generated by LLM, focusing on **the two-value entailment relation (T/F) between a statement and an explanation**. In contrast, MPSC is designed to fully exploit **the consistency among  outputs from different perspectives** within LLM. In our opinion, MPSC covers a broader scope, as it is straightforward to regard the statement and explanation as two perspectives and leverage the entailment relation as a form of inter-consistency measure within our framework. \n\nFurthermore, there are many differences in the specific method design. Maieutic Prompting regards the generated outputs as a tree structure, emphasizing the entailment between each parent and son. Therefore, its outputs has a sequential causal relationship. In contrast, in our approach, outputs from different perspectives has no order. And we construct a graph to encode pair-wise relations between vertices from different perspectives. Regarding the inference process,  while Maieutic Prompting treats it as a MAX-SAT problem, which is NP-hard, we propose a continuous optimization problem over the graph, benefiting from a closed-form solution. \n\nThanks for pointing out this paper. We will add it into the related work session in the updated paper.\n\n> Generalizability...\n\nWe have made a general response about your concerns. Please refer to it for more details.\n\n> how much manual effort is needed to design those perspectives? (and writing the prompts for each perspective?) How sensitive is the final performance w.r.t. the prompts written for each perspective?\n\nIn response to the first question about manual designed perspectives, we have made a general response. Please refer to it for more details.\n\nRegarding the other two questions about prompt design, we barely work on prompt design and only use convention natural language instructions (please refer to Table 12/13/14). It is evident that the prompt we used is definitely not (even far from) the optimal. \nMoreover, we emphasize that the prompt design will not only affect MPSC but also other baselines, since they utilize the same set of generated solutions and test cases. \n\nIn our opinion, the two points can guarantee the reproducibility of the reported performance in our paper and the prompt insensitivity of MPSC.\n\n> constructing the graph: each edge needs to be specifically designed (section 3.2), why those choices and how much difference does it make if designed differently? \n\nThe Solution, Specification and Test case are three well-established perspectives for code generation [1]. Based on their definitions, the inter-consistency measure through code execution is pretty natural and intuitive. We also discuss the possibility of the automatic inter-consistency measure in the general response. Please refer to it for more details.\n\n[1] Agile Software Development Methods: Review and Analysis\n\n> For intra-consistency, similarly the authors designed many different measures, and based on the experiment results the best measure varies depending on the task. How would one pick which measure to use in practice?\n\nWe designed many different measures to better analyze different types of intra-consistency within LLM (e.g. *Bayes Risk* is related to lexical consistency, *Cardinality* is designed to evaluate semantic consistency). Across various scenarios, we consistently observed robust performance with MPSC-Weighted Cardinality, making it our recommended preference.\n\n> solving the optimization: depending on the number of nodes and edges, the solving part could be very expensive\n\nThe iterative algorithm converges pretty fast. On HumanEval, the average convergence is achieved in 45.21 iterations, while on mbpp, it takes 32.52 iterations. Notably, the algorithm converges even more swiftly on CodeContests, requiring only 11.75 iterations. This consistent pattern of fast convergence across various benchmarks underscores the algorithm's efficiency and effectiveness."
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1679/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700327172652,
                "cdate": 1700327172652,
                "tmdate": 1700329002740,
                "mdate": 1700329002740,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "Nfu1iJxaJc",
                "forum": "hUs8YHAUEr",
                "replyto": "Pev718ZXIq",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer F87r (2/2)"
                    },
                    "comment": {
                        "value": "> without a training/dev set, how could one pick \\alpha in an unsupervised way?\n\nFirst of all, we want to emphasize that even with randomly selected alpha (e.g. 0.05 ~ 0.95), the performance of MPSC (especially the Weighted Cardinality setting) still outperforms baselines (please refer to Figure 4).\n\nWe admit that we cannot select the optimal alpha without priori about the test data distribution. In our main experiment, we sample 10 cases (which is a relatively small number) as our dev dataset. We then conduct a grid search for alpha on it (from 0.05 to 0.99 with a step of 0.05).\n\n> if given the same number of samples, i.e., baselines with 800 samples vs MPSC, how does the performance compare?\n\nWe totally agree with you about this fair experimental settings. In response to your concerns, we reduce the number of samples we use to 80 solutions, 20 specifications and 100 test cases, which is even unfair for MPSC since we can actually extract 10 test cases per API call. Because of your attention to variance in our method, we conducted sampling with five distinct seeds and reported the mean Pass@1 performance along with the std. The results are shown as follows. It is evident that MPSC still maintains high performance.\n- 83.52(\u00b10.72) on HumanEval\n- 73.43(\u00b10.43) on HumanEval+\n- 8.89(\u00b10.7) on CodeContests\n- 72.2(\u00b10.76) on MBPP\n\n> what is the variance of the proposed method, given that more samples from different perspectives are drawn?\n\nWe think the variance is likely to decrease, since the only source of randomness in MPSC comes from the sampling process of LLM. As the number of samples increases, it is reasonable to anticipate a reduction in variation.\n\n> how does the proposed method compare with \u201cTeaching Large Language Models to Self-Debug.\u201d\n\nThis paper doesn\u2019t release their codes, which makes the reproduction much harder. We have already tried to reproduce the method according to the prompts given in their appendix, but the gains is pretty small on our datasets.\n\n> Table 4 shows the test cases give the most gains, so maybe a simple baseline could be added: use the generated test cases to filter out incorrect generated solutions, and then apply self-consistency on the filtered set.\n\nEven though the test case perspective gives the most gains in ablation study, it doesn\u2019t guarantee the quality of generated test cases. Notably, the accuracy of generated test cases is relatively low, with only 63.83% on HumanEval and a mere 24.54% on MBPP. Directly filtering solutions through these generated test cases is anticipated to result in subpar performance, potentially even worse than employing vanilla self-consistency without the filtering.\n\nWe want to reiterate that the substantial performance gains of MPSC are not attributed to the quality of the LLM generated outputs. Instead, these gains stem from the consistency within the LLM, which is fully exploited by MPSC.\n\n> How does the proposed method work on the best model experimented (GPT-4)? Does it still give gains?\n\nWe are sorry that GPT4 API is too expensive to conduct the experiments as you wish. Here we conduct an alternative experiment to improve GPT4 generated solutions with ChatGPT generated test cases and specifications. The Pass@1 results are shown below. We use the same alpha as in the main experiment.\n\n| Method|HumanEval|HumanEval+|CodeContests|MBPP|\n| ------------------------- | ----- | ----- | ----- | ----- |\n| GPT4                      | 81.55 | 71.43 | 6.07  | 71.26 |\n| MPSC-Uniform              | 89.02 | 75.89 | 7.88  | 74.79 |\n| MPSC-MBR                  | 89.02 | 78.66 | 8.48  | 73.24 |\n| MPSC-Weighted Cardinality | 89.63 | 78.01 | 10.39 | 74.67 |\n\nThe efficacy of MPSC remains evident in its substantial performance gains, even when applied to GPT-4. It should be noted that these gains, while considerable, appear relatively modest compared with the remarkable improvements seen in ChatGPT. This discrepancy is understandable given that MPSC relies on the consistency within a single LLM. Despite ChatGPT and GPT-4 are two versions of the same LLM, subtle variations can still influence outcomes. We posit that employing MPSC with outputs exclusively generated by GPT-4 could potentially unlock unparalleled performance."
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1679/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700328815384,
                "cdate": 1700328815384,
                "tmdate": 1700329228764,
                "mdate": 1700329228764,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "ZQL5rvyzqv",
                "forum": "hUs8YHAUEr",
                "replyto": "Nfu1iJxaJc",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1679/Reviewer_F87r"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1679/Reviewer_F87r"
                ],
                "content": {
                    "comment": {
                        "value": "Thanks for the response. Overall I think the proposed method still requires too much manual design: if only one or two of them is manually designed like prompting, it might be fine, but MPSC requires many other manual choices as well, and the final performance varies quite a lot depending on each choice, i.e., there's no single universal best choice people can use in practice. Also picking \\alpha requires a dev set which is an unfair comparison to existing methods that are entirely unsupervised. Hence I will keep my original rating."
                    }
                },
                "number": 14,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1679/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700673133762,
                "cdate": 1700673133762,
                "tmdate": 1700673133762,
                "mdate": 1700673133762,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "Joa8Jbex87",
                "forum": "hUs8YHAUEr",
                "replyto": "Pev718ZXIq",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer F87r"
                    },
                    "comment": {
                        "value": "Thanks again for your comments and willingness for discussion. \n\nWe acknowledge your opinion that we do include manual design into MPSC for code generation, including the perspective and inter-consistency measure design. But as stated in the general response, we want to again underline that MPSC is inherently capable of entirely automatic reasoning without manual efforts. And in our opinion, **leveraging human priori about the task (i.e. the well-defined perspectives and verification in software engineering) for better reasoning of LLM should not be regarded as a drawback of our work**. With the current progress of LLM, achieving significant performance gains (e.g. surpassing GPT4 with GPT3.5) while requiring no manual efforts (not even defining one singular consistency function) is not feasible. Also, prompt engineering can serve as a good example of unleashing great potentials of LLM with a few manual efforts, which is valuable for real application.\n\nRegarding the choice of alpha, we only acknowledge that we cannot choose the optimal alpha without any information about data distribution (and only 10 samples can give a good estimation). We must emphasize that, even with the worst alpha, MPSC-Weighted Cardinality still surpasses other baselines as shown in Figure 4. And we recommend to use MPSC-Weighted Cardinality as stated in our previous comments."
                    }
                },
                "number": 17,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1679/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700723655398,
                "cdate": 1700723655398,
                "tmdate": 1700723676593,
                "mdate": 1700723676593,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "yIlPVyh9AM",
            "forum": "hUs8YHAUEr",
            "replyto": "hUs8YHAUEr",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1679/Reviewer_cqa4"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1679/Reviewer_cqa4"
            ],
            "content": {
                "summary": {
                    "value": "This paper investigates the intra-consistency and inter-consistency of LLMs through the code generation tasks. A multi-perspective self-consistency (MPSC) framework is proposed to enhance the decoding process of LLMs by introducing a multipartite graph. MPSC achieve noticeable improvement in Pass@1 on four code generation tasks."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1. This work investigates both intra-consistency and inter-consistency of LLMs\n2. The proposed MPSC achieves significant improvement on code generation\n3. The proposed MPSC can act like a plug-in to enhance other LLMs"
                },
                "weaknesses": {
                    "value": "1. The MPSC is complicate and unstable which limits the reproducibility\n2. The cost of MPSC is very high which limits its application\n3. The narrative of the paper is not clear"
                },
                "questions": {
                    "value": "Comments\n1. There have been some works investigate the inter-consistency issue [1]. I think the inter-consistency issue should come from different LLMs other than a single LLM. Therefore, the inconsistency among solutions, specifications, and test cases seems like a kind of intra-consistency within a single LLM.\n\n[1] Examining Inter-Consistency of Large Language Models Collaboration: An In-depth Analysis via Debate\n\n2. MPSC needs to sample 200 solutions for a problem, a very high temperature should be used to ensure diversity. I am a little worried about its reproducibility and stability. Moreover, it is costly to implement MPSC due to we should sample 200 solutions for each problem.\n\n3. I have spent a lot of time trying to understand the details of the MPSC framework. A real example of the multipartite graph will be helpful to lower the threshold of understanding."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1679/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698742339464,
            "cdate": 1698742339464,
            "tmdate": 1699636096107,
            "mdate": 1699636096107,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "9DrM3v0nt4",
                "forum": "hUs8YHAUEr",
                "replyto": "yIlPVyh9AM",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer cqa4"
                    },
                    "comment": {
                        "value": "We really appreciate your feedback and suggestion, but we have some different opinions on the comments. We provide explanations to address your concerns and questions. We sincerely hope you can reconsider the review after reading our responses.\n\n> 1. The MPSC is complicate and unstable which limits the reproducibility\n\nWe are sorry if our description of MPSC is hard to understand, which may cause your confusion. But we want to emphasize that **MPSC is a simple, intuitive and deterministic algorithm.** \n\nFirstly, MPSC requires the LLM to generate outputs from different perspectives. And intuitively we can leverage graph to model the relations among them, in which the edge weight w(vi,vj) is well defined as the inter-consistency between two vertices.\n\nWith the graph encoding the consistency information, we can then easily employ a simple but effective graph ranking algorithm (i.e. manifold ranking [1]) to aggregate the information and hence select the most consistent solution.\n\nBoth the graph construction process (edge weight is obtained through code execution) and the graph ranking process are deterministic. So the reproducibility can be guaranteed.\n\n[1] Learning with Local and Global Consistency\n\n> 2. There have been some works investigate the inter-consistency issue [2]. I think the inter-consistency issue should come from different LLMs other than a single LLM.\n\nThanks for your thoughtful advice about the missing related work. \n\nWe need to emphasize that the inter-consistency defined in this work is among different perspectives with respect to one query / question.\n\nWe believe that, for a single LLM, there exists a form of consistency in its responses to the same question across different perspectives, which we term inter-consistency. Simultaneously, there is intra-consistency observable in various responses emerging from the same perspective. MPSC is designed to fully exploit both these two kinds of consistency information within one model.\n\nIn essence, our emphasis lies in leveraging the inter-consistency of the same LLM. On the contrary, [2] finds the inter-**IN**consistency between different models, and proposes to solve it through a formal debate framework. Even though we happen to use the same name of \u201cinter-consistency\u201d, we refer to different concepts. And their motivation and contribution are quite different from ours.\n\nThanks for pointing out this paper. We will consider adding it into the related work session in the revision version.\n\n[2] Examining the Inter-Consistency of Large Language Models: An In-depth Analysis via Debate\n\n> 3. The cost of MPSC is very high which limits its application.  \n MPSC needs to sample 200 solutions for a problem, a very high temperature should be used to ensure diversity. I am a little worried about its reproducibility and stability. Moreover, it is costly to implement MPSC due to we should sample 200 solutions for each problem.\n\nFirst, we want to clarify that sampling 200 solutions for evaluation has been a convention setting in code generation since Codex [3]. And we follow the same temperature setting as in CodeT [4].\n\nTo fully address your concern about reproducibility, we resample solutions with 3 random seeds and report the mean Pass@1 performance with std. We only experiment with WizardCoder(7b/13b/34b) on HumanEval here, because the OpenAI API access is both expensive and time-consuming during this period. The results are shown below. It is evident that the improvement $\\Delta$ brought by MPSC is quite stable.\n\n|Model Size| Random Selection | MPSC |$\\Delta$|\n|--|--|--|--|\n|7B|52.20(\u00b12.16)|70.97(\u00b10.93)|18.77(\u00b11.74)|\n|13B|58.62(\u00b11.22)|76.33(\u00b10.94)|17.71(\u00b12.17)|\n|34B|66.04(\u00b11.27)|79.99(\u00b10.72)|13.95(\u00b11.83)|\n\nWe are also grateful for your careful consideration about the cost of MPSC in practical scenarios. Therefore, we reduce the solution sampling number into 10 / 50 / 100. The results are shown below. Even with fewer solutions, MPSC can still accurately select the correct ones (if exists) and achieve extraordinary performance.\n\n|#Samples|Method|HumanEval|HumanEval+|MBPP|CodeContests|\n|--|--|:--|:--|:--|:--|\n|100|random selection|68.38(\u00b10.08)|58.70(\u00b10.12)|66.82(\u00b10.07)|2.51(\u00b10.07)|\n|100|MPSC|85.61(\u00b10.3)|76.08(\u00b10.33)|72.19(\u00b10.17)|10.87(\u00b10.29)|\n|50|random selection|68.50(\u00b10.24)|58.78(\u00b10.27)|66.85(\u00b10.09)|2.56(\u00b10.06)|\n|50|MPSC|85.13(\u00b10.3)|75.75(\u00b10.49)|72.14(\u00b10.36)|10.68(\u00b10.46)|\n|10|random selection|68.40(\u00b10.6)|58.85(\u00b10.49)|67.02(\u00b10.12)|2.81(\u00b10.21)|\n|10|MPSC|83.42(\u00b10.9)|73.79(\u00b10.53)|72.39(\u00b10.24)|8.73(\u00b11.98)|\n\n[3] Evaluating Large Language Models Trained on Code\n\n[4] CodeT: Code Generation with Generated Tests\n\n>  4. A real example of the multipartite graph will be helpful to lower the threshold of understanding.\n\nAgain, we are sorry for the unclear description of MPSC. Thanks for your advice, we will add a real example of the graph in the revision version."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1679/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700239448639,
                "cdate": 1700239448639,
                "tmdate": 1700239448639,
                "mdate": 1700239448639,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "WEb6IxXG2M",
                "forum": "hUs8YHAUEr",
                "replyto": "9DrM3v0nt4",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1679/Reviewer_cqa4"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1679/Reviewer_cqa4"
                ],
                "content": {
                    "comment": {
                        "value": "Thanks for the authors' response. However, I will keep my score and believe that the paper can be further improved and clarified."
                    }
                },
                "number": 11,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1679/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700665376385,
                "cdate": 1700665376385,
                "tmdate": 1700665376385,
                "mdate": 1700665376385,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "YtxAFj9QeK",
                "forum": "hUs8YHAUEr",
                "replyto": "yIlPVyh9AM",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Thanks for Comments and Willingness for Further Discussion"
                    },
                    "comment": {
                        "value": "Thank you for sharing your comments, and we appreciate your perspective. Do you have any other questions or additional concerns? we are willing to have further discussion. Your thoughtful advice is valuable to our refinement, and we welcome any additional insights you may have."
                    }
                },
                "number": 12,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1679/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700668645276,
                "cdate": 1700668645276,
                "tmdate": 1700668660221,
                "mdate": 1700668660221,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "daZ9VTBkql",
            "forum": "hUs8YHAUEr",
            "replyto": "hUs8YHAUEr",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1679/Reviewer_F8qr"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1679/Reviewer_F8qr"
            ],
            "content": {
                "summary": {
                    "value": "This paper introduces a framework based on multiple perspectives for further researching and enhancing the previous self-consistency method. The idea is to divide self-consistency into consistency among various perspectives. The authors have validated the effectiveness of this method on different models and programming datasets."
                },
                "soundness": {
                    "value": "1 poor"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1. The improvement over the baselines is significant. However, it's unclear whether this improvement is due to the allowance of code execution.\n\n2. The paper is easy to read.\n\n3. The method proposed in this paper can be applied to both closed-source large models (like ChatGPT) and open-source large models."
                },
                "weaknesses": {
                    "value": "1. A key issue with the methodology and experiments of this paper is that the proposed method actually requires the execution of code, rather than merely generating it. For instance, in Listing 3 of Appendix 3, one needs to execute the solution to complete the validation with test cases. The authors need to emphasize this distinction from other methods. Clearly, when code execution is allowed, the task becomes easier. This issue makes the main experimental results of the paper, as shown in Table 2, unfair, as other methods do not require code execution.\n\n2. Can the method proposed in this paper be applied under conditions where code execution is not allowed? If so, what are the results? The authors have not demonstrated this.\n\n3. Is the learning approach designed in this paper overly complicated? Is it possible to avoid using w(vi,vj) and f(vi) and directly employ an MLP or other ensemble methods to obtain the answer? For instance, self-consistency actually uses max-vote directly. Overly complex optimization algorithms make the methodological contributions of this paper ambiguous.\n\n4. The specific \"perspectives\" used in this paper do not entirely align with intuition. For example, in Figure 2, the paper views the solution, specification, and test case as three perspectives, whereas conceptually, they are three answer components."
                },
                "questions": {
                    "value": "Please refer to the weaknesses."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1679/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698832980038,
            "cdate": 1698832980038,
            "tmdate": 1699636096031,
            "mdate": 1699636096031,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "POfWj4knrW",
                "forum": "hUs8YHAUEr",
                "replyto": "daZ9VTBkql",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer F8qr"
                    },
                    "comment": {
                        "value": "We really appreciate your feedback, but we have some different opinions on the comments. We provide more explanations for each weakness you pointed out in your comments. We sincerely hope you can reconsider the review after reading our responses.\n\n> 1. A key issue with the methodology is that the proposed method actually requires the execution of code ... Clearly, when code execution is allowed, the task becomes easier. This issue makes the main experimental results ... unfair, as other methods do not require code execution.  \n2. Can the method proposed in this paper be applied under conditions where code execution is not allowed? \n\nOn one hand, we never execute codes with golden test cases, but only with generated test cases. It doesn\u2019t make the task easier because the correctness of generated test cases is not guaranteed. On the other hand, main baselines (including Self-Consistency, MBR-Exec, CodeT) **all require code execution** . Therefore, the comparison in our main experiment is fair.\n\n- Self-Consistency: we follow the setting in [1]. If two solution pass the same set of generated test cases and specifications, we regard them \u201cconsistent\u201d. Then we take a majority voting to rank solutions following [2].\n- CodeT: CodeT first uses generated test cases to verify each solution by code execution. Then it utilizes RANSAC algorithm to create consensus sets based on execution results. The size of consensus set is then used to rank solutions.\n- MBR-Exec: This method ranks solutions by minimum Bayes risk decoding based on the execution results in the generated test cases.\n\nWe will make the details of these baselines all clear in our updated paper.\n\n[1] CodeT: Code Generation with Generated Tests\n[2] Self-Consistency Improves Chain of Thought Reasoning in Language Models\n\n> 3. Is the learning approach designed in this paper overly complicated? Is it possible to avoid using w(vi,vj) and f(vi) and directly employ an MLP or other ensemble methods to obtain the answer?\n\nWe want to argue that the design of MPSC is simple and intuitive.\n\nf(vi) is the ranking score of each output, which is necessary for any ranking algorithm since it is the final objective. The edge weight w(vi,vj) is naturally defined as the inter-consistency of two vertices from different perspectives in the graph, which can be deterministically obtained by code execution. After we build the graph (we will add a real example of the multipartite graph in our paper for clearer understanding), we can easily apply a simple but effective graph ranking algorithm here, i.e. manifold ranking [3], to aggregate the consistency information and select the best solution.\n\nIt is clear that **MPSC is not a supervised learning approach**. It\u2019s a non-parametric, deterministic algorithm. We don\u2019t need to involve any learnable parameters, e.g. using MLP. \n\nThere indeed exists other ensemble strategies like self-consistency, and we have included it as baseline. MPSC surpasses it by a large margin.\n\n[3] Learning with Local and Global Consistency\n\n> 4. The specific \"perspectives\" used in this paper do not entirely align with intuition. For example, in Figure 2, the paper views the solution, specification, and test case as three perspectives, whereas conceptually, they are three answer components.\n\nSolution, test case and specification are three important aspects in agile software development methods [4]. They play different roles in the software development lifecycle. They are not different \u201canswer components\u201d because the only answer component required in code generation task is the solution. One can certainly complete this task without introducing test cases and specifications. And our key insight is to make LLM think from these non-essential but significant perspectives, so that we can leverage the consistency information within LLM to further enhance its own capabilities. \n\n[4] Agile Software Development Methods: Review and Analysis"
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1679/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700235545102,
                "cdate": 1700235545102,
                "tmdate": 1700235623972,
                "mdate": 1700235623972,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "avAX0Iu38Y",
                "forum": "hUs8YHAUEr",
                "replyto": "daZ9VTBkql",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1679/Reviewer_F8qr"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1679/Reviewer_F8qr"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your response. Now I understand that other baselines also employ code execution. This should be emphasized, otherwise readers might mistakenly think that, like self-consistency, it only requires Large Language Models (LLMs). However, I noticed that the main text of the paper did not mention this.\n\nConsidering that MPSC requires an environment for code execution, this raises some new concerns for me:\n\n1. Under this limitation, the contribution of MPSC seems diminished. For instance, given that CodeT has already used LLMs to generate test cases, the additional generation of Solution and Specification in this paper does not appear to be a significant innovation.\n\n2. The original paper on Self-Consistency was not applied to code, nor did it require code execution. Therefore, adapting Self-Consistency to code might not be straightforward. This makes the comparison between MPSC and Self-Consistency somewhat unclear in terms of its meaning.\n\nIn summary, although the authors have addressed some of my concerns, they have also raised new ones, especially regarding the novelty compared to existing methods like CodeT. Additionally, the methodology section (Sec 3) of MPSC still seems overly complex."
                    }
                },
                "number": 13,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1679/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700670693814,
                "cdate": 1700670693814,
                "tmdate": 1700670728982,
                "mdate": 1700670728982,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "cbdwGVJh0c",
                "forum": "hUs8YHAUEr",
                "replyto": "daZ9VTBkql",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer F8qr"
                    },
                    "comment": {
                        "value": "Thanks for your comments. We have already added the implementation details of baselines in Appendix E. \n\nRegarding the contributions and novelty of MPSC, we have different opinions. The main contribution of MPSC's is fully leveraging consistency within LLM through an optimization over graph, not using code execution on test cases. The same thing can also apply to CodeT. Its contribution comes from using RANSAC algorithm in code generation. Its novelty doesn't diminish because previous work has already used LLM to generate test cases (Alphacode[1]) and introduced code execution (Alphacode, MBR-exec[2]).\n\nSelf-consistency cannot be directly used for code generation (any NLG tasks in fact), as stated in their paper \"One should note that self-consistency can be applied only to problems where the \ufb01nal answer is from a \ufb01xed answer set\". Our implementation of Self-consistency makes it available for code generation and fair for comparison.\n\n[1] Competition-level code generation with AlphaCode  \n[2] Natural Language to Code Translation with Execution"
                    }
                },
                "number": 16,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1679/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700709737567,
                "cdate": 1700709737567,
                "tmdate": 1700710060243,
                "mdate": 1700710060243,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "h2IKpFA0Y6",
            "forum": "hUs8YHAUEr",
            "replyto": "hUs8YHAUEr",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1679/Reviewer_myx4"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1679/Reviewer_myx4"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes Multi-Perspective Self-Consistency (MPSC), which extends the original self-consistency framework to consider both inter-consistency and intra-consistency. For code generation, they consider 3 perspectives: solutions, specifications and test cases. MPSC generates multiple samples for each perspective, then constructs a multipartite graph and learns a scoring function to select the final answers. They compare MPSC to other baselines including self-consistency, MBR-Exec, CodeT and self-collaboration. They demonstrate that MPSC consistently outperforms the baselines by a significant margin on multiple coding benchmarks."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. MPSC is a natural extension of self-consistency for code generation, where the consistency among the solution, test cases and specifications can be precisely verified by code execution.\n\n2. The experiments show remarkable performance improvement compared to strong baselines that utilize multiple samples and/or test cases."
                },
                "weaknesses": {
                    "value": "The main weaknesses of this work are: (1) the implementation details are unclear; and (2) some ablation studies are missing. Specifically, I have the following questions:\n\n1. How is MBR-Exec implemented? I do not understand why MBR-Exec can perform worse than self-consistency. To my understanding, self-consistency selects the final program based on the exact match; i.e., selecting the most frequently appeared code in all samples. On the other hand, MBR-Exec selects programs based on the frequency of execution results. Does MBR-Exec utilize the given test cases as in the original paper?\n\n2. For MPSC-Label, how are the golden test cases utilized? Do you directly filter out those programs that do not pass the test cases? In general I do not understand why MPSC-Weighted Cardinality can sometimes outperform MPSC-Label.\n\n3. It is interesting to see that GPT-3.5 with MPSC can outperform GPT-4. However, sampling 200 solutions is still very expensive. Do you have results with fewer number of samples, e.g., 10 or 100? What is pass@200, which should be the upper bound of the performance?\n\n4. It is helpful to add discussion on the quality of generated test cases and specifications. For example, what are the true positive and false negative rates?\n\nAlso, I think MPSC is well-suited for code generation, but how to extend it to other domains remains unclear."
                },
                "questions": {
                    "value": "1. How is MBR-Exec implemented? Does MBR-Exec utilize the given test cases as in the original paper?\n\n2. For MPSC-Label, how are the golden test cases utilized? Do you directly filter out those programs that do not pass the test cases?\n\n3. Do you have results with fewer number of solutions, e.g., 10 or 100 instead of 200? What is pass@200, which should be the upper bound of the performance?\n\n4. It is helpful to add discussion on the quality of generated test cases and specifications. For example, what are the true positive and false negative rates?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1679/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699244235299,
            "cdate": 1699244235299,
            "tmdate": 1699636095945,
            "mdate": 1699636095945,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "dGdryVpkd1",
                "forum": "hUs8YHAUEr",
                "replyto": "h2IKpFA0Y6",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer myx4"
                    },
                    "comment": {
                        "value": "We are grateful for your positive feedback and thoughtful advice. We address the weaknesses and questions you pointed out as follows. We hope this can resolve your doubts.\n>1. How is MBR-Exec implemented? Does MBR-Exec utilize the given test cases as in the original paper?\n\nWe are sorry for the missing implementation details of baselines.\n\nFor the self-consistency baseline, we actually don\u2019t use the lexical exact match, but follow the setting in [1]. That is, if two solutions pass the same set of generated test cases and specifications, we regard them \u201cconsistent\u201d. Then we take a majority voting to rank solutions.\n\nFor MBR-exec implementation, we don\u2019t use the golden test cases but the generated test cases for a fair comparison. Because MPSC and other baselines do not execute the golden test cases. \n\nSo it is reasonable that self-consistency exceeds MBR-Exec. We will make these details clearer in the updated paper.\n\n[1] CodeT: Code Generation with Generated Tests\n\n>2. For MPSC-Label, how are the golden test cases utilized? Do you directly filter out those programs that do not pass the test cases?\n\nWe are sorry for the misuse of phrase \u201cgolden test case\u201d, which may cause your confusion.\n\nTo avoid misunderstanding, we want to emphasize that labels used in MPSC-Label setting is the example test cases provided in docstrings (silver test cases), not the test cases used during testing (golden test cases).\n\nWe **NEVER** directly filter the programs with silver test cases or golden test cases.\n\nThe main idea of MPSC-Label (we refer you to the section 3.3 and Table 1 for more details) is to pass the messages of silver test case vertices to the generated solution vertices through the graph. On the other hand, MPSC-Weighted Cardinality utilizes the intra-consistency within LLM.\n\nThey utilize different kinds of information (one from the outsides, one from the insides). The performance is surprising but also reasonable. As shown in [2], the intra-consistency is highly correlated to correctness. Our experiment further demonstrates this point.\n\n[2] Self-Consistency Improves Chain of Thought Reasoning in Language Models\n\n>3. Do you have results with fewer number of solutions, e.g., 10 or 100 instead of 200? What is pass@200, which should be the upper bound of the performance?\n\nFirst, we want to clarify that sampling 200 solutions for evaluation has been a convention setting in code generation since Codex [3].\n\nWe are grateful for your careful consideration about the costs of MPSC in practical scenarios. Here we add an extensive experiment by only sampling 10 / 50/ 100 solutions (we conduct sampling for 5 times with different seeds, and report mean Pass@1 performance with std error bar). We use the same MPSC-Weighted Cardinality settings as that in the main experiment. It is evident that even with fewer solutions samples, MPSC is able to select the correct ones (if exists), and outperforms baseline (i.e. random selection) by a significant margin.\n\n\n|#Samples|Method|HumanEval|HumanEval+|MBPP|CodeContests|\n|--|--|:--|:--|:--|:--|\n|100|random selection|68.38(\u00b10.08)|58.70(\u00b10.12)|66.82(\u00b10.07)|2.51(\u00b10.07)|\n|100|MPSC|85.61(\u00b10.3)|76.08(\u00b10.33)|72.19(\u00b10.17)|10.87(\u00b10.29)|\n|50|random selection|68.50(\u00b10.24)|58.78(\u00b10.27)|66.85(\u00b10.09)|2.56(\u00b10.06)|\n|50|MPSC|85.13(\u00b10.3)|75.75(\u00b10.49)|72.14(\u00b10.36)|10.68(\u00b10.46)|\n|10|random selection|68.40(\u00b10.6)|58.85(\u00b10.49)|67.02(\u00b10.12)|2.81(\u00b10.21)|\n|10|MPSC|83.42(\u00b10.9)|73.79(\u00b10.53)|72.39(\u00b10.24)|8.73(\u00b11.98)|\n\nHere we also report pass@200, which is the upper bound of all methods. The gap between the upper bound and MPSC is relatively small (8% on HumanEval, 5% on CodeContests, 10% on MBPP), and again proves the effectiveness of our method.\n- HumanEval: 93.90\n- HumanEval+: 90.24\n- CodeContests: 19.39\n- MBPP: 83.37\n\n[3] Evaluating Large Language Models Trained on Code\n\n>4. It is helpful to add discussion on the quality of generated test cases and specifications. \n\nWe have already discussed the quality of generated test cases and specifications in Table 10. Instead of using accuracy, we utilize pass@k to demonstrate the effectiveness of MPSC on ranking other perspectives (i.e. test cases and specifications). And the pass@1 is actually equal to accuracy. So the accuracy of specifications and testcases are as following: \n\n- HumanEval: Test case 63.83%, Specification 45.66%\n- MBPP: Test case 24.54%, Specification 50.83%\n\nIt should be noted that the accuracy of specification is not 100% accurate. Because the formal verification of specification requires professional human evaluation, which is both expensive and time-consuming. As an alternative, we apply a looser verification by examining whether a specification can pass golden test cases.\n\n>5. how to extend it to other domains remains unclear.\n\nPlease refer to the general response for more details."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1679/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700235539582,
                "cdate": 1700235539582,
                "tmdate": 1700235539582,
                "mdate": 1700235539582,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "Iey5Zrhjbc",
                "forum": "hUs8YHAUEr",
                "replyto": "dGdryVpkd1",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1679/Reviewer_myx4"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1679/Reviewer_myx4"
                ],
                "content": {
                    "comment": {
                        "value": "Thank the authors for the explanation, it clarifies the settings of some experiments. I keep my review score, though I think extra work should still be done to make the approach design and implementation details clearer in paper writing."
                    }
                },
                "number": 15,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1679/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700708027796,
                "cdate": 1700708027796,
                "tmdate": 1700708027796,
                "mdate": 1700708027796,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "5ADLi1fzbC",
            "forum": "hUs8YHAUEr",
            "replyto": "hUs8YHAUEr",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1679/Reviewer_q6tm"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1679/Reviewer_q6tm"
            ],
            "content": {
                "summary": {
                    "value": "This paper presents Multi-Perspective Self-Consistency (MPSC), a novel framework aiming at improving the performance of LLMs at decoding time in complex reasoning tasks such as code generation. Extending from previous work on self consistency (e.g., Wang et al., 2022), the authors introduce multiple perspectives and a formulation of inter-consistency, which captures the agreement between generated outputs from diverse perspectives. The authors conduct experiments in code generation using various code competition benchmarks and three perspectives: solution, specification, and test cases. Empiricial results show a good amount of improvement over the baseline method."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "- The multi-perspective method is well-motivated and well-suited for tasks like code generation.\n- The authors conduct comprehensive evaluation and show significant performance improvement over various baselines.\n- The paper is well-written."
                },
                "weaknesses": {
                    "value": "- The main limitaiton of the work is the useability on a broader range of tasks. Despite MPSC is claimed to be task-agnostic, only code generation was presented in the paper, which greatly limits the impact of this work. On one hand, the authors only study code competition task, and it is unknown whether the framework can work in code generation in the wild. On the other hand, the authors should consider including at least one more NL task to demonstrate the extensibility of the framework.\n\n- It is unclear whether and how well the framework can generalize towards more perspectives. In code generation, there are only three perspectives, which is quite limited. It would be great to think about and demonstrate that MPSC can work with arbitary number of perspectives.\n\n- The perspectives are manually curated now, which can be a limitation for tasks with vague perspective definitions. It would be great to discuss whether manual curation of perspectives is required and if not how that would impact the end performance."
                },
                "questions": {
                    "value": "- What would be the reason for degradation in MBPP?  \n\n- The improvement is diminishing when using a higher k in pass@k. Can the authors perform experiments with a much higher k (e.g. 100) and see the gap there?\n\n- For Bayes Risk, why would using BLEU metrics preferred especially given the code generation task?\n\n- Can the authors discuss the overhead added due to the graph introduced by MPSC?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 5,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1679/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699465708103,
            "cdate": 1699465708103,
            "tmdate": 1699636095866,
            "mdate": 1699636095866,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "O06DWYyv2g",
                "forum": "hUs8YHAUEr",
                "replyto": "5ADLi1fzbC",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer q6tm (1/2)"
                    },
                    "comment": {
                        "value": "We highly value your constructive feedback and wish to express our gratitude. But we would like to present our differing views on the issues you raised. We have provided detailed explanations in our responses for each question you pointed out, and we sincerely hope you may reconsider your review.\n\n> 1. The main limitaiton of the work is the useability on a broader range of tasks...  \n2. Whether manual curation of perspectives is required and if not how that would impact the end performance...\n\nWe have written a general response to your concern. Please refer to the it about the details.\n\n> 3. It is unknown whether the framework can work in code generation in the wild.\n\nWe have conduct comprehensive experiments on four popular benchmarks of code generation. MPSC has shown superior performance on all four of them and surpassed other methods (even GPT4) by a large margin. To our best knowledge, none of the current LLM-based code generation research, e.g., [1][2][3] conducts experiments of code generation in the wild. And there is also no high-quality such benchmarks. We would be glad to conduct experiments if there is any. In theory, MPSC can be applied for any scenarios in the wild provided that code execution is feasible.\n\n[1] Evaluating Large Language Models Trained on Code  \n[2] WizardCoder: Empowering Code Large Language Models with Evol-Instruct  \n[3] Code Llama: Open Foundation Models for Code\n\n> 4. It is unclear whether the framework can generalize towards more perspectives.\n\nTo avoid potential misunderstanding, we want to underscore that the introduction of \u201cperspectives\u201d is to induce outputs reflecting LLM\u2019s understanding of the query, and therefore better exploit the consistency within LLM. So the number of perspectives should be adapted to the requirements of the given task, rather than being rigidly constrained by an arbitrary number.\n\nRegarding your concern, we would like to discuss about the impact of the number of perspectives on MPSC. It should be noted that the number of perspectives only determines the partitions of the constructed graph. MPSC framework contains two stages: Graph Construction (GC) and Graph Ranking (GR). The GC stage requires to measure pair-wise inter-consistency between vertices from two different perspectives and intra-consistency of each vertex. They both are independent of the number of perspectives. The GR stage is essentially an optimization process over a graph (see Eq.3 for details). Notably, this optimization process, with a closed-form solution (see Appendix A for details), does not leverage the properties of a multi-partite graph and hence remains unaffected by the number of perspectives.\n\n> 5. The improvement is diminishing when using a higher k in pass@k. Can the authors perform experiments with a much higher k (e.g. 100)\n\nFirst we want to emphasize that pass@k with small k (e.g. 1,2,5) is much more important in practical scenario since users won\u2019t expect to do a second selection from a total of 50 solutions. And current works about code generation models (including ChatGPT, GPT4, StarCoder, WizardCoder) only report pass@1 performance.\n\nThe diminishing improvement is expected with higher k theoretically. An intuitive way to understand that is from the definition of pass@k, which is the probability of whether the selected $k$ samples out of 200 pass unit tests (Refer to Appendix C for more details). The lowerbound of selection, random selection (also our baseline), has a pass@k value of $1-\\frac{\\tbinom{200-c}{k}}{\\tbinom{200}{k}}$ ($c$ is the number of correct solutions out of 200 solutions). While the upperbound of selection has a pass@k value of 100% (if there exist correct solutions). When k=100, c=6, even the lowerbound can achieve 99%. When k=50, c=10, the lowerbound can achieve 95%. The small gap between lower bound and upper bound makes the evaluation meaningless for all ranking algorithms.\n\n> 6. For Bayes Risk, why would using BLEU metrics preferred especially given the code generation task?\n\nWe choose BLEU because the MPSC-Bayes Risk setting is designed to measure the **lexical** intra-consistency. And we utilize the BLEU metrics following the first MBR method in NLP [4].\n\nIf you refer to the semantical consistency of codes, the structural equivalence (Sec 3.3) reflects some sorts of \u201cMBR\u201d with respect to the code execution results.\n\n[4] Minimum\u00a0Bayes-Risk Decoding for Statistical Machine Translation"
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1679/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700311149119,
                "cdate": 1700311149119,
                "tmdate": 1700311149119,
                "mdate": 1700311149119,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "52KBasreHp",
                "forum": "hUs8YHAUEr",
                "replyto": "5ADLi1fzbC",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1679/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer q6tm (2/2)"
                    },
                    "comment": {
                        "value": "> 7.  What would be the reason for degradation in MBPP?\n\nWe conduct a case study about the failure modes of MPSC where the foundation model do generate some correct solutions. We find some serious ambiguities in MBPP because of no example test cases provided in its docstrings. Here we list two typical kinds of ambiguity.\n\n- format ambiguity: The type of return value is not explicitly defined in the prompt. In the following case, LLM generate more than 50 \u201cmisguided\u201d answers which return the correct solution but in a `tuple` format.\n    - prompt:\n        \n        ```bash\n        def sort_sublists(input_list):\n        '''\n        Write a function to sort each sublist of strings in a given list of lists.\n        '''\n        ```\n        \n    - MPSC selected solution:\n        \n        ```bash\n        for sublist in input_list:\n            sublist.sort()\n        return input_list\n        ```\n        \n    - golden test cases for testing:\n        \n        ```bash\n        assert sort_sublists(([\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]))==[['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n        ```\n        \n- semantic ambiguity: The instruction in docstrings is not clear and contains ambiguity. In the following case, LLM generate more than 50 \u201cmisguided\u201d answers which regard the `str` variable as a list because the description `given list of words` in docstrings. But it is in fact a string. It also generate more than 250 \"misguided\" testcases with `str` variable as a `list`.\n    - prompt\n        \n        ```bash\n        def long_words(n, str):\n        '''\n        Write a function to find words that are longer than n characters from a given list of words.\n        '''\n        ```\n        \n    - MPSC selected solution:\n        \n        ```bash\n        words = []\n        for word in str:\n            if len(word) > n:\n                words.append(word)\n        return words\n        ```\n        \n    - golden solution:\n        \n        ```bash\n        word_len = []\n        txt = str.split(\" \")\n        for x in txt:\n            if len(x) > n:\n                word_len.append(x)\n        return word_len\n        ```\n        \n\nIn both cases, LLM is seriously misguided to a different understanding of docstrings because of the ambiguity. MPSC is designed to fully exploit the consistency within LLM to select the most consistent solution, and hence is seriously influenced. In our opinion, the degradation is not only plausible, but also further justifies the design of our framework.\n\n> 8. Can the authors discuss the overhead added due to the graph introduced by MPSC?\n\nThe overhead of MPSC mainly comes from the inter-consistency measurement through code execution. For verification between two vertices, the time is about 1e-4 sec (measured by executing one solution with one test case for 1000 times) in average. Following our main experimental setting (200 solutions & 500 test cases & 100 specifications), the sequential execution time is about $(200\\times 500+200\\times 100+500\\times 100)\\times 0.0001s=17s$. It\u2019s worth noting that all the measurement can be executed in parallel. Moreover, as shown in Table 5&6, MPSC maintains the superior performance with only 10% test cases and specifications, which only requires 1.25s with sequential execution."
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1679/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700311600614,
                "cdate": 1700311600614,
                "tmdate": 1700311633741,
                "mdate": 1700311633741,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]