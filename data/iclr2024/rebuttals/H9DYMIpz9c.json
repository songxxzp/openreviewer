[
    {
        "title": "Farzi Data: Autoregressive Data Distillation"
    },
    {
        "review": {
            "id": "Ie1VUg7cqO",
            "forum": "H9DYMIpz9c",
            "replyto": "H9DYMIpz9c",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission9481/Reviewer_LDAP"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission9481/Reviewer_LDAP"
            ],
            "content": {
                "summary": {
                    "value": "The authors introduce a dataset distillation (DD) method called Farzi Data for data with a \"left to right\" (autoregressive) causal structure. Their algorithm has two novel elements: 1) the parameterization of the synthetic distilled data, which allows them to apply it to discrete data (such as the tokens in language modeling); and 2) a method for computing the outer loop gradient for DD when the inner loop is performed with Adam, which has a constant memory footprint independent of the number of inner optimization steps. They conduct extensive experiments with their proposed method on language modeling and sequential recommendation tasks. Compared to existing DD methods (adapted to discrete data via their parameterization), they obtain improved performance across the tested datasets, often obtaining downstream performance better than training a model on the entire original dataset."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "**Algorithmic Contribution.** Algorithm 1 for computing the gradient through the inner-loop optimization with Adam using constant memory is a significant contribution. Among existing dataset distillation methods, those which take into account the entire training trajectory on the distilled data tend to obtain better accuracy (as compared to other methods which use surrogates for this objective such as the gradient matching objective in dataset condensation). However, the computational burden of these methods (specifically the memory requirement, which necessitates keeping the entire computation graph) renders them infeasible for application to larger datasets. Farzi Data takes a significant step towards addressing this problem by introducing an algorithm for differentiating through an inner loop optimized with Adam, whose memory does not scale with the number of steps in the inner loop (see Fig. 5). This is an important improvement for DD to be practically useful in real ML applications.\n\n**Empirical Results.** The empirical results are also impressive. The authors obtain better performance than competing methods across several different real-world benchmarks. There are even scenarios where their distilled data consistently outperforms training on the entire original dataset (cf. Table 1), indicating that Farzi Data implicitly promotes some sort of \"data cleaning\" whereby samples that *hurt* model performance are removed or discounted. This is similar to, e.g., removing mislabeled points or data with negative Shapley values, but Farzi Data is not explicitly trained for this task."
                },
                "weaknesses": {
                    "value": "**Presentation and Clarity.** While the actual prose of the paper was generally clear and easy to read, there are some major concerns with notation/presentation that limit understanding of some of the main contributions of the paper.\n\nP1. There are many cases where important notation is not defined. For instance, $\\mathrm{Rep}(\\mathcal{F}, \\mathcal{D})$ is defined in the Appendix, but not the main text, and is critical to interpreting Theorem 3.1. It is not stated what the terms $d\\mathbf{m}$, $d\\mathbf{x}$, and $d\\mathbf{w}$ in Algorithm 1 are supposed to be, so it is impossible to determine if the expressions are correct or not. How to construct the output of the algorithm from these quantities is also not clear. What is the correspondence of the quantities in Alg. 1 to the DD problem, i.e., what will we actually update using the meta-gradient once we know how to compute it? Some (but not all) of these details can be found in the Appendix, but as they are critical to being able to understand the results, they should be moved to the main text and given appropriate explanations.\n\nP2. Stylistically, there is also some nonstandard notation. For instance, $\\mathcal{O}(100)$ (3rd bullet point, pg. 2). I suppose the authors meant \"on the order of 100x\", but big-O notation has a mathematically precise meaning that doesn't make sense here. Another instance is Proposition 3.2. \"Correctness of Algorithm 1, Line 13\" is not a complete mathematical statement (or a complete sentence). The result should be stated completely and precisely.\n\n**Theoretical Results.** There are also issues with the theoretical results.\n\nT1. The most critical problem is that the proof of the main theorem (Theorem 3.1) is not mathematically sound. Specifically, the authors want to show that the expected representativeness of their low-rank synthetic data parameterization is strictly less than the expected representativeness of a naive synthetic data parameterization, under some suitable conditions and for quadratic classifiers: $\\mathbb{E}[\\mathrm{Rep}(\\mathcal{F}, \\mathcal{D}_F)] < \\mathbb{E}[\\mathrm{Rep}(\\mathcal{F}, \\mathcal{D}_N)]$. ($\\mathcal{D}_F$ and $\\mathcal{D}_N$ stand for Farzi and naive data, respectively.) In their proof in Appendix B.1, they show that $\\mathbb{E}[\\mathrm{Rep}(\\mathcal{F}, \\mathcal{D}_F)] < B_1$ and $\\mathbb{E}[\\mathrm{Rep}(\\mathcal{F}, \\mathcal{D}_N)]$ for some bounds $B_1$ and $B_2$. Then, since $B_1 < B_2$, they conclude the desired result. This is not valid: $a < b$, $c < d$, and $b < d$ does not imply that $a < c$. There needs to be a _lower_ bound on the representativeness for the naive parameterization.\n\nI remark that I believe the _result_ is (at least \"morally\") correct. The theorem essentially reduces to saying that the Rademacher complexity resulting from the low-rank parameterization is smaller than the Rademacher complexity from a general parameterization, which is intuitively obvious. However, the _proof_ has a fatal error and must be corrected somehow.\n\nT2. For Lemma B.3 to hold, there must clearly be some assumptions on the loss function $l$; in order to apply the lemma from Shalev-Shwartz, the Rademacher complexity of the loss composed with the models in $\\mathcal{F}$ must be considered, not $\\mathcal{F}$ itself. As stated, I believe this lemma is not correct and the loss must be accounted for. Apart from the logical error, the motivation for the use of quadratic classifiers in the theorem wasn't clear to me. What connection do such models have to the auto-regressive tasks that Farzi Data is applied to?\n\nT3. This is related to the presentation problems regarding the notation used in Algorithm 1, but the proof of Proposition 3.2 is also suspect. What is meant by $d\\mathbf{m} = d\\mathbf{m} + \\frac{\\partial w_t}{\\partial m_t} \\cdot d\\mathbf{w}$? Is $w_t$ supposed to be $\\mathbf{w}_T$, or is this expression meant to be a recursive formula? What about the formulas for the other quantities, and how are these combined to compute the meta gradient?\n\nIf these issues can be satisfactorily addressed, along with the questions in the section below, I would be willing to raise my score to accept, given how promising the empirical results are."
                },
                "questions": {
                    "value": "Q1. The authors mention that training with the reference trajectories $\\Omega$ is important for obtaining the best performance, as compared with training only from randomly initialized networks. However, it wasn't clear to me if this might just have been the result of a greater number of training steps when learning the distilled dataset. That is, are the results in Fig. 6(b) with the total number of meta-gradient steps constant, or do the additional precomputed trajectories result in more meta-gradient steps?\n\nQ2. On a related note, it was not clear to me exactly how the precomputed trajectories were used. My assumption was that instead of training the network in the inner loop only from random initializations, instead the network from the inner loop will be initialized with parameters from one of the training trajectories. Is this correct?\n\nQ3. Why isn't FMLP also used as a teacher network in Table 1?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission9481/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission9481/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission9481/Reviewer_LDAP"
                    ]
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission9481/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1697578262755,
            "cdate": 1697578262755,
            "tmdate": 1699637192678,
            "mdate": 1699637192678,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "cAvlKj54Wc",
                "forum": "H9DYMIpz9c",
                "replyto": "Ie1VUg7cqO",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission9481/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission9481/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to reviewer LDAP (Part 1/2)"
                    },
                    "comment": {
                        "value": "First of all, we really appreciate your review \u2014 we believe this is a good quality review where you ask very valid questions; irrespective of your low score recommendation. However, we do hope our responses shed some light on your key confusions and convince you to improve your score. It would really help us push this important line of work to one of the most technically capable audiences, at ICLR. Please let us know if we can add / expand on something:\n\n**Q: Important notation is not defined in the main-text.**\n\nA: Thank you for raising these super-valid points! We will make sure to address the following changes as you suggested to improve the readability of our paper:\n- **what the terms $d\\mathbf{m}, d\\mathbf{x}, d\\mathbf{w}$**: We apologize for missing this detail. $d\\mathbf{m}, d\\mathbf{x}, d\\mathbf{w}$ are the meta-gradients of $f(w_T)$ w.r.t $m_0, x, w_0$ respectively. Most of this notation is re-used from [1], but we will make sure to add this to the main-text.\n- **what will we actually update using the meta-gradient in Algorithm 1**: Using simple, gradient based optimization in the outer loop (we use Adam), once we have the meta-gradient from Algorithm 1, i.e., $d\\mathbf{x} \\triangleq df(w_T) / d\\mathbf{x}$; we use this gradient to update $\\mathbf{x} \\leftarrow Adam(\\mathbf{x}, d\\mathbf{x})$ in the standard way. Note that $\\mathbf{x}$ in our case is parameterized as $\\tilde{\\mathcal{D}}_{syn}$ and $\\mathbf{M}$.\n- **non-standard $\\mathcal{O}(100)$**: Absolutely, we\u2019ll make sure to write 100x instead of $\\mathcal{O}(100)$. Thanks!\n- **Statement of Proposition 3.2**: We\u2019ll make sure to write the complete statement in the main-text instead of the current way. Thank you for pointing this out!\n\n**Q: Issue in Theorem 3.1**\n\nA: Thank you for catching our honest mistake at the end of Theorem 3.1 \u2014 we are highly appreciative! We tried taking the lower-bound approach as you suggested but to no-end: there are no commonly available lower-bounds for Radamacher complexities because of the underlying $\\sup()$ in its definition. Even trying to develop novel lower bounds isn\u2019t a trivial process and/or contribution. Hence, given the short timeline of this rebuttal, we have decided to remove Theorem 3.1 from our paper and totally admit to our mistake. \n\nWe do hope that you believe that removing this Theorem doesn\u2019t hurt our technical and practical contributions too much, as you have yourself suggested in your review.\n\n**Q: Notation questions in Proposition 3.2**\n\nA: Thanks for pointing this out - we can definitely improve upon the clarity here. You\u2019re correct by mentioning that this is a recursive formula, starting from $t=T$ going all the way to $t=1$. As outlined in Algorithm 1, $d\\mathbf{m}, d\\mathbf{x}, d\\mathbf{w}$---which are the meta-gradients of $f(w_T)$ w.r.t $m_0, x, w_0$ respectively---are variables which are carried over, with the equations in Algorithm 1 defining the update rules for our recursive meta-gradient calculation. Please note that $d\\mathbf{x}$ which represents $df(w_T) / d\\mathbf{x}$ is the final meta-gradient used for updating our synthetic data ($\\tilde{\\mathcal{D}}_{syn}$ and $\\mathbf{M}$) that we\u2019re interested in. Similarly, for other meta-learning applications like learning suitable weight initializations (e.g., MAML), we can use the same Algorithm 1 to estimate other meta-gradients like $d\\mathbf{w}$ which represents $df(w_T) / dw_0$, if we use Adam in the inner-loop.\n\nPlease note that our Algorithm 1 shares the same spirit as the popular reverse-mode SGD algorithm with its recursive formulation [1], albeit much simpler due to being a first-order optimizer.\n\n**Q: Are the results in Fig. 6(b) with the total number of meta-gradient steps constant?**\n\nA: Great question again! We would like to mention here that all of the results in Fig. 6(b) are performed with the outer loop running till convergence of a maximum of 4000 steps. Please note that realistically, convergence for all settings in our paper happens between 1000-2000 steps, at most. We\u2019ll make sure to add a clarification in the main text.\n\nWe would also like to provide some added intuition behind using the pre-trained trajectories as is currently used in Farzi. In the model weight space, $\\Omega$ contains a set of points with varying levels of quality (models are trained starting from random till convergence, with intermediate checkpoints being stored). Farzi\u2019s inner loop, using these points as starting points, now has a better exploration of the entire model weight space, and the final data will be better optimized to train models of varying quality. This makes the final data summary more robust and enables it to train models at different stages of training.\n\n[1] Maclaurin, Dougal, David Duvenaud, and Ryan Adams. \"Gradient-based hyperparameter optimization through reversible learning.\" International conference on machine learning. PMLR, 2015."
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission9481/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700728538246,
                "cdate": 1700728538246,
                "tmdate": 1700728538246,
                "mdate": 1700728538246,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "KqbT3NNcP2",
            "forum": "H9DYMIpz9c",
            "replyto": "H9DYMIpz9c",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission9481/Reviewer_THWQ"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission9481/Reviewer_THWQ"
            ],
            "content": {
                "summary": {
                    "value": "The paper provides an extension of dataset distillation to sequence modeling along with a few other innovations, such as a low rank approximation of the distilled dataset and an efficient trick to save memory during meta-learning. Overall, the paper contains strong (albeit limited) empirical results on the sequence modeling (penn tree bank) and recommendation systems datasets."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "* The high level motivation of the problem is quite the need of the hour, as with larger models we need to better understand their dependencies on the data\n* Pursuit of this research direction could potentially yield methods that enable us to train SOTA transformer models for a fraction of the input cost\n* Empirical results are thorough, although a bit limited in terms of number of datasets for sequence modeling (only PTB is used)"
                },
                "weaknesses": {
                    "value": "A number of points about the approach were unclear to me from the writeup, and I would appreciate clarifications from the authors:\n\n* It is said that the complexity of the dataset distillation algorithm scales by the size of the vocabulary (page. 4) and the size of the sequence that we wish to model. I can see the latter to be the case, since the loss will now be summed over the entire sequence as opposed to one forward pass (so the complexity of the forward pass is increased). However, I do not see how the time complexity increases with the vocabulary size. Do we mean space complexity? Also, more than the forward pass the dominant factor in dataset distillation is the computation of a bunch of hessian vector products in the meta gradient. Those terms do not depend on the vocabulary size either\u2026 please clarify..\n* It would be nice to provide an intuition for what is saving the memory, making things O(1) in memory.  Currently the big algorithm block does not provide an intuition for how this approach is O(1) in memory regardless of the number of timesteps of unrolling. This is important to clarify, since this is an important contribution, if clearly explained. If this approach is essentially gradient checkpointing, then it is worth noting that Deng and Russakovsky already implement a version of this in their code. \n* Looking at Eqn. 2, I am a bit puzzled as to how \\Omega, namely the trajectories from the real data are incorporated in the DD process. From what I am able to understand, \\theta_0 \\sim Omega -- namely the init is sampled from the pretrained trajectories, and then from the right hand side of eqn. 2 I understand that the rest of the trajectory is obtained using Adam on the synthetic data. Where is the role of the pretrained trajectories then? Please explain..\n\n* Rank regularization has been done in the previous work (Deng and Russakovsky) for dataset distillation. It should be cited that this has been done, and not be presented as a novelty.."
                },
                "questions": {
                    "value": "My major questions concern the clarifications about the approach listed above, without which it is really hard to judge the technical correctness / soundness of the paper."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission9481/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698794707116,
            "cdate": 1698794707116,
            "tmdate": 1699637192562,
            "mdate": 1699637192562,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "JH1yl4jv1D",
                "forum": "H9DYMIpz9c",
                "replyto": "KqbT3NNcP2",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission9481/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission9481/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to reviewer THWQ"
                    },
                    "comment": {
                        "value": "We really thank you for your time and effort in reviewing the paper and providing us with your valuable feedback! Below are the responses to your well-motivated questions, which we hope will shed more clarity on Farzi\u2019s design. Please let us know if we can add / expand on something:\n\n**Q: I do not see how the time complexity increases with the vocabulary size.**\n\nA: Looking at Farzi\u2019s time complexity in Section 3, both the time and space complexities depend directly on the vocabulary size, i.e., $\\dim(\\mathcal{V})$. Let me provide further intuition on this:\n- Taking the naive, non-parameterized Farzi data parameterization as a simpler reference, each entry in the $\\mu \\times \\xi \\times \\dim(\\mathcal{V})$ data summary is a *parameter* in the outer-loop optimization. Hence, both the sequence length ($\\xi$) and the vocabulary size ($\\dim(\\mathcal{V})$) directly contribute to the space complexity, as well as the time complexity, e.g., for computing and updating the meta-gradient for each of these parameters, that too for each of the $T$ steps in the inner loop.\n\n**Q: What is making things O(1) in memory? Is it essentially gradient checkpointing?**\n\nA: Thank you for the question! Definitely makes sense to provide an intuition for this. The key technological advancement here is Algorithm 1, and to be more specific Lines 13-15, which derive the reverse-mode meta-gradient calculation equations, when Adam is used in the inner-loop. Having access to these equations, we can now only keep the $d\\mathbf{m}, d\\mathbf{x}, d\\mathbf{w}$ vectors as loop carry-over variables and compute the exact meta-gradient for updating the data summary (i.e., $d\\mathbf{x}$) in $O(T)$ time using the for-loop in Algorithm 1, and making the space complexity independent of $T$. However, naive autodiff and standard meta-gradient libraries like higher would store *all intermediate variables of the inner-loop* making the space complexity linear in terms of $T$.\n\nFurther, regarding the comparison to (Deng and Russakovsky), please note that they first of all leverage prior work [1] which developed reverse-mode SGD (similar to our reverse-mode Adam, albeit much simpler due to being a first-order optimizer). Next, reverse-mode Adam is completely different from gradient checkpointing in the case of meta-learning where it\u2019s non-trivial and suboptimal [2]. On the other hand, our reverse-mode Adam is correct (optimal) because of our hand-derived meta-gradient calculations (Proposition 3.2).\n\n**Q: How is $\\Omega$\u2014the trajectories from the real data\u2014incorporated in the DD process?**\n\nA: Thanks for pointing this out! There is definitely a clarification to be made here: $\\Omega$ contains the *flat* set of all episodic checkpoints for the training trajectories and when we sample $\\theta_0$ (0 here represents the inner loop time-index), it can come from the union of all the intermediate checkpoints available to us ($\\Omega$). We\u2019ll make sure to add the clarification in the pdf as well.\n\n**Q: Rank regularization has been done in previous work, and not be presented as a novelty.**\n\nA: Thanks for pointing this out! We do not intend to claim latent parameterization of data, in its entirety as our novelty. However, we sincerely believe the following pieces of development to be critical and also novel to our propositions:\n- Previous work regarding parameterized data distillation (not just (Deng and Russakovsky)) have been motivated to achieve better performance using fewer total bytes to store the data. However, in our setting of autoregressive data distillation, we would like to explicitly note that naive data parameterization is infeasible computationally due to the vocabulary size dimension in our data. \n- We provide formal connections as to why rank regularization *improves* performance by reducing overfitting and promoting implicit regularization. Please note that while this conclusion is intuitive, we are the first to showcase a formal proof.\n\nWe would like to end by requesting you to kindly reconsider your final rating as it strictly decides the outcome of this paper, which in your own self-opinion is well-timed and contains strong empirical evidence.\n\n[1] Maclaurin, Dougal, David Duvenaud, and Ryan Adams. \"Gradient-based hyperparameter optimization through reversible learning.\" International conference on machine learning. PMLR, 2015.\n\n[2] Hascoet, Laurent, and Mauricio Araya-Polo. \"Enabling user-driven checkpointing strategies in reverse-mode automatic differentiation.\" arXiv preprint cs/0606042 (2006)."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission9481/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700727979507,
                "cdate": 1700727979507,
                "tmdate": 1700727979507,
                "mdate": 1700727979507,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "6xFAd71bxb",
            "forum": "H9DYMIpz9c",
            "replyto": "H9DYMIpz9c",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission9481/Reviewer_htDK"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission9481/Reviewer_htDK"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes a method for distillation of \"auto-regressive data\", in this case meaning any data that is represented as event sequences. This can include natural language text, but also general time-series data. Their method aims to summarize a dataset into a sequence of latent embeddings (which can subsequently be decoded) given a downstream task such that they achieve similar performance to training on the complete dataset. They do this through a meta-learning procedure, optimizing directly through Adam for data which lowers downstream task loss."
                },
                "soundness": {
                    "value": "4 excellent"
                },
                "presentation": {
                    "value": "4 excellent"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "My review comes from the point of view of someone familiar with training on natural language (and associated downstream evaluation), but not general event forecasting problems. I was not familiar with the benchmarks used by the author prior to reading this paper. \n\n**Originality and Significance**\n\n- The paper seems original. Aspects of this work (e.g. using meta-learning/second order methods) for distillation have been touched on in the past, but usually for smaller datasets, and generally not for auto-regressive tasks. Most past works I have seen which work on large corpuses revolve around finding mixing coefficients for existing datasets [1]. This method doesn't work on datasets of that size, however this shows an improvement in scaling. \n- Getting a meta-learning approach to work on such dataset sizes is quite difficult, given difficulties with estimating second-order components over the full dataset. Scaling this to even larger language-style datasets would be an interesting (future) contribution.\n\n\n\n**Quality and Clarity**\n\nThis paper is quite well-written. Experimental details are clear, and the method is properly motivated. Diagrams clarify the algorithm and the key difficulties to this method are highlighted appropriately.\n\n[1] The Pile: An 800GB Dataset of Diverse Text for Language Modeling, Gao et al. 2021"
                },
                "weaknesses": {
                    "value": "**Weaknesses**\n\n- The authors touch on language datasets as a motivation, however do not study this (or other large-sequence tasks) due to practical model/sequence length scaling constraints. Are there reasonable paths forward that would allow this to scale to longer sequence lengths/larger models? \n- Given that the outer loop evaluates across the full original dataset, and the inner loop needs to be run several times to get updated parameters (Figure 5), what's the overall cost saving versus just training a model on the original dataset for more time (until matching student performance), if any? \n- Have the authors thought about cases where there is significant noise in the training corpus? Given that the loss is computed with respect to the original dataset, it seems like this could be a problem if one ever tried to directly filter a noisy web-crawl."
                },
                "questions": {
                    "value": "All questions have been included in the \"Weaknesses\" section above."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission9481/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698825156434,
            "cdate": 1698825156434,
            "tmdate": 1699637192432,
            "mdate": 1699637192432,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "cdKFSLDISD",
                "forum": "H9DYMIpz9c",
                "replyto": "6xFAd71bxb",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission9481/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission9481/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to reviewer htDK"
                    },
                    "comment": {
                        "value": "We really thank you for your time and effort in reviewing the paper and providing us with your valuable feedback! Below are the responses to your well-motivated questions, which we hope will shed more clarity on Farzi\u2019s design. Please let us know if we can add / expand on something:\n\n**Q: Are there reasonable paths forward that would allow this to scale to longer sequence lengths/larger models?**\n\nA: Thanks for the question! Regarding longer sequence lengths, even in most LLM pre-training setups, typical input sequence length is in the order of a few thousands. This is certainly feasible with the setup proposed by Farzi\u2019s latent parameterization (but would struggle if the sequence length, e.g., exceed hundreds of thousands). Further, performing the Farzi optimization for larger models is also possible out-of-the-box with hardware/compute requirement no-more-than training the LLM itself. The only reason we weren\u2019t able to perform data distillation for LLMs is because we don\u2019t have the compute to train LLMs by itself.\n\n**Q: What's the overall cost saving versus just training a model on the original dataset for more time?**\n\nA: Great question! Since this question was also raised by other reviewers, we have put the results in a separate comment up top for the sake of not repeating, and are happy to present our impressive results!\n\n**Q: Have the authors thought about cases where there is significant noise in the training corpus?**\n\nA: Wonderful question, and highly relevant in, e.g., pre-training scenarios as you mentioned. Even though we don\u2019t have direct evidence in this paper, there is indeed very strong hope for automatic denoising while performing data distillation. Looking at Figure 4 in [1] which also performs data distillation, training on data summarized by data distillation is (1) definitely much better than training on random samples of noisy data; and (2) better than training on the full dataset when there is high-noise in the datasets. The intuition behind this is that data distillation implicitly promotes de-noising, as the overall optimization objective is to maximize model performance within a small data budget, implicitly minimizing the noise in such low-data scenarios.\n\nWe would like to end by requesting you to kindly reconsider your final rating as it strictly decides the outcome of this paper, which in your own self-opinion is well-timed, and a fresh approach to data optimization for autoregressive tasks like NLP.\n\n[1] Sachdeva, Noveen, et al. \"Infinite recommendation networks: A data-centric approach.\" Advances in Neural Information Processing Systems 35 (2022): 31292-31305."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission9481/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700727543703,
                "cdate": 1700727543703,
                "tmdate": 1700727543703,
                "mdate": 1700727543703,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "5ChaClFszG",
            "forum": "H9DYMIpz9c",
            "replyto": "H9DYMIpz9c",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission9481/Reviewer_FjiL"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission9481/Reviewer_FjiL"
            ],
            "content": {
                "summary": {
                    "value": "The paper introduces FARZI, a data distillation framework for machine learning tasks. The goal is to condense the original large dataset into a much smaller number of synthetic sequences, so that downstream performance on the synthetic data matches (or even improves) performance on the full real dataset. The authors cast the problem using a bi-level optimization formulation, similar to meta-model matching based dataset distillation. The naive formulation is infeasible due to the very large token vocabulary and the maximum sequence length. To address this, the authors propose to factorize the synthetic dataset into a latent data summary and a token-decoder matrix. This renders the optimization continuous (as opposed to discrete), while it provides flexibility to sample synthetic sentences from a distribution (as opposed to having a fixed small set of synthetic sentences). Furthermore, the authors suggest to replace SGD in the inner loop by the Adam optimizer. To mitigate the large memory footprint, they derive an efficient approximation for reverse-model differentiation of the Adam optimization. The authors assess FARZI on sequential recommendation and language modeling tasks, where they manage to match or even exceed the downstream full-data performance using as little as 0.1% of the original dataset. The authors conduct several experiments and ablation studies to shed light on various aspects of their framework."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "4 excellent"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "The paper makes several interesting contributions. The meta-model matching based dataset distillation was originally proposed for continuous data (e.g., image data), as opposed to language data that use discrete tokens. The use of a latent space addresses this challenge by ensuring that the optimization can be performed in a continuous space, but by also allowing us to sample the synthetic sentences from a compact distribution. Furthermore, the observation that the Adam optimizer is a much better choice for the inner loop optimization (compared to SGD) is very interesting and dramatically improves downstream performance. To address the large memory footprint, the authors derive an efficient approximation of the reverse-mode differentiation of the Adam optimizer, which nicely complements their finding that Adam is better than SGD. Interestingly, this may be more broadly applicable in other bi-level optimization tasks (e.g., in a meta-learning context).\n\nThe paper is well written and the related work is covered quite extensively. The authors describe in detail the various insights of their framework. When it comes to the experimental evaluation, they provide a lot of information on the metrics, datasets, hyperparameters, objectives, and even architectures.\n\nThe experimental evaluation is quite convincing and supports the claims made by the authors. It is very interesting that FARZI can even outperform downstream performance on the full original dataset, which could indicate the improved robustness with dataset distillation. I liked the fact that the authors investigated various aspects of FARZI, such as the versatility of the synthetic data, the cross-architecture generalization, the performance of different meta-objectives, the cold start problem, and the impact of pre-trained trajectories."
                },
                "weaknesses": {
                    "value": "1. Even though this paper makes interesting contributions to the DD literature for autoregressive tasks, it is not so obvious that it would be \nvery helpful for much larger text corpora and large language models with millions or billions of parameters. The memory footprint might end up being very large, rendering the whole framework infeasible. Furthermore, a compression rate of 0.1% may not be extremely helpful for very large datasets consisting of billions of sentences. This may limit the applicability of FARZI to settings consisting of \"reasonably large but not very large\" language corpora.\n\n2. It was not clear to me how time-consuming the FARZI dataset generation process is. For example, how long did it take to generate the synthetic datasets for the tasks considered in this work? In particular, did FARZI improve the total runtime? For instance, if generating the synthetic data takes very long, then there may be very little benefit (if any) from this process. Furthermore, it is not automatically obvious that a smaller dataset can be trained faster than a larger one. There is the added question of the number of epochs required to reach convergence. The synthetic dataset may require more rounds. This was not obvious in the experimental evaluation. If I am not mistaken, I feel that the subject of runtime was only superficially touched in this work, and a more thorough discussion (with detailed pros and cons) would be needed.\n(Theoretically, this may not be a big issue if the same synthetic dataset could be successful used on several downstream tasks, but this is not immediately true. If we need dataset distillation for each separate task, then we may end up performing FARZI several times.)"
                },
                "questions": {
                    "value": "1. Could the authors elaborate more on the total runtime (total time for synthetic dataset generation + total time for downstream training with synthetic vs. full data)? It would be helpful if the authors could shed light on the various questions/comments raised in Weakness (2) above.\n\n2. In Equation (2), \\Omega is a set containing initializations for the inner loop, if I understand correctly. But instead of picking the initialization randomly, these come from a small number of training trajectories on the full dataset. If that is true, then the \\theta_i in the definition of \\Omega has nothing to do with the update rule for \\theta_t in Equation (2). This may still be confusing to some readers though because the same symbols are used (theta with a subscript, so the authors may want to clarify this point (i.e., what exactly is in \\Omega).\n\n3. I was not clear how exactly the authors chose the final hyperparameters for each setting. Did they exhaustively try all corresponding combinations in the hyperparameter table and picked the best one?\n\n4. Is a new synthetic batch created at the beginning of each outer-loop step based on the latent factorization?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission9481/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699222222036,
            "cdate": 1699222222036,
            "tmdate": 1699637192321,
            "mdate": 1699637192321,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "7GxDwzOJIU",
                "forum": "H9DYMIpz9c",
                "replyto": "5ChaClFszG",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission9481/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission9481/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to reviewer FjiL"
                    },
                    "comment": {
                        "value": "We really thank you for your time and effort in reviewing the paper and providing us with your valuable feedback! Below are the responses to your well-motivated questions, which we hope will shed more clarity on Farzi\u2019s design. Please let us know if we can add / expand on something:\n\n**Q: It is not so obvious that Farzi would be very helpful for much larger text corpora and large language models**\n\nA: While we absolutely agree that large language models would be an exciting application for Farzi, we would like to mention that most research labs do not have the compute necessary for such line of work. Hence, we believe penalizing for such reasons (that is only if considered while rating this paper) might be a very strict requirement that implicitly undermines exploratory or academic research.\n\n**Q: Could the authors elaborate more on the total runtime.**\n\nA: Great question! Since this question was also raised by other reviewers, we have put the results in a separate comment up top for the sake of not repeating, and are happy to present our impressive results!\n\n**Q: $\\theta_i$ in the definition of $\\Omega$ has nothing to do with the update rule for $\\theta_t$ in Equation (2)**\n\nA: Thanks for pointing this out! There is definitely a clarification to be made here: $\\Omega$ contains the *flat* set of all episodic checkpoints for the training trajectories and when we sample $\\theta_0$ (0 here represents the inner loop time-index), it can come from the union of all the intermediate checkpoints available to us ($\\Omega$). We\u2019ll make sure to add the clarification in the pdf as well.\n\n**Q: It was not clear how exactly the authors chose the final hyperparameters for each setting**\n\nA: Just like any deep learning setup, we test a random subset (as per a reasonable grid search budget) of the grid of combinations listed in Tables 4 & 5 and report the best result after selecting the best hyper-parameters using a validation set.\n\n**Q: Is a new synthetic batch created at the beginning of each outer-loop step based on the latent factorization?**\n\nA: Thanks for the question! We list the sequence of steps in Farzi for some added clarity and will add this as an algorithm block in the appendix:\n1. Before any optimization we randomly initialize $\\tilde{\\mathcal{D}}_{syn}$ and $\\mathbf{M}$\n2. Sample a batch of fake sequences from $\\tilde{\\mathcal{D}}_{syn}$\n3. Perform one outer loop step as demonstrated in figure 2\n4. Repeat from step 2, till convergence\n\nWe would like to end by requesting you to kindly reconsider your final rating as it strictly decides the outcome of this paper, which in your own self-opinion contains important technical contributions, and contains strong empirical evidence."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission9481/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700727264900,
                "cdate": 1700727264900,
                "tmdate": 1700727264900,
                "mdate": 1700727264900,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "oklGIKdeEa",
            "forum": "H9DYMIpz9c",
            "replyto": "H9DYMIpz9c",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission9481/Reviewer_At7H"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission9481/Reviewer_At7H"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes FARZI, a data distillation method for auto-regressive ML tasks/event-sequence datasets. The method summarizes a large dataset into a set of synthetic sequences in latent space which can be decoded later. They show that model performance is upheld/enhanced when compared to training on the complete dataset on the downstream tasks of sequential recommendation and language modeling. For data distillation, the paper shows Adam to be better than SGD as inner loop optimizer, and derives an efficient reverse mode differentiation of Adam such that its memory complexity is independent of the number of inner loop steps."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "- Originality and Significance: The latent parametrization that makes FARZI optimization friendly, and the proposed trick that enables reverse mode differentiation of Adam such that its memory complexity is independent of the number of inner loop steps are great contributions and of practical value.\n- Quality and Clarity: The paper is well written with extensive experiments whose details and evaluations are that are clearly described. The results are impressive. The method is able to achieve better performance on downstream tasks compared with using the full dataset."
                },
                "weaknesses": {
                    "value": "- It is not clear whether this method will be practical and scale for larger language models and larger datasets. It would be great if the authors can elaborate on this.\n- There is not a clear analysis of the total time gains of this method in comparison with training from scratch. Providing some values would make the case for this method more compelling."
                },
                "questions": {
                    "value": "Listed in weakness section."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission9481/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission9481/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission9481/Reviewer_At7H"
                    ]
                }
            },
            "number": 5,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission9481/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699616060078,
            "cdate": 1699616060078,
            "tmdate": 1699637192209,
            "mdate": 1699637192209,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "BnwYIsAXeU",
                "forum": "H9DYMIpz9c",
                "replyto": "oklGIKdeEa",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission9481/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission9481/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to reviewer At7H"
                    },
                    "comment": {
                        "value": "We really thank you for your time and effort in reviewing the paper and providing us with your valuable feedback!\n\nBelow are the responses to your important and well-needed questions, and please let us know if we can add / expand on something:\n\n**Q: It is not clear whether this method will be practical and scale for larger language models and larger datasets.**\n\nA: We split the response into two parts, one for larger datasets, and one for larger models: \n- The model is out-of-the-box scalable to as large datasets as we want, simply because the model only requires *batches of the dataset we want to summarize*. For more context, the largest dataset used in the paper (Netflix) has almost half a million data-points, and we only use a batch size of $512$ in the outer loop. Even with such an extremely small batch size, only $2,000$ sequences synthesized by Farzi can train models equally well as training on all half a million sequences in the original dataset.\n- Being restricted to an academic research environment, we don\u2019t have the compute necessary to experiment with large language models (LLMs). Even though it would be a well-timed application to LLMs, we believe Farzi paves a clear way for future research in data distillation for LLMs. Nonetheless, we would like to point out that Farzi\u2019s reverse-mode Adam derivation makes it possible to perform data distillation for LLMs using no more than the same hardware that is used to train such LLMs. In other words, the memory complexity for Farzi is the same as training the base model.\n\n**Q: There is not a clear analysis of the total time gains of this method.**\n\nA: Great question! Since this question was also raised by other reviewers, we have put the results in a separate comment up top for the sake of not repeating, and are happy to present our impressive results!\n\nWe would like to end by requesting you to kindly reconsider your final rating as it strictly decides the outcome of this paper, which in your own self-opinion is of good practical value, and contains strong empirical evidence."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission9481/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700727003487,
                "cdate": 1700727003487,
                "tmdate": 1700727003487,
                "mdate": 1700727003487,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]