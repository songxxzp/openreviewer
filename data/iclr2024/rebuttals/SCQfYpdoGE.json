[
    {
        "title": "Prediction without Preclusion: Recourse Verification with Reachable Sets"
    },
    {
        "review": {
            "id": "3hs7aeN0Am",
            "forum": "SCQfYpdoGE",
            "replyto": "SCQfYpdoGE",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission5341/Reviewer_2QxH"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission5341/Reviewer_2QxH"
            ],
            "content": {
                "summary": {
                    "value": "This paper introduces the \"recourse verification\" task, aimed at identifying models that assign fixed predictions, and proposes methods to assess whether a model can provide actionable recourses based on reachable sets."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "4 excellent"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "- The paper is well-written and easy to follow.\n- The motivation and justification for fixed points and regions are sound.\n- The experiments demonstrate an improvement in the feasibility of recourse across published datasets."
                },
                "weaknesses": {
                    "value": "Weaknesses:\n- I am unsure about the paper's significant contribution. The primary focus appears to be on describing a search algorithm to confirm the existence of a feasible action for a user. \n- My major concern regarding this paper is its inapplicability to continuous features, as claimed by the authors. Is it possible to extend the MIP formulation to MILP formulation to incorporate continuous features?\n- The paper compares the proposed method to two conventional baselines in terms of improving recourse feasibility. Recently, there have been some papers potentially improving feasibility, such as [1] and [2]. I suggest comparing with them."
                },
                "questions": {
                    "value": "- The optimization problem (2) aims to optimize a constant value of 1. What does this objective imply? Does this optimization problem solely seek to find all feasible actions (feasible recourses)?\n- Is there a relationship between two reachable sets? For instance, if $x_1$ is within the reachable set of $x$ and $x_2$ is within the reachable set of $x_1$, is it guaranteed that $x_2$ is also within the reachable set of $x$?\n\n**References**:\n\n[1] Nguyen, Duy, Ngoc Bui, and Viet Anh Nguyen. \"Feasible Recourse Plan via Diverse Interpolation.\" International Conference on Artificial Intelligence and Statistics, 2023.\n\n[2] Rafael Poyiadzi, Kacper Sokol, Raul Santos-Rodriguez, Tijl De Bie, and Peter Flach. Face: Feasible and Actionable counterfactual explanations. In Proceedings of the AAAI/ACM Conference on AI, Ethics, and Society, 2020."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission5341/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission5341/Reviewer_2QxH",
                        "ICLR.cc/2024/Conference/Submission5341/Senior_Area_Chairs"
                    ]
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission5341/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698504653779,
            "cdate": 1698504653779,
            "tmdate": 1700554440795,
            "mdate": 1700554440795,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "LxdXZSGNBK",
                "forum": "SCQfYpdoGE",
                "replyto": "3hs7aeN0Am",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5341/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5341/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your review and questions! We have addressed your questions below\n\n> The paper compares the proposed method to two conventional baselines in terms of improving recourse feasibility. \n\nThanks for asking this question! This question provides an excellent opportunity to clarify the concept of \"feasibility\".\n\nThese methods are designed to find actions that are \u201cfeasible\u201d in that they cross over the decision boundary of complex models like XGB and DNNs. It\u2019s important to note that their primary focus is not on guaranteeing feasibility concerning \"actionability constraints.\"\n\nThe recourse problem is:\n\\begin{align}\n        \\min \\quad & cost({\\mathbf{a} | \\mathbf{x}})\\\\\n        s.t. \\quad & f(\\mathbf{x} + \\mathbf{a}) = +1 \\\\\n        & \\mathbf{a} \\in A({\\mathbf{x}})\n\\end{align}\n\nThe methods you describe are designed to return actions that obey the $f(x+a) = 1$ constraint. However, they cannot handle the actionability constraints $\\mathbf{a} \\in A(\\mathbf{x})$. So their \u201cactions\u201d will violate the $\\mathbf{a} \\in A(\\mathbf{x})$ condition. For example, Face [2] fails to handle interval, encoding, and implication constraints (see Table 1). In practice, this means that they will behave in the same way as DiCE which fails to handle similar constraints. This leads to loopholes (method returns an action that violates the actionability constraints) and blindspots (a point that has a feasible action, but the search algorithm cannot find it) as seen in Table 3\n\n> I am unsure about the paper's significant contribution. The primary focus appears to be on describing a search algorithm to confirm the existence of a feasible action for a user.\n\nThis is a very difficult problem to address (please see [this](https://openreview.net/forum?id=SCQfYpdoGE&noteId=AEN6qNww0p) for more details). Stepping back, however, the technical contribution is that it\u2019s hard to build a method that can find actions that will work with general classes of models and that satisfy actionability constraints. \n\nThe reason why we need methods like the ones above is that it is inherently difficult to find points that cross over the decision boundary when we work with complex models like DNNs, XGB, and RF. The methods resolve this issue to ensure feasibility with respect to the $f(\\mathbf{x}+\\mathbf{a})$. In doing so, they sacrifice the ability to certify infeasibility with respect to the $\\mathbf{a} \\in A(\\mathbf{x})$ constraints.\n\nThis is where reachable sets are powerful. Our framework provides a way to handle this for any model. We can build a reachable set once and then apply it to many models $f$. This allows us to certify feasibility for complex models like XGBoost, DNNs, and RFs.\n\n> My major concern regarding this paper is its inapplicability to continuous features, as claimed by the authors.\n\nThis seems to be a misunderstanding of something that we wrote.\n\nOur approach is applicable to continuous features! Every method that we have in the paper will work on classifiers that use continuous features. Our software is designed to handle them.\n\nThe only issue that we have with continuous features is that we may not be able to certify infeasibility in all possible cases. In this regime, we still obtain meaningful results with regard to verification \u2013 by certifying feasibility and by flagging certain kinds of infeasibility.\n\nWe can show that recourse is feasible by using IsReachable to show that we can reach other points in the sample. Or by certifying that a point produced using another method obeys actionability constraints. \nWe can flag infeasibility by detecting only fixed points by calling the FindAction Routine (Eq 5).\nIn the remaining, our methods will still work and output results that are correct as we will claim \u201cI don\u2019t know\u201d rather than \u201cfeasible\u201d and \u201cinfeasible\u201d. \n\nWe can show that recourse is feasible by using Theorem 3 with any labeled dataset to set an upper bound for the number of points needed in a reachable set. \n\n> The optimization problem (2) aims to optimize a constant value of 1. What does this objective imply? Does this optimization problem solely seek to find all feasible actions (feasible recourses)\n\nYes, this is a correct interpretation. \n\n> Is there a relationship between two reachable sets? For instance, if x1 is within the reachable set of x and x2 is within the reachable set of x1, is it guaranteed that x2 is also within the reachable set of x\n\nThis is not guaranteed to be true. Suppose $\\mathbf{x_1} \\in R(\\mathbf{x_0})$ and  $\\mathbf{x_2} \\in R(\\mathbf{x_1})$.  $ R(\\mathbf{x_0})$ and $R(\\mathbf{x_1})$ may or may not be overlapping. In the case when they are not overlapping then $\\mathbf{x_2}$ does not lie in $R(\\mathbf{x_0})$. In the case when they are overlapping $\\mathbf{x_2}$ may lie in $R(\\mathbf{x_0})$ if  $\\mathbf{x_2}$ is in the overlapping region. The only time when $\\mathbf{x_2} \\in R(\\mathbf{x_0})$ is guaranteed to be in $R(\\mathbf{x_0})$ is when $ R(\\mathbf{x_1}) \\subseteq R(\\mathbf{x_0})$."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5341/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700257996609,
                "cdate": 1700257996609,
                "tmdate": 1700257996609,
                "mdate": 1700257996609,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "36HjgSRctW",
                "forum": "SCQfYpdoGE",
                "replyto": "LxdXZSGNBK",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5341/Reviewer_2QxH"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5341/Reviewer_2QxH"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your response. Some parts of your answer have indeed clarified aspects of your paper for me. I have adjusted the score to 5. However, I would like to discuss a few points further:\n\n- Concerning continuous features, I understand that there is uncertainty regarding \"infeasibility\" answers. The proposal to quantify the probability of \"infeasibility\" in such cases is both a necessary and a valuable extension.\n\n- If I understand correctly, in cases with only discrete features, your problem can be formulated as a graph-based path-finding problem. Each vertex represents a user's feature set, and edges connect vertices with their reachable sets. It seems that Depth-First Search (DFS) or Breadth-First Search (BFS) could be used to determine \"feasibility.\" What distinguishes your method from the approach I've outlined, and what makes your method preferable?\n\n- In real-world scenarios, certain actions may be feasible for one group of people but not for others, reflecting the user-dependence feature of reachable sets more broadly. How does your method adapt to such practical cases?"
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5341/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700554424995,
                "cdate": 1700554424995,
                "tmdate": 1700554424995,
                "mdate": 1700554424995,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "fmUZmxCmst",
                "forum": "SCQfYpdoGE",
                "replyto": "3hs7aeN0Am",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5341/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5341/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Author response (2/2)"
                    },
                    "comment": {
                        "value": "> If I understand correctly, in cases with only discrete features, your problem can be formulated as a graph-based path-finding problem. Each vertex represents a user's feature set, and edges connect vertices with their reachable sets. \n\nA graph-based path-finding algorithm would not work for two reasons:\n\n1. In cases with only discrete features, the problem can only be cast as a graph-based path-finding problem if we have observed all possible samples. Otherwise, we may be interested in looking for paths to vertices that do not exist.\n\n2. In the case that we had observed all possible features, then reachable points would not necessarily be connected. For example, suppose that the reachable set for the point $\\mathbf{x\\_0} \\in X$ contains the points $\\mathbf{x\\_1} \\in R(\\\\mathbf{x\\_0})$ and $\\mathbf{x\\_2} \\in R(\\\\mathbf{x\\_0})$. In this case, we may have that $\\mathbf{x\\_2} \\not\\in R(\\mathbf{x\\_1})$ and $\\mathbf{x\\_1} \\not\\in R(\\mathbf{x\\_2})$. Please see our previous response for how reachable sets may not be overlapping or contained in one another. Therefore, there may be no path connecting points within the reachable set. \n\n\n> In real-world scenarios, certain actions may be feasible for one group of people but not for others, reflecting the user-dependence feature of reachable sets more broadly. How does your method adapt to such practical cases\n\nThank you for this question! This would be a setting where - for example, 100 people have the same features $\\mathbf{x}\\_0$ but different actionability constraints from $A(\\mathbf{x}\\_0)$. If the people had different features, then they would each have a different reachable set.\n\nIn general, the machinery that we develop can be used with any action set at $A(\\mathbf{x}_0)$. This means that if we could elicit actionability constraints from each person \u2013 using e.g., an interface like [1] - then we could use it to generate a personalized reachable set for each person and use that to verify the feasibility of recourse. In short, we can support this use case. However, we envision that the most common use case is that practitioners will have to run our methods without observing differences among individuals.\n\nIn our main use case, we purposefully disregard these individual-level differences and seek to find models that restrict access for all individuals. In this setting, we use an action set that consists of \u201cinherent constraints\u201d. For example, in section 5 we collaborated with a domain expert to identify constraints that would apply to all individuals. $A({\\mathbf{x}})$ only includes basic constraints that should adhere to everyone. Thus, when we flag recourse as infeasible using $A(\\mathbf{x})$, then it will imply that recourse is also infeasible under $ A\\_i({\\mathbf{x}})$ since $A({\\mathbf{x}}) \\subset A\\_i({\\mathbf{x}}).$ We use this strategy in our experiments specifically for this reason \u2013 i.e., to show that recourse can be infeasible simply under actionability constraints that are \u201cnot subject to debate.\u201d\n\n[1] Wang, Zijie J, Jennifer Wortman Vaughan, Rich Caruana, and Duen Horng Chau. Gam coach: Towards\ninteractive and user-centered algorithmic recourse. In Proceedings of the 2023 CHI Conference on Human\nFactors in Computing Systems, pages 1\u201320, 2023"
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5341/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700599194224,
                "cdate": 1700599194224,
                "tmdate": 1700601928625,
                "mdate": 1700601928625,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "x5xeBbW8Ku",
                "forum": "SCQfYpdoGE",
                "replyto": "3hs7aeN0Am",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5341/Reviewer_2QxH"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5341/Reviewer_2QxH"
                ],
                "content": {
                    "comment": {
                        "value": "> In cases with only discrete features, the problem can only be cast as a graph-based path-finding problem if we have observed all possible samples. Otherwise, we may be interested in looking for paths to vertices that do not exist.\n\nIt's not necessary to construct the entire graph of all samples; the graph-based implication is just a more intuitive concept. Starting from the initial vertex $x_0$, you iterate through the child nodes that are both valid and within the Reachable set $R(x_0)$. For instance, let's consider the child nodes $x_1$ and $x_2$. If either $x_1$ or $x_2$ represents a recourse, the procedure concludes. If not, the procedure continues with the valid child nodes of $x_1$ and then proceeds to $x_2$. Note that in some cases, you do not need to consider all child nodes, just ones that are confirmed valid.\n\n> In the case that we had observed all possible features, then reachable points would not necessarily be connected. For example, suppose that the reachable set for the p ...\n\nThe graph I am referring to is specifically a directed graph. I'm having difficulty understanding your message."
                    }
                },
                "number": 13,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5341/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700711899784,
                "cdate": 1700711899784,
                "tmdate": 1700711919574,
                "mdate": 1700711919574,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "OYknBUuTcl",
            "forum": "SCQfYpdoGE",
            "replyto": "SCQfYpdoGE",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission5341/Reviewer_jEod"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission5341/Reviewer_jEod"
            ],
            "content": {
                "summary": {
                    "value": "This paper studies recourse verification of machine learning models. Recourse verification is an important aspect of algorithmic recourse, which seeks to identify models that assign predictions without any actionable recourse for the decision subject. Ensuring the existence of actionable recourse is essential in applications affecting people\u2019s lives and livelihoods, such as job hiring, loan approvals, and welfare programs. A model that offers no recourse for its decisions may permanently exclude subjects from accessing these benefits without offering a path to eligibility. Existing research largely focuses on recourse provision \u2014 providing individuals with actionable recourse \u2014 but only a few works study the infeasibility of providing recourse.\n\nThis work proposes an approach for recourse verification under actionability constraints based on reachable sets. A reachable set is a collection of feature vectors that can be reached from a given input using a set of allowed actions. The proposed method certifies the existence or non-existence of recourses by querying the model on every point in the reachable set or an approximation of this set. If the method finds a subset of the reachable set that contains a recourse, it certifies the existence of recourse. Similarly, if it cannot find a recourse in a superset of the reachable set, it certifies the infeasibility of providing recourse. If it cannot certify either of the above, it abstains."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. The paper studies an important problem that has not been explored well in the literature. It makes a significant contribution in this area.\n2. The paper is well-written and easy to follow.\n3. It is claimed that the proposed method does not require any assumption on the prediction model. However, the model might need to satisfy some conditions for the decomposition approach, which is essential when the problem dimensionality is high. See the weaknesses section for more details."
                },
                "weaknesses": {
                    "value": "1. The recourse verification process evaluates every point in the reachable set, which could be time-consuming if the problem dimensionality is high. The paper seeks to address this issue by a decomposition approach that partitions the action set using features that can be altered independently. However, this approach has not been explained well in the paper.\n2. It is unclear how the separable features are identified. What role does the prediction model play in the identification of these features?\n3. It is unclear what conditions the prediction model must satisfy for the features to be separable. For instance, the verification step may return an infeasibility certificate in partitions A_1(x) and A_2(x), but actionable recourses may still exist in the Cartesian product A_1(x) X A_2(x) of the two sets.\n\nMinor comments:\n1. Increasing the font size in Tables 1 and 2 could help improve readability.\n2. It seems like a word is missing in the following sentences:\n    1.  Pg. 1 \u2014 \u201cIn fraud detection and content moderation, for example, models should assign fixed [predictions?] to prevent malicious actors from\u2026\u201d\n    2. Pg. 3 \u2014 \u201cWe can elicit these constraints from users in natural language and convert them to expressions that can [be] embedded into an optimization problem.\u201d\n3. Figure 3 is a bit confusing and could be made clearer. The x-axis has no label. It seems that the size of the reachable set *grows* rapidly under the decomposition approach compared to brute force, which is contrary to the text. If I understand correctly, the purpose of using decomposition is to reduce the number of points to verify."
                },
                "questions": {
                    "value": "1. Could this approach be extended to certify the existence or non-existence of an abundance of recourse options instead of just one? A single recourse option might not be feasible for everybody, and having multiple recourses could provide more options to people. It might be possible to certify statements like \"20% of the actions in the action set would lead to a positive outcome\" by querying a random subset of the action set.\n2. Different actions may have different costs for the subjects. For instance, it might be easier for a loan applicant to increase their credit score than their income. Could we incorporate costs for the actions and certify the existence of a low-cost recourse?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission5341/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission5341/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission5341/Reviewer_jEod"
                    ]
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission5341/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698712059923,
            "cdate": 1698712059923,
            "tmdate": 1700701095512,
            "mdate": 1700701095512,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "H0qf2UbjoT",
                "forum": "SCQfYpdoGE",
                "replyto": "OYknBUuTcl",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5341/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5341/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your time and feedback. We appreciate your suggestions for minor comments and will address them! We would like to help clarify the misunderstandings. \n\n> It is unclear how the separable features are identified. What role does the prediction model play in the identification of these feature?\n\nThere seems to be some kind of misunderstanding that we would like to correct. The prediction model plays no role in determining if features are separable or non-separable. \nSeparable features are defined as features that can be altered independently under a given action set $A(x)$. For example, the features $reapplicant$ and $n\\\\_accounts$ can be altered independently of one another. However, features like $max\\\\_degree\\\\_BS$, $max\\\\_degree\\\\_MS$, $max\\\\_degree\\\\_PHD$ that arise from a one-hot encoding cannot be altered independently. Likewise, features that are tied together in $X$ like if $is\\\\_employed = true$ then $work\\\\_hrs\\\\_per\\\\_week > 0$.  \nIn our case, the action set captures all the relationships described above. Given an action set $A(\\mathbf{x})$, we can easily identify the features that can be altered independently if the actions from one feature $A(x_1)$ do not affect or are not dependent on the actions in $A(x_2)$. Likewise we can find the actions that are non-separable if the actions in $A(x_1)$ rely on other features.  We can express the action set as a  \u201cproduct space\u201d of smaller action sets over the features. We can use this to _generate_ reachable sets for each action set in a way that is far more efficient without sacrificing correctness.\n\n> the verification step may return infeasibility certificate in partitions A_1(x) and A_2(x), but actionable recourses may still exist in the Cartesian product A_1(x) X A_2(x) of the two sets.\n\nThis seems to be a misunderstanding that stems from the previous comment on separability. This cannot happen because our partition is designed to specifically avoid this effect. In particular, we would only consider a partition where we can express the actions as $A(x) = A\\_1(x_1) \\times A\\_2(x_2) \\times A_m(x_m)$ \n\n> Could this approach be extended to certify the existence or non-existence of an abundance of recourse options instead of just one. \nA single recourse option might not be feasible for everybody.\n\nWe thank you for bringing this to our attention! \n\nOur methods can easily be extended to certify the existence or non-existence of multiple options. We can count the number of recourse options in a reachable set as a measure of \u201cabundance.\u201d Given a complete reachable set, we can certify existence or non-existence. Given an interior approximation, we can only certify existence. \nStepping back, we think that the measures are also interesting as a richer measure of feasibility when recourse is feasible - e.g., if there is only 1 point in a reachable set that would lead to recourse, then recourse is brittle and existing methods for recourse provision are unlikely to find it (i.e., high likelihood of blind spot). We will mention this in our manuscript!\n\n> Could we incorporate costs for the actions and certify the existence of a low-cost recourse?\n\nYes this can be done. Here are the steps:\nCompute the reachable set  such that $\\\\{ \\mathbf{x} + \\mathbf{a} \\mid \\mathbf{a} \\in A({\\mathbf{x})} \\text{ and } \\mathbf{a} \\in \\text{cost}(\\mathbf{a};\\mathbf{x}) \\\\}$\nWe can now filter the reachable set $R(\\mathbf{x})$ to only include reachable points such that $\\text{cost}(\\mathbf{x},\\mathbf{x_0}) \u2264 B$ where $B$ represents a budget. Filtering out points after the reachable set has been computed allows us to generate the reachable set once and reuse it to handle different budgets. \nWe do not explore this for two reasons. The first is because costs and budgets are difficult to elicit in a way that most people would agree on. The second, relatedly, is because we would like to flag infeasibility in a way that is not subject to debate. So if a model is precluded access, this is arising because of the oversight of basic actionability constraints rather than because we have elicited the wrong costs or set the wrong budget.\n\n> the purpose of using decomposition is to reduce the number of points to verify\n\nWe want to clarify that the purpose of decomposition is not \u201creduce the number of points to verify.\u201d Rather it is a computationally efficient way to compute the reachable set $R(\\mathbf{x})$. The action set remains the same regardless of decomposition. Figure 3 represents just how efficient decomposition is compared to brute force. In less than 3 seconds decomposition is able to fully compute large reachable sets of 600 points compared to brute force which can only generate 40 points in the same time frame.  \n\n> Minor comments\n\nThank you for catching these. We have uploaded an updated manuscript with these fixes!"
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5341/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700258215460,
                "cdate": 1700258215460,
                "tmdate": 1700258215460,
                "mdate": 1700258215460,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "7xgWuZSDwJ",
                "forum": "SCQfYpdoGE",
                "replyto": "H0qf2UbjoT",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5341/Reviewer_jEod"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5341/Reviewer_jEod"
                ],
                "content": {
                    "title": {
                        "value": "Reviewer Comment"
                    },
                    "comment": {
                        "value": "I would like to thank the authors for their time and effort in responding to my review. The authors have addressed my concerns and explained the parts that were unclear to me. Including those clarifications in the paper might help make it easier to understand.\n\nIn my opinion, this paper studies an important problem and makes a significant contribution towards solving it, which justifies its acceptance. I am happy to revise my recommendation to accept."
                    }
                },
                "number": 12,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5341/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700701180796,
                "cdate": 1700701180796,
                "tmdate": 1700701180796,
                "mdate": 1700701180796,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "lRN5IsB1DH",
            "forum": "SCQfYpdoGE",
            "replyto": "SCQfYpdoGE",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission5341/Reviewer_z4uU"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission5341/Reviewer_z4uU"
            ],
            "content": {
                "summary": {
                    "value": "This work introduces the recourse verification: to verify if the prediction is desirable for any actions over the inputs, which is modeled as a formal verification problem given the trained model and input specifications. The paper gives examples using the proposed reachable sets."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "- The idea of verification seems to be novel in the sense of recourse and the motivation is clear.\n- The formulation is easy to follow."
                },
                "weaknesses": {
                    "value": "- My biggest concern lies in the lack of contribution in the verification methods, which directly follow the basic idea of formal verification but seem not to dive deeper into the optimization algorithms or target the specific challenge in the recourse setting.\n- When introducing reachable sets, more details are expected to be discussed, i.e. continuous or discrete, $\\ell_p$-norm bound ball. The verification seems to be sound but incomplete, and it is expected to be compared to more off-the-shelf reachibility-based verification methods in [1].\n- Although experiments show the prediction without recourse and current methods fail to detect them, there are no other baselines of recourse verification for the comparison of tightness and time efficiency. Also, the experiment part is not well organized in the sense of merging section 4 and 5 as experiments.\n\n[1] Liu, C., Arnon, T., Lazarus, C., Strong, C., Barrett, C., & Kochenderfer, M. J. (2021). Algorithms for verifying deep neural networks. *Foundations and Trends\u00ae in Optimization*, *4*(3-4), 244-404."
                },
                "questions": {
                    "value": "See weakness"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission5341/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission5341/Reviewer_z4uU",
                        "ICLR.cc/2024/Conference/Submission5341/Senior_Area_Chairs"
                    ]
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission5341/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698811758853,
            "cdate": 1698811758853,
            "tmdate": 1700712501310,
            "mdate": 1700712501310,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "Q3qJfcP46E",
                "forum": "SCQfYpdoGE",
                "replyto": "lRN5IsB1DH",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5341/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5341/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your review and feedback! We found a few big misunderstandings in your review that we would like to address! \n\n> When introducing reachable sets, more details are expected to be discussed, i.e., continuous or discrete, \u2113p-norm bound ball. The verification seems to be sound but incomplete, and it is expected to be compared to more off-the-shelf reachability-based verification methods in [1].\n\nThere seems to be a big misunderstanding that we would like to clarify! We are very familiar with the reachability-based methods to verify deep neural networks presented by Liu et al. [1]. One issue is that these algorithms are designed for deep neural networks, so they would not naturally work for complex model classes like RFs and XGB. **The main issue is that these algorithms will fail for \u201crecourse verification\u201d because they cannot verify the stability of predictions under *actionable perturbations.***\n\nIn particular, the algorithms are designed to certify that the prediction of a DNN at $\\mathbf{x}_0$ will not change under perturbations in a smooth and convex set  \u2013 e.g., the set of all perturbations within a $\\ell_p$-Ball. In a recourse verification task, however, we are exclusively interested in certifying that a model\u2019s predictions at $\\mathbf{x}_0$ would not change under the set of actionable perturbations: $\\\\{ \\mathbf{x} = \\mathbf{x}_0 + \\mathbf{a} \\mid \\mathbf{a} \\in A(\\mathbf{x}_0) \\\\}$\n\nThis set of actionable perturbations is neither smooth nor convex. This is because the action set $A(\\mathbf{x}_0)$ is neither smooth nor convex in the vast majority of applications we care about (i.e., classification tasks with semantic feature spaces). For example, $A(\\mathbf{x})$ would require discrete perturbations for binary and integer-valued features like $n\\\\_accounts$. This is also the case for non-separable constraints that we need to enforce actionability over categorical variables like job_type or capture logical relationships like if $is\\\\_employed = \\texttt{TRUE} \\quad \\implies\\quad hrs\\\\_worked\\\\_per\\\\_week > 0$. \n\nWe are happy to include a comparison in a potential revision. However, we do not think that this would be informative since it would show that the methods fail at a task that they need to be designed to handle. In particular, we would expect to obtain a number of loopholes and blindspots using these approaches as we would have to work with a convex relaxation of the perturbation set. \n\n> There are no other baselines of recourse verification for the comparison of tightness and time efficiency.\n\nThis might also be a misunderstanding related to the issue above. This is the first paper to present an actual procedure for recourse verification, so there are no other baselines to compare to. There are also no other off-shelf methods that are designed for recourse verification in this setting \u2013 in part because we are exclusively interested in certifying stability over \u201cactionable\u201d perturbations where the perturbation set is almost always non-smooth and non-convex.\n\nWith this in mind, we did want to provide a detailed account of tightness and time efficiency. We discuss these issues in Section 3. To reiterate, the MIP is solved to optimality within \u226a 1s for the instances we consider in Section 4. In general, the core property that we exploit is that action sets can be decomposed to compute reachable sets. In Figure 3, for example, we can generate the largest reachable set that we would need in $\\leq3$ seconds. Computation and time efficiency are important considerations since they may often present a barrier to adoption. Our results above suggest that these issues should not be a bottleneck in most practical applications. In the event that they are the algorithms have the benefit that they use limited memory and can be easily run in parallel over multiple CPUs. Another key benefit is that we only need to call these procedures once \u2013 as the reachable set that we recover can be used for all possible models\n\n> My biggest concern lies in the lack of contribution in the verification methods, which directly follow the basic idea of formal verification\n\nThank you for mentioning this! Some of this may stem from a lack of familiarity with work on algorithmic recourse. If so, please read our main response above. In short, formal verification is urgently required in this task \u2013 since models can assign fixed predictions that permanently preclude access from credit, employment, or assistance. The task is also challenging from a technical standpoint \u2013 as we must certify the stability predictions of a model over the set of actionable perturbations, which are neither convex nor smooth. This lack of structure makes it a very difficult problem to address, especially in a way that is model-agnostic. In contrast, existing robustness verification methods (e.g. [1]) primarily focus on structured and nice perturbation sets. We discuss these issues in Section 3, but we are happy to make it more prominent if you need."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5341/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700262008853,
                "cdate": 1700262008853,
                "tmdate": 1700262610127,
                "mdate": 1700262610127,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "HIK9OhbB0S",
                "forum": "SCQfYpdoGE",
                "replyto": "Q3qJfcP46E",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5341/Reviewer_z4uU"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5341/Reviewer_z4uU"
                ],
                "content": {
                    "comment": {
                        "value": "Thanks for the clarification. Some of my concerns have been addressed, and so I will raise my score to 5."
                    }
                },
                "number": 14,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5341/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700712468181,
                "cdate": 1700712468181,
                "tmdate": 1700712468181,
                "mdate": 1700712468181,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "m1Umq9nHHF",
            "forum": "SCQfYpdoGE",
            "replyto": "SCQfYpdoGE",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission5341/Reviewer_fbZh"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission5341/Reviewer_fbZh"
            ],
            "content": {
                "summary": {
                    "value": "The authors present a new idea, recourse verification, certifying if a predictive model guarantees actionable items for users to change the prediction outcome. Different from the typical algorithmic recourse problem where the goal is to find actionable items with minimum cost, this work aims at ensuring that users are not mistakenly precluded from recourse. In the paper, the authors first establish fundamental concepts and theorems for this new topic. Afterwards, they propose \"reachable set\" for enumerating plausible feature values after actions. With proper decomposition of feature space as the author propose, feasibility of recourse can be effectively tested. Finally, the authors conduct evaluations on real-world datasets and confirm the efficacy of verification."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1. Recourse verification as a new research topic seems intriguing and impactful. It makes sense that some predictive models can accidentally limit availability of recourse and thereby hinder the fairness. Upon this important issue, the authors establish a good foundation for follow-up research and may also benefit researchers working on the typical algorithmic recourse problems.\n2. The proposed algorithms seem reasonable and the step of implementation is clear. Also, the effectiveness is verified in the experiments.\n3. The writing is overall clear and easy to follow. The details of experiments are provided. The limitations of this work are also adequately discussed."
                },
                "weaknesses": {
                    "value": "Certain parts of the proposed method may still be in early stages of development, which may require further refinement to guarantee its practical value. For example, as discussed in the limitation section, the verification algorithm does not work on continuous features. More concerns of mine are summarized in the Questions section below."
                },
                "questions": {
                    "value": "1. It is unclear how often does the undesired preclusion occur in practice. In particular, continuous features are quite common and may trivially avoid preclusion if the capacity of the predictive model is not constrained. Even if we focus on discrete features only, I am still not sure if undesired preclusion can frequently happen. Let us assume users A and B who pass and got rejected respectively by a predictive model. If we ignore the cost, an easy recourse for A can be the difference between A and B in the feature space. If there are more users getting approved by the model, more candidates of recourse are available for A's actions; namely, it is more unlikely that we find no proper recourse for user A when data size grows. If the diversity of the approved users is so limited that no recourse can be found for user A, I wonder if the preclusion is then more like intended (e.g., setting up strict rules) instead of being an accident.\n2. Following question 1, I am wondering if it is reasonable to adopt the idea of cost constraint in recourse provision to reduce the reachable set? For example, we certify if a model is not \"fixed\" given an upper bound of cost.\n3. How do we check the quality of a recourse verification algorithm? Specifically, if we employ two recourse verification methods and get inconsistent results, how do we decide which one is better?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission5341/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission5341/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission5341/Reviewer_fbZh"
                    ]
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission5341/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698815288943,
            "cdate": 1698815288943,
            "tmdate": 1699636536844,
            "mdate": 1699636536844,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "0zAY2kG7ds",
                "forum": "SCQfYpdoGE",
                "replyto": "m1Umq9nHHF",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5341/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5341/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "> It is unclear how often does the undesired preclusion occur in practice. In particular, continuous features are quite common and may trivially avoid preclusion if the capacity of the predictive model is not constrained\u2026. If the diversity of the approved users is so limited that no recourse can be found for user A\n\nWe think there may be a big misunderstanding, and we\u2019d like to get to the bottom of it. To make things easier, let\u2019s consider an extreme version of your setting. Say we have a classifier $f$ that approves *one* user with features $\\mathbf{x}_\\textrm{app}$ and rejects all other users with features $\\mathbf{x}_i \\neq \\mathbf{x}\\_{app}$ . Formally, we have:\n\n\\begin{align} \nf(x) = 1 \\text{ for all } \\mathbf{x} = \\mathbf{x}\\_\\textrm{app} \\\\\\\\\nf(x) = -1 \\text{ for all } \\mathbf{x} \\neq \\mathbf{x}\\_\\textrm{app}\n\\end{align}\n\nGiven a person with features $\\mathbf{x}\\_i$, let us define the change they need to reach features $\\mathbf{x}\\_\\textrm{app}$ as $\\mathbf{a}\\_i = \\mathbf{x}\\_\\textrm{app} - \\mathbf{x}\\_i$. Your review seems to suggest that we would claim that person $i$ does not have recourse when $\\mathbf{a}\\_i  \\notin A(\\mathbf{x}\\_i).$ To be clear, this is not the case. When $\\mathbf{a}\\_i \\notin A(\\mathbf{x}\\_i)$, this only means that person $i$ cannot reach $\\mathbf{x}_\\textrm{app}$. However, we would not claim \u201cpreclusion\u201d because there may be many other points that person $i$ could reach that lead to approval. \n\nThis is because we search over all possible changes that a user can perform - not simply the changes to reach users that are approved.\n\nOur methods are designed to handle this search because we search for all possible actions that a person could perform over the feature space (i.e., rather than only the features of users in, e.g., a training dataset). **Thus, the \u201cdiversity of users\u201d in a dataset will not influence a claim of preclusion.**\nWhen the feature set is discrete, we can search over all points in the discrete exhaustively, and thus claim that a person $i$ has recourse or does not have recourse. \nWhen the feature set is continuous, we can only claim that a person has recourse. If we cannot find a point for which a person has recourse, then we claim that we do not know.\n\n> Following question 1, I am wondering if it is reasonable to adopt the idea of cost constraint in recourse provision to reduce the reachable set? For example, we certify if a model is not \"fixed\" given an upper bound of cost.\n\nYes this can be done. Here are the steps:\nCompute the reachable set  such that $\\\\{ \\mathbf{x} + \\mathbf{a} \\mid \\mathbf{a} \\in A({\\mathbf{x})} \\text{ and } \\mathbf{a} \\in \\text{cost}(\\mathbf{a};\\mathbf{x}) \\\\}$\nWe can now filter the reachable set $R(\\mathbf{x})$ to only include reachable points such that $\\text{cost}(\\mathbf{x},\\mathbf{x_0}) \u2264 B$ where $B$ represents a budget. Filtering out points after the reachable set has been computed allows us to generate the reachable set once and reuse it to handle different budgets. \n\n\nWe do not explore this for two reasons. The first is because costs and budgets are difficult to elicit in a way that most people would agree on. The second, relatedly, is because we would like to flag infeasibility in a way that is not subject to debate. So if a model is precluded access, this is arising because of the oversight of basic actionability constraints rather than because we have elicited the wrong costs or set the wrong budget.\n\n\n> How do we check the quality of a recourse verification algorithm? Specifically, if we employ two recourse verification methods and get inconsistent results, how do we decide which one is better?\n\nWe should not get \u201cinconsistent\u201d results. Say that we have two different methods for recourse verification $Recourse_A({\\mathbf{x}},{f},{R})$ and $Recourse_B({\\mathbf{x}},{f},{R})$\n\nHere, each method $Recourse_A$ and $Recourse_B$ takes as input a model $f$, a point $x$ and a reachable set $R(x)$. Given these methods, it would output a claim of \u201chas recourse\u201d, \u201cno recourse\u201d, or \u201cI don\u2019t know.\u201d\n\nIn this case, the results should be consistent in that we should never have one method claim \u201crecourse\u201d and another method \u201cno recourse.\u201d\n\nWe can have a situation where $Recourse_A$ or $Recourse_B$ claims \u201cI don\u2019t know\u201d while another claims \u201crecourse\u201d or \u201cno recourse\u201d:\n\nBased on this, methods for recourse verification can only differ in terms of their abstention rate. Ideally, we would like for methods to avoid abstaining. In applications like credit scoring, we would like to have a low \u201cabstention rate\u201d on the points that do not have recourse. This is because we would like to flag models that can detect preclusion."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5341/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700258372861,
                "cdate": 1700258372861,
                "tmdate": 1700258372861,
                "mdate": 1700258372861,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "jL8tPgPWoV",
                "forum": "SCQfYpdoGE",
                "replyto": "m1Umq9nHHF",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5341/Reviewer_fbZh"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5341/Reviewer_fbZh"
                ],
                "content": {
                    "comment": {
                        "value": "I thank the authors for the thorough response. The response addresses my concerns, particularly regarding Question 1. After evaluating this work again, we decide to keep my score and vote for accept. As previously commented, this work has some limitations (e.g. issues on continuous features) as acknowledged by the authors, while the idea of verification seems promising and potentially impactful. I also think the authors have established a solid foundation for this new topic, which can benefit researchers engaged in this area."
                    }
                },
                "number": 11,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5341/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700659495155,
                "cdate": 1700659495155,
                "tmdate": 1700659582369,
                "mdate": 1700659582369,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]