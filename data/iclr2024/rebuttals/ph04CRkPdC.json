[
    {
        "title": "Think before you speak: Training Language Models With Pause Tokens"
    },
    {
        "review": {
            "id": "xne17xImrv",
            "forum": "ph04CRkPdC",
            "replyto": "ph04CRkPdC",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6107/Reviewer_cnas"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6107/Reviewer_cnas"
            ],
            "content": {
                "summary": {
                    "value": "This paper presents a method to inject pause tokens into language models during pretraining and fine-tuning, such that the language model can spend more tokens/compute before outputting the final answer. Specifically, pause tokens are randomly injected into sequence during pretraining and appended to questions during fine-tuning. Extensive experiments on several datasets demonstrate the robust gain induced by this method."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "- The paper is well written and easy to follow.\n- The method is novel and interesting.\n- The experiments are extensive and demonstrate clear gains."
                },
                "weaknesses": {
                    "value": "- It seems mysterious and problematic that sometimes more pause tokens can lead to worse performance."
                },
                "questions": {
                    "value": "- How does one randomly inject pause token during pretraining? Could there be more than one pause token in a row during pretraining? Is there an upperbound on how many pause tokens can be in a row?\n- Have you tried to prompt LLM with filler words that typically represent pause or thinking? Like \"let me think a bit ....\" etc?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6107/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698643025177,
            "cdate": 1698643025177,
            "tmdate": 1699636659767,
            "mdate": 1699636659767,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "uJoAxEeOk6",
                "forum": "ph04CRkPdC",
                "replyto": "xne17xImrv",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6107/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6107/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Thank you! Our response:"
                    },
                    "comment": {
                        "value": "We thank the reviewer for their time and positive feedback. We are happy to note that the reviewer found our work \u201cnovel and interesting\u201d and appreciates the \u201cextensive experiments and clear gains\u201d. Below we address the concerns they raised.\n\n> It seems mysterious and problematic that sometimes more pause tokens can lead to worse performance.\n\nThis is an interesting question, **but we believe that this is not mysterious if we view it from the fundamental lens of _overfitting_.** Recall that if a model is inundated with a lot of features, it can fail to generalize well as it is unable to pick up on the general patterns in those features. In our case, if we look at each intermediate vector input to some hidden layer as a feature, when we add $p$ pause tokens, we add $p$ new features. When we add an excessive number of pause tokens, the subsequent layer may suffer from overfitting. Of course, the value of $p$ for which overfitting starts to happen, must vary from task to task, depending on the task\u2019s complexity. \n\n> How are pause tokens injected during pretraining \n\nWe add pause tokens at uniformly randomly selected positions in input sequences. We then  trim the appended sequence back to the original length. We do this so as to have a fair comparison with standard pretraining without pause tokens: this way, we preserve the same computational cost during pretraining. \n\n> Could there be more than one pause token in a row during pretraining? Is there an upperbound on how many pause tokens can be in a row?\n\nYes, there can be some cases  where many pause tokens come in a row. In fact, it is an interesting direction for future work to come up with better ways of adding pause tokens during pretraining, as the consecutive pause tokens can be more helpful. This is because at inference, we do add a consecutive chunk of pause tokens at the end of prompt. \n\n> Have you tried to prompt LLM with filler words that typically represent pause or thinking?\nWhat we tried was appending periods (\u201c.\u201d) as the pause tokens, as discussed in Section 4.3. We doubt that even prompting with words like \u201clet me think a bit\u201d will allow the model to leverage additional computational pathways within the transformer, as our work clearly shows that one needs to pretrain the model accordingly for the same. \n\nThanks again for your time and for your feedback!"
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6107/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700624465015,
                "cdate": 1700624465015,
                "tmdate": 1700624465015,
                "mdate": 1700624465015,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "EzSk3bscms",
                "forum": "ph04CRkPdC",
                "replyto": "uJoAxEeOk6",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6107/Reviewer_cnas"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6107/Reviewer_cnas"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for the response. I will maintain the current score."
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6107/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700673504991,
                "cdate": 1700673504991,
                "tmdate": 1700673504991,
                "mdate": 1700673504991,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "3KelV0MmaE",
            "forum": "ph04CRkPdC",
            "replyto": "ph04CRkPdC",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6107/Reviewer_zLe3"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6107/Reviewer_zLe3"
            ],
            "content": {
                "summary": {
                    "value": "The paper presents and analyzes Pause Training - a technique for training transformer language models while inserting virtual \"pause\" tokens between real tokens. The model is then trained normally, except that the training loss does not apply to predictions at pause tokens, essentially letting the model do whatever it wants as long as it predicts the next true token correctly. The intent behind pause training is to let the model do additional computation (\"thinking\") before predicting the next real token. Authors consider several scenarios where pause tokens are introduced during pretraining or finetuning, for a range of 130M-1B model sizes, and evaluate several alternatives such as introducing extra real tokens (e.g. dots). Overall, authors observe the greatest gains from pause training when it is introduced at both pretraining  and finetuning stage, and find significantly smaller effect for finetuning only. The paper reports several additional experiments, including an ablation analysis of how many pause tokens are needed. Finally, authors draw several parallels to modern prompting and PEFT methods such as chain of thought and prompt tuning."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "4 excellent"
                },
                "contribution": {
                    "value": "1 poor"
                },
                "strengths": {
                    "value": "1. The paper presents a comprehensive experimental analysis of a (relatively simple) phenomena. Authors consider multiple downstream tasks, multiple model sizes, and tries several baselines. Overall, I believe that the quality of experiments is one of the stronger sides of this paper.\n\n2. The paper focuses on a very simple algorithm, meaning that it can be easily implemented in most frameworks and libraries.\n\n3. The paper is generally well written , both conceptual explanations and experiments were easy to follow. Discussions and parallels drawn were interesting to read."
                },
                "weaknesses": {
                    "value": "My main problem with the paper is that it ignores several very similar works from the early years of Transformer.\n\nProbably the closest idea to pause tokens is adaptive computation time (ACT) [1]. ACT was originally proposed for recurrent neural networks with the exact same motivation: to let the model \"think\" before generating a difficult token. The idea of ACT translates easily to Transformers, and many subsequent works in the last 7 years (e.g. [2,3]) use ACT for various transformer types, in both sequence and depth dimensions. If authors choose to also overview ACT in related work (and I encourage them to), please note that there are *many* more studies on adaptive computation time and I only referenced a few of them from the top of my head. Furthermore, unlike Pause Tokens, ACT offers a way of teaching model to automatically decide how many extra turns it needs to solve a problem.\n\nWith that in mind, I believe that a proper analysis of Pause Training should at least compare it to a temporal (regular) ACT for the same model with equivalent tuning budget.\n\n* [1] https://arxiv.org/abs/1603.08983\n* [2] https://arxiv.org/abs/1807.03819\n* [3] https://arxiv.org/abs/2109.11745\n\nAnother related (but less similar) study is [4], that introduces additional learnable tokens for attention layers. The paper itself uses attention-only architecture, while subsequent works use the same idea for regular transformers, including a notable implementation[5]. To the best of my understanding, [4] proposes a mathematically similar idea that is likely to have similar effects to pause training, therefore there is no reason it shouldn't be a baseline for comparison. Additionally, [6-7] (and others) also propose to augment language models with attention to additional virtual tokens to improve language model quality. These other works pursue different goals from this paper, but, to the best of my knowledge, they are no less related than PEFT methods discussed on page 9.\n\n* [4] https://arxiv.org/abs/1907.01470\n* [5] https://github.com/lucidrains/x-transformers#augmenting-self-attention-with-persistent-memory\n* [6] https://arxiv.org/abs/1911.00172\n* [7] https://arxiv.org/abs/1612.04426\n\n\nOverall, I believe that the paper presents an interesting idea which could offer a simpler and more efficient alternative to ACT-related methods, but it could also be inferior to them, and there is no way of knowing that from the experiments in the submitted draft. I would recommend authors to consider adressing the following questions for revised version of the paper:\n- how does PT compare to ACT variants in terms of quality?\n- how does PT compare to learned extra tokens (e.g. [4])?\n- which approach is better at deciding where to put extra tokens?\n- for modern language models, PT appears more efficient than a reasonably optimized ACT. How much faster is it in terms of training speed?\n- which method is better for very few vs very many pause tokens?\n(and similar)\n\nUnfortunately, in the current form, I believe that answering those questions would require authors to reformulate too much of the paper content and message, and therefore neccesitate a full additional review. Therefore, I currently recommend rejection, but I encourage authors to resubmit a revised version once they can properly analyze how PT compares to earlier methods.\nThere are two circumstances in which I could raise the score within this review cycle:\n\n1. authors prove that I misunderstood a significant chunk of the paper content and it is NOT in fact related to ACT family & others\n2. authors prove that all of those questions can be answered trivially, without running many additional experiments or changing much of the paper"
                },
                "questions": {
                    "value": "On page 7, authors found that the optimal number of pause tokens depends on the specific task, e.g. GSM8k or SQuAD. Did you try to train the model to dynamically decide the number of pause tokens? Essentially, allowing model to predict  pause tokens at a certain penalty (like ACT) or spread a certain fixed budget of pause tokens between different positions (like CTC traning)?\nThe reason I'm asking is that, since the baselines are able to do the same thing, it would be curious to check which approach (PT or ACT or CTC) is better at deciding where to put the pause tokens.\n\n\n\nMinor typo: authors use SquAD as a dataset name. To the best of my knowledge, the original paper[8] refers to this dataset as SQuAD, with uppercase Q.\n\n[8] https://arxiv.org/abs/1606.05250"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6107/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698839686820,
            "cdate": 1698839686820,
            "tmdate": 1699636659666,
            "mdate": 1699636659666,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "TWmbSVkQgF",
                "forum": "ph04CRkPdC",
                "replyto": "3KelV0MmaE",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6107/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6107/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Thank you for missing references. We explain why these are completely orthogonal. (Part 1)"
                    },
                    "comment": {
                        "value": "We thank the reviewer for their time and providing detailed feedback. The reviewer appreciated the \u201csimplicity of our algorithm\u201d and \u201ccomprehensive results\u201d and raised some valid concerns about missing related work, which we address below. \n\n> My main problem with the paper is that it ignores several very similar works from the early years of Transformer.\n\nThank you for pointing us to these lines of works, which we have now cited (Appendix K), along with a few other papers as well, which we had indeed missed in our original version. **However, we would like to strongly emphasize why our work is orthogonal to (and complements) adaptive compute approaches, and why it is unreasonable to compare against them as baselines:** \n\n## Comparison with Adaptive Computation Time (ACT): \n\n1.  **Ours is an extremely simple change that appends the same number of dummy tokens to all inputs, without adapting to the input or cleverly selecting any positions.** (during pre-training we randomly insert these tokens). In contrast, ACT [3][4][5] and related methods enjoy heavily-perfected adaptive machinery such as trained gating, halting, probing and routing mechanisms that allow them to adaptively allocate compute based on the input (and the model\u2019s confidence etc.,). **Our current exploration is not concerned with such complex input-adaptiveness in any way.** The core question we ask is a much simpler one as you note \u2014 does appending dummy tokens even do anything? \u2014 for which we surprisingly find positive evidence. This, we believe is a significant novel finding in its own right. While we analyzed some basic varying of inference-time compute (Section 5.2) for the sake of ablations, we note that these again are done independent of the input i.e., we report accuracy, appending the same $p$ tokens to all inputs, and vary $p$ universally). \n\n**If** one compelled us to view this as comparable to adaptive compute techniques, we still argue that this is orthogonal and if at all, complementary: \n\n2. A hypothetical pause-token-based adaptive compute technique would fall under a completely different paradigm of flexible compute (by varying input-length), rather than varying depth or model-size (which is used in cascades [6] or early-exit models, including DACT-BERT[4] and the Universal Transformer [3] you pointed us to). Importantly, increasing the input-length increases the computational width of the Transformer (i.e., the number of parallel operations) which is orthogonal to increasing the computational depth via parameter count or recurrent layers. **We formalize the benefits of expanding the computational width in the now-added Appendix J, where we show that there are tasks that benefit from this, but cannot benefit from depth-expansion in existing ACT.** Consider for example, computing $f(v_1, v_2, ... v_{50} ) = (v_1+v_{32}) \\cdot (v_3 + v_{44}) ... (v_{27}+v_{2})$ where $f$ involves say  $1000$ many parallel addition operations \u2014 here, under some natural conditions, repeating sequential operation like in Universal Transformers would be of no use, while adding pause tokens would help implement many of these parallel operations! \n\n3. On that note, adding recurrent layers like in Universal Transformers, would add much more to the wall-clock time during inference (owing to the extra sequential computations) compared to pause tokens (which only add pause-token-specific computations in parallel to existing computations).  \n\n4. To further appreciate why adaptive compute techniques are orthogonal to ours, observe that our technique can be directly combined with existing techniques like cascades, early-exits etc., i.e., one may increase/decrease the number of pause tokens, and decide to exit from a lower/higher layer. \n\n5. Besides, it is worth noting that even within the ACT literature, cascade approaches and early-exit approaches treat each other as different paradigms, and do not typically compare against each other as baselines. \n\nTo reiterate, regardless of our technical points 2, 3, 4 and 5 above, we believe that solely for point 1, our contributions should not be treated as comparable to adaptive compute time (ACT), nor do we claim to provide a competitive ACT-esque approach. **What our work explores is a fundamental question about a simple change to the Transformer.**  We agree that ACT is an important line of work that needs to be cited and discussed (Appendix K). **Unfortunately, we believe it is too reductive to reject our paper on the basis that we do not compare numbers with ACT algorithms that enjoy specialized machinery and are tangentially related.**"
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6107/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700624599227,
                "cdate": 1700624599227,
                "tmdate": 1700625881904,
                "mdate": 1700625881904,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "iRHlVK92rr",
                "forum": "ph04CRkPdC",
                "replyto": "3KelV0MmaE",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6107/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6107/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Thank you for missing references. We explain why these are completely orthogonal. (Part 2)"
                    },
                    "comment": {
                        "value": "## Comparison with Memory tokens\n\nAgain, we are grateful for these excellent pointers. We had unfortunately missed this, but we have fixed this now (see Appendix K, where we have also added more works outside of your review). \n\n**We explain why the related Transformer works, which may appear superficially similar, are orthogonal to us.** Conceptually, ideas like Persistent Memory [7], RNN-cache [8] and kNN-LM [9] rely on introducing \u201cglobal information\u201d into the model. This:\n\n - introduces significant number of new token parameters (e.g., the Persistent Memory tokens require 1024 global vectors in each layer, so roughly O(10M) new parameters).\n\n - These vectors act only as keys and values, but not as queries. \n\n - These vectors do not depend on the inputs.\n\n\nIn contrast, pause tokens can be thought of as providing \u201clocal\u201d information to the model by:\n\n- Introducing virtually no parameters besides a handful of parameters for the *single* pause token, (precisely 1 new vector, so O(1k) parameters)\n\n- Which subsequently generate intermediate vectors that act as keys, values **and queries** \n\n- And due to the above important difference, the new intermediate vectors depend on the input.\n\n===\n\n## Other questions: \n\n**Determining the number of pause tokens**: We determined the number of pause tokens by simply choosing between 10 or 50. We believe there is value in making the first step in the \u201cpause tokens\u201d direction simple so we can be confident that this core idea itself is promising. \nComplementing this with more sophisticated ACT-type techniques is an important direction for future work!\n\n## Conclusion\n\nIn summary, we completely agree with you that there are important related lines of work which we should have cited (and which we now have, please see Appendix K. We will reorganize the main paper to prominently include this discussion in future versions.). \n\n**We believe our work can complement and inspire new ACT approaches in the future. However, we hope you agree that reducing this paper to a new ACT-like approach [that should compete with other ACT approaches], and rejecting it on those grounds, is not well-warranted. We are afraid this characterization is unfortunately not accurate (as our approach does not claim to be, nor is as sophisticated as, an ACT approach) and unfortunately too reductive (as it ignores the value in our fundamental finding that adding a simple change can be helpful). We sincerely hope you will reconsider your score for our work in light of this discussion, and we once again thank you for pointing these important lines of work to us which we've now discussed in detail in the paper.**\n\n\n[1] Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Brian Ichter, Fei Xia, Ed H. Chi, Quoc V. Le, and Denny Zhou. Chain-of-thought prompting elicits reasoning in large language models. In NeurIPS, 2022.  \n[2] Maxwell Nye, Anders Johan Andreassen, Guy Gur-Ari, Henryk Michalewski, Jacob Austin, David Bieber, David Dohan, Aitor Lewkowycz, Maarten Bosma, David Luan, Charles Sutton, and Augustus Odena. Show your work: Scratchpads for intermediate computation with language models, 2021.     \n[3] Mostafa Dehghani, Stephan Gouws, Oriol Vinyals, Jakob Uszkoreit, and \u0141ukasz Kaiser.  Universal transformers, 2019.     \n[4] Cristobal Eyzaguirre, Felipe del Rio, Vladimir Araujo, and Alvaro Soto. Dact-bert: Differentiable adaptive computation time for an efficient bert inference, 2021.      \n[5] Alex Graves. Adaptive computation time for recurrent neural networks, 2017.   \n[6] Wittawat Jitkrittum, Neha Gupta, Aditya Krishna Menon, Harikrishna Narasimhan, Ankit Singh Rawat, and Sanjiv Kumar. When does confidence-based cascade deferral suffice?, 2023.  \n[7] Sainbayar Sukhbaatar, Edouard Grave, Guillaume Lample, Herve Jegou, and Armand Joulin. Augmenting self-attention with persistent memory, 2019.  \n[8] Edouard Grave, Armand Joulin, and Nicolas Usunier. Improving neural language models with a continuous cache, 2016.  \n[9] Urvashi Khandelwal, Omer Levy, Dan Jurafsky, Luke Zettlemoyer, and Mike Lewis. Generalization through memorization: Nearest neighbor language models, 2020."
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6107/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700625076977,
                "cdate": 1700625076977,
                "tmdate": 1700680417436,
                "mdate": 1700680417436,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "wml6FzLMiq",
            "forum": "ph04CRkPdC",
            "replyto": "ph04CRkPdC",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6107/Reviewer_orpq"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6107/Reviewer_orpq"
            ],
            "content": {
                "summary": {
                    "value": "This paper introduces an approach to the training and inference of language models by incorporating a concept of learnable \"pause tokens.\" Language models generate responses token-by-token, where each subsequent token is influenced by the preceding ones. However, this research explores the impact of allowing the model to manipulate more hidden vectors by adding a sequence of learnable \"pause\" tokens to the input prefix before outputting the answer. The key idea is to allow the model extra computation time before committing to an answer. Experiments were conducted on models with different parameters and various tasks, which suggest that incorporating delays during inference time shows gains when the model is pre-trained and fine-tuned with these delays. Notably, significant gains were observed in tasks like question-answering on the SQuAD dataset, CommonSenseQA, and reasoning tasks."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1. This paper offers an intriguing exploration into the behavior of language models by increasing computation at the level of hidden states, rather than at the text level, like Chain-of-Thought. It presents the concept of the language model \"thinking\" through the generation of intermediate hidden states. \n2. The introduction of a \"pause token\" is a novel approach that enables this deeper computational process to enhance the model\u2019s performance on various tasks. There are a few useful observations. One is that pause tokens are necessary for both pre-training and fine-tuning stages. \n3. The comprehensive experimentation involving various models and tasks contributes to the robustness of the paper. A strong aspect of the paper is its detailed ablation studies, which effectively dissect the influence of the \"pause\" token, thereby providing valuable insights into delayed next-token prediction."
                },
                "weaknesses": {
                    "value": "1. Regardless of the empirical gains, we need more theoretical insights into why and how \"pause tokens\" work during pre-training and fine-tuning. There is not enough motivation behind this trick. We need to understand why we need to \"delay a model's answer generation.\" There are a few intuitions, but are not well-articulated and convincing enough. The reason to answer this question is necessary because the community can benefit if the pause tokens are so important to replace normal autoregressive LLMs. \n2. Adding the \"pause token\" brings new challenges and headaches. A limitation of the \"pause token\" approach lies in its necessity to be integrated into both the pre-training and fine-tuning phases, potentially hindering its broader applicability. The introduction of the \"pause\" token consumes a significant portion of the model\u2019s input window space\u2014approximately 10% of the sequence length\u2014resulting in a loss of some training data information. Additionally, the number of \"pause\" tokens acts as a hyperparameter, exerting a considerable influence on task performance. This number is not consistent but varies across different tasks, adding a layer of complexity and variability to the model's application and performance.\n3. The introduction of pause tokens undoubtedly adds a computational overhead to the training and inference processes. The paper could benefit from a more detailed analysis of this trade-off, especially in terms of computational resources and time. Assessing the scalability of this approach in larger models or in resource-constrained environments would be beneficial. Providing benchmarks on computational costs and suggesting ways to optimize this aspect could enhance the practicality of the approach."
                },
                "questions": {
                    "value": "1. How do you determine the number of \u201cpause\u201d tokens?\n2. How is the generalization ability of \u201cpause\u201d tokens, for example, pretraining with \u201cpause\u201d tokens and inference on tasks without fine-tuning? Are these tokens tasks specific?\n3. The title doesn't convey any meaningful information, \"Think before you speak\" is too casual and just for eye-catching, and \"Pause tokens\" are not obviously justified in the title."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission6107/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission6107/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission6107/Reviewer_orpq"
                    ]
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6107/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698946895111,
            "cdate": 1698946895111,
            "tmdate": 1699636659562,
            "mdate": 1699636659562,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "iyvLIfPSJi",
                "forum": "ph04CRkPdC",
                "replyto": "wml6FzLMiq",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6107/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6107/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Added formal theoretical intuition and formal compute-efficiency analysis"
                    },
                    "comment": {
                        "value": "Thank you for your well-articulated and precise criticisms of the paper. We have made significant additions to the paper based on your criticism as explained below.\n\n## Theoretical intuition behind Pause tokens (added in Section J)\n>  There is not enough motivation behind this trick. We need to understand why we need to \"delay a model's answer generation.\" There are a few intuitions but are not well-articulated and convincing enough.\n\nWe completely agree with the concern that the intuition was originally fuzzy. To address this, **we have now added a rigorous and formal analysis of when and why pause tokens can help \u2013 please see Appendix J, leading to Theorem J.1.** To summarize for your convenience, we make two formal insights:\n\n1. We formally show that pause tokens are helpful in problems that require a number of parallel operations that are much larger than the number of input tokens. For example, assume the model is given as input a sequence of $L$ numbers $v_1, v_2, ... v_L$, and it must compute a polynomial $(v_1 + v_2) \\cdot (v_3 + v_1) ... (v_4 + v_8)$, that involves $N$ parallel additions, where $N \\gg L$. A standard transformer can only implement $L$ operations in parallel, while appending pause tokens can allow implementing all $N$ operations.\nWe argue that a similar case can arise in natural language settings e.g., consider an evidence-based multiple-choice question task with $C$ choices and $E$ pieces of evidence. Solving this would require $C \\cdot E$ operations that individually corroborate each choice against each piece of evidence. But $C \\cdot E$ scales much higher than the input sequence length which would scale as $O(C + E)$. \n\n2. As another key insight, we argue that the self-attention/feedforward module has an \u201cuntapped\u201d representational capacity that grows with its parameter count, say K. Importantly, this quantity is independent of the input length L. While standard inference only allows this module to realize L different operations, appending O(K) pause tokens can help realize as many K different operations.\n\n## Challenges with Pause Tokens \n\n> Need to incorporate pause tokens during pretraining: \n\nWhile we agree that this is a hindrance, **this is in fact the key discovery of our exploratory paper which was hitherto unknown**. Further, some recent papers like [1] also argue that post hoc learning of chain-of-thought style reasoning may not work very well if only introduced in a post-hoc manner, as the default next token prediction pretraining objective (without learning to rely on the reasoning during training) does not model the same. \n\n> Pause tokens consume model\u2019s input window space: \n\nThere appears to be a misunderstanding here: we deliberately fixed the window length same as standard training for the sake of fairness of computational costs for both models. In fact, this indeed further highlights another interesting aspect about pause training \u2013 it is able to outperform standard training even while being at a disadvantage due to less number of \u201creal\u201d tokens seen!\n\n\n> Number of pause tokens as the hyper-parameter: \n\nWe agree that this hyperparameter can be a nuisance.  However, we note that this was varied (and that too, over a grid of two values!) only in the downstream finetuning, and not during pre-training.\n\n[1] Merrill, W., & Sabharwal, A. (2023). The Expressive Power of Transformers with Chain of Thought. ArXiv, abs/2310.07923."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6107/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700623681541,
                "cdate": 1700623681541,
                "tmdate": 1700625730138,
                "mdate": 1700625730138,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "NJyzx1Ev9r",
                "forum": "ph04CRkPdC",
                "replyto": "wml6FzLMiq",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6107/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6107/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Added formal theoretical intuition and formal compute-efficiency analysis (part 2)"
                    },
                    "comment": {
                        "value": "## Assessing computational costs  (added in Section I)\n> adds a computational overhead to the training and inference processes\u2026 The paper could benefit from a more detailed analysis of this trade-off,\n\nYou have raised some important practically-relevant questions regarding the compute-efficiency of pause-inference. **We have conducted an extensive analytical study of this in Appendix I (and Theorem I.3 and Theorem 1.4) in terms of FLOPS-efficiency and wall-clock-compute-efficiency.**  For your convenience, here are our main takeaways: \n\n- **Pause tokens are FLOPS-efficient compared to increasing parameter count:** If we were to add 10 pause tokens to our 1B model, how many extra FLOPS does it consume? Subsequently, if we allocate the same extra FLOPS budget to other ways of increasing the number of attention operations, how much accuracy gains would we see? Specifically, we consider (a) adding layers and (b) adding attention heads as ways to increase the number of attention operations. We find that for our architecture, adding 10 pause tokens at inference, over an initial prompt of length 100 tokens, becomes equivalent to (a) adding 2 layers (on top of 24 pre-existing layers) or (b) adding 3 attention heads per layer (in addition to 32 pre-existing heads). Both these approaches increase the parameter counts from 1B to (a) 1.1B and (b) 1.048B respectively, which is a modest increase in parameter count that cannot promise the gains we see in our 1B model with pause tokens. \n\n- **Pause tokens do not add extra serial compute:** Pause tokens are consumed in parallel with the prefix, with minimal wall-clock overhead. However, adding layers increases wall-clock time linearly with the number of layers. Similarly, other techniques like CoT introduce significant wall-clock overhead since they involve auto-regressively decoding each intermediate token (a wall-clock time of $pl$, where $p$ is the number of tokens and $l$ is the number of layers).\n\n===\n\n## Other questions\n> How do you determine the number of \u201cpause\u201d tokens?\n\n**This is a practically important question! In our current** exploratory work, we wanted to analyze the benefits of a simple no-frills approach of appending dummy tokens. Here, we simply choose between appending 10 or 50 tokens in the downstream task.   However, in the future, we could leverage the progress in the fields of adaptive computation and utilize some kind of confidence measure or gating units to introduce a variable number of pause tokens per input. Please note that we do not claim to propose any adaptive compute methods in the current submission. \n\n> How is the generalization ability of \u201cpause\u201d tokens, for example, pretraining with \u201cpause\u201d tokens and inference on tasks without fine-tuning? Are these tokens tasks specific?\n\n**To answer your question, we have added \u201czero shot evaluation\u201d results in Appendix D**, where we do not finetune the model on the downstream task, and thus the pause tokens are untouched pretraining. Here, we compare the standard and the pause pretrained model (with 0, 10 and 50 pauses at inference). While on most of our tasks, our zero-shot values of both models are too low to be meaningful, we do observe that on datasets like GSM8k (mathematical reasoning) and PhysicalIQA (general understanding), pause tokens give some gains. We believe this provides preliminary evidence that these tokens are generalizable. Future work can help in improving this generalizability. \n\n\n> The title doesn't convey any meaningful information, \"Think before you speak\" is too casual and just for eye-catching, and \"Pause tokens\" are not obviously justified in the title.\n\nWe will certainly rework the title in future versions. \n\n## Conclusion \n\nWe again thank the reviewer for their thoughtful and valid criticisms about the lack of (a) intuition and (b) compute efficiency analysis of pause tokens. **We believe that our updated paper and experiments fill these important gaps with key insights. We sincerely hope that you are able to re-assess this paper in light of these results in favor of acceptance.**"
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6107/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700623963574,
                "cdate": 1700623963574,
                "tmdate": 1700625741231,
                "mdate": 1700625741231,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "ObpCr3lUcj",
            "forum": "ph04CRkPdC",
            "replyto": "ph04CRkPdC",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6107/Reviewer_SV1s"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6107/Reviewer_SV1s"
            ],
            "content": {
                "summary": {
                    "value": "This paper shows that pretraining and tuning are necessary for consistent gains with pause tokens, which give transformers the ability to slightly decouple the amount of FLOPs from the number of tokens. The method inserts pause tokens at random positions during pretraining, and appends $M_{ft}$ and $M_{inf}$ pause tokens at fine-tuning and inference.\n\nExperiments show that pause tokens improve performance for a variety of tasks.\nAblations show that, surprisingly, more pause tokens is not always better."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "The paper successfully gets pause tokens working, which were previously thought not to work. The writing and presentation are clear, as are the experiments and results."
                },
                "weaknesses": {
                    "value": "The paper is convincing and demonstrates some gains can be found via pause-token training. One weakness is that the method does not compare directly to Chain of Thought (CoT).\n\nIn contrast to pause tokens, which require both pretraining and fine-tuning, CoT is an inference-time only method that potentially requires extra human annotations. Another difference is that CoT has the ability to perform variable-length computation, as opposed to the fixed number of pause tokens added at inference time."
                },
                "questions": {
                    "value": "Typos\n1. Section 3.1: tokenresiding, the this\n2. 4.3: standard-pretraing\n\nComments\n1. A recent paper [1], that shows that extra scratch space improves the computational power of transformers, could help motivate this paper.\n\n[1] Merrill, W., & Sabharwal, A. (2023). The Expressive Power of Transformers with Chain of Thought. ArXiv, abs/2310.07923."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6107/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699424951275,
            "cdate": 1699424951275,
            "tmdate": 1699636659461,
            "mdate": 1699636659461,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "bgmlt9HuRZ",
                "forum": "ph04CRkPdC",
                "replyto": "ObpCr3lUcj",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6107/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6107/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Conceptual connections to CoT are interesting, but we explain why direct numerical comparisons are moot"
                    },
                    "comment": {
                        "value": "We thank the reviewer for their time and feedback and for appreciating the experimental results. The reviewer raised a concern about comparison with CoT, which we address below.\n\n> Method does not compare directly with Chain of Thought \n\nThe connections to CoT are indeed conceptually interesting, which we touched upon in the Related Work and Discussion sections. We completely agree that pause-training requires pre-training while CoT doesn\u2019t \u2014 this is a great point of comparison. We have now added this to our discussion section. However, we wish to clarify that **a direct numerical comparison with CoT would be apples-to-oranges**, and the results are predictable a-priori. We would like to explain why below.\n\nIn short, **CoT is a compute-hungry approach, while pause-training does not add (substantially) to wall-clock time:** each intermediate reasoning token in CoT is sequentially and auto-regressively decoded from the model. This naturally would give us high performance gains, but at a high compute cost. Formally, if there are $P$ intermediate CoT tokens and $L$ layers, CoT performs $P \\cdot L$  **sequential** operations. Pause tokens on the other hand processes the P dummy identical tokens in **parallel**, with little excess in wall-clock time (depending on the number of parallel computational threads). Thus, by construction, pause-inference is computationally- and representationally-disadvantaged compared to CoT, rendering any numerical comparisons meaningless. \n\nThus, as mentioned in the paper, we believe that in terms of accuracy, CoT is without question, an upper bound on pause-inference.  To address this discussion further, we have added relevant discussion to this in Appendix I.\n\n> CoT has the ability to perform variable-length computation\n\nThis is an interesting aspect to consider! We agree that CoT can implicitly adapt its computation time to the input. But interestingly, on the flip side, **there is no explicit way to control the number of intermediate tokens in CoT, while this can easily be done for pause-inference.** In pause-inference, we can simply finetune different models with different numbers of pause-tokens and use whichever one we need depending on the \u201ccompute length\u201d we require.  Alternatively, we also found a modest amount of robustness to varying the number of pause tokens at inference directly (while fine tuning with a fixed number of pause tokens) as shown in Figure 4c and 4d. (Note that this variation is not adaptive to the input though; it is done for all inputs.)\n\nOverall, we wish to emphasize that our work is aimed at highlighting how the simple approach of adding dummy tokens can surprisingly be helpful. While this can be thought of as a weaker form of CoT, we do not aim to propose an alternative to CoT and we believe the comparison to CoT is straightforward (in favor of CoT, if we care about accuracy). \n\n\n===\n### Other comments\nWe thank the reviewer for pointing us to [1], which we have now cited in our work. The insights from this work are definitely relevant to us. It is worth noting that their analysis considers the CoT setting where the intermediate tokens are generated by the model itself, and fed back into the model. This enhances the \u201ccomputational depth\u201d of the model, which may be crucial to their theoretical claim. On the other hand, pause tokens enhance only the computational width of the model. In the now-added Appendix J, we formally argue why even this alone can be helpful in some tasks. \n\nWe again thank the reviewer for their time and valuable feedback on the paper. \n\n[1] Merrill, W., & Sabharwal, A. (2023). The Expressive Power of Transformers with Chain of Thought. ArXiv, abs/2310.07923."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6107/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700623154834,
                "cdate": 1700623154834,
                "tmdate": 1700679463031,
                "mdate": 1700679463031,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]