[
    {
        "title": "Iterated Deep $Q$-Network: Efficient Learning of Bellman Iterations for Deep Reinforcement Learning"
    },
    {
        "review": {
            "id": "fsf58HKMxK",
            "forum": "G5Fo7H6dqE",
            "replyto": "G5Fo7H6dqE",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1352/Reviewer_u8zz"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1352/Reviewer_u8zz"
            ],
            "content": {
                "summary": {
                    "value": "The paper proposes a modification to the DQN algorithm that is called iDQN. The idea is to have different heads that are updated in a rolling fashion and where each head is updated by considering the previous head as the \"target Q-values\" in the Bellman iterations. The paper provides some analysis of the idea and empirical results on mountain car and Atari games."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "- The idea is sound and relatively straightforward\n- The paper is overall well-written\n- The empirical results reported are strong and seem to be reported fairly while following good practice in the reported scores"
                },
                "weaknesses": {
                    "value": "- The technical analysis lacks strong theoretical justifications besides rephrasing a theorem from another paper and some not fully clear interpretations of this\n- The approach adds some hyper-parameters that are partly discussed and justified but not fully, see questions."
                },
                "questions": {
                    "value": "- Concerning the computation requirement, one gradient descent step seems to become at least slightly more computational expensive as compared to DQN. In the paper it is mentioned at the very end of the discussion section that \"with K=5 (it) only requires 1 to 2 times more time to run\". Can this quantification be more accurate or why would it \"sometimes\" same compute time and \"sometimes\" double the compute time?\n- The ablation study and discussion section provide an interesting discussion on the hyperparameters and answer many of the questions one could have. However, I still have questions about the interpretations done for these hyperparameters. Why do you claim that you provide a \"thorough understanding of their effects\" given that I don't see very clear backup for the claims such as \"Problems in which the environment is highly stochastic will require more gradient steps to learn a Bellman iteration hence the need to decrease the rolling step frequency\" and \"highly stochastic problems will benefit from having a small target update frequency since the positions of the online networks are more likely to be noisy\". I would suggest explaining in more details how these claims are made and if there is no fully clear data for these interpretations, I would suggest being a little more cautious.\n- Is an open-source implementation of the code made available? I do not see any GitHub link."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1352/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698488694914,
            "cdate": 1698488694914,
            "tmdate": 1699636062629,
            "mdate": 1699636062629,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "xdTrTzWtOW",
                "forum": "G5Fo7H6dqE",
                "replyto": "fsf58HKMxK",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1352/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1352/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We thank the Reviewer for the insightful comments and the time spent reviewing the paper.\n\n> 1. The technical analysis lacks strong theoretical justifications [...].\n\nWe argue that the theoretical analysis is valid and supports our claim that iDQN has a theoretical benefit over DQN. In the revised submission, we further clarify Section $5$ in order to ease the understanding. We stress the point that using an already-published theorem does not make the theoretical analysis weaker. In Section $5$, we now propose two different points of view. In the first one, we consider iDQN without target networks and demonstrate that each approximation error is minimized with $K$ times more gradient steps than with DQN. In the second point of view, we justify why the following approximation errors are controllable when using iDQN as opposed to DQN, which uses a naive approach.\n\n> 2. Concerning the computation requirement, [...].\n\nWe face the problem that an algorithm takes a different amount of time to run depending on:\n- the type of GPU used to run the algorithm. Our cluster has different types of GPUs, which makes the comparison hard to make (see table underneath).\n- the number of seeds that are run in parallel.\n- the Atari game. Some games take longer to run simply because the emulator takes longer to generate the next step.\n- the performance. Better algorithms are more likely to generate longer trajectories. This also has an impact on the running time.\n\nHere are some examples to illustrate our point:\n\n| Game         | Algorithm | Time  | # seeds | GPU  | \n| :----------- | :-------: | :---: | :-----: | :--: |\n| Alien        | IQN       |  63h  |   2     |  B   |\n| Alien        | iDQN K=5  |  60h  |   2     |  B   |\n| Asterix      | DQN       |  42h  |   2     |  B   |\n| Asterix      | iDQN K=4  |  46h  |   2     |  B   |\n| Breakout     | DQN       |  31h  |   2     |  B   |\n| Breakout     | iDQN K=5  |  54h  |   2     |  B   |\n| Enduro       | iDQN K=5  |  25h  |   1     |  A   |\n| Enduro       | iDQN K=5  |  50h  |   1     |  B   |\n| Enduro       | iDQN K=5  |  58h  |   2     |  B   |\n| VideoPinball | iDQN K=5  |  25h  |   1     |  A   |\n| VideoPinball | iDQN K=5  |  49h  |   1     |  B   |\n| VideoPinball | iDQN K=5  |  67h  |   2     |  B   |\n\nA: RTX 4090\nB: RTX 2080Ti, RTX 3080Ti, RTX 3090, or A5000 GPU\n\nFor those reasons, we changed the sentence in the paper to say that the running time of iDQN is comparable to the one of IQN on the same hardware for the same Atari game.\n\n> 3. The ablation study and discussion section provide an interesting discussion on the hyperparameters [...].\n\nWe agree with the Reviewer. We further clarified those claims with $2$ new ablation studies on the $2$ hyperparameters in Figure $9$ middle and right of the revised submission.\n\n> 4. Is an open-source implementation of the code [...].\n\nWe invite the Reviewer to have a look at our code in the appendix. We will turn the GitHub public upon acceptance."
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1352/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700055745395,
                "cdate": 1700055745395,
                "tmdate": 1700055745395,
                "mdate": 1700055745395,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "Q7XehNeiUG",
                "forum": "G5Fo7H6dqE",
                "replyto": "fsf58HKMxK",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1352/Reviewer_u8zz"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1352/Reviewer_u8zz"
                ],
                "content": {
                    "title": {
                        "value": "I maintain a positive assessment of the contributions of the paper"
                    },
                    "comment": {
                        "value": "Thank you for the replies that clarify most of my questions. I thus currently maintain a positive assessment of the paper.\n\nConcerning the code, I still do not see it. I suppose that I am missing the obvious... In which part of the appendix is it? Or do you mean the pseudo-code in Algorithm 1, which is different than open source code?"
                    }
                },
                "number": 10,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1352/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700142247267,
                "cdate": 1700142247267,
                "tmdate": 1700142359267,
                "mdate": 1700142359267,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "iDDURO82oR",
            "forum": "G5Fo7H6dqE",
            "replyto": "G5Fo7H6dqE",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1352/Reviewer_i5KK"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1352/Reviewer_i5KK"
            ],
            "content": {
                "summary": {
                    "value": "The authors introduce iDQN, a variant of Deep Q-Network (DQN) that splits the value network into multiple heads. Each head bootstraps from the previous one, enabling parallel learning of the iterated (projected) Bellman operator. The rationale is that each head can begin training before the previous head has fully converged, thereby speeding up learning. The authors compare iDQN against DQN and C51 baselines across a large suite of Atari games using the interquartile mean (IQM) of human-normalized scores as the performance metric."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "- The main goal of the paper, trying to learn iterations of the Bellman operator faster, makes a lot of sense and is a promising avenue for improving the sample efficiency of DQN.\n- Adding multiple heads to the network is a smart way to do this efficiently. Whereas normally multiple networks would be needed to naively implement this idea\u2014which would be prohibitively expensive\u2014the different heads can share extracted features and reduce computational cost.\n- iDQN obtains strong results on the Atari benchmark, appearing to improve performance over the baselines in terms of IQM human-normalized scores.\n- The paper is well written and includes lots of helpful diagrams for the reader."
                },
                "weaknesses": {
                    "value": "- Although intuitively sound, the main idea lacks sufficient theoretical support. The only theorem in the paper is quoted from [1] for approximate value iteration, which provides a bound on the error $\\||Q^* - Q^{\\pi_K}\\||$ in terms of a weighted sum of previous error components $\\||\\Gamma^* Q_{k-1} - Q_k\\||$. The authors claim that since one gradient step of iDQN affects multiple of these components at a time, then \"iDQN can lower the approximation error bound more than DQN.\u201d However, I do not think this argument is true. This bound is based on the accuracy of previous Q-functions relative to their respective Bellman updates after learning. Just because a gradient step for iDQN affects more than one Q-function at a time does not mean the error bound will automatically be lower. For example, if one of iDQN\u2019s heads suddenly changes, the errors for the downstream heads could suddenly increase because the Bellman operator\u2019s projected location would also change, requiring the other heads to adjust accordingly.\n- There is weak empirical evidence that learning many Bellman iterations in parallel is feasible and significantly improves value estimation. Because each head must bootstrap from the previous one, I would think that maybe only two heads at most could be reliably trained simultaneously; any heads afterwards would begin bootstrapping from extremely biased estimates and quality would degrade significantly. This appears to be the case in Figure 5, where even using 10 heads does not greatly reduce the value error compared to 1 head in a low-dimensional problem.\n- The separate network heads for iDQN are split immediately after the convolutional layers, and not immediately before the final linear layer as I would have expected. Because the vast majority of weights in the DQN conv net are contained in the dense layers, this adds an enormous number of extra parameters to iDQN, which might be improving its performance. It also makes the proposed method very expensive.\n- The target-network update frequency is faster for iDQN than the baseline DQN, which I think makes the empirical comparison unfair. This could be contributing to the apparent performance increase in addition to the extra parameters.\n- The paper would benefit from a stronger discussion of $n$-step returns, as the proposed method is more related to $n$-step methods than is currently appreciated. An $n$-step return can be seen as a stochastic approximation to $n$ iterations of the (on-policy) Bellman operator. Thus, $n$-step returns are an alternative way to achieve a similar effect as the proposed algorithm. The paper currently cites TD($\\lambda$) [2] for $n$-step returns, but it should cite [3] instead\u2014see the bibliographical/historical remarks at the end of chapter 7 of [4] for related references.\n\n**References**\n\n[1] Amir-massoud Farahmand. Regularization in Reinforcement Learning. 2011.\n\n[2] Richard S. Sutton. Learning to Predict by the Methods of Temporal Differences. 1988.\n\n[3] Christopher J. C. H. Watkins. Learning from Delayed Rewards. 1989.\n\n[4] Richard S. Sutton and Andrew G. Barto. Reinforcement Learning: An Introduction. 2018."
                },
                "questions": {
                    "value": "none"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission1352/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1352/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1352/Reviewer_i5KK"
                    ]
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1352/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698548547591,
            "cdate": 1698548547591,
            "tmdate": 1699636062541,
            "mdate": 1699636062541,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "SzVeHasLOu",
                "forum": "G5Fo7H6dqE",
                "replyto": "iDDURO82oR",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1352/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1352/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We thank the Reviewer for the extensive feedback.\n\n> 1. Although intuitively sound, the main idea lacks sufficient theoretical support. [...].\n\nWe respectfully disagree about this. We believe that there is a misunderstanding and hope that Section $5$ of the new submission clarifies it. We think that the example brought by the Reviewer is misleading for the general understanding of the theoretical benefit of iDQN. We insist on the fact that it is crucial to compare the behavior of iDQN with the behavior of DQN in the example given by the Reviewer. In the revised submission, we now tackle this specific case in Figure $6$ and the text explaining this figure. The approximation errors corresponding to the downstream networks can indeed vary along the training, especially when the target networks of iDQN get updated. Nonetheless, we show that those approximation errors are bounded by a controllable term as opposed to DQN, which only takes the last online network as a starting point to learn the approximation error of the subsequent step. In simpler words, while DQN has a naive approach to minimize the approximation errors corresponding to the subsequent steps, iDQN proposes a way to pre-train the next online $Q$-function.\n\n> 2. There is weak empirical evidence that learning many Bellman iterations in parallel is feasible [...].\n\nWe believe that this comment is linked with the first point and hope that the answer helps clarify the concern. We now have updated the submission and provided significant additional evidence that learning many Bellman iterations brings a boost in performance. Indeed, Figure $7b$ of the revised submission shows that iDQN + $3$-step return is performing on the level of advanced distributional methods while not learning the distribution of the return. Figure $8$ illustrates that the combination of iDQN with IQN is outperforming iDQN and IQN. \n\nConcerning the experiment on Car-On-Hill, we provide the following table showing the distance of the current estimate $V^{\\pi_k}$ to the optimal $Q$-function $|| V^* - V^{\\pi_k} ||$:\n\n| K  | k=15         | k=20         | \n| :- | :----------: | :----------: |\n| 1  | 3.91 +- 0.87 | 2.77 +- 0.87 |\n| 2  | 4.02 +- 0.64 | 2.82 +- 0.75 |\n| 4  | 4.15 +- 0.70 | 2.32 +- 0.45 |\n| 5  | 3.64 +- 0.73 | 2.24 +- 0.36 |\n| 10 | 2.50 +- 0.42 | 2.03 +- 0.09 |\n| 20 | 2.25 +- 0.24 | 2.02 +- 0.11 |\n\nWhen $K$ increases, we observe a clear decrease of the considered distance.\n\n> 3. The separate network heads for iDQN are split immediately after the convolutional layers, [...].\n\nThe cost of splitting the heads after the last convolutional layer can be quantified by the spatial complexity and the temporal complexity. Regarding the spatial complexity, we provide a thorough analysis in Section $C$ of the appendix. This analysis shows that the increase in spatial complexity is negligible compared to the memory required for storing the replay buffer. For the temporal complexity, in theory, it is possible to fully parallelize the additional computations required by iDQN such that it is reduced to the temporal complexity of DQN. In practice, we observe an overhead comparable to IQN. We believe that the approach proposed by iDQN is still worth it, considering the theoretical and experimental advantages that it brings. \n\nWe want to point out a misconception brought by the review. The boost in performance given by iDQN over DQN is not a direct consequence of the fact that iDQN is using more parameters. Indeed, in iDQN, the actions are sampled from a single network having the same amount of parameters than a DQN agent. It is the way the networks are trained that brings a boost in performance.\n\n> 4. The target-network update frequency is faster for iDQN than the baseline DQN [...].\n\nWe provide a new ablation study in Figure $8$ right of the revised submission in which we set the rolling step frequency of iDQN to be equal to the target update frequency of DQN ($8000$). In this experiment, we observe that iDQN greatly outperforms DQN. This is due to the fact that iDQN performs $4$ times more gradient steps per approximation error than DQN while having the same overall number of gradient steps.\n\n> 5. The paper would benefit from a stronger discussion of $n$-step returns, [...].\n\nWe kindly ask the Reviewer to have a look at the new submission in which new experiments with $n$-step return have been added. We agree with the Reviewer that an $n$-step return can be seen as a stochastic approximation to $n$ iterations of the (on-policy) Bellman operator; however, these $n$ iterations are directly included in the reward instead of being learned in a chained manner like iDQN proposes. \n\nThank you for noticing this mistake. We now cite the suggested work for $n$-step return."
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1352/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700055532409,
                "cdate": 1700055532409,
                "tmdate": 1700055532409,
                "mdate": 1700055532409,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "GSfJRTQYjt",
                "forum": "G5Fo7H6dqE",
                "replyto": "SzVeHasLOu",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1352/Reviewer_i5KK"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1352/Reviewer_i5KK"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for the new experiments and the added discussion about n-step returns.\n\nThe updated Section 5 and Figure 6 are helpful. However, my concerns about the theory still remain. As written, Theorem 1 is still conditioning each iteration on the previous, frozen network $Q_{k-1}$ assuming that the true Bellman operator can be applied to it. If $Q_{k-1}$ is still changing while $Q_k$ is trying to minimize $\\|| \\Gamma^* Q_{k-1} - Q_k \\||$, then the bound is invalidated.\n\nI also think the intuition in Figure 6 is an oversimplification of the actual dynamics in iDQN. It looks like you have let $\\lambda = \\||\\bar{Q}_1 - Q_1\\||$ be the error between the approximate Bellman result and the exact result after updating $Q_0$. It is true that the contractive nature of the Bellman operator would shrink this distance by a factor of $\\gamma$ (only if we ignore function approximation though, but this is reasonable for the sake of the convergence argument). However, it is not true that $\\lambda$ is necessarily smaller than the original distance $\\||Q_0 - Q_1\\||$ as depicted in your figure because transient noise in the updates could push $\\bar{Q}_1$ far away from the fixed point before it converges. It seems you are implicitly assuming some monotonicity condition on the approximate Bellman iterates. You say that $\\lambda$ is controllable by lowering the learning rate, but I do not see how this is the case.\n\nRegarding the network structures, I see your point that each individual network head has roughly the same capacity as one DQN, but the fact remains that your network is still using ~5x more computation and memory than a normal DQN. The spatial complexity cannot be neglected just because the replay memory is also large; GPU memory is much more limited than CPU memory in practice. If you were able to obtain strong performance with $K=2$ then perhaps these limitations could be overlooked, but $K=5$ is very expensive."
                    }
                },
                "number": 12,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1352/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700267700795,
                "cdate": 1700267700795,
                "tmdate": 1700267700795,
                "mdate": 1700267700795,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "qyfJboDJff",
                "forum": "G5Fo7H6dqE",
                "replyto": "dYSNbqgCFB",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1352/Reviewer_i5KK"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1352/Reviewer_i5KK"
                ],
                "content": {
                    "comment": {
                        "value": "I thank the authors for the clarifications. I did not mean to misrepresent $\\lambda$ in your figure. However, my point remains that the current argument does not capture the interplay between the two Q-functions. If the first Q-function changes, it could invalidate the progress the second Q-function is making, and so on. Because of these complex dynamics, it is not obvious that simply performing $H$ gradient steps on both Q-functions automatically leads to a lower error.\n\nFurthermore, there are some theoretical issues with the current arguments in Theorems A.1 and A.2. The biggest one is the assumption that the Bellman operator is a contraction mapping. As you said previously:\n\n> This relates to Equation $ ||\\Gamma^* \\\\bar{Q}_1 - \\Gamma^*Q_1||^2 < \\gamma ||\\bar{Q}_1 - Q_1||^2$. This equation is true for all $Q$-functions. This is why it is also true in the case where the $\\bar{Q}_1$ and $Q_1$ are neural networks since neural networks are also functions.\n\nThis is unfortunately incorrect. The Bellman optimality operator is known to be a non-contraction even in the simple case of linear function approximation; see Baird's counterexample for an instance in which Q-Learning diverges [1]. Furthermore, the standard *on-policy* Bellman operator is not even guaranteed to be a contraction when used with nonlinear functions, as shown by the spiral counterexample here [2]. Since the bulk of the theoretical arguments are based on the assumed contraction property of the DQN loss, the theorems would require extensive changes to be ready for acceptance.\n\nFinally, I disagree that spatial complexity is not a concern. It may be the case that a standard GPU can handle the specific network architecture used in your experiments. But, as noted by Reviewer LPKc, larger networks will quickly become impractical, essentially limiting users to choose models that occupy only a fraction of their GPU memory. I do think this is a drawback of the proposed method, although the theoretical issues I mentioned above are more pressing.\n\n[1] Residual Algorithms: Reinforcement Learning with Function Approximation. Baird. 1995.\nhttps://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=1b8e45c10238f261a468171374f0c515be790650\n\n[2] Analysis of Temporal-Difference Learning with Function Approximation. Tsitsiklis & Van Roy. 1996.\nhttps://proceedings.neurips.cc/paper/1996/file/e00406144c1e7e35240afed70f34166a-Paper.pdf"
                    }
                },
                "number": 17,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1352/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700710332365,
                "cdate": 1700710332365,
                "tmdate": 1700710332365,
                "mdate": 1700710332365,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "gt3b7114UM",
            "forum": "G5Fo7H6dqE",
            "replyto": "G5Fo7H6dqE",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1352/Reviewer_LPKc"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1352/Reviewer_LPKc"
            ],
            "content": {
                "summary": {
                    "value": "The authors propose a method which builds on the use of target networks as used by DQN and many other algorithms. Essentially this boils down to introducing K intermediate Q-networks where the Kth such network is roughly equivalent to the online network. The authors further rely on a theorem from Farahmand, 2011 to bound the approximation error and show that their iterative solution can lower the approximation bound from DQN.\n\nThe authors then go on to show that this approach beats DQN empirically and argue that it is largely independent of different improvements on DQN\u2014ie that any method that makes use of a target network can benefit from this improvement."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "4 excellent"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "The idea is simple, but effective across a seemingly wide range of implementations (e.g. all that use a target network). The presentation of the work was very good, and the description of the literature and this works place within the literature was one of the best I've seen in a while (see below for one minor quibble). The analysis of why this should, theoretically, improve over DQN was also effective."
                },
                "weaknesses": {
                    "value": "I'm a bit of two minds about this work in that the approach is interesting, but in the comparison with DQN much of the gains can be seemingly reached by just switching the optimizer out for ADAM. Similarly while iDQN can be combined with IQN (as a stand in for newer, more complicated algorithms) I would like to see a more comprehensive treatment of this combination along with perhaps comparison(s) versus more novel algorithms, e.g. Muesli, or against algorithms such as the cited ensemble methods such as REM, due to the fact that iDQN requires an ensemble of K models (ignoring Q_0). \n\nFinally, if we look at the extended 54 Atari experiments there are both a number of examples where DQN+Adam out-performs iDQN. In fact it's not entirely clear to me that iDQN out-performs on average, and it would be useful to see that. It may do so, but it appears close."
                },
                "questions": {
                    "value": "See above. In particular it would be helpful for the authors to address the comparisons with DQN+Adam and with more modern algorithms and if they see this as tangential."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1352/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698867929315,
            "cdate": 1698867929315,
            "tmdate": 1699636062439,
            "mdate": 1699636062439,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "uaMMAXoXSX",
                "forum": "G5Fo7H6dqE",
                "replyto": "gt3b7114UM",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1352/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1352/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We thank the Reviewer for the useful suggestions and comments.\n\n> 1. I'm a bit of two minds about this work in that the approach is interesting, [...].\n\nWe now provide more experiments in the new submission to show the benefit of iDQN. We want to highlight the new experiments on iDQN + 3-step return, presented in Figure $7b$. iDQN + 3-step return achieves similar results to strong distributional approaches (Rainbow, IQN + 3-step return, and Munchausen DQN + IQN + 3-step return).\n\n> 2. Similarly while iDQN can be combined with IQN (as a stand in for newer, more complicated algorithms) [...].\n\nWe believe that this point is related to the answer of point $1.$. Furthermore, we added a more comprehensive study on the combination of IQN and iDQN in Figure $8$ (left). iIQN is now the combination of iDQN and IQN with $64$ quantiles and $64$ target quantiles (like the original version of IQN) instead of $32$ quantiles and $32$ target quantiles used in the first submission. We stress the fact that REM is using an ensemble of $Q$-function to sample actions, while in iDQN, the actions are sampled from a single $Q$-function. Nevertheless, we added a specific figure for the comparison (see Figure $20$).\n\n> 3. Finally, if we look at the extended 54 Atari experiments [...].\n\nSimilarly to point $2.$, we believe that this point is related to the answer to point $1.$. Moreover, in this work, we decided to focus on the interquartile mean since it has been shown to be more appropriate to differentiate algorithms [1]. Looking at the number of games a method is outperforming another method does not take into account the gap between the scores in each game. Overall, iDQN overtakes DQN on $30$ Atari games while losing on $23$ games and being on par on $1$ game.\n\n> 4. In particular it would be helpful for the authors to address [...].\n\nWe believe that this comment no longer applies to the revised submission. We hope that the additional experiments satisfy the Reviewer.\n\n[1] Rishabh Agarwal et. al. Deep reinforcement learning at the edge of the statistical precipice. Neurips, 2021."
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1352/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700055166245,
                "cdate": 1700055166245,
                "tmdate": 1700055856594,
                "mdate": 1700055856594,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "ilrpzAXCzm",
                "forum": "G5Fo7H6dqE",
                "replyto": "uaMMAXoXSX",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1352/Reviewer_LPKc"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1352/Reviewer_LPKc"
                ],
                "content": {
                    "comment": {
                        "value": "The updates do help, however I'm still unsure about the gains. Additionally I do have the same concerns re: the memory usage of the network as Reviewer i5KK, namely that you're duplicating the convolutional layer and increasing the fully connected layer by a factor of K+1. This is always going to be a concern.\n\nThat being said, while the usage detailed in appendix D does help to answer these concerns, it is not necessarily positively. An increase from 16 to 92 Mb is huge if we're talking about large networks that may barely fit into GPU memory. From the perspective of such networks (e.g. consider RLHF for LLMs, although definitely out of scope for this paper) the GPU memory is much more important than the memory used for replay.\n\nOne consideration is to reduce the size of the individual layers to make this a fair apples-to-apples comparison."
                    }
                },
                "number": 15,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1352/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700671136839,
                "cdate": 1700671136839,
                "tmdate": 1700671136839,
                "mdate": 1700671136839,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "bKpNLcVMvj",
            "forum": "G5Fo7H6dqE",
            "replyto": "G5Fo7H6dqE",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1352/Reviewer_AD1r"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1352/Reviewer_AD1r"
            ],
            "content": {
                "summary": {
                    "value": "The authors propose a novel q-learning method based on incrementally creating additional target and online networks, using the online network of one to define the target network of another. The target networks are periodically updated with the parameters of the previous online network, the one that initialized it. All online networks are updated concurrently by minimizing the sum of the q-learning loss of each online-target network pair. Additionally, new online/target networks are initialized from the most recent online network and the oldest pair are discarded. Finally, each online network shares some layers with each network having their separate \"heads\".\n\nThe proposed method, called iterated deep q-network (iDQN), is informally related to a loss bound for approximate value iteration and empirically evaluated on the Atari domain. Their results show a modest improvement in aggregate score over standard DQN with the adam optimizer. A limited ablation study compares using K=5 and K=10 (where K is the number of networks to keep) and shows K=10 performing better in 2 of the 3 games tried."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "The proposed idea of keeping older online/target networks and continuing to optimize them in tandem is a novel and interesting idea. In a way, this feels like an approximation of doing several steps of gradient updates per iteration, but done concurrently and amortized over time, which would have the potential to accelerate learning.\n\nThe writing is clear and the background well discussed.\n\nThe atari experiments follow good experimental practices."
                },
                "weaknesses": {
                    "value": "I had trouble understanding the intuition the author's are trying to convey when they refer to \"learning the Bellman iteration\". This is a central concept in various discussions but I'm still unclear about what they mean. Fortunately, the authors also provide more formal descriptions of their method so I am fairly confident I understand what their method is doing, at least mechanistically.\n\nThe theoretical analysis seems very informal and I don't believe we can say much from it. The comparison with the loss bound that the authors make implies that we are talking about the same $Q_k$'s but their definitions differ greatly between the action-values of each step of approximate value iteration and those defined by the proposed method.\n\nIt's not clear whether the comparison to DQN is fair when normalizing for \"gradient steps\". If DQN is twice as fast, could I not do twice as many gradient steps? The question this brings is if this isn't more an observation of update frequency, e.g., doing several updates per environment step, which we know can improve performance with regards to sample efficiency. I'd be interested in hearing the author's thoughts on this.\n\nThe ablation study is quite limited. I understand that these experiments are computationally expensive but some understanding of the behavior of this method and its hyperparameter could still be found with smaller scale experiments in less costly domains. Several of my questions (below) could have been answered with a more complete ablation study."
                },
                "questions": {
                    "value": "Why does iDQN have 4 set convolutional layer parameters when discussed in Appendix C, \"$2(2C + (K+1)F)$\"? I count 2, 1 shared amongst the target networks and 1 shared amongst the online networks.\n\nAt a high level, I have trouble understanding why having more networks like proposed would help and I suspect it is contingent on other design choices not explicitly captured by the loss in Eq. (2). This leads me to a series of questions. Which parts are necessary?\n- Does having several online/target network provide any benefits when not sharing layers between networks?\n- Does this idea of having many online/target networks help even with not fixing the target networks (target update period of 1)?\n- What is the effect of rolling online/target networks? Is it necessary? Is more always better?\n\nWhy is the target update period considered an \"additional hyperparameter\" when discussing hyperparameter tuning? Couldn't DQN also benefit from that tuning in that case?\n\nIn Figure 4a, shouldn't $Q_1$ be closer (or equal distance) to $\\Gamma^*\\bar{Q}_0$ compared to $\\bar{Q}_1$ always or did I misunderstand this illustration?\n\nWhy does Figure 3 and Figure 11 (left) have different notation for $Q_0$, e.g., different color and a bar?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1352/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698881510149,
            "cdate": 1698881510149,
            "tmdate": 1699636062348,
            "mdate": 1699636062348,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "FUyMQzwX1I",
                "forum": "G5Fo7H6dqE",
                "replyto": "bKpNLcVMvj",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1352/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1352/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We thank the Reviewer for the insightful comments and feedback. We appreciate the fact that the appendix was meticulously studied.\n\n> 1. I had trouble understanding the intuition the author's [...].\n\nWe believe that understanding what we call \"learning the Bellman iteration\" is a major point for the general comprehension of our work. Therefore, we hope that the following clarification will be useful to clear all doubts. The optimal $Q$-function is the fixed point of the Bellman operator. DQN uses the fact that the Bellman operator is a contracting operator. Thus, iterating multiple times over this Bellman operator can lead any random $Q$-function to the desired fixed point. Theoretically speaking, DQN applies the Bellman operator when computing the target, as explained in Section $3$. Due to the use of function approximation, DQN needs to first learn the target before applying the Bellman operator a second time. This step of learning the target is what we call learning the Bellman iteration. \n\nNevertheless, we take the Reviewer's opinion into account and, in the revision, we now use the term: \u201cminimizing the approximation errors\u201d in Section $5$. \n\n> 2. The theoretical analysis seems very informal [...].\n\nWe believe that there is a misunderstanding here since the $Q$-functions used in iDQN are the same as the ones used in the theorem. We stress that DQN and iDQN are performing approximate value iteration. As written in Section $5$, the loss of DQN $(r + \\gamma \\max_{a'} Q_{k-1}(s', a') - Q_k(s, a))$ is an unbiased estimator of the approximation error $||\\Gamma Q_{k-1} - Q_k||_{2, \\nu}^2$ and the same goes for iDQN. We further clarify that part in Section $5$. We would appreciate some feedback from the Reviewer to know if this has improved the understandability of the section. We hope that this explanation togethet with the clarification brought in the answer of point $1.$ help resolve this misunderstanding.\n\n> 3. It's not clear whether the comparison to DQN is fair [...].\n\nWe point out that the comparison to DQN is not only made for the same amount of gradient steps but also for the same amount of samples. The latter is the usual way of comparing algorithms for the Atari benchmark. In order the respond to the last part of the comment, we added an experiment in Figure $8$ left of the revised submission. In this experiment, we set the rolling step frequency to be equal to the target update frequency of DQN ($8000$). In that case, both algorithms have access to the same amount of Bellman iterations. In the same figure, we added an experiment in which DQN performs $4$ times more gradient steps than DQN (Adam), as asked by the Reviewer. We see that the performances drop while iDQN greatly outperforms both versions of DQN.\n\n> 4. The ablation study is quite limited.\n\nWe understand the request. We invite the Reviewer to check the revised submission in which we added several ablation studies corresponding to each point raised by the review. A description of the new ablation studies is provided in the general response.\n\n> 5. Why does iDQN have 4 set convolutional layer parameters [...].\n\nLooking at Figure $11$, there are $2$ set of convolutional layers for online networks and $2$ set of convolutional layers for target networks. Only the online networks are shown in the Figure $11$. As raised in point $11.$, we have modified the figure to avoid any possible confusion. \n\n> 6. Does having several online/target network provide any benefits [...].\n\nYes, it does. As we now show in Figure $17$ of the revised submission, the networks are more flexible when they are independent hence allowing them to further explore the space of $Q$-function.\n\n> 7. Does this idea of having many online/target networks help [...].\n\nPlease find a new ablation study to answer this question in Figure $9$ middle. When $T=1$, iDQN might suffer from the stochasticity of the location of the online $Q$-functions as shown with the experiment on *Asterix*.\n\n> 8. What is the effect of rolling online/target networks? [...]\n\nThe rolling step allows iDQN to regress the following Bellman iteration. After the first rolling step, iDQN learns from iteration $2$ to $K+1$ instead of from iteration $1$ to $K$. Without rolling steps, iDQN would be stuck at $K$ Bellman iteration, and the fixed point could not be reached. With a fixed amount of gradient steps, more Bellman iterations are not always better since each Bellman iteration needs to be learned properly. We added an experiment in the revised submission to support that point. In Figure $9$ right, we decreased the rolling step frequency from $R=6000$ to $R=100$. In *Breakout*, iDQN with $R=100$ has access to $60$ times more Bellman iterations than iDQN with $R=6000$ while performing worse."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1352/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700055005122,
                "cdate": 1700055005122,
                "tmdate": 1700055005122,
                "mdate": 1700055005122,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]