[
    {
        "title": "Partitioned-Learned Count-Min Sketch"
    },
    {
        "review": {
            "id": "PSRDeJXpjz",
            "forum": "7W4boWjb3Q",
            "replyto": "7W4boWjb3Q",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2979/Reviewer_C7mx"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2979/Reviewer_C7mx"
            ],
            "content": {
                "summary": {
                    "value": "This paper aims to incorporate learned information to improve the performance for the count-min sketch (for the heavy-hitter analysis task in data streams). In particular, the algorithm receives a prediction of the frequency of input items, and it utilizes this info to build a separate data structure for items with similar (predicted) frequencies via a simple thresholding strategy. Indeed, if this partition of the data is good enough (which means items of similar frequency are put in the same parts), then it can achieve a better accuracy-space tradeoff compared with a generic count-min sketch. Similar ideas have been considered in recent papers such as Vaidya et al. (ICLR 2021) which studied bloom filters."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "I think that the general idea of having separate count-min sketch for items of similar frequency is nice, and it is convincin that this could improve the performance (provided that the prediction is accurate). In addition, the experiment results seem to be promising. In particular, it looks like even with a relatively simple and weak prediction, the proposed algorithm can already achieve significant improvement over baselines on various data sets."
                },
                "weaknesses": {
                    "value": "- The algorithm needs additional information than the estimated frequency of items, particularly the E_i F_i parameters are only artifacts of your algorithm instead of something natural to the heavy-hitter problem\n\n- The robustness (i.e., what happens if the prediction is completely wrong) is not discussed/evaluated. Indeed, one major motivation for algorithms with predictions is to utilize ML predictions while still preserving the worst-case guarantee.\n\n- It would also be better to have a measure of the prediction error, as well as relate the performance of your algorithm to that error measure to obtain a smooth tradeoff between robustness and consistency.\n\n- I also see some technical issues, and please find the detailed comments in the \"Questions\" section."
                },
                "questions": {
                    "value": "- It seems your E_i and F_i are dependent on the thresholds t_i\u2019s. However, it seems you need to estimate E_i and F_i, and then use them to find the t_i\u2019s. This does not make sense to me.\n\n- Page 4, \u201cwhich region is falls in\u201d -> \u201cwhich region it falls in\u201d\n\n- Page 4, item 1 in Sec 2.2 has unpaired parenthesis\n\n- Page 6, third paragraph. Can you give more intuition on why the theoretical upper bound does not work well? Is there any rationale for introducing a p in the exponent? This way of adding a new parameter seems quite random to me.\n\n- In page 6 you mentioned that using larger number of score thresholds typically does not improve the performance \u2014 why is this? Also, this somewhat contradicts the claim in Section 5, where you mention that \u201cdetermining the optimal number of partitions is a crucial next step that can significantly enhance its performance\u201d.\n\n- Page 7, why the space of the learned model is of the lower order so that it can be ignored?\n\n- Only the arXiv version of Vaidya et al., ICLR 2021 paper is cited \u2014 consider citing the conference version. Please also check this for other references.\n\n- Several references do not have their venues listed, for isntance Chabchoub et al., 2009 and Dolera et al., 2022."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission2979/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2979/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2979/Reviewer_C7mx"
                    ]
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2979/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698480006292,
            "cdate": 1698480006292,
            "tmdate": 1700805234814,
            "mdate": 1700805234814,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "hdur4Y9Uny",
                "forum": "7W4boWjb3Q",
                "replyto": "PSRDeJXpjz",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2979/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2979/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal by Authors"
                    },
                    "comment": {
                        "value": "Thank you for your constructive feedback and careful reading of our paper. We address the most important questions and concerns below.\n> The robustness is not discussed/evaluated. Indeed, one major motivation for algorithms with predictions is to utilize ML predictions while still preserving the worst-case guarantee. \n\nGiven fixed thresholds, even when the predictions are completely inaccurate, PL-CMS optimizes the space allocations of each CMS accordingly, which means that PLCMS is naturally robust. Specifically, we use the predictions to estimate the quantities $E_i$ and $F_i$ as well as the number of unique buckets from the training dataset. If, for example, we incorrectly place a large number of infrequent items in the first region, $F_1$ will be large and we will assign $\\text{CMS}_1$ a lot of space to lower its FPR. \n\nAs an example, consider the case when our ML model is just a random oracle that uniformly assigns elements of the stream into different regions of PL-CMS, without any correlation to their actual frequencies. Further, assume that the number of unique buckets is small (which is typically true in practice). In this setting, one can show that the expected error of any item under PL-CMS is roughly equal to its expected error under the standard Count-Min sketch -- that is, when the learned model degenerates to random guesses, PL-CMS still matches the performance of the unlearned algorithm, indicating a high level of robustness. Since a random oracle will allot every region a roughly equal fraction of infrequent items $F_i$ and a roughly equal total frequency of items $E_i$ and, as a result, each CMS will be assigned the roughly same amount of buckets $m_i$, we will have $\\frac{E_i}{m_i}\\approx \\frac{n/c}{m/c} = \\frac{n}{m}$, where $c$ is the number of regions. This is the same ratio (and in turn yields the same false positive rate) as if we assigned all items to a single CMS with $m$ buckets. Note that a similar argument would hold if the model assigned items to different regions with different probabilities. In this case, letting $p_i$ be the probability of an item being assigned to region $i$, we would have $m_i \\approx m \\cdot p_i$.\n\nTo verify the above argument, we have included additional experiments in section A.3.3 of the Appendix, where we show that given a learned model that outputs random predictions, PL-CMS performs similarly to standard CMS and LCMS on the Zipfian datasets except for 3-CMS on the Macbeth dataset with $n/k=16$ which we are currently investigating.\nWe would also like to point out that while it is important to consider the robustness of algorithms with predictions, none of the prior works in the area (LCMS of Hsu et al. and Partionioned Learned Bloom Filters of Vaidya et al.) provide such an analysis.\nWe agree that establishing a measure of prediction error is a crucial next step to optimizing the threshold values of PL-CMS and studying its consistency.\n\n> It seems your $E_i$ and $F_i$ are dependent on the thresholds $t_i$\u2019s. However, it seems you need to estimate $E_i$ and $F_i$, and then use them to find the $t_i$\u2019s. This does not make sense to me.\n\nThe threshold values do not depend on $E_i$ and $F_i$. We first perform a grid search to find the threshold values and then estimate $E_i$ and $F_i$ given the chosen thresholds.\n\n> Page 6, third paragraph. Can you give more intuition on why the theoretical upper bound does not work well? Is there any rationale for introducing a $p$ in the exponent? This way of adding a new parameter seems quite random to me.\n\nThe theoretical bound on the false positive rate is loose due to applying Markov's inequality in the analysis. The term inside the parentheses found in Equation 6 is the failure probability for any repetition which is set to $1/e$ by picking $m_i$ appropriately. We then raise it to the number of repetitions $t_i$. Thus, adding a constant $p$ is equivalent to estimating the per repetition failure probability as $1/e^p$ instead of $1/e$ which makes it closer to reality. \n\n> In page 6 you mentioned that using larger number of score thresholds typically does not improve the performance \u2014 why is this? Also, this somewhat contradicts the claim in Section 5. \n\nThis is a great question. We agree that optimizing the thresholds themselves rather than the number of regions is more important to improving our algorithm's performance. Finding a way to optimize the number of regions could potentially allow us to better understand why using a small number of regions often works well in practice. \n\n> Page 7, why the space of the learned model is of the lower order so that it can be ignored?\n\nThank you for pointing this out. We follow the approach of Hsu et al. in which we focus on the space complexity of the data structure instead of its learned model since the space occupied by the oracle can be amortized over time. We will include a clarification in the paper."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2979/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700342966969,
                "cdate": 1700342966969,
                "tmdate": 1700342966969,
                "mdate": 1700342966969,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "qLsNrKO41p",
            "forum": "7W4boWjb3Q",
            "replyto": "7W4boWjb3Q",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2979/Reviewer_4TXw"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2979/Reviewer_4TXw"
            ],
            "content": {
                "summary": {
                    "value": "This paper studies how to partition the stream into multiple region and process each local region with a Count-Min Sketch. Heavy hitters and frequent items are important tasks in streaming setting and have many applications. The authors provide both theoretical analysis and experimental studies to showcase the proposed algorithm outperforms the baseline in many cases."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "The main idea of this paper is sound and intuitive. In fact many other sketching algorithm (not learned) leverage the same idea. Some recent works in the space are AugmentedSketch, ElasticSketch, and Panakos.\n\nThe theory analysis is well written and friendly to readers. The analysis looks correct to me.\n\nThe parameter optimization method is interesting and may lead to broader impact."
                },
                "weaknesses": {
                    "value": "AOL dataset is subject to controversy. I would recommend the author to remove experimental results about AOL. (https://en.wikipedia.org/wiki/AOL_search_log_release)\n\nAuthor may want to clarify the assumption on the stream and compare with some other popular summaries in the experiments to indicate the benefits of learning. If the stream is in insertion-only or in bounded-deletion model, then author should compare with the SpaceSaving algorithm. (see https://arxiv.org/pdf/2309.12623.pdf and https://arxiv.org/abs/1803.08777). If the stream is in turnstile model, then the author should include comparison with Count Sketch (Charikar, Moses, Kevin Chen, and Martin Farach-Colton. \"Finding frequent items in data streams.\").\n\nI might have missed it. How is the score $l_i$ decided and is it learned in training? For instance, in Macbeth, the proposed algorithms use threshold 200|100, and 300|200|100."
                },
                "questions": {
                    "value": "See weakness"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission2979/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2979/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2979/Reviewer_4TXw"
                    ]
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2979/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698797454740,
            "cdate": 1698797454740,
            "tmdate": 1699636242136,
            "mdate": 1699636242136,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "TccD43jH95",
                "forum": "7W4boWjb3Q",
                "replyto": "qLsNrKO41p",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2979/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2979/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal by Authors"
                    },
                    "comment": {
                        "value": "We thank you for your positive review and helpful comments. We address the main questions and concerns below:\n\n> AOL dataset is subject to controversy. I would recommend the author to remove experimental results about AOL.\n\nThank you for pointing this out -- we were not aware of this controversy. We initially included the results for AOL to be able to compare our algorithm with LCMS of Hsu et al. which reports results for the same dataset. We will remove it and look for a different search log dataset to replace it with.\n\n> Author may want to clarify the assumption on the stream and compare with some other popular summaries in the experiments to indicate the benefits of learning. If the stream is in insertion-only or in bounded-deletion model, then author should compare with the SpaceSaving algorithm. If the stream is in turnstile model, then the author should include comparison with Count Sketch.\n\nIn all the applications we consider, the stream is insertion only. However, our algorithm in principle can work in turnstile streams as well. Moreover, PL-CMS can be used with any base frequency estimation sketch, as long as we can derive a closed-form formula for the FPR that we can optimize to determine space allocations across the regions. For the Count-Min sketch, this formula leads to a convex program that we can efficiently solve. We have attempted to extend our approach to Count sketch but were not able to find a formula that we could efficiently optimize. Nonetheless, we agree that including an empirical comparison to other frequency estimation algorithms and their partitioned learned variants would be highly interesting.\n\n> I might have missed it. How is the score decided and is it learned in training? For instance, in Macbeth, the proposed algorithms use threshold 200|100, and 300|200|100\n\nThis is a great question. We choose the thresholds by performing a grid search on the training dataset and picking thresholds that yield the lowest average FPR in identifying $(\\epsilon,k)$-frequent items in a wide range of space allocations. Assuming the length of the testing dataset $n$, we scale the found thresholds by $n/n_{tr}$ where $n_{tr}$ is the length of the training dataset. Specifically, to find the first threshold $l_1$, we incrementally iterate through a wide range of cutoff values and report the one that yields the lowest FPR for LCMS on the training dataset. Next, we fix $l_1$ and perform another grid search to find the next cutoff $l_2< l_1$ which yields the lowest FPR for 2-CMS. Similarly, to find $l_3$ (where $l_3 < l_2$), we fix $l_1$ and $l_2$. We let $l_3$ be the cutoff value which yields the lowest FPR for 3-CMS using $l_1$,$l_2$ and $l_3$. In the final step, we rescale the thresholds by $n/n_{tr}$. We will include a more detailed description of the process in our paper."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2979/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700342326141,
                "cdate": 1700342326141,
                "tmdate": 1700342326141,
                "mdate": 1700342326141,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "oaRQ7IVX44",
                "forum": "7W4boWjb3Q",
                "replyto": "qLsNrKO41p",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2979/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2979/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal by Authors (cont.)"
                    },
                    "comment": {
                        "value": "> If the stream is in turnstile model, then the author should include comparison with Count Sketch (Charikar, Moses, Kevin Chen, and Martin Farach-Colton. \"Finding frequent items in data streams.\").\n\nIn section A.3.4 of the Appendix, we include additional results comparing the Partitioned Learned Count-Sketch (PL-CS) to our PL-CMS on the Zipfian datasets. In all the experiments we use the same parameters for PL-CS as for PL-CMS using the actual $E_i$ and $F_i$ values, since we do not know how to optimize its parameters to minimize the FPR. We also apply the same best cutoff thresholds. We observe that the standard and learned CS of Hsu et al. (denoted as CS and LCS, respectively) perform similarly to basic CMS and LCMS. For the Macbeth dataset with $n/k=16$, PL-CS with 3 Count-Sketches (denoted as 3CS-A) achieves a worse FPR than the baseline algorithms and 3-CMS-A. For Bible with $n/k=879$, 2CS-A also underperforms and yields a much higher FPR than the baseline algorithms and 2CMS-A. It is also important to mention that using Count-Sketch induces a small false negative rate in the task of identifying the frequent elements which is not present for Count-Min Sketch variants. While we do not expect the optimal PL-CS to provide significant advantages over PL-CMS, optimizing its parameters is an interesting future research direction."
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2979/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700577448596,
                "cdate": 1700577448596,
                "tmdate": 1700583241165,
                "mdate": 1700583241165,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "kVuYKcJz6k",
                "forum": "7W4boWjb3Q",
                "replyto": "oaRQ7IVX44",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2979/Reviewer_4TXw"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2979/Reviewer_4TXw"
                ],
                "content": {
                    "comment": {
                        "value": "What is the challenge to use the proposed framework in optimizing count sketch?\nPerhaps it is possible to use Chebyshev's inequality for equation (2) in analyzing count sketch and then union bound?"
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2979/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700633774258,
                "cdate": 1700633774258,
                "tmdate": 1700633774258,
                "mdate": 1700633774258,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "Jtd1unetHQ",
                "forum": "7W4boWjb3Q",
                "replyto": "qLsNrKO41p",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2979/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2979/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for the suggestion, we believe your approach could yield an optimizable FPR formula. Using Chebyshev's, for a single hash function we would have $Pr(|\\hat{f}_x - f_x|\\geq \\frac{\\epsilon n}{k}) \\leq\\frac{ k \\|f\\|_2^2}{m_i\\epsilon n}$. Union bounding over $t_i$ hash functions gives error probability $\\leq \\frac{ t_ik \\|f\\|_2^2}{m_i\\epsilon n}$, so our false positive formula becomes $\\text{FPR}\\leq \\sum_i^c F_i \\cdot\\frac{ t_ik \\|f\\|_2^2}{m_i\\epsilon n}$. Given total space $S$, setting $r_i\\cdot S = m_i\\cdot t_i$ ,  we get $\\text{FPR}\\leq \\sum_i^c F_i \\cdot\\frac{ t_i^2k \\|f\\|_2^2}{r_i S\\epsilon n}$. Since $t_i=0$ is a minimizer but is not valid, we could potentially set it as a constant $1$. \n\nThat would give the following optimization problem $\\min_{r_1,\\ldots r_c} \\sum_i^c F_i \\cdot\\frac{k\\|f\\|_2^2}{r_i S \\epsilon n}$ subject to $\\sum_i^c r_i = 1$ and $r_1, \\ldots, r_c \\geq 0$. Ignoring the second constraint, this can most likely be solved using Lagrange multipliers yielding a closed-form solution. \n\nHowever, since Count-Sketch takes the median of the $t$ estimates, this upper bound is too loose to be useful. Due to using the Union bound, the FPR increases with larger $t$. Using the Median trick would give a tighter upper bound, but also a more complex FPR upper bound formula to optimize. Nonetheless, it is an interesting next step to explore. It is important to note, that the final algorithm would still need to estimate the $F_i$ quantities."
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2979/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700691744416,
                "cdate": 1700691744416,
                "tmdate": 1700693209470,
                "mdate": 1700693209470,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "TLR30u69G4",
                "forum": "7W4boWjb3Q",
                "replyto": "Jtd1unetHQ",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2979/Reviewer_4TXw"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2979/Reviewer_4TXw"
                ],
                "content": {
                    "comment": {
                        "value": "That makes sense. Thanks for the detailed response.\nPerhaps see https://arxiv.org/pdf/1207.5200.pdf for the median of median trick for Count Sketch.\nI think this framework has great potential."
                    }
                },
                "number": 10,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2979/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700713627917,
                "cdate": 1700713627917,
                "tmdate": 1700713627917,
                "mdate": 1700713627917,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "kviHhkjbA9",
            "forum": "7W4boWjb3Q",
            "replyto": "7W4boWjb3Q",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2979/Reviewer_jB1e"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2979/Reviewer_jB1e"
            ],
            "content": {
                "summary": {
                    "value": "The paper studies the frequency estimation problem in the learning-based setting where we aim to improve the performance of algorithms with the help of machine learning prediction. In the previous work of (Hsu et al. 2019), the main idea is to use the machine learning method to participate items into two sets. Items with sufficiently high predicted frequencies have their frequencies tracked exactly, while the remaining items, with low predicted frequencies, are placed into the Count-Min Sketch data structure. In this work, the authors extend this idea and propose the partitioned learned count-min sketch(PL-CMS) where the algorithm partitions the items into multiple ranges based on the prediction. The paper studies how to set the threshold of each range to make the performance of the algorithm better formally (in this paper,  the estimation error metric is different where the authors aim to improve the false positive rate of identifying the heavy items). The experiments also show the advantages of the proposed algorithm."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1. The theoretical contribution of the paper is solid. The idea of extending the prediction to multiple ranges is natural. However, the analysis of how to set the thresholds of each range is not clear. The paper gives a formal analysis of this.\n\n2. The presentation of the paper is clear and easy to follow."
                },
                "weaknesses": {
                    "value": "1. The paper does not give a study of the cases when the machine learning prediction is noisy, which is one of the central parts of the previous works. In this work, we want to partition the items into multiple ranges, hence the requirement of the prediction precisions is even higher and the study of the algorithm using the noisy prediction is even more important. \n(one related model in [1] is rather than predict the range each item will be in, we instead assume the prediction can give an approximation of the frequency of each item. with an alpha additive error and beta multiplicative error)\n\n[1] Justin Chen et al. Triangle and Four-Cycle Counting with Predictions in Graph Stream. ICLR 2022"
                },
                "questions": {
                    "value": "1. In this paper, the definition of the heavy items we are interested in is the i such that $f_i \\ge n/k$. In a number of the works, the heavy hitter also be defined as $f_i \\ge \\sum_j f_j / k$, can the analysis in this work be extended to this model?\n\n2. In the experiments, the authors study the performance of the algorithm using both the ideal prediction and the noisy prediction. The result shows that there are still some gaps in performance between the two cases. I think it would be an interesting part if the author could give an (brief) analysis of the precision of the current prediction."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2979/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698811867674,
            "cdate": 1698811867674,
            "tmdate": 1699636242061,
            "mdate": 1699636242061,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "UBIci56qaK",
                "forum": "7W4boWjb3Q",
                "replyto": "kviHhkjbA9",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2979/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2979/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal by Authors"
                    },
                    "comment": {
                        "value": "Thank you for your time and helpful comments. We address the questions and concerns below:\n>The paper does not give a study of the cases when the machine learning prediction is noisy, which is one of the central parts of the previous works. In this work, we want to partition the items into multiple ranges, hence the requirement of the prediction precisions is even higher and the study of the algorithm using the noisy prediction is even more important. (one related model in [1] is rather than predict the range each item will be in, we instead assume the prediction can give an approximation of the frequency of each item. with an alpha additive error and beta multiplicative error)\n\nGiven fixed thresholds, even when the predictions are noisy or completely inaccurate, PL-CMS optimizes the space allocations of each CMS accordingly, which means that PLCMS is naturally robust. Specifically, we use the predictions to estimate the quantities $E_i$ and $F_i$ as well as the number of unique buckets from the training dataset. If, for example, we incorrectly place a large number of infrequent items in the first region, $F_1$ will be large and we will assign $\\text{CMS}_1$ a lot of space to lower its FPR. \n\nAs an example -- consider the case when our ML model is just a random oracle that uniformly assigns elements of the stream into different regions of PL-CMS, without any correlation to their actual frequencies. Further, assume that the number of unique buckets is small (which is typically true in practice). In this setting, one can show that the expected error of any item under PL-CMS is roughly equal to its expected error under the standard Count-Min sketch -- that is, when the learned model degenerates to random guesses, PL-CMS still matches the performance of the unlearned algorithm, indicating a high level of robustness. The argument here is just that, since a random oracle will allot every region a roughly equal fraction of infrequent items $F_i$ and a roughly equal total frequency of items $E_i$ and, as a result, each CMS will be assigned the roughly same amount of buckets $m_i$, we will have $\\frac{E_i}{m_i}\\approx \\frac{n/c}{m/c} = \\frac{n}{m}$, where $c$ is the number of regions. This is the same ratio (and in turn yields the same false positive rate) as if we assigned all items to a single CMS with $m$ buckets. Note that a similar argument would hold if the model assigned items to different regions with different probabilities. In this case, letting $p_i$ be the probability of an item being assigned to region $i$, we would have $m_i \\approx m \\cdot p_i$.\n\nTo verify the above argument, we have included additional experiments in section A.3.3 of the Appendix, where we show that given a learned model which outputs random predictions, 2-CMS and 3-CMS perform similarly to standard CMS and LCMS on the Zipfian datasets except for 3-CMS on the Macbeth dataset with $n/k=16$ which we are currently investigating.\\\\\n We agree that establishing a measure of prediction error such as an alpha additive error and beta multiplicative error would be a very interesting future direction and could potentially help us optimize the partition thresholds. \n\n> In this paper, the definition of the heavy items we are interested in is the $i$ such that $f_i\\geq n/k$. In a number of the works, the heavy hitter also be defined as $f_i\\geq \\sum_j f_j/k$, can the analysis in this work be extended to this model?\n\nWe define $n$ as the sum of all frequencies in the data stream so the definitions are equivalent. The number of distinct items in the stream does not directly come into our bounds.\n\n> In the experiments, the authors study the performance of the algorithm using both the ideal prediction and the noisy prediction. The result shows that there are still some gaps in performance between the two cases. I think it would be an interesting part if the author could give a (brief) analysis of the precision of the current prediction.\n\nWe believe the reviewer asks about the effect of estimating the $E_i$, and $F_i$ values on the algorithm's performance. We agree that it is an interesting direction to pursue. While we currently do not have a formal analysis of the estimates' precision, since we assume that the training dataset comes from the same distribution as the testing dataset, we expect the approximated $E_i$ and $F_i$ to be close to the true values (which we observe in practice)."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2979/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700342220049,
                "cdate": 1700342220049,
                "tmdate": 1700342220049,
                "mdate": 1700342220049,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "edIoZ1Cho4",
                "forum": "7W4boWjb3Q",
                "replyto": "UBIci56qaK",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2979/Reviewer_jB1e"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2979/Reviewer_jB1e"
                ],
                "content": {
                    "title": {
                        "value": "Response to the Authors"
                    },
                    "comment": {
                        "value": "Thanks for the detailed response. The authors show that even if the prediction is completely inaccurate (like a random oracle), the performance of the proposed approach will still be no worse than the standard approach. I think it will make the submission stronger if the author can make it into the main body of the paper. \n\nHowever, in my opinion, in addition to the worst-case guarantee, another important and interesting question here is under which condition, the noisy prediction will still make the algorithm have a strictly better performance than the standard approach? Or can the error be related to some quantity that measures how noisy the prediction is? Hence, my opinion is the current version of the paper is on the borderline of acceptance."
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2979/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700673299283,
                "cdate": 1700673299283,
                "tmdate": 1700673299283,
                "mdate": 1700673299283,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "YSFjMi6MGm",
            "forum": "7W4boWjb3Q",
            "replyto": "7W4boWjb3Q",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2979/Reviewer_PmnJ"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2979/Reviewer_PmnJ"
            ],
            "content": {
                "summary": {
                    "value": "In their paper, the authors introduce a novel approach for efficient heavy hitter frequency estimation, referred to as PL-CMS, which leverages a learned Count Min Sketch (CMS) technique across multiple score partitions generated from a trained model. This method builds upon prior research, notably the 'Learned Count Min Sketch' (LCMS), which employs a single score threshold, as well as the work of Dai and Shrivastava (2020) and Vaidya et al. (2020), where multiple partitions are utilized for a learned Bloom filter.\n\nThe key advantage of PL-CMS is its ability to achieve lower false positive rates while adhering to specific space constraints. The authors demonstrate the effectiveness of their approach through experiments conducted on four real-world datasets."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "4 excellent"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1. PL-CMS performs better with lower False Positive Rates compared to LCMS and CMS.\n2. The approach although derived and inspired from the existing works, fills are right gap in the literature of learned CMS structures.\n3. The theoretical analysis provided an upper bound on False positive rate."
                },
                "weaknesses": {
                    "value": "1. The solution is a simple extension of Dai and Shrivastava (2020) and Vaidya et.al. (2020) for LCMS. In my opinion it discounts the novelty. However it is not a strong criticism against the paper.\n2. Fig 2 legends will help.\n3. The choice of parameters are not well explained (page 7 para 4 and Section 4.5). How does that relate to Fig 2?\n4. page 7 para 4- \u201cWe ignore the space of the learned model itself, which is lower order is our settings\u201d. Please provide space taken by model and CMS tables together for each dataset to justify the statement."
                },
                "questions": {
                    "value": "1. Comparison with other 2 methods of Zhang et. al. (2020): The paper hinted that their approach involves highly accurate learned model and hence omitted for comparison. Are there ways to compare them on equal grounds?\n2. What is the model size for LCMS and PL-CMS for each datasets? Can we train them to achieve similar accuracy levels as in Zhang et. al. (2020)? What are the bottlenecks?\n3. Is the code available for replication of plots/results?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2979/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699565512860,
            "cdate": 1699565512860,
            "tmdate": 1699636241979,
            "mdate": 1699636241979,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "jCu8qO5NA2",
                "forum": "7W4boWjb3Q",
                "replyto": "YSFjMi6MGm",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2979/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2979/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal by Authors"
                    },
                    "comment": {
                        "value": "Thank you for your positive review and helpful comments. We address the main questions and concerns below:\n> The choice of parameters are not well explained (page 7 para 4 and Section 4.5). How does that relate to Fig 2?\n\nWe choose the thresholds by performing a grid search on the training dataset and picking thresholds that yield the lowest average FPR in identifying $(\\epsilon,k)$-frequent items in a wide range of space allocations. Assuming the length of the testing dataset $n$, we scale the found thresholds by $n/n_{tr}$ where $n_{tr}$ is the length of the training dataset. Specifically, to find the first threshold $l_1$, we incrementally iterate through a wide range of cutoff values and report the one that yields the lowest FPR for LCMS on the training dataset. Next, we fix $l_1$ and perform another grid search to find the next cutoff $l_2< l_1$ which yields the lowest FPR for 2-CMS. Similarly, to find $l_3$ (where $l_3 < l_2$), we fix $l_1$ and $l_2$. We let $l_3$ be the cutoff value which yields the lowest FPR for 3-CMS using $l_1$,$l_2$ and $l_3$. In the final step, we rescale the thresholds by $n/n_{tr}$. We will include a more detailed description of the process in our paper.\n\nFigure 2 explains the motivation behind introducing the parameter $p$ in our theoretical false positive rate upper bound to make the bound more closely reflect the false positive rates observed in practice. We use the updated formula to optimize the space allocations of each region and its parameters given fixed thresholds found from the grid search. Note, that the thresholds determine the $E_i$ and $F_i$ parameters in each region used to optimize the space allocations.\n\n> Comparison with other 2 methods of Zhang et. al. (2020): The paper hinted that their approach involves highly accurate learned model and hence omitted for comparison. Are there ways to compare them on equal grounds?\n\nWe were not able to compare the two algorithms on equal grounds on the Beijing PM2.5 dataset. We trained a learned model according to the approach of Zhang et al. with the same architecture and specified $5\\%$ training dataset split size as well as the reported parameters but our resulting model was not accurate and had an MSE of $31552.73$. Since the authors' algorithm relies on accurate predictions and they did not describe how to optimize its parameters, we were not able to proceed further. We also tried to run Zhang's algorithm using our model's architecture and the same train-test ratio of 8:2. For $n/k=420$ with space allocation of $1954$ units, Zhang's algorithm (with parameters reported in their paper) yields an FPR of $0.9$, whereas PLCMS achieves a much lower FPR of $0.367$ for the same space budget. \n\n> What is the model size for LCMS and PL-CMS for each datasets? Can we train them to achieve similar accuracy levels as in Zhang et. al. (2020)? What are the bottlenecks? \n\nWe use the same learned model for LCMS and PL-CMS. The size of the model for the Zipfian datasets is equal to the size of the dictionary that stores the rank of each word in the training dataset. Following the approach of Hsu et al., we focus on the space complexity of the data structure instead of its learned model which can be amortized over time (i.e., if identifying frequent items over many days or other time periods, the model remains fixed, while a new data structure is used in each round). \n\nSince the approach of Zhang et al. requires adjusting the frequencies of items during training, it cannot be directly applied to the Zipfian datasets. Furthermore, Zhang's algorithm requires retraining the model for every different $n/k$ value as well as fine-tuning many of its parameters.\n\n> Is the code available for replication of plots/results?\n\nWhile the code is not currently published, we are working to make it available."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2979/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700342048848,
                "cdate": 1700342048848,
                "tmdate": 1700342048848,
                "mdate": 1700342048848,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]