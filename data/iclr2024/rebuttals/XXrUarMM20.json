[
    {
        "title": "Efficient and Quantization-Friendly Ternary Fourier Convolution Algorithms"
    },
    {
        "review": {
            "id": "qevOnsIybp",
            "forum": "XXrUarMM20",
            "replyto": "XXrUarMM20",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission3779/Reviewer_NNvf"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission3779/Reviewer_NNvf"
            ],
            "content": {
                "summary": {
                    "value": "- To address the issue of numerical errors caused by model quantization in the complex domain, the authors present a novel fast convolution algorithm referred to as Ternary Fourier Convolution (TFC) that utilizes ternary matrices for input and weight transformations before multiplication.\n- The proposed TFC is derived from the implementation of symbolic arithmetic on the Fourier transform to eliminate the involvement of irrational numbers.\n- And, the authors incorporate correction terms to convert ineffective circular convolution results into efficient ones. The proposed method achieves 3.68\u00d7, 4.89\u00d7, and 4.54\u00d7 theoretical multiplication complexity reduction for 3\u00d73, 5\u00d75, and 7\u00d77 convolutions, respectively.\n- Moreover, the corresponding post-training quantization method requires only a few samples for calibrating network parameters and restoring accuracy without the high cost of retraining. The extensive experiments demonstrate an accuracy drop of less than 0.2% under Int8 quantization for models trained on ImageNet."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "- (+) The proposed TFC addresses the issue of numerical errors caused by model quantization in a complex domain in a simple way and shows the efficiency in convolutions.\n- (+) The method introduces a simple calibrating network parameter to minimize quantization errors and shows comparisons for quantization bits results."
                },
                "weaknesses": {
                    "value": "- (-) It seems to lack qualification results to support Table 2 such as comparisons of feature maps.\n- (-) The ablation study on scale factor (e.q. 14) seems to be needed for its effectiveness.\n- (-) We need an architecture table to compare one (TFC) with the others regarding layer-wise output size and number of parameters."
                },
                "questions": {
                    "value": "- Please see the above weak points."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "details_of_ethics_concerns": {
                    "value": "None."
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission3779/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698563502074,
            "cdate": 1698563502074,
            "tmdate": 1699636334530,
            "mdate": 1699636334530,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "eXqznO4hes",
                "forum": "XXrUarMM20",
                "replyto": "qevOnsIybp",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission3779/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission3779/Authors"
                ],
                "content": {
                    "title": {
                        "value": "To Reviewer NNvf"
                    },
                    "comment": {
                        "value": "We thank you for your reviews and address your concerns as follows.\n\n**Q1**: It seems to lack qualification results to support Table 2 such as comparisons of feature maps.\n\n**A1**: Since we opt for a classification task on Imagenet dataset in the comparison experiments, the model accuracy serves as an indicator of the algorithm's quality. For example, using our proposed SFC6(7\u00d77, 3\u00d73) algorithm under Int8 arithmetic, the accuracy reduction is to only 0.15%, which substantially outperforms similar fast convolution quantization work.\n\n**Q2**: The ablation study on scale factor (e.q. 14) seems to be need for its effectiveness.\n\n**A2**: We add new ablation experiments on the scaling factor. The detailed results are given in **Table R1-2**. \n\n**Table R1**\n\n| Resnet18(69.76%) | Minmax | Scaling Factor Fine-tune |\n| ---------------- | ------ | ------------------------ |\n| Accuracy         | 67.42  | 69.58                    |\n\nWe can see by involving scaling factor fine-tune scheme, the model accuracy is better preserved.\n\nWe also add ablation experiments on the grain of scaling factor. A fine-grain scaling factor can improve the accuracy of quantized models, but it may affect the deployment efficiency on hardware. For activation, frequency-wise quantization is necessary. For filters, channel-wise and frequency-wise yield similar results, both outperforming tensor-wise. Where hardware permits, simultaneous frequency-wise and channel-wise quantization would give the best results.\n\n**Table R2**\n\n| scaling factor grain of Activations | Tensor-wise  | Frequency-wise | Frequency-wise | Frequency-wise              |\n| ----------------------------------- | ------------ | -------------- | -------------- | --------------------------- |\n| scaling factor grain of filters     | Channel-wise | Channel-wise   | Frequency-wise | Frequency-wise+Channel-wise |\n| Accuracy                            | 69.18        | 69.54          | 69.55          | 69.58                       |\n\n**Q3**: We need an architecture table to compare one (TFC) with the others regarding layer-wise output size and number of parameters.\n\n**A3**: Applying our method or a fast convolution algorithm does not increase the number of parameters in the model or change the size of the layer output. The parameters of the transformation matrix in our algorithms are often incorporated as fixed values in the program or designed for dedicated domain accelerators, rather than being stored as additional parameters. When combining our method with quantization, the storage of the quantized scaling factor is required, but this demand is minimal compared to the number of original parameters in the network."
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission3779/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700417580078,
                "cdate": 1700417580078,
                "tmdate": 1700417580078,
                "mdate": 1700417580078,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "1mK5aum4oa",
                "forum": "XXrUarMM20",
                "replyto": "eXqznO4hes",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission3779/Reviewer_NNvf"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission3779/Reviewer_NNvf"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your detailed explanations and extensive experiments.  I will keep my score. It needs to include more ablation studies on feature maps and training/test time to show its effectiveness."
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission3779/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700532150512,
                "cdate": 1700532150512,
                "tmdate": 1700532150512,
                "mdate": 1700532150512,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "mA2t6RfCpf",
                "forum": "XXrUarMM20",
                "replyto": "qevOnsIybp",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission3779/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission3779/Authors"
                ],
                "content": {
                    "title": {
                        "value": "To Reviewer NNvf Part II"
                    },
                    "comment": {
                        "value": "Thank you for your timely and helpful feedback. We have made revision to address your concerns in the latest revised version. Let we address your concerns as follows.\n\n\n\n1. **Absolution studies on feature map.**\n\n In the **Appendix A.2**, we plot the layer-wise Mean Squared Error (MSE) error of feature maps as the qualification metric to compared different algorithms, using AdaQuant[1] as the fine-tune method. Some of its contents are shown in Table R3:\n\n**Table R3. MSE error of feature maps for different algorithms**\n\n| Resnet18,conv4.1.2    | Standard convolution |        | Winograd (4\u00d74, 3\u00d73) |      | SFC6 (7\u00d77, 3\u00d73) |        |\n| --------------------- | -------------------- | ------ | ------------------- | ---- | --------------- | ------ |\n| is fine-tune          | No                   | Yes    | No                  | Yes  | No              |        |\n| MSE error to FP model | 2.7e-3               | 2.8e-4 | 1.3                 | 0.36 | 2.3e-2          | 6.8e-3 |\n\nWe can see that, in our proposed SFC algorithm, **the MSE loss of feature maps is significantly lower than that in the Winograd algorithm**. However, it is worth noting that, when using the scaling-factor fine-tune method, the MSE loss of feature maps in the SFC algorithm is smaller than that in the standard convolution, while the accuracy of the quantized model does not improve. It enlightens us that the MSE error of the feature map is not the sole criterion to judge the quantization quality.\n\n2. **Absolution studies on training time.**\n\nWe compared our PTQ method and the QAT[2] method on VGG-16 networks under CIFAR-10 dataset to prove the effectiveness of our method. \n\nHowever, we observed that, when employing the SFC4(44,33) algorithm with sufficient quantization-aware training time, the final accuracy can surpass that of the floating-point model. We suspect that this improvement is attributed to the fact that the SFC algorithm is based on the Fourier transform, and the processing properties for images endowed by the Fourier transform (referred to as the **Frequency Principle[5]**) enhance the model's performance after extensive training. As a result, we provide two quantization-aware training times: one for recovering the accuracy of the FP32 model and another for converging to the highest accuracy, serving as a reference.\n\n**Table R4. Training time**\n\n| VGG16 (92.6%) | QAT[2] 8bit  |              | PTQ (ours) 8bit |\n| ------------- | ------------ | ------------ | --------------- |\n| Time          | 22min(92.6%) | 39min(93.4%) | 17s(92.6%)      |\n\nOur PTQ method accelerates the training time for recovering model accuracy by a factor of 78\u00d7.\n\n\n\n3. **Absolution studies on testing(inference) time.**\n\nThere has been considerable work on deploying & optimizing Winograd algorithm on CPUs[3] and GPUs[4]. As our algorithm can be computed in the same computational flow as the Winograd, its deployment has no serious technical problems.\n\nWe implement our proposed symbolic Fourier convolution algorithm on our laptop GPU to validate that its can provides real-world inference speedups, substantiating not only theoretical computational reductions. For comparison, we evaluated our method against the CUDA Deep Neural Network library (cuDNN)[6] in the context of the 3\u00d73 convolution layer for inference. Because of the time limitation, we were unable to implement the algorithm across entire networks or in Int8 format. As we can see, our algorithms demonstrates a 1.75x speedup compared to cuDNN.\n\n**Table R5. Inference Convlayer with BatchSize=1, KernelSize=3\u00d73\uff0cFeatureMap=28\u00d728\uff0cChannel=128\u00d7128 and fp32 format on Nvidia GTX 1650 Laptop GPU**\n\n|      | cuDNN | im2col | SFC4(4\u00d74, 3\u00d73) |\n| ---- | :---: | ------ | -------------- |\n| time | 128us | 194us  | **73us**           |\n\n\n\n[1] Hubara, Itay, et al. \"Improving post training neural quantization: Layer-wise calibration and integer programming.\" *arXiv preprint arXiv:2006.10518* (2020).\n\n[2] Andri, Renzo, et al. \"Going further with winograd convolutions: Tap-wise quantization for efficient inference on 4x4 tiles.\" *2022 55th IEEE/ACM International Symposium on Microarchitecture (MICRO)*. IEEE, 2022.\n\n[3] Maji, Partha, et al. *Efficient Winograd or Cook-Toom Convolution Kernel Implementation on Widely Used Mobile CPUs*. IEEE, 2019\n\n[4] Jia, Liancheng, et al. \u201cEnabling Efficient Fast Convolution Algorithms on GPUs via MegaKernels.\u201d *IEEE Transactions on Computers*, 2020, pp. 1\u20131\n\n[5] Xu, Z., et al. \u201cOverview Frequency Principle/Spectral Bias in Deep Learning.\u201d *arXiv.Org*, 2022.\n\n[6] Chetlur, Sharan, et al. *cuDNN: Efficient Primitives for Deep Learning*. 2014."
                    }
                },
                "number": 10,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission3779/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700595302540,
                "cdate": 1700595302540,
                "tmdate": 1700742253796,
                "mdate": 1700742253796,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "m1uttmsgQK",
            "forum": "XXrUarMM20",
            "replyto": "XXrUarMM20",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission3779/Reviewer_tjrq"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission3779/Reviewer_tjrq"
            ],
            "content": {
                "summary": {
                    "value": "This paper explores techniques for accelerating fast convolution algorithms based on Fourier transform through quantization. To mitigate the impact of quantization error, the paper utilized a ternary transformation matrix derived from symbolic arithmetic applied to the Fourier transform. Furthermore, the paper combines post-training quantization (PTQ) approach to enable INT8 quantization. The methods achieve a reduction on theoretical computation complexity while showing negligible accuracy loss on ResNet ImageNet benchmarks."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1). The paper is well written. The algorithm is clearly explained and easy to follow.\n\n2). The results show clear improvement on both the computation complexity reduction, while preserving the model accuracy at INT8."
                },
                "weaknesses": {
                    "value": "1). The use of \u201cTernary\u201d in the title is misleading, as ternary refers to an intermediate transform matrix; the actual precision is INT8.\n\n2). One of the primary concerns is the speedup achieved through current approach. The paper only provides theoretical multiplication complexity reduction, which may not necessarily translate to real-world speedup. Given the complexity of the algorithm and the potential overhead, it is important to provide empirical measurements of computation efficiency. \n\n3). PTQ method is a well-established technique.\n\n4). The evaluation is only performed on ResNet models, which, while important, are somewhat outdated. It would be benificail to evaluate the methods across a more extensive range of CNN models, particularly the compact ones like EfficientNet and MobileNet.\n\n5). Today, numerous techniques exist for accelerating CNN models, including the design of compact architecture, sparsity, distillation, and quantization. For quantization alone, it is possible to reduce precision to sub-4 bit level while preserving model accuracy. The paper only compares its approach to other fast convolution algorithms, such as Winograde, and while it demonstrates improvement, it is challenging to evaluate the significance of this approach compared to toher alternatives."
                },
                "questions": {
                    "value": "In addition to weaknesses above, \n\n1). How will this method be used for filters with smaller sizes, such as 1x1 and depth-wise conv layers?\n\n2). Figure 3, the blue line for standard convolution does not seem to use SOTA PTQ techniques, which can effectively close the accuracy gap for INT4 (such as ref. 1 and 2).\n\n3). Typo? Page 2, contribution 1 paragraph, x, x, and 7x7."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission3779/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698721963439,
            "cdate": 1698721963439,
            "tmdate": 1699636334441,
            "mdate": 1699636334441,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "tgSZdoFSrX",
                "forum": "XXrUarMM20",
                "replyto": "m1uttmsgQK",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission3779/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission3779/Authors"
                ],
                "content": {
                    "title": {
                        "value": "To Reviewer tjrq Part I"
                    },
                    "comment": {
                        "value": "Thank you for pointing out many important issues. We have made revisions to address your concerns in the revised version. The revision can be summarized as follows:\n\n1. We have revised the name of our proposed algorithm to Symbolic Fourier Convolution (SFC), replacing the prior name of Ternary Fourier Convolution (TFC).\n\n2. We have involved Bit Operations(BOPs)[1] [2] [3] as a alternative metric to precisely quantify computation costs/acceleration ratio.\n\n3. We have involved a sota PTQ baseline AdaQuant[4], this method improve the result of bsl and our algorithms under Int4 quantization.\n\n4. We have corrected the typos in the revised version.\n\nAnd then let we address your concerns as follows.\n\n**Q1**:  The use of \u201cTernary\u201d in the title is misleading, as ternary refers to an intermediate transform matrix; the actual precision is INT8.\n\n**A1**: We apologize for the confuse in our initial preparation. We have updated the name of our proposed algorithm to **Symbolic Fourier Convolution (SFC)**, replacing the previous designation of Ternary Fourier Convolution (TFC). The new name more accurately reflects the underlying concept of our algorithm. The earlier name could potentially be misleading, suggesting the use of three-valued computation throughout the entire convolution process.\n\n\n\n**Q2**:  One of the primary concerns is the speedup achieved through current approach. The paper only provides theoretical multiplication complexity reduction, which may not necessarily translate to real-world speedup. Given the complexity of the algorithm and the potential overhead, it is important to provide empirical measurements of computation efficiency.\n\n**A2**: Thanks you for your suggestion. **First, we implement our proposed symbolic Fourier convolution algorithm on our Laptop GPU to validate that its can provides real-world speedups**, substantiating not only theoretical computational reductions. For comparison, we evaluated our method against the CUDA Deep Neural Network library (cuDNN) in the context of the 3\u00d73 convolution layer for inference. Because of the time limitation, we were unable to implement the algorithm across entire networks in Int8 format.  As we can see, our algorithms demonstrates a 1.75x speedup compared to cuDNN.\n\n**Table R1. Inference fp32 Conv with BatchSize=1, KSize=3\u00d73\uff0cFMSize=28\u00d728\uff0cC=128\u00d7128 on Nvidia GTX 1650 Laptop GPU**\n\n|      | cuDNN | im2col | SFC  |\n| ---- | :---: | ------ | ---- |\n| time | 128us | 194us  | 73us |\n\nFurthermore, we opt for **Bit-Operations(BOPs)** as a fine metric to precisely quantify computation costs.  This metric comprehensively considers factors such as **bit-width,  operations number, and the varying hardware costs of addition and multiplication**. And it is widely used in various model compressing fields, including  Neural Architecture Search(NAS)[6], quantization[5] [7] and pruning [5] research.  BOPs for integer addition are defined as $BOPs = b \\cdot ADDs$, where '$b$' represents the addition bit-width. Similarly, BOPs for integer multiply-and-accumulate are defined as $BOPs = b1 \\cdot b2 \\cdot MACs$, where '$b1$' and '$b2$' represent the bit-widths of the two operators, respectively.\n\nFor element-wise multiplication, our method consumes $MACs=Tnums\\cdot TransSize\\cdot TransSize\\cdot IC\\cdot OC$ when deploying a dense convolution layer, where $ Tnums = ceil(H/TileSize)\\cdot ceil(W/TileSize)$. And the input transformation consumes $ADDs = Tnum\\cdot ((TileSize+KernelSize)\\cdot TransSize)(TileSize+KernelSize+TransSize)\\cdot IC$,  the output transformations consumes $ADDs = Tnum\\cdot (TileSize\\cdot TransSize)(TileSize+TransSize)\\cdot OC$.\n\nWhen the arithmetic bit-width=8, we can find that $BOPs_{ElementWiseMult} >> BOS_{OutTrans} \\approx BOS_{InTrans}$, which is why many works based on fast convolution primarily considers only element-wise multiplication numbers when calculating the speedup ratio.\n\nThe BOPs of different methods are shown in Table R2. Compared to the state-of-the-art PTQ method AdaQuant[1], SFC method can **significantly reduce the MACs while maintaining narrow bit-width in multiplication**, thus obtaining lower BOPs. In comparison with Winograd-based work[2], our algorithm **does not need to expand the intermediate arithmetic bit-width to maintain the model accuracy**, and thus the BOPs are also lower.\n\n**Table R2. BOPs of ResNet18(69.76%)**\n\n|           | AdaQuant(PTQ)[1] |       | Wino(4\u00d74, 3\u00d73)+QAT[2] | SFC6(7\u00d77, 3\u00d73)+PTQ | SFC4(4\u00d74, 3\u00d73)+PTQ | SFC4(4, 3)+PTQ |\n| --------- | ---------------- | ----- | --------------------- | ------------------ | ------------------ | -------------- |\n| Bit-width | 8                | 4     | 8/10                  | 8                  | 8/6                | 8/4            |\n| Accuracy  | 69.73            | 63.47 | 69.41                 | 69.58              | 69.04              | 63.02          |\n| BOPs      | 96.2G            | 24.1G | 44.3G                 | **34.3G**          | **22.8G**          | **15.8G**      |"
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission3779/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700417353699,
                "cdate": 1700417353699,
                "tmdate": 1700742525009,
                "mdate": 1700742525009,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "dV9pGiHAO2",
                "forum": "XXrUarMM20",
                "replyto": "m1uttmsgQK",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission3779/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission3779/Authors"
                ],
                "content": {
                    "title": {
                        "value": "To Reviewer tjrq Part II"
                    },
                    "comment": {
                        "value": "**Q3**:  PTQ method is a well-established technique.\n\n**A3**: While the PTQ method is a well-established technique, previous work could not perfectly combine it with fast convolutional algorithms to achieve further speedup. For example, the method in ref [3] results in a 2.2%  accuracy reduction for Resnet18 under Int8 PTQ, and in ref [4], there was a 4.6%  accuracy reduction in Resnet18 under Int6 PTQ.  In contrast, our method can be effectively combined with the PTQ with only 0.1% accuracy loss under Int8 and 0.7% under Int6 (Table R2). \n\n\n\n**Q4**: The evaluation is only performed on ResNet models, which, while important, are somewhat outdated. It would be benificail to evaluate the methods across a more extensive range of CNN models, particularly the compact ones like EfficientNet and MobileNet.\n\n**A4**\uff1aIn this paper, we done experiments on ResNets and compared with other works. Here, we add new experiments on VGG16, EfficientNetB0 and Mobilenetv2 under the Cifar10 datasets. The results are in alignment with our expectations, and all models consistently maintained accuracy.\n\n**Table R3. Accuracy on VGG16, Mobilnetv2 and EfficientnetB0**\n\n| Model      | VGG16 (92.64%)   |                  | Mobilnetv2 (94.43%) |                  | EfficientnetB0 (94.73%) |                  |\n| ---------- | ---------------- | ---------------- | ------------------- | ---------------- | ----------------------- | ---------------- |\n| Algorithms | TFC4(44,33)+Int8 | TFC6(66,33)+Int8 | TFC4(44,33)+Int8    | TFC6(66,33)+Int8 | TFC4(44,33)+Int8        | TFC6(66,33)+Int8 |\n| Accuracy   | 92.79%           | 92.61%           | 94.38%              | 94.37%           | 94.67%                  | 94.75%           |\n\n\n\n**Q5:** Today, numerous techniques exist for accelerating CNN models, including the design of compact architecture, sparsity, distillation, and quantization. For quantization alone, it is possible to reduce precision to sub-4 bit level while preserving model accuracy. The paper only compares its approach to other fast convolution algorithms, such as Winograd, and while it demonstrates improvement, it is challenging to evaluate the significance of this approach compared to other alternatives.\n\n**A5:** **The motivation of this paper is to enhance the compatibility of fast convolution algorithms with quantization methods, aiming to achieve improved compression performance by combining them**. Fast convolutional algorithms have many advantages, including their **suitability across various hardware platforms**, including CPUs[8], GPUs[9], domain specific accelerators[2]. Other acceleration methods like extreme low-bit quantization and sparsity are more dependent on the support of the hardware architecture for their respective function. For example, Nvidia Turing GPUs can only support specific quantization formats (Int8 and Int16) and sparsity templates (4:2 sparsity).\n\nDiscussion in terms of quantization alone: Although achieving sub-4bit quantization and maintaining model accuracy is possible through Quantization-aware Training (QAT) [10], it requires the entire dataset and significant training resources.  In our work, we leverage Post-training quantization (PTQ), which is more lightweight, requiring only a small dataset and estimating parameters in a few minutes. Compared to the sota PTQ alone method AdaQuant[1], our method can achieve **much higher accuracy under similar BOPs or much lower BOPs under similar accuracy**(Table R4). Finally, we believe that our  SFC algorithm can also achieve sub 4-bit quantization via QAT, although we have not attempted it yet.\n\n **Table R4. BOPs of ResNet18(69.76%)**\n\n|           | AdaQuant(PTQ)[1] | SFC4(4\u00d74, 3\u00d73)+PTQ | SFC4(4, 3)+PTQ |\n| --------- | ---------------- | ------------------ | -------------- |\n| Bit-width | 4                | 8/6                | 8/4            |\n| Accuracy  | 63.47            | **69.04**          | 63.02          |\n| BOPs      | 24.1G            | 22.8G              | **15.8G**      |\n\n\n\nDiscussion in terms of sparsity: The irregular data flow resulting from sparsity poses a significant challenge to hardware architecture design, often leading to hardware inefficiency. Unlike PTQ methods, sparse methods, to maintain accuracy, have high training costs. Furthermore, sparse methods are not incompatible with fast convolutional algorithms; **a previous study [11] explores sparsity in the Winograd domain**. Therefore, we believe that our SFC algorithm can be effectively combined with sparsity methods in the transformation domain.\n\nDiscussion in terms of distillation: We think our algorithm is not in conflict with knowledge distillation. Our method provide a fast algorithm for convolution and it is also friendly for quantization. And knowledge distillation is to train a smaller, student model to reproduce the behavior of a larger, teacher model. We can view them as distinct  stages in the model compression pipeline."
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission3779/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700417448229,
                "cdate": 1700417448229,
                "tmdate": 1700673040083,
                "mdate": 1700673040083,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "T7yTL1aA3x",
                "forum": "XXrUarMM20",
                "replyto": "m1uttmsgQK",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission3779/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission3779/Authors"
                ],
                "content": {
                    "title": {
                        "value": "To Reviewer tjrq Part III"
                    },
                    "comment": {
                        "value": "**Q6**: How will this method be used for filters with smaller sizes, such as 1x1 and depth-wise conv layers?\n\n**A6**: Our method can accelerate 3\u00d73 and lager size convolutions very efficiently (the only fast convolution algorithm to our knowledge that can accelerate 3\u00d73 convolutions by more than 3\u00d7 at Int8 without loss of accuracy), but it does not work for 1\u00d71 convolutions. However, our algorithm may affect the application value of the 1\u00d71 convolution. In many compact architectures, 1\u00d71 convolutions are designed to reduce calculations, but can not extract features in the spatial dimension like 3\u00d73. When the overhead of 3\u00d73 convolution is greatly reduced (our method can reduce it by 3.68\u00d7), the significance of this design purpose may not be as significant as before. \n\nOur method can work for depth-wise convolution. However, according to the roof-line model, the inference bottleneck for depth-wise convolution is not in computation but in data transmission(low activation reuse on channel dimension). Thus reducing its computational complexity may not increase its inference speed. Data compression techniques for activation and weights may be more significant for accelerating depth-wise convolution.\n\n\n**Q7**:  Figure 3, the blue line for standard convolution does not seem to use SOTA PTQ techniques, which can effectively close the accuracy gap for INT4 (such as ref. 1 and 2).\n\n**A7**:  Thanks for your suggestion, in our revised manuscript we involved a sota PTQ baseline **AdaQuant[1]**, this method improve the result of bsl and our algorithms under 4-bit quantization. **However, for the Winograd convolution, there are convergence problems and the results are even worse**. This is the why the way recent quantization works for Winograd unify utilized method based on gradients backward propagation[2] [3] [4].\n\n**Table R5. Partial results of Figure 3 in the revised manuscript**\n\n|           | Wino(44,33)        |              | standard convolution |          | SFC(77,33)         |          | SFC(4, 3) |\n| --------- | ------------------ | ------------ | -------------------- | -------- | ------------------ | -------- | --------- |\n| method    | gradients backward | AdaQuant     | gradients backward   | AdaQuant | gradients backward | AdaQuant | AdaQuant  |\n| bit-width | 8                  | 8            | 4                    | 4        | 4                  | 4        | 4         |\n| accuracy  | 67.32              | **8.586\u2193\u2193\u2193** | 60.52                | 63.47\u2191   | 53.82              | 55.84\u2191   | 63.02     |\n\n\n\n**Q8**: Typo? Page 2, contribution 1 paragraph, x, x, and 7x7.\n\n**A8**: Thank you tor your careful reading. We apologize for our oversights. We have corrected these typos in our revised manuscript . \n\n\n\n[1] Hubara, Itay, et al. \"Improving post training neural quantization: Layer-wise calibration and integer programming.\" *arXiv preprint arXiv:2006.10518* (2020).\n\n[2] Andri, Renzo, et al. \"Going further with winograd convolutions: Tap-wise quantization for efficient inference on 4x4 tiles.\" *2022 55th IEEE/ACM International Symposium on Microarchitecture (MICRO)*. IEEE, 2022.\n\n[3] Chikin, Vladimir, and Vladimir Kryzhanovskiy. \"Channel balancing for accurate quantization of winograd convolutions.\" *Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition*. 2022.\n\n[4] Tianqi, Chen, et al. \"Towards Efficient and Accurate Winograd Convolution via Full Quantization.\" *Thirty-seventh Conference on Neural Information Processing Systems*. 2023.\n\n[5] Wang, Ying, Yadong Lu, and Tijmen Blankevoort. \"Differentiable joint pruning and quantization for hardware efficiency.\" *European Conference on Computer Vision*. Cham: Springer International Publishing, 2020.\n\n[6] Guo, Zichao, et al. \"Single path one-shot neural architecture search with uniform sampling.\" *Computer Vision\u2013ECCV 2020: 16th European Conference, Glasgow, UK, August 23\u201328, 2020, Proceedings, Part XVI 16*. Springer International Publishing, 2020.\n\n[7] Liu, Zechun, et al. \"Reactnet: Towards precise binary neural network with generalized activation functions.\" *Computer Vision\u2013ECCV 2020: 16th European Conference, Glasgow, UK, August 23\u201328, 2020, Proceedings, Part XIV 16*. Springer International Publishing, 2020.\n\n[8] Maji, Partha, et al. *Efficient Winograd or Cook-Toom Convolution Kernel Implementation on Widely Used Mobile CPUs*. IEEE, 2019\n\n[9] Jia, Liancheng, et al. \u201cEnabling Efficient Fast Convolution Algorithms on GPUs via MegaKernels.\u201d *IEEE Transactions on Computers*, 2020, pp. 1\u20131\n\n[10] Rastegari, Mohammad, et al. \"Xnor-net: Imagenet classification using binary convolutional neural networks.\" *European conference on computer vision*. Cham: Springer International Publishing, 2016.\n\n[11] Liu, Xingyu, et al. \u201cEfficient Sparse-Winograd Convolutional Neural Networks.\u201d *International Conference on Learning Representations*, 2018."
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission3779/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700417491136,
                "cdate": 1700417491136,
                "tmdate": 1700673361895,
                "mdate": 1700673361895,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "7Sx8veraov",
            "forum": "XXrUarMM20",
            "replyto": "XXrUarMM20",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission3779/Reviewer_uiWW"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission3779/Reviewer_uiWW"
            ],
            "content": {
                "summary": {
                    "value": "The paper introduces a new fast convolution algorithm that uses ternary matrices for transformations, minimizing these quantization errors. This technique is based on symbolic arithmetic applied to the Fourier transform, avoiding irrational numbers, and includes correction terms to improve the convolution results' efficiency. A novel post-training quantization method is also proposed, which calibrates network parameters using only a few samples, thus avoiding the need for expensive retraining. The proposed algorithms significantly reduce multiplication complexity\u2014up to 4.89\u00d7 for common convolution sizes\u2014and demonstrate an impressively low accuracy drop of less than 0.2% on ImageNet models under Int8 quantization. This performance surpasses competing methods, offering a more efficient and accurate approach for CNN deployment in resource-constrained environments."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "1 poor"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1. using symbolic operation instead of numerical computation is very attractive. The demonstration of the proposed idea is very solid and sound. \n2. I really appreciate the quantization method based on the frequency. The observation that a relation between the energy distribution and the frequency channel coordinates is very promising.\n2. The evaluation result is very significant, about a 5x reduction in multiplicative complexity compared with other works."
                },
                "weaknesses": {
                    "value": "1. The writing of this paper is very hard to follow. Many typos are in the paper, such as some numbers are missing in the first contribution of section Introduction \" x x \", and the bottom line is missing in Table 2. \n2. The motivation for this paper is not clear. Since many compression works like extreme low-bit quantization, pruning, and low-rank decomposition are proposed to accelerate the convolution layers, the motivation using Fourier transformation is not clear.\n3. The evaluation is not sufficient. The metric in evaluation is multiplicative complexity, however, the compression ratio and real-time acceleration performance are missing."
                },
                "questions": {
                    "value": "1. It would be better to provide the real-time latency to show the acceleration performance on hardware platforms like GPU/FPGA/CPU. The theoretical reduction in the multiplication operation.\n2. Can this method be used in other layers? For example, FC can be seen as a special CNN layer with a kernel size being 1, and what if the proposed method is applied to FC layers?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission3779/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission3779/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission3779/Reviewer_uiWW"
                    ]
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission3779/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698780866363,
            "cdate": 1698780866363,
            "tmdate": 1699636334315,
            "mdate": 1699636334315,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "NPnOVVOcWD",
                "forum": "XXrUarMM20",
                "replyto": "7Sx8veraov",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission3779/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission3779/Authors"
                ],
                "content": {
                    "title": {
                        "value": "To Reviewer uiWW Part I"
                    },
                    "comment": {
                        "value": "Thank you for pointing out many important issues. We have made revisions to address your concerns in the revised version. The revision can be summarized as follows:\n\n1. We have corrected the typos in the revised version.\n2. We have strengthened the expression of motivation in the abstract and introduction.\n3. We have involved Bit Operations(BOPs)[1] [2] [3] as a alternative metric to precisely quantify computation costs/acceleration ratio.\n\nAnd then let we address your concerns as follows.\n\n**Q1**: The writing of this paper is very hard to follow. Many typos are in the paper, such as some numbers are missing in the first contribution of section Introduction \" x x \", and the bottom line is missing in Table 2.\n\n**A1**: Thank you tor your careful reading of our paper. We have corrected these typos in our latest manuscript . \n\n\n**Q2**: The motivation for this paper is not clear. Since many compression works like extreme low-bit quantization, pruning, and low-rank decomposition are proposed to accelerate the convolution layers, the motivation using Fourier transformation is not clear.\n\n**A2**: The motivation of this paper is to **enhance the compatibility of fast convolution algorithms with quantization methods, aiming to achieve improved computation efficiency by combining them**. Thanks to your suggestion, we have strengthened the expression of motivation in the revised manuscript. Experiment section shows that our method is far ahead of similar work in terms of accuracy, quantization bit-width, and speedup ratio.  \n\nCompared with other compression methods, fast convolution algorithms have many advantages, including their **suitability across various hardware platforms**, including CPUs[8], GPUs[9], domain specific accelerators[2]. Other acceleration methods like extreme low-bit quantization and pruning are more dependent on the support of the hardware architecture for their respective function. For example, Nvidia Turing GPUs can only support specific quantization formats (Int8 and Int16) and pruning templates (4:2 sparsity). \n\nDiscussion in terms of quantization alone: Although achieving sub-4bit quantization and maintaining model accuracy is possible through Quantization-aware Training (QAT) [10], it requires the entire dataset and significant training resources.  In our work, we leverage Post-training quantization (PTQ), which is more lightweight, requiring only a small dataset and estimating parameters in a few minutes. Compared to the sota PTQ alone method AdaQuant[1], our method can **achieve much higher accuracy under similar BOPs** (Bit Operations, which we will detail this metric in **A3** section) or **much lower BOPs under similar accuracy**(Table R1). Finally, we believe that our SFC algorithm can also achieve sub 4-bit quantization via QAT, although we have not attempted it yet.\n\n **Table R1. BOPs of ResNet18(69.76%)**\n\n|           | AdaQuant(PTQ)[1] | SFC4(4\u00d74, 3\u00d73)+PTQ | SFC4(4, 3)+PTQ |\n| --------- | ---------------- | ------------------ | -------------- |\n| Bit-width | 4                | 8/6                | 8/4            |\n| Accuracy  | 63.47            | **69.04**          | 63.02          |\n| BOPs      | 24.1G            | 22.8G              | **15.8G**      |\n\n\n\nDiscussion in terms of pruning: The irregular data flow resulting from pruning poses a significant challenge to hardware architecture design, often leading to hardware inefficiency. Unlike PTQ methods, pruning methods, to maintain accuracy, have high training costs. Furthermore, pruning methods are not incompatible with fast convolutional algorithms; **a previous study [4] explores sparsity in the Winograd domain**. Therefore, we believe that our SFC algorithm can be effectively combined with pruning methods in the transformation domain.\n\nDiscussion in terms of low-rank decomposition: Compared to low-rank decomposition, which provides only **approximate computations**, fast convolution algorithms provide **mathematically equivalent computations**, once numerical errors are within model tolerance, the loss of accuracy is less."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission3779/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700417215308,
                "cdate": 1700417215308,
                "tmdate": 1700675616798,
                "mdate": 1700675616798,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "JC8RA0F2bO",
                "forum": "XXrUarMM20",
                "replyto": "7Sx8veraov",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission3779/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission3779/Authors"
                ],
                "content": {
                    "title": {
                        "value": "To Reviewer uiWW Part II"
                    },
                    "comment": {
                        "value": "**Q3**\uff1aThe evaluation is not sufficient. The metric in evaluation is multiplicative complexity, however, the compression ratio and real-time acceleration performance are missing.\n\n**A3**\uff1aThanks you for your suggestion, we opt for **Bit-Operations(BOPs)** in our revised manuscript as a fine metric to precisely quantify computation costs.  This metric comprehensively considers factors such as **bit-width, the number of operations, and the varying hardware costs of addition and multiplication**. And it is widely used in various model compressing fields, including  Neural Architecture Search(NAS)[6], quantization[5] [7] and pruning [5] research.  BOPs for integer addition are defined as $BOPs = b \\cdot ADDs$, where '$b$' represents the addition bit-width. Similarly, BOPs for integer multiply-and-accumulate are defined as $BOPs = b1 \\cdot b2 \\cdot MACs$, where '$b1$' and '$b2$' represent the bit-widths of the two operators, respectively.\n\nFor element-wise multiplication, our method consumes $MACs=Tnums\\cdot TransSize\\cdot TransSize\\cdot IC\\cdot OC$ when deploying a dense convolution layer, where $ Tnums = ceil(H/TileSize)\\cdot ceil(W/TileSize)$. And the input transformation consumes $ADDs = Tnum\\cdot ((TileSize+KernelSize)\\cdot TransSize)(TileSize+KernelSize+TransSize)\\cdot IC$,  the output transformations consumes $ADDs = Tnum\\cdot (TileSize\\cdot TransSize)(TileSize+TransSize)\\cdot OC$.\n\nWhen the arithmetic bit-width=8, we can find that $BOPs_{ElementWiseMult} >> BOS_{OutTrans} \\approx BOS_{InTrans}$, **which is why many works based on fast convolution primarily considers element-wise multiplication complexity when calculating the speedup ratio.**\n\nThe BOPs of different methods are shown in Table R2. Compared to the state-of-the-art PTQ method AdaQuant[1], our SFC method can **significantly reduce the MACs while maintaining narrow bit-width in multiplication**, thus obtaining lower BOPs. In comparison with Winograd-based work[2], our algorithm does **not need to expand the intermediate arithmetic bit-width to maintain the model accuracy**, and thus the BOPs are also lower.\n\n**Table R2. BOPs of ResNet18(69.76%)**\n\n|           | AdaQuant(PTQ)[1] |       | Wino(4\u00d74, 3\u00d73)+QAT[2] | SFC6(7\u00d77, 3\u00d73)+PTQ | SFC4(4\u00d74, 3\u00d73)+PTQ | SFC4(4, 3)+PTQ |\n| --------- | ---------------- | ----- | --------------------- | ------------------ | ------------------ | -------------- |\n| Bit-width | 8                | 4     | 8/10                  | 8                  | 8/6                | 8/4            |\n| Accuracy  | 69.73            | 63.47 | 69.41                 | 69.58              | 69.04              | 63.02          |\n| BOPs      | 96.2G            | 24.1G | 44.3G                 | **34.3G**          | **22.8G**          | **15.8G**      |\n\n\n**Q4**. It would be better to provide the real-time latency to show the acceleration performance on hardware platforms like GPU/FPGA/CPU. The theoretical reduction in the multiplication operation.\n\n**A4**\uff1aThere has been considerable works on deploying & optimizing Winograd algorithm on CPUs[8] and GPUs[9]. As our algorithm can be computed in the same computational flow as the Winograd, we think its deployment has no serious technical problems.\n\nWe implement our proposed symbolic Fourier convolution algorithm on our laptop GPU to validate that its can provides real-world speedups, substantiating not only theoretical computational reductions. For comparison, we evaluated our method against the CUDA Deep Neural Network library (cuDNN) in the context of the 3\u00d73 convolution layer for inference. Because of the time limitation, we were unable to implement the entire networks in Int8 format. As we can see, **our algorithms demonstrates a 1.75x speedup compared to cuDNN**.\n\n**Table R3. Inference Convlayer with BatchSize=1, KernelSize=3\u00d73\uff0cFeatureMap=28\u00d728\uff0cChannel=128\u00d7128 and fp32 format on Nvidia GTX 1650 Laptop GPU**\n\n|      | cuDNN | im2col | SFC4(44, 33)  |\n| ---- | :---: | ------ | ---- |\n| time | 128us | 194us  | **73us** |\n\nWe are also working on FPGA-based CNN accelerator utilizing our proposed algorithm. Welcome to follow our hardware work in the future."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission3779/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700417251212,
                "cdate": 1700417251212,
                "tmdate": 1700742448173,
                "mdate": 1700742448173,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "z3GyMAHJbT",
                "forum": "XXrUarMM20",
                "replyto": "7Sx8veraov",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission3779/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission3779/Authors"
                ],
                "content": {
                    "title": {
                        "value": "To Reviewer uiWW Part III"
                    },
                    "comment": {
                        "value": "**Q5**: Can this method be used in other layers? For example, FC can be seen as a special CNN layer with a kernel size being 1, and what if the proposed method is applied to FC layers?\n\n**A5**: Our method can accelerate 3\u00d73 and lager size convolutions very efficiently (the only fast convolution algorithm to our knowledge that can accelerate 3\u00d73 convolutions by more than 3\u00d7 at 8bit with negligible accuracy loss), but it does not work for FC layers. However, in a significant number of CNNs, 3\u00d73 convolution takes up a heavy computational load, much more than FC.\n\n\n\n[1] Hubara, Itay, et al. \"Improving post training neural quantization: Layer-wise calibration and integer programming.\" *arXiv preprint arXiv:2006.10518* (2020).\n\n[2] Andri, Renzo, et al. \"Going further with winograd convolutions: Tap-wise quantization for efficient inference on 4x4 tiles.\" *2022 55th IEEE/ACM International Symposium on Microarchitecture (MICRO)*. IEEE, 2022.\n\n[3] Chetlur, Sharan, et al. *cuDNN: Efficient Primitives for Deep Learning*. 2014.\n\n[4] Liu, Xingyu, et al. \u201cEfficient Sparse-Winograd Convolutional Neural Networks.\u201d *International Conference on Learning Representations*, 2018.\n\n[5] Wang, Ying, Yadong Lu, and Tijmen Blankevoort. \"Differentiable joint pruning and quantization for hardware efficiency.\" *European Conference on Computer Vision*. Cham: Springer International Publishing, 2020.\n\n[6] Guo, Zichao, et al. \"Single path one-shot neural architecture search with uniform sampling.\" *Computer Vision\u2013ECCV 2020: 16th European Conference, Glasgow, UK, August 23\u201328, 2020, Proceedings, Part XVI 16*. Springer International Publishing, 2020.\n\n[7] Liu, Zechun, et al. \"Reactnet: Towards precise binary neural network with generalized activation functions.\" *Computer Vision\u2013ECCV 2020: 16th European Conference, Glasgow, UK, August 23\u201328, 2020, Proceedings, Part XIV 16*. Springer International Publishing, 2020.\n\n[8] Maji, Partha, et al. *Efficient Winograd or Cook-Toom Convolution Kernel Implementation on Widely Used Mobile CPUs*. IEEE, 2019\n\n[9] Jia, Liancheng, et al. \u201cEnabling Efficient Fast Convolution Algorithms on GPUs via MegaKernels.\u201d *IEEE Transactions on Computers*, 2020, pp. 1\u20131\n\n[10] Rastegari, Mohammad, et al. \"Xnor-net: Imagenet classification using binary convolutional neural networks.\" *European conference on computer vision*. Cham: Springer International Publishing, 2016."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission3779/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700417275900,
                "cdate": 1700417275900,
                "tmdate": 1700672346631,
                "mdate": 1700672346631,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]