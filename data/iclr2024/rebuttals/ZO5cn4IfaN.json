[
    {
        "title": "Efficient Distributed Training with Full Communication-Computation Overlap"
    },
    {
        "review": {
            "id": "MBHcGwzFcV",
            "forum": "ZO5cn4IfaN",
            "replyto": "ZO5cn4IfaN",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2582/Reviewer_Qwcz"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2582/Reviewer_Qwcz"
            ],
            "content": {
                "summary": {
                    "value": "The paper proposes CO2, a new approach that enables efficient distributed training of large language models on clusters with limited bandwidth. CO2 introduces local-updating and asynchronous communication to the distributed data-parallel training, allowing for full overlap of communication with computation. The approach achieves 100% scalability even on clusters with limited communication bandwidth. The paper also introduces staleness gap penalty and outer momentum clipping techniques to improve convergence and training stability. The proposed approach is validated through extensive experiments on computer vision and natural language processing tasks as well."
                },
                "soundness": {
                    "value": "4 excellent"
                },
                "presentation": {
                    "value": "4 excellent"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "+ The paper is well-written and comprehensible.\n+ The code is available in this work.\n+ The utilization of local updating and asynchronous communication makes a full overlap of computation and communication. \n+ The paper provides enough theoretical explainability and empirical validation. \n+ The experimental results are sound and promising."
                },
                "weaknesses": {
                    "value": "I do not have much to comment on the weakness, as this work goes beyond my acceptance threshold."
                },
                "questions": {
                    "value": "How many runs for each task? I understand that training a Language Learning Model from scratch can be quite costly. However, conducting the experiment only once may not yield persuasive results."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2582/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698641015004,
            "cdate": 1698641015004,
            "tmdate": 1699636195774,
            "mdate": 1699636195774,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "Bih9qsHMnP",
                "forum": "ZO5cn4IfaN",
                "replyto": "MBHcGwzFcV",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer Qwcz"
                    },
                    "comment": {
                        "value": "Dear reviewer,\n\nThanks for the comments and questions. Please see below for our response to your concern.\n\n**Q1: How many runs for each task? Conducting the experiment only once may not yield persuasive results**\n\nA1:\nWe thank for the helpful comments. All runs in the convergence experiments were executed five times with distinct random seeds to ensure robust results. And for the throughput experiments, the presented throughput results are averaged values extracted from iterations 100 to 200 for each experiment, which is in order to reduce fluctuations. We will emphasize these experiment details in the forthcoming rebuttal revision version of the paper."
                    }
                },
                "number": 13,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2582/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700656406425,
                "cdate": 1700656406425,
                "tmdate": 1700656406425,
                "mdate": 1700656406425,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "tQfITz6G7v",
            "forum": "ZO5cn4IfaN",
            "replyto": "ZO5cn4IfaN",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2582/Reviewer_rgZH"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2582/Reviewer_rgZH"
            ],
            "content": {
                "summary": {
                    "value": "The paper proposes an approach called CO2 to improve throughput of distributed model training by overlapping computation and communication. Building on prior work that perform multiple training iterations with local updates before each global model synchronization, CO2 enables further throughput improvement by making the global synchronization asynchronous and overlapped with the next round of local updates. CO2 proposes two techniques for addressing the convergence issues of the asynchrony: (i) staleness penalty gap, and (ii) outer momentum clipping. The paper presents theoretical analyses of the convergence guarantees of these two techniques. The evaluation results show that CO2 can achieve convergence results comparable to baselines that are fully synchronous (e.g, Adam) and better than those using local updates (e.g, LocalSGD). The experimental results also show the throughput and scalability of CO2 are better than Adam."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "The paper is tackling an important problem since communication is a major bottleneck for scaling model sizes and training hardware, and so approaches for reducing communication overheads are very relevant to the community. \n\nThe idea of overlapping communication with computation is reasonable given the cost-effectiveness. I also liked the fact that the paper attempts to quantify and fix the resulting staleness update problem. \n\nThe evaluation considers a diverse and important set of workloads and hardware environments, which helps to understand the generality of CO2."
                },
                "weaknesses": {
                    "value": "I observe some critical problems in the draft that raise the question of whether CO2 can simultaneously achieve good convergence and high throughput. \n\n1. The convergence and throughput trade-off of inner loop step count ($\\tau$) is not clearly reported in evaluation. In particular, the convergence results in Tables 1 & 2 should include the corresponding $\\tau$ and throughput. I was unable to determine whether the good convergence results are achieved with $\\tau$ that also provides throughput benefits. \n\n2. The paper is silent on the memory overheads of CO2 relative to baselines, even though Algorithm 2 suggests that multiple copies of the model is required to support asynchronous communication. \n\n3. Equation 3 assumes learning rate decay in the inner loop which is not true for learning rate schedules, such as cyclic, which involve learning rate increases. \n\n4. It is unclear to me whether CO2 can achieve expected throughput benefits in scenarios with parallelism techniques (e.g., tensor slicing, sequence parallelism, and zero stage 3) that introduce communication to forward/backward passes. It seems these (synchronous) communication operations would interfere with the overlapped communication and hurt overall throughput. Evaluating such scenarios could help to better understand the generality of CO2."
                },
                "questions": {
                    "value": "See weaknesses."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission2582/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2582/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2582/Reviewer_rgZH"
                    ]
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2582/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699140931913,
            "cdate": 1699140931913,
            "tmdate": 1700674931315,
            "mdate": 1700674931315,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "fFbTUrDc8E",
                "forum": "ZO5cn4IfaN",
                "replyto": "tQfITz6G7v",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer rgZH (Part 1)"
                    },
                    "comment": {
                        "value": "Dear reviewer,\n\nThank you for your valuable and constructive feedback, which contributes a lot to the enhancement of our paper. Below, we provide our responses addressing your concerns. And all the revisions will be updated in the forthcoming rebuttal revision version of the paper.\n\n**Q1: The trade-off between convergence and throughput benefits**\n\nA1: \nThanks for the helpful comments. The omission of throughput results in Table 1 and 2 stems from (part of) our convergence experiments being conducted on 8 A100 nodes connected through a high-speed RoCE RDMA network. And the investigated model sizes were relatively small, which mitigates the discernibility of CO2's speed advantage. As rightly pointed out by you and other reviewers, we recognize the significance of showing the trade-off between convergence and throughput benefits for CO2, we have addressed this gap by providing the missing throughput data in the below Tables. The presented throughput results represent averaged values extracted from iterations 100 to 200 for each experiment. Given the extensive nature of our experiments, convergence outcomes in Table 1 and 2 originate from two distinct clusters. Specifically, the IC and ALM tasks were executed on an A100 cluster equipped with RoCE RDMA high-speed inter-node connections, featuring 8 nodes and a total of 64 GPUs. Conversely, the SS, PC, and BLM tasks were conducted on a 3090 cluster with a standard TCP/IP Ethernet inter-node connection, comprising 4 nodes and 32 GPUs. Upon observing tasks trained on the A100 platform, it is evident that the throughput of CO2 surpasses other counterparts, although with a slight advantage. This advantage becomes more pronounced on tasks trained on the 3090 platform. It is reasonable to infer that this advantage will be amplified on larger clusters, especially those with slower inter-node connections.\n\nPrior to commencing large-scale convergence experiments, we meticulously tune the values of $\\tau$ for each task using a simple grid search strategy within the range of {1, 3, 6, 12, 24, 48, 96, 192} to reach a balance of accuracy and throughput. Hyperparameter tuning experiments are conducted on smaller versions of models when the model to be trained is large, owing to the associated high time and resource costs. We start the tuning of $\\tau$ from 1 to larger candidate values given the consideration of high-speed communication on the corresponding platform. It is worth noting that, in addition to CO2, other methods such as Local-SGD/Adamw and SlowMo also require tuning of $\\tau$. In practice, we exclusively tune $\\tau$ for CO2 and employ the same tuned $\\tau$ values for Local-SGD/Adamw and SlowMo. This is because of the similar role played by $\\tau$ in these local-updating methods. Employing identical $\\tau$ values for different methods on the same task ensures a fair comparison of their convergence and training throughput.\n\n| Task | Model| SGD (Adamw) | Local-SGD (Local-Adamw) | SlowMo     | CO2 |\n|-|-|-|-|-|-|\n|      |             | Acc / Thpt  | Acc / Thpt / $\\tau$             | Acc / Thpt / $\\tau$ | Acc / Thpt / $\\tau$ |\n| IC (A100)    | ResNet-50   | 76.92 / 108739      | 75.57 / 108758 / 1                  | 77.12 / 108741 / 1       | 77.14 / 108753 / 1       |\n| IC (A100)   | ViT (Base)  | 81.33 / 39422        | 78.43 / 39512 / 3                   | 79.83 / 39509 / 3       | 80.95 / 39533 / 3       |\n| IC (A100)    | VVT (Large) | 83.64 / 44375        | 81.09 / 44390 / 1                   | 82.75 / 44376 / 1       | 83.38 / 44387 / 1       |\n| SS (3090)   | VVT (Large) | 47.82 / 5384        | 44.25 / 5528 / 6                   | 47.51 / 5521 / 6       | 47.80 / 5562 / 6       |\n| PC (3090)   | Point-MAE   | 68.56 / 5859        | 64.25 / 5931 / 3                   | 68.69 / 5904 / 3       | 68.89 / 5956 / 3       |\n\n\\* For IC and SS tasks, we present the throughput results in \"images/s\", the image resolution is 224x224; For PC task, we present the throughput results in \"point clouds/s\", each point cloud has 1024 points. \n\n| Task | Model| Adamw      | Local-Adamw | SlowMo     | CO2|\n|-|-|-|-|-|-|\n|      |                 | Acc / Thpt | Acc / Thpt / $\\tau$  | Acc / Thpt / $\\tau$ | Acc / Thpt / $\\tau$ |\n| ALM (A100)  | GPT-2 (Small)   | 7.44 / 6.543e6       | 7.95 / 6.556e6 / 3        | 7.34 / 6.554e6 / 3       | 7.37 / 6.556e6 / 3       |\n| ALM (A100)  | GPT-2 (Medium)  | 6.61 / 2.084e6       | 7.49 / 2.094e6 / 3       | 6.41 / 2.091e6 / 3       | 6.36 / 2.092e6 / 3       |\n| ALM (A100)  | GPT-2 (Large)   | 6.26 / 1.052e6       | 7.00 / 1.059e6 / 6       | 6.29 / 1.053e6 / 6       | 6.13 / 1.056e6 / 6      |\n| ALM (A100)  | TN-LLM (7B)     | 16.82 / 0.281e6      | 18.63 / 0.303e6 / 12       | 16.95 / 0.301e6 / 12      | 16.78 / 0.308e6 / 12      |\n| BLM (3090)  | RoBERTa (Large) | 3.96 / 2262       | 4.38 / 2815 / 6        | 3.98 / 2794 / 6       | 3.95 / 2892 / 6       |\n\n\\* For ALM and BLM tasks, we present the throughput results in \"tokens/s\"."
                    }
                },
                "number": 1,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2582/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700477054425,
                "cdate": 1700477054425,
                "tmdate": 1700652858186,
                "mdate": 1700652858186,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "pOX54YyU0H",
                "forum": "ZO5cn4IfaN",
                "replyto": "tQfITz6G7v",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer rgZH (Part 2)"
                    },
                    "comment": {
                        "value": "**Q2: The memory overheads of CO2**\n\nA2: \nThank you for the comprehensive review. As an asynchronous method, CO2 leverages the advantages of a high overlap ratio facilitated by asynchronous communication, while contending with an augmented memory footprint due to the one-step asynchronous delay. Here we present a preliminary comparative analysis of the memory footprint of the methods discussed in the paper, using the widely adopted Adamw optimizer as the baseline and excluding considerations of mixed precision. Local-Adamw, a variant of Adamw, conducts local forward and backward passes and updates parameters without synchronizing gradients. It shares the same memory footprint as Adamw but exhibits lower communication frequency and diminished accuracy performance. SlowMo, can be seen as a variant of Local-Adamw, introduces slow momentum calculation and outer model updates to enhance accuracy. Despite maintaining the same communication frequency as Local-Adamw, SlowMo incurs an additional memory footprint (twice that of the model itself) due to the introduced slow momentum and outer updates. In comparison, CO2 introduces a one-step-delay outer momentum and outer model updates to overlap communication with multiple steps of local-updating computation, enhancing communication-computation overlap. This improvement comes at the cost of an additional memory footprint (twice that of the model itself) compared to SlowMo, attributed to asynchronous operations.\n\nDespite the heightened memory overhead introduced by CO2, it enables full overlap (in the best case) of communication and computation, particularly advantageous for large clusters with limited inter-node connections. Techniques such as ZeRO-1, ZeRO-2, and ZeRO-3 have been incorporated to alleviate redundant memory footprint issues associated with optimizer states, gradients, and model parameters within the inner loop training of CO2. These measures could mitigate the adverse effects of CO2's augmented memory overheads. Furthermore, some ongoing efforts are dedicated to refining the CO2 algorithm in subsequent versions, with a focus on mitigating additional memory overheads. \n\n**Q3: The non-decay learning rate consideration**\n\nA3: \nThank you for bringing up this point. Indeed, the assumption of a decaying learning rate when designing the staleness gap may be considered somewhat restrictive. We acknowledge that our experiments did not thoroughly explore various types of learning rate schedules. To address this concern, we conducted a comparative experiment on GPT-2 (Small) using the CyclicLR schedule provided in PyTorch with the \"triangular2\" policy (see [pytorch link](https://pytorch.org/docs/stable/generated/torch.optim.lr_scheduler.CyclicLR.html) and [github link](https://github.com/bckenstler/CLR)), training for 100K steps. The test results and their comparisons with CosineAnnealingLR are summarized in the table below:\n\n| Experiments             |Train PPL      |Validation PPL |\n|-------------------------|---------------|---------------|\n| CO2, CosineAnnealingLR, No Penalty |7.52           |7.56           |\n| CO2, CosineAnnealingLR, Penalty    |7.36           |7.39           |\n| CO2, CyclicLR, No Penalty |7.58           |7.63           |\n| CO2, CyclicLR, Penalty    |7.45           |7.51           |\n\nThe experimental outcomes consistently affirm the favorable impact of the staleness gap penalty technique on training performance, regardless of the choice between CosineAnnealingLR and CyclicLR. While the enhancements in perplexity (PPL) may not be substantial, they exhibit a reliable positive trend. It is noteworthy that PPL values using CyclicLR surpass those using CosineAnnealingLR, potentially owing to suboptimal learning rate tuning. Despite the cyclic nature of the learning rate in CyclicLR, the staleness gap penalty continues to exert its positive influence. This could be attributed to the periodic decrease in the learning rate during CyclicLR's training iterations, facilitating the efficacy of the staleness gap penalty. It is pertinent to acknowledge that both tested schedules incorporate a learning rate warm-up during the initial 4000 iterations, which also represents a form of increasing learning rate. From a technical standpoint, we posit that there may exist specific learning rate schedules where the staleness gap penalty technique may not exhibit optimal performance. In such instances, we advocate exploring alternative decaying learning rate schedules or considering the option to disable the staleness gap penalty."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2582/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700477135485,
                "cdate": 1700477135485,
                "tmdate": 1700652899152,
                "mdate": 1700652899152,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "ynHafwj2OM",
                "forum": "ZO5cn4IfaN",
                "replyto": "tQfITz6G7v",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer rgZH (Part 3)"
                    },
                    "comment": {
                        "value": "**Q4: The compatibility with parallelism technologies**\n\nA4: \nWe appreciate the comprehensive assessment provided. Given the additional memory footprints associated with asynchronous updates, the compatibility of CO2 with various parallelism techniques becomes an indispensable consideration, especially in the context of large-scale model training. During the implementation of the algorithm, we systematically investigated its compatibility with ZeRO-series optimizers. Currently, ZeRO-1, ZeRO-2, and ZeRO-3 are integrated into the inner loop training of CO2, with the exclusion of the outer loop. We conducted thorough experiments to validate the effectiveness and efficiency of these integrations. In particular, with respect to ZeRO-3, which entails more sophisticated communication during both forward and backward passes, we had considered its compatibility with CO2. Given CO2's local-updating behavior in the inner loop, continuous gradient synchronization is deemed unnecessary at each step. As a result, communication operations for CO2 with ZeRO-3 involve only two all-gather collective communication primitives at the beginning of the forward and backward passes, respectively, which differs from the original implementation of ZeRO-3.\n\nConcerning tensor parallelism, sequence parallelism, and their integration with CO2, while we have not implemented them at this moment, their mechanisms appear non-conflicting with CO2's inner loop training. Tensor parallelism divides large matrix multiplications across multiple devices, and sequence parallelism divides the input sequence into chunks, processing them simultaneously on different devices for efficient training of long sequences. We will try to integrate them with CO2 in the future work."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2582/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700477193545,
                "cdate": 1700477193545,
                "tmdate": 1700652915878,
                "mdate": 1700652915878,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "UIgqymIFMF",
                "forum": "ZO5cn4IfaN",
                "replyto": "pOX54YyU0H",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2582/Reviewer_rgZH"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2582/Reviewer_rgZH"
                ],
                "content": {
                    "title": {
                        "value": "Memory overheads of CO2"
                    },
                    "comment": {
                        "value": "Thanks for your response. While it mostly addresses my concerns, it did not clarify how many model copies are required by CO2, especially with reference to Algorithm 2 as I pointed out my comment. Your response seems to suggest that 2 copies are required (similar to SlowMo) but I think Algorithm 2 suggests at least 4. It is very possible that I have overcounted in Algorithm 2, but that is why addressing this question directly in the paper would help readers like me avoid such confusion. I appreciate that leveraging ZeRO is a reasonable mitigation to the memory overheads."
                    }
                },
                "number": 15,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2582/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700674652229,
                "cdate": 1700674652229,
                "tmdate": 1700674652229,
                "mdate": 1700674652229,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "7v7DMSvjSF",
                "forum": "ZO5cn4IfaN",
                "replyto": "ynHafwj2OM",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2582/Reviewer_rgZH"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2582/Reviewer_rgZH"
                ],
                "content": {
                    "title": {
                        "value": "Appreciate the response"
                    },
                    "comment": {
                        "value": "I greatly appreciate the careful and detailed response to my questions. Overall, I found the responses valuable to improving my understanding and rating of the work. I will raise my score to 6."
                    }
                },
                "number": 16,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2582/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700674898432,
                "cdate": 1700674898432,
                "tmdate": 1700674898432,
                "mdate": 1700674898432,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "cvWcLhf3eK",
            "forum": "ZO5cn4IfaN",
            "replyto": "ZO5cn4IfaN",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2582/Reviewer_m91N"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2582/Reviewer_m91N"
            ],
            "content": {
                "summary": {
                    "value": "To address the communication problem in large-scale distributed training of deep neural networks, the paper proposes a combination of local-SGD and asynchronous communication to derive a new distributed training algorithm named CO2. In CO2, two novel approaches are developed to ensure that CO2 aligns the convergence performance with conventional distributed data-parallel algorithms. Experiments are conducted on a 64-GPU testbed, showing that CO2 outperforms existing methods significantly. The studied problem is timely and important. The paper is also well-written."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "- Propose a new distributed training algorithm, CO2, using local updates and asynchronous communication to alleviate the communication problem in conventional synchronous data-parallel distributed training. \n- New tricks to address the convergence problem in stale gradients.\n- Comphesive experiments to show the effectiveness of CO2."
                },
                "weaknesses": {
                    "value": "- Some stale parallel algorithms (e.g., SSP [ref1]), whose key ideas are quite similar to CO2, were not included in the discussion and comparison. The survey paper [ref2] may help find SSP-like methods for comparison.\n- It seems that 100% scaling efficiency is over-claimed. The scaling efficiency highly depends on $\\tau$. Higher $\\tau$ has better scaling efficiency but has worse convergence performance. Thus, achieving 100% scaling efficiency with a $\\tau>1$ while sacrificing the convergence performance cannot conclude the algorithm has true 100% scaling efficiency.\n\n[ref1] More Effective Distributed ML via a Stale Synchronous Parallel Parameter Server, NeurIPS 2013.\n[ref2] Communication-efficient distributed deep learning: A comprehensive survey, arXiv 2020."
                },
                "questions": {
                    "value": "- How about comparing with SSP-like algorithms in terms of theoretical convergence bound and empirical scaling efficiency? \n- How $\\tau$ is set in Table 1?\n- How about the end-to-end training performance (i.e., time to accuracy)?\n- How to choose $\\tau$ in a new distributed GPU cluster?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission2582/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2582/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2582/Reviewer_m91N"
                    ]
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2582/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699468058209,
            "cdate": 1699468058209,
            "tmdate": 1699636195641,
            "mdate": 1699636195641,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "8DHaJ27rZG",
                "forum": "ZO5cn4IfaN",
                "replyto": "cvWcLhf3eK",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer m91N (Part 1)"
                    },
                    "comment": {
                        "value": "Dear reviewer,\n\nThank you for your valuable and constructive feedback, which contributes a lot to the enhancement of our paper. Below, we provide our responses addressing your concerns. And all the revisions will be updated in the forthcoming rebuttal revision version of the paper.\n\n**Q1: How about comparing with SSP-like algorithms in terms of theoretical convergence bound and empirical scaling efficiency?**\n\nA1:\nThanks for bringing this up. The stale-synchronous parallel (SSP) framework as described in [ref2] aims to mitigate the straggler problem with relaxed synchronization. Specifically, SSP allows faster workers to perform more updates than slower ones, reducing the waiting time of faster workers. However, to maintain model consistency and ensure convergence, SSP imposes a staleness bounded barrier that limits the iteration gap between the fastest and slowest workers. Comparing with CO2, their differences mainly lie in these three aspects:\n1) The SSP framework as described in [ref1] and [ref2] is built upon the Parameter-Server architecture. While CO2 as well as the Local-SGD and SlowMo algorithms investigated in the paper all based on the All-Reduce architecture.\n2) The SSP-like algorithms indeed introduces asynchronization into its training procedure, however, it does not allow the communication to be overlapped with computations. And its staleness is not punished, which will leads unsatisfactory convergence performances. As comparison, the asynchronous communication in CO2 makes the communication can be overlapped with multiple-step local updates, which hugely improves the training efficiency. And the staleness gap penalty technique allows to mitigate the negative effects on convergence results. These imply the scaling efficiency and convergence performance of SSP-like algorithms will be worse than CO2 in practice.\n3) The convergence analysis section in [ref2] indicates that the convergence rate of SSP in normal cases is $O(\\frac{1}{\\sqrt{T}})$ . Comparing with CO2, when the total steps $T\\tau$ is sufficiently large, i.e, $T\\gg G^3\\tau^3$, the convergence rate of CO2 is $\\mathcal{O}\\left(\\frac{1}{\\sqrt{G T \\tau}}\\right)$. So theoretically, the convergence rates of these two algorithms are similar.\n\n\n**Q2: 100% scaling efficiency is over-claimed**\n\nA2:\nWe appreciate the thoughtful suggestion. Indeed, the original concept behind the design of CO2 aims to achieve a full overlap of the communication with multi-step local computation, the length of which is determined by the parameter $\\tau$. However, it is acknowledged that an excessively large $\\tau$ may have a detrimental impact on convergence performance, introducing a trade-off between the overlap ratio of communication and computation and the overall convergence. In previous experiments, we have observed that an appropriately chosen $\\tau$ can achieve a high level of overlap (100%) while maintaining satisfactory accuracy results. We fully understand the concerns raised and will address them by refining the relevant statements in the paper during the rebuttal revision, aiming for a more balanced depiction of the scalability claims."
                    }
                },
                "number": 10,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2582/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700655655390,
                "cdate": 1700655655390,
                "tmdate": 1700655655390,
                "mdate": 1700655655390,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "sKTHyeciUI",
                "forum": "ZO5cn4IfaN",
                "replyto": "cvWcLhf3eK",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer m91N (Part 2)"
                    },
                    "comment": {
                        "value": "**Q3: How\u00a0$\\tau$\u00a0is set in Table 1?**\n\nA3:\nThanks for the valuable comments. We agree that describing the tuning procedure and the setting of $\\tau$ in experiments are helpful for understanding the algorithm. In our experiments, we tune the values of $\\tau$ for each task using a simple grid search strategy within the range of {1, 3, 6, 12, 24, 48, 96, 192} to reach a balance of accuracy and throughput. The tuning experiments are conducted on smaller versions of models when the model to be trained is large, owing to the associated high time and resource costs. We start the tuning of $\\tau$ from 1 to larger candidate values given the consideration of high-speed communication on the corresponding platform. It is worth noting that, in addition to CO2, other methods such as Local-SGD/Adamw and SlowMo also require tuning of $\\tau$. In practice, we exclusively tune $\\tau$ for CO2 and employ the same tuned $\\tau$ values for Local-SGD/Adamw and SlowMo. This is because of the similar role played by $\\tau$ in these local-updating methods. Employing identical $\\tau$ values for different methods on the same task ensures a fair comparison of their convergence and training throughput.\n\nWe list the values of $\\tau$ in all the convergence experiments in the paper as below:\n\n| Task | Model| SGD (Adamw) | Local-SGD (Adamw) | SlowMo     | CO2 |\n|-|-|-|-|-|-|\n|      |             | Acc  | Acc / $\\tau$             | Acc / $\\tau$ | Acc / $\\tau$ |\n| IC (A100)    | ResNet-50   | 76.92      | 75.57 / 1                  | 77.12 / 1       | 77.14 / 1       |\n| IC (A100)   | ViT (Base)  | 81.33        | 78.43 / 3                   | 79.83 / 3       | 80.95 / 3       |\n| IC (A100)    | VVT (Large) | 83.64        | 81.09 / 1                   | 82.75 / 1       | 83.38 / 1       |\n| SS (3090)   | VVT (Large) | 47.82        | 44.25 / 6                   | 47.51 / 6       | 47.80 / 6       |\n| PC (3090)   | Point-MAE   | 68.56        | 64.25 / 3                   | 68.69 / 3       | 68.89 / 3       |\n\n| Task | Model| Adamw      | Local-Adamw | SlowMo     | CO2|\n|-|-|-|-|-|-|\n|      |                 | Acc | Acc / $\\tau$  | Acc / $\\tau$ | Acc / $\\tau$ |\n| ALM (A100)  | GPT-2 (Small)   | 7.44       | 7.95 / 3        | 7.34 / 3       | 7.37 / 3       |\n| ALM (A100)  | GPT-2 (Medium)  | 6.61       | 7.49 / 3       | 6.41 / 3       | 6.36 / 3       |\n| ALM (A100)  | GPT-2 (Large)   | 6.26       | 7.00 / 6       | 6.29 / 6       | 6.13 / 6      |\n| ALM (A100)  | TN-LLM (7B)     | 16.82      | 18.63 / 12       | 16.95 / 12      | 16.78 / 12      |\n| BLM (3090)  | RoBERTa (Large) | 3.96       | 4.38 / 6        | 3.98 / 6       | 3.95 / 6       |\n\n\n**Q4: How about the end-to-end training performance (i.e., time to accuracy)?**\n\nA4:\nThanks for the valuable question. Actually, we had conducted experiments on GPT-2 (Small, Medium and Large) to show the time to accuracy performances of CO2. The resulted curves are presented in Table 7 in the Appendix of the paper. Note that the experiments are performed on the A100 platform with high-speed inter-node connections. Even with the high-speed connections, CO2 still exhibits the fastest convergence speed on relative time compared to other existing methods. \n\n**Q5: How to choose\u00a0$\\tau$\u00a0in a new distributed GPU cluster?**\n\nA5:\nThank you for your question. We use grid search to select $\\tau$. Specifically, we employ a simple grid search strategy within the range of {1, 3, 6, 12, 24, 48, 96, 192} to determine the value of $\\tau$, aiming to achieve a balance between accuracy and throughput. To reduce computational demands during hyperparameter tuning for large models, we first conduct experiments on smaller model versions and then apply the hyperparameter to larger models. Similar to CO2, other methods such as Local-SGD/Adamw and SlowMo also need the tuning of $\\tau$. In our practical implementation, we first fine-tune $\\tau$ for CO2 and subsequently apply the same tuned $\\tau$ values for Local-SGD/Adamw and SlowMo. Standardizing $\\tau$ values across different methods for a given task ensures a fair and meaningful comparison of their convergence behavior and training throughput."
                    }
                },
                "number": 11,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2582/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700655714772,
                "cdate": 1700655714772,
                "tmdate": 1700655714772,
                "mdate": 1700655714772,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "mRne7UMitP",
            "forum": "ZO5cn4IfaN",
            "replyto": "ZO5cn4IfaN",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2582/Reviewer_vfwG"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2582/Reviewer_vfwG"
            ],
            "content": {
                "summary": {
                    "value": "The paper introduces CO2, a framework for improved communication/computation overlap for distributed deep learning, especially in the case of limited network bandwidth. CO2 leverages local SGD, performing a fixed (tunable) number of local iterations while allreduces perform synchronization in the background, allowing communication to almost always be hidden. To ensure good convergence, CO2 computes a staleness gap metric and uses this to scale updates, as well as a clipping mechanism to limit the variance of updates. A convergence bound is proven and experiments on a variety of network architectures and datasets show convergence matches that of standard SGD and other communication-avoiding algorithms; in the low-bandwidth regime, CO2 additionally offers significantly improved performance and scalability."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. This paper is addressing an important situation: communication-bound training workloads. This can occur due to both large models and slower interconnects. I appreciate that the paper specifically and clearly calls out lower-bandwidth networks as an area it is focused on. While the idea is relatively straightforward, it includes some details to get it to work well in practice.\n2. The paper adequately specifies its proposed algorithm and includes some theoretical justification to support its claims.\n3. There are extensive experiments on a variety of models, including relatively large ones, demonstrating roughly equivalent convergence curves, indicating that the method does not compromise learning.\n4. Scalability studies are also conducted, showing slightly improved performance on high-bandwidth networks and significantly improved performance on low-bandwidth networks relative to a standard allreduce implementation."
                },
                "weaknesses": {
                    "value": "1. I think the claims of \"perfect 100% scalability\" are a bit oversold. This relies on appropriately selecting $\\tau$, the number of local steps between global communications; it seems clear that if you can arbitrarily set the amount of computation done to hide communication, you can easily hide it. (Though I wish to be clear that the paper is clear that you can't make $\\tau$ arbitrarily high and still achieve good convergence.) This also neglects other aspects of training which may limit scalability (e.g., I/O for data ingestion).\n2. The paper does not provide guidance on selecting an appropriate $\\tau$, and in its experiments searches over a small set of potential values. This seems like a challenging parameter to tune in practice, as it could significantly increase hyperparameter tuning costs.\n3. It is not clear to me how the paper improves upon existing communication-efficient works which try to tune the communication frequency to achieve both good learning and runtime performance. In particular, works like Wang & Joshi, \"Adaptive Communication Strategies to Achieve the Best Error-Runtime Trade-off in Local-Update SGD\", or Haddadpour et al., \"Local SGD with Periodic Averaging: Tighter Analysis and Adaptive Synchronization\", seem like relevant points of comparison.\n4. The paper lacks implementation details. Specifically, it does not specify how the asynchronous allreduce is implemented (e.g., is it using a NCCL allreduce on a separate CUDA stream?). It is also not clear whether the asynchronous allreduce is operating on a separate weight/gradient buffer from the one being used for computation; or what the memory overheads of the method are.\n5. While I appreciate that the experiments were run multiple times (Section 4.1), the results do not include any measure of variance. This makes it hard to understand whether CO2 amplifies the variance between runs and how much methods actually differ.\n6. Scalability is only evaluated on one model. I would be interested to see how models other than the TransNormer-LLM scale; in my experience, smaller models tend to benefit less from communication optimizations as they are already often able to hide most communication.\n7. The scaling study in Section 4.3 does not include any comparisons with other communication-efficient methods. Given that SlowMo demonstrates very similar convergence curves, it seems prudent to see whether CO2 offers better scalabiltiy.\n8. From a performance perspective, the paper is missing a detailed analysis substantiating its claims. In particular, the communication/computation overlap achieved is never actually measured."
                },
                "questions": {
                    "value": "1. I think the paper would be stronger if the claims of \"perfect 100% scalability\" were toned down and better contextualized. (See above for some details.)\n2. How should $\\tau$ be selected? Is hyperparameter tuning the only way to do so?\n3. How does the paper improve upon prior works which tune the communication frequency (see above for some references)? Could these approaches be used to tune $\\tau$ automatically?\n4. Please add implementation details and a discussion of memory overheads. I think memory may be especially relevant for larger models such as LLMs.\n5. Please add the observed variance to the accuracy results. It would also be good to include error bars in the scaling performance results.\n6. How do other models considered in the paper (e.g., ResNets or ViTs) scale?\n7. How do other communication-efficient (e.g., SlowMo) methods scale on the fast and slow network?\n8. How much communication/computation overlap is actually achieved by CO2, particularly at scale?\n9. A more minor point: The paper refers to gradient bucketing as a way to overlap communication and computation (e.g., in Section 1). I think this is not quite correct; rather, gradient bucketing is a latency/bandwidth tradeoff (performing fewer allreduces on larger buffers). While this can be more efficient, and consequently improve communication/computation overlap, it does not itself enable overlap.\n\n-----\n\nIn light of the authors' response and promised updates, I have raised my score. They have addressed a number of points above."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission2582/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2582/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2582/Reviewer_vfwG"
                    ]
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2582/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699549840144,
            "cdate": 1699549840144,
            "tmdate": 1700666772334,
            "mdate": 1700666772334,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "Tl5wtD2AN7",
                "forum": "ZO5cn4IfaN",
                "replyto": "mRne7UMitP",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer vfwG (Part 1)"
                    },
                    "comment": {
                        "value": "Dear reviewer,\n\nWe appreciate your valuable and constructive feedback, which significantly contributes to the improvement of our paper. In response to your concerns, we have provided detailed responses, and all the revisions will be incorporated into the upcoming rebuttal revision version of the paper.\n\n**Q1: Tone down and better contextualize the claims of \"perfect 100% scalability\"**\n\nA1:\nWe appreciate the thoughtful suggestion. Indeed, the original concept behind the design of CO2 aims to achieve a full overlap of the communication with multi-step local computation, the length of which is determined by the parameter $\\tau$. However, it is acknowledged that an excessively large $\\tau$ may have a detrimental impact on convergence performance, introducing a trade-off between the overlap ratio of communication and computation and the overall convergence. In previous experiments, we have observed that an appropriately chosen $\\tau$ can achieve a high level of overlap (100%) while maintaining satisfactory accuracy results. We fully understand the concerns raised and will address them by refining the relevant statements in the paper during the rebuttal revision, aiming for a more balanced depiction of the scalability claims.\n\n**Q2: How to select $\\tau$?**\n\nA2:\nThank you for your question. We use grid search to select $\\tau$. Specifically, we employ a simple grid search strategy within the range of {1, 3, 6, 12, 24, 48, 96, 192} to determine the value of $\\tau$, aiming to achieve a balance between accuracy and throughput. To reduce computational demands during hyperparameter tuning for large models, we first conduct experiments on smaller model versions and then apply the hyperparameter to larger models. Similar to CO2, other methods such as Local-SGD/Adamw and SlowMo also need the tuning of $\\tau$. In our practical implementation, we first fine-tune $\\tau$ for CO2 and subsequently apply the same tuned $\\tau$ values for Local-SGD/Adamw and SlowMo. Standardizing $\\tau$ values across different methods for a given task ensures a fair and meaningful comparison of their convergence behavior and training throughput.\n\nAlthough grid search is used at present, there are more potential efficient strategies. One innovative suggestion is to perform a pre-run warmup with $\\tau=1$ for a limited number of iterations. During this warmup phase, metrics like computation time and all-reduce communication time are collected to calculate an optimal number of steps for local computation ($\\tau^*$). Then in formal runs, $\\tau$ can be initialized as $\\tau^*$, and adjusted based on accuracy results. Besides, varying $\\tau$ values at different stages of training, similar to learning rates, is also an interesting idea. These ideas could be explored in future research related to CO2, we have not deeply investigated them currently.\n\n**Q3: How does the paper improve upon prior works which tune the communication frequency (see above for some references)?**\n\nA3:\nWe thank for the insightful comments. The prior studies referenced above introduce adaptive communication frequency (i.e., the value of $\\tau$) schedules on the native Local-SGD method. As for our work, the proposed CO2 leverages more sophisticated asynchronous communication design and outer updates on the top of naive Local-SGD, and further proposes staleness gap penalty and momentum clipping to improve convergence and training stability.\n\nWe acknowledge that these adaptive schedules for $\\tau$ are likely to yield a more favorable trade-off compared with using a constant $\\tau$. However, these adaptive schedules can be seamlessly integrated into our CO2 algorithm. Exploring and incorporating such adaptive strategies is a promising direction for enhancing CO2 in the future research."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2582/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700624878975,
                "cdate": 1700624878975,
                "tmdate": 1700652719073,
                "mdate": 1700652719073,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "LDyn18zgXZ",
                "forum": "ZO5cn4IfaN",
                "replyto": "mRne7UMitP",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer vfwG (Part 2)"
                    },
                    "comment": {
                        "value": "**Q4: Implementation details and discussions on memory overheads**\n\nA4:\nThank you for bringing this to our attention. We acknowledge the lack of details in our paper regarding the implementation of asynchronous communication and the analysis of memory overheads. In our implementation, the asynchronous communication operations are intentionally conducted on a new CUDA stream dedicated solely to communication. At the end of the inner loop, a collective communication primitive of NCCL all-reduce, is launched among all ranks within the communication group. Subsequently, a waiting operation is executed to ensure the completion of the last launched all-reduce from the preceding outer loop, allowing the subsequent computation operations to proceed.\n\nTo facilitate asynchronous communication, a separate weight buffer is essential to store the stale version of the model. While this results in increased memory footprints compared to the synchronous version, it enables communication to overlap with multiple local steps. Specifically, in comparison to the SlowMo algorithm, CO2 incurs an additional memory footprint, twice that of the model itself, to support asynchronous communication and outer updates. To address redundant memory footprint concerns, techniques such as ZeRO-1, ZeRO-2, and ZeRO-3 have been integrated, alleviating issues related to optimizer states, gradients, and model parameters within the inner loop training of CO2. These measures aim to mitigate the negative impact of CO2's heightened memory overheads. Ongoing efforts are also dedicated to refining the CO2 algorithm in subsequent versions, with a specific focus on minimizing additional memory overheads.\n\n**Q5: Add the observed variances**\n\nA5:\nThank you for bringing this to our attention. We have organized the experimental outcomes and presented the variance results on accuracy and throughput below. In terms of convergence results, Local-SGD/Adamw consistently exhibits the largest variances, due to lack of compensation measures for accuracy. SlowMo and CO2 demonstrate only slightly larger variances than SGD/Adamw, as they both integrate an outer loop to enhance convergence. Between CO2 and SlowMo, CO2 exhibits smaller variances due to the application of staleness gap penalty and momentum clipping.\n\nRegarding throughput, it is evident that all methods experience larger variances on larger clusters. This is reasonable as communication on larger clusters tends to be more unstable and fluctuates frequently. On large clusters, such as those with 64 or 128 GPUs, CO2 with different settings of $\\tau$ demonstrates slightly larger variances than the baseline Adamw, regardless of the speed of inter-node networks.\n\n| Task | Model | SGD (Adamw) | Local-SGD (Local-Adamw) | SlowMo | CO2 |\n|-|-|-|-|-|-|\n| IC (A100) \u00a0 \u00a0| ResNet-50 \u00a0 | 76.92 ($\\pm$ 0.05) | 75.57 ($\\pm$ 0.76) | 77.12 ($\\pm$ 0.11)  | 77.14 ($\\pm$ 0.09) |\n| IC (A100) \u00a0 | ViT (Base) \u00a0| 81.33 ($\\pm$ 0.04) | 78.43 ($\\pm$ 0.22) | 79.83 ($\\pm$ 0.16) \u00a0| 80.95 ($\\pm$ 0.08) |\n| IC (A100) \u00a0 \u00a0| VVT (Large) | 83.64 ($\\pm$ 0.06) | 81.09 ($\\pm$ 1.15) | 82.75 ($\\pm$ 0.27) | 83.38 ($\\pm$ 0.06) |\n| SS (3090) \u00a0 | VVT (Large) | 47.82 ($\\pm$ 0.05) | 44.25 ($\\pm$ 2.24) | 47.51 ($\\pm$ 0.12) | 47.80 ($\\pm$ 0.11) |\n| PC (3090) \u00a0 | Point-MAE \u00a0 | 68.56 ($\\pm$ 0.08) | 64.25 ($\\pm$ 2.11) | 68.69 ($\\pm$ 0.32) | 68.89 ($\\pm$ 0.39) |\n\n| Task | Model \u00a0 | Adamw \u00a0| Local-Adamw | SlowMo | CO2 |\n|-|-|-|-|-|-|\n| ALM (A100) \u00a0| GPT-2 (Small) \u00a0 | 7.44 ($\\pm$ 0.36) \u00a0 | 7.95 ($\\pm$ 2.04) \u00a0 \u00a0| 7.34 ($\\pm$ 0.89) \u00a0 \u00a0 \u00a0 | 7.37 ($\\pm$ 0.73) \u00a0 \u00a0 \u00a0 |\n| ALM (A100) \u00a0| GPT-2 (Medium) \u00a0| 6.61 ($\\pm$ 0.53) \u00a0 | 7.49 ($\\pm$ 1.87) \u00a0 | 6.41 ($\\pm$ 0.65) \u00a0 \u00a0 \u00a0 | 6.36 ($\\pm$ 0.66) \u00a0 \u00a0 \u00a0 |\n| ALM (A100) \u00a0| GPT-2 (Large) \u00a0 | 6.26 ($\\pm$ 0.58) \u00a0 | 7.00 ($\\pm$ 1.91) \u00a0 | 6.29 ($\\pm$ 0.61) \u00a0 \u00a0 \u00a0 | 6.13 ($\\pm$ 0.52) \u00a0 \u00a0 \u00a0|\n| ALM (A100) \u00a0| TN-LLM (7B) \u00a0 \u00a0 | 16.82 ($\\pm$ 0.86) \u00a0| 18.63 ($\\pm$ 3.13) \u00a0 | 16.95 ($\\pm$ 1.01) \u00a0 \u00a0 \u00a0| 16.78 ($\\pm$ 0.95) \u00a0 \u00a0 \u00a0|\n| BLM (3090) \u00a0| RoBERTa (Large) | 3.96 ($\\pm$ 0.37) \u00a0 | 4.38 ($\\pm$ 0.83) \u00a0 \u00a0| 3.98 \u00a0($\\pm$ 0.85) \u00a0 \u00a0 \u00a0| 3.95 ($\\pm$ 0.96) \u00a0 \u00a0 \u00a0 |\n\n| Ethernet | Method | Throughput | | | | |\n|-|-|-|-|-|-|-|\n|      |       | 8 GPUs     | 16 GPUs   | 32 GPUs | 64 GPUs | 128 GPUs |\n| RDMA  | CO2 ($\\tau$=12) | 17980 ($\\pm$ 48)     | 35692 ($\\pm$ 126)              | 72491 ($\\pm$ 183)    | 150073 ($\\pm$ 362)   | 307557 ($\\pm$ 617)    |\n| RDMA  | Adamw      | 19276 ($\\pm$ 59)       | 38888 ($\\pm$ 118)              | 77782 ($\\pm$ 93)    | 151554 ($\\pm$ 209)   | 289106 ($\\pm$ 423)    |\n| TCP/IP | CO2 ($\\tau$=48) | 18090 ($\\pm$ 95)       | 35969 ($\\pm$ 193)              | 71249 ($\\pm$ 179)    | 147507 ($\\pm$ 315)   | 304736 ($\\pm$ 729)    |\n| TCP/IP  | CO2 ($\\tau$=12) | 17995 ($\\pm$ 72)       | 18975 ($\\pm$ 108)              | 36095 ($\\pm$ 151)    | 70839 ($\\pm$ 373)    | 129865 ($\\pm$ 564)    |\n| TCP/IP  | Adamw     | 18444 ($\\pm$ 49)       | 3488 ($\\pm$ 115)               | 7077 ($\\pm$ 127)     | 12855 ($\\pm$ 308)    | 22810 ($\\pm$ 526)     |"
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2582/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700625119697,
                "cdate": 1700625119697,
                "tmdate": 1700652770120,
                "mdate": 1700652770120,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "O9q2j5nvOv",
                "forum": "ZO5cn4IfaN",
                "replyto": "mRne7UMitP",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer vfwG (Part 3)"
                    },
                    "comment": {
                        "value": "**Q6: How do other models considered in the paper (e.g., ResNets or ViTs) scale?**\n\nA6:\nThank you for your inquiry. We specifically focused on assessing the scalability of TransNormer-LLM (7B) because the other models examined in our study are relatively small, with the number of parameters for each being smaller than 1B. As you rightly pointed out, smaller models tend to derive less benefit from communication optimizations. The communication overheads associated with all-reducing these small models are minimal, rendering the communication tails often negligible. Additionally, for computer vision (CV) task models such as ResNet or ViT, we typically do not scale them to very large sizes, although there is ongoing research exploring the scalability of ViT to 22B.\n\nTo effectively demonstrate the scalability advantages of CO2, we conducted experiments specifically on GPT-3 (13B), a well-known language model with autoregressive transformer architecture. The results are shown in the below Table, includes throughput comparisons with SlowMo to address Q7. The results reveal that on GPT-3 (13B), CO2 consistently achieves higher throughput on platforms with different communication conditions.\n\n| Ethernet                | Method          | $\\tau$ | Throughput | | | | |\n|-|-|-|-|-|-|-|-|\n|         |    |       |8 GPUs | 16 GPUs      | 32 GPUs | 64 GPUs | 128 GPUs |\n| RDMA   | CO2    | 12 |9468   |18587         |37905    |75682   |151846    |\n| RDMA   | SlowMo | 12 |9463   |18620         |37467    |75503   |148987    |\n| RDMA   | Adamw  |    |9519   |19131         |38824    |75326   |147723    |\n| TCP/IP | CO2    | 48 |9508   |18672         |38151    |75573   |151678    |\n| TCP/IP | SlowMo | 48 |9424   |18511         |38092    |75209   |146024    |\n| TCP/IP | CO2    | 12 |9324   |9694          |18792    |36968    |78638    |\n| TCP/IP | SlowMo | 12 |9359   |9628          |18085    |33864    |66908    |\n| TCP/IP | Adamw  |    |9482   |2283          |4192     |7984   |13832     |\n\n**Q7: How do other communication-efficient (e.g., SlowMo) methods scale on the fast and slow network?**\n\nA7:\nThank you for your valid concerns. While Local-SGD/Adamw generally demonstrates commendable scalability performance, our investigation revealed that their convergence behaviors often fall short, as outlined in Table 1 and Table 2 in the paper. So we choose to only provide the detailed comparison between CO2 and SlowMo, considering their performance on both fast and slow networks. The experiments are conducted on GPT-3 (13B), are summarized in the Table corresponding to Q6. The results indicate that CO2 exhibits moderate advantages in terms of throughput compared to the communication-efficient method, SlowMo. Notably, these observed advantages will be more pronounced with larger clusters.\n\n**Q8: How much communication/computation overlap is actually achieved by CO2, particularly at scale?**\n\nA8:\nThank you for the valuable feedback. Evaluating the communication/computation overlap is indeed crucial to substantiate the core claims of our paper. Notably, Table 3 in the manuscript provides a comprehensive overview of the scalability ratio of CO2 with varying $\\tau$ across distinct communication platforms, offering a comparative analysis against Adamw. This scalability ratio can be considered as a metric for assessing the communication/computation overlap.\n\nTo enhance our analysis, we conducted quantitative measurements on the time allocated to local computations and asynchronous communication. This assessment specifically targeted CO2 with different $\\tau$ configurations on an A100 cluster equipped with 128 GPUs, employing a slower TCP/IP inter-node network. Adhering to the settings outlined in the paper, utilizing TransNormer-LLM (7B), we maintained consistency in our experimental conditions. The measured duration for a single-step local computation was approximately 0.109s, while an all-reduce communication incurred a cost of 1.566s. Subsequently, we computed and calculated the communication/computation overlap ratio for various $\\tau$ values, presenting the results in the Table below.\n\n| Ethernet | Method | $\\tau$ | Overlap Ratio|\n|-|-|-|-|\n| TCP/IP | CO2 | 48 | 100%   |\n| TCP/IP | CO2 | 24 | 100%   |\n| TCP/IP | CO2 | 12 | 83.28%   |\n| TCP/IP | CO2 | 6 | 41.81%   |\n| TCP/IP | CO2 | 3 | 20.39%   |\n| TCP/IP | CO2 | 1 | 6.52%   |\n\n**Q9: On the gradient bucketing**\n\nA9: \nI appreciate the reviewer's observation, and I agree with the noted concern. The depiction of gradient bucketing in the paper requires refinement, and we will address this in the revised version. It's important to clarify that the primary objective of gradient bucketing is to reduce the number of communication operations during gradient synchronization by employing larger tensor buffers in each operation. Communication/computation overlap is another system optimization build upon gradient bucketing."
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2582/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700625241066,
                "cdate": 1700625241066,
                "tmdate": 1700652825728,
                "mdate": 1700652825728,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "9DNuzLO8Ah",
                "forum": "ZO5cn4IfaN",
                "replyto": "O9q2j5nvOv",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2582/Reviewer_vfwG"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2582/Reviewer_vfwG"
                ],
                "content": {
                    "title": {
                        "value": "Response"
                    },
                    "comment": {
                        "value": "Thank you for the detailed and extensive response. This has addressed a number of my concerns and I have consequently raised my score.\n\nI hope to see these updates incorporated into the paper. In particular, the inclusion of variances, a more thorough discussion of choosing $\\tau$, and the achieved communication/computation overlap are especially appreciated."
                    }
                },
                "number": 14,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2582/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700666921034,
                "cdate": 1700666921034,
                "tmdate": 1700666921034,
                "mdate": 1700666921034,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "JLc9xtFQ3p",
            "forum": "ZO5cn4IfaN",
            "replyto": "ZO5cn4IfaN",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2582/Reviewer_cSfz"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2582/Reviewer_cSfz"
            ],
            "content": {
                "summary": {
                    "value": "This work proposes a new distributed training algorithm called CO2, which aims to improve the communication efficiency of data-parallel training by overlapping local training iterations with parameter averaging from the previous global step. The proposed method is tested across multiple machine learning tasks and achieves better scalability than the baseline approaches while maintaining comparable convergence properties."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "* Overall, the proposed method is conceptually simple yet shows promising results.\n* The paper has a broad range of experiments, covering 5 setups with models that are widely used in practice.\n* Authors conduct a detailed ablation study for the components of CO2, as well as measure its scalability in different environments."
                },
                "weaknesses": {
                    "value": "* While I am not an expert in distributed optimization, to my understanding, similar methods allowing full overlap of communication and computation have been proposed previously. See, for example, [1] from the related work section: on page 17, they state that \"as long as the number of local updates \u03c4 is large enough, the communication can be fully overlapped with the local computation.\" This appears to be quite close to the primary contribution of this work, therefore I believe that the submission needs to describe the key distinctions from prior work in more detail.\n* I think that the experimental setup description could benefit from more details. For example, while the authors mention that their hyperparameters were tuned \"to find the optimal balance between efficiency and performance\", we do not see neither the exact values of $\\tau$ for each experiment nor the exact description of the tuning procedure. Also, authors mention that they leverage ZeRO for TransNormer experiments, but do not state the exact type of the optimizer within that family.\n* Lastly, the majority of model sizes used in this work have quite small parameter counts (fewer than 1B), and therefore it is a bit surprising to see communication as the bottleneck for training even on 80Gbps networks. I think that it would be beneficial to provide more detailed breakdowns of computation and communication times (for example, the time to process 1 microbatch and 1 batch of data, as well as the time to exchange parameters) in each setting to demonstrate the necessity of large $\\tau$.\n\n[1] Cooperative SGD: A unified Framework for the Design and Analysis of Communication-Efficient SGD Algorithms. Jianyu Wang, Gauri Joshi. JMLR 2021"
                },
                "questions": {
                    "value": "* What were the values of $\\tau$ for each experiment?\n* Which stage of ZeRO have you used for the TransNormer experiment?\n* In Table 2, it is somewhat surprising to see that CO2 (an asynchronous method) obtains consistently lower perplexity than a non-asynchronous adaptive method (AdamW). Do you have any explanations of that phenomenon?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 5,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2582/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699553363283,
            "cdate": 1699553363283,
            "tmdate": 1699636195507,
            "mdate": 1699636195507,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "nhnvG9oYg8",
                "forum": "ZO5cn4IfaN",
                "replyto": "JLc9xtFQ3p",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer cSfz (Part 1)"
                    },
                    "comment": {
                        "value": "Dear reviewer,\n\nThank you for your valuable and constructive feedback, which contributes a lot to the enhancement of our paper. Below, we provide our responses addressing your concerns. And all the revisions will be updated in the forthcoming rebuttal revision version of the paper.\n\n**Q1: Describe the key distinctions from prior work in more detail**\n\nA1:\nThe main contribution of the Cooperative SGD paper is to unify a variety of local-update SGD algorithms, such as local SGD, elastic averaging SGD, and decentralized parallel SGD, under the proposed unified Cooperative SGD framework. It also provides a unified convergence analysis for the methods under this framework. As one of the by-products, it proposes to add an auxiliary variable $z$ on the elastic averaging SGD, which serves as a local copy of the model. It can be seen as a preliminary approach that enables the asynchronous communication of model averaging to overlap with computation. However, our method leverages more sophisticated asynchronous communication design to improve the convergence. The differences between our method and the Cooperative SGD are threefold: 1) The CO2 algorithm is built upon SlowMo, which involves slow momentum and outer updates to improve the convergence; 2) CO2 leverages more sophisticated asynchronous communication design together with the outer momentum and outer updates to hide more communications; 3) CO2 also introduces staleness gap penalty and outer momentum clipping to improve the convergence as well as training stability.\n\n\n**Q2: The values of\u00a0$\\tau$\u00a0for each experiment and the description of the tuning procedure**\n\nA2:\nThanks for the valuable comments. We agree that describing the tuning procedure and the setting of $\\tau$ in experiments are helpful for understanding the algorithm. In our experiments, we tune the values of $\\tau$ for each task using a simple grid search strategy within the range of {1, 3, 6, 12, 24, 48, 96, 192} to reach a balance of accuracy and throughput. The tuning experiments are conducted on smaller versions of models when the model to be trained is large, owing to the associated high time and resource costs. We start the tuning of $\\tau$ from 1 to larger candidate values given the consideration of high-speed communication on the corresponding platform. It is worth noting that, in addition to CO2, other methods such as Local-SGD/Adamw and SlowMo also require tuning of $\\tau$. In practice, we exclusively tune $\\tau$ for CO2 and employ the same tuned $\\tau$ values for Local-SGD/Adamw and SlowMo. This is because of the similar role played by $\\tau$ in these local-updating methods. Employing identical $\\tau$ values for different methods on the same task ensures a fair comparison of their convergence and training throughput.\n\nWe list the values of $\\tau$ in all the convergence experiments in the paper as below:\n\n| Task | Model| SGD (Adamw) | Local-SGD (Adamw) | SlowMo     | CO2 |\n|-|-|-|-|-|-|\n|      |             | Acc  | Acc / $\\tau$             | Acc / $\\tau$ | Acc / $\\tau$ |\n| IC (A100)    | ResNet-50   | 76.92      | 75.57 / 1                  | 77.12 / 1       | 77.14 / 1       |\n| IC (A100)   | ViT (Base)  | 81.33        | 78.43 / 3                   | 79.83 / 3       | 80.95 / 3       |\n| IC (A100)    | VVT (Large) | 83.64        | 81.09 / 1                   | 82.75 / 1       | 83.38 / 1       |\n| SS (3090)   | VVT (Large) | 47.82        | 44.25 / 6                   | 47.51 / 6       | 47.80 / 6       |\n| PC (3090)   | Point-MAE   | 68.56        | 64.25 / 3                   | 68.69 / 3       | 68.89 / 3       |\n\n| Task | Model| Adamw      | Local-Adamw | SlowMo     | CO2|\n|-|-|-|-|-|-|\n|      |                 | Acc | Acc / $\\tau$  | Acc / $\\tau$ | Acc / $\\tau$ |\n| ALM (A100)  | GPT-2 (Small)   | 7.44       | 7.95 / 3        | 7.34 / 3       | 7.37 / 3       |\n| ALM (A100)  | GPT-2 (Medium)  | 6.61       | 7.49 / 3       | 6.41 / 3       | 6.36 / 3       |\n| ALM (A100)  | GPT-2 (Large)   | 6.26       | 7.00 / 6       | 6.29 / 6       | 6.13 / 6      |\n| ALM (A100)  | TN-LLM (7B)     | 16.82      | 18.63 / 12       | 16.95 / 12      | 16.78 / 12      |\n| BLM (3090)  | RoBERTa (Large) | 3.96       | 4.38 / 6        | 3.98 / 6       | 3.95 / 6       |\n\n**Q3: Which stage of ZeRO have you used for the TransNormer experiment?**\n\nA3:\nThanks for the question. We use ZeRO stage 2 in the experiments of TransNormer-LLM, will add this information into the paper later."
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2582/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700655114920,
                "cdate": 1700655114920,
                "tmdate": 1700655114920,
                "mdate": 1700655114920,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "JYw3zveou8",
                "forum": "ZO5cn4IfaN",
                "replyto": "JLc9xtFQ3p",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer cSfz (Part 2)"
                    },
                    "comment": {
                        "value": "**Q4: Detailed breakdowns of computation and communication times**\n\nA4:\nThank you for the valuable comments. We conducted quantitative measurements on the time allocated to local computations and asynchronous communication. This assessment specifically targeted CO2 with different $\\tau$ configurations on an A100 cluster equipped with 128 GPUs, employing a slower TCP/IP inter-node network. Adhering to the settings outlined in the paper, utilizing TransNormer-LLM (7B), we maintained consistency in our experimental conditions. The measured duration for a single-step local computation was approximately 0.109s, while an all-reduce communication incurred a cost of 1.566s. Subsequently, we computed and calculated the communication/computation overlap ratio for various $\\tau$ values, presenting the results in the Table below.\n\n| Ethernet | Method | $\\tau$ | Overlap Ratio|\n|-|-|-|-|\n| TCP/IP | CO2 | 48 | 100%   |\n| TCP/IP | CO2 | 24 | 100%   |\n| TCP/IP | CO2 | 12 | 83.28%   |\n| TCP/IP | CO2 | 6 | 41.81%   |\n| TCP/IP | CO2 | 3 | 20.39%   |\n| TCP/IP | CO2 | 1 | 6.52%   |\n\n\n\n**Q5: Why CO2 obtains consistently lower perplexity than AdamW?**\n\nA5:\nThe elements that have an impact on accuracy in CO2 are multiple sides: asynchronous operation and local updating may hurt the convergence as them both introduce noise into the training procedure, while staleness gap penalty and outer momentum clipping may improve the convergence. The resulted accuracy is a mixture of all these elements. Furthermore, in our experiments, we found that in some cases, moderate values of $\\tau$ (i.e., the number of local steps) have a regularizing effect, which leads to an improvement on the accuracy results."
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2582/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700655161654,
                "cdate": 1700655161654,
                "tmdate": 1700655161654,
                "mdate": 1700655161654,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "NnaXV8SS9N",
            "forum": "ZO5cn4IfaN",
            "replyto": "ZO5cn4IfaN",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2582/Reviewer_8oQm"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2582/Reviewer_8oQm"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposed a novel distributed training method: CO2, which can overlap communication and computation in distributed training. This technique is particularly useful when there are a large number of GPU nodes and the inter-connection between nodes are very slow. Compared to previous works, this paper introduces (1) penalty on stale momentum (2) momentum clipping. Empirical ablations show these two techniques are crucial to improve the training convergence performance. The authors also conducted extensive empirical studies, including experiments on image classification, large language model training, to demonstrate the effectiveness of the proposed method."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "4 excellent"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "- The paper has extensive empirical studies across different learning tasks as well as different network environments.\n- The authors also provided a convergence analysis for the proposed method."
                },
                "weaknesses": {
                    "value": "- The idea of overlapping communication and computation is not new, as mentioned in the paper. The key contribution of this paper would be introducing the staleness penalty and momentum clipping mechanisms. They also present solid experimental resutls.\n- The comparison with previous works are not enough. For example, totally overlapping communication and computation has already been achieved. like Wang et al, 2020. Overlap-Local SGD. The authors should include more discussions on the differences. or even include this method as a baseline.\n- It is not very clear the convergence analysis was performed on which algorithm. Does the analysis consider staleness penalty and momentum clipping? Also, the convergence analysis looks like following previous works. It'd be better to cite few at the very beginning of the analyses."
                },
                "questions": {
                    "value": "See the above section."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission2582/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2582/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2582/Reviewer_8oQm"
                    ]
                }
            },
            "number": 6,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2582/-/Official_Review"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699671033090,
            "cdate": 1699671033090,
            "tmdate": 1699671033090,
            "mdate": 1699671033090,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "8FGKb8JBTN",
                "forum": "ZO5cn4IfaN",
                "replyto": "NnaXV8SS9N",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2582/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer 8oQm"
                    },
                    "comment": {
                        "value": "Dear reviewer,\n\nWe thank for the reviewer's comprehensive evaluation on our paper. Below, we provide our responses addressing your concerns. And all the revisions will be updated in the forthcoming rebuttal revision version of the paper.\n\n**Q1: The idea of overlapping communication and computation is not new. The comparison with previous works are not enough, like Wang et al, 2020. Overlap-Local SGD**\n\nA1:\nWe thank for the valuable comments. We will include the Overlap-Local SGD method in our comparisons. The method is also able to overlap communication by local computations via adding an anchor model on each node. The differences between our method and the Overlap-Local SGD are threefold:\n1) Overlap-Local SGD achieves communication-computation overlap on the top of naive Local-SGD, whose convergence performance is normally not good enough. On the other hand, the CO2 is built on SlowMo, which involves outer loop includes outer momentum and outer updates to improve the convergence of native Local-SGD. \n2) As mentioned by the reviewer, CO2 introduced staleness gap penalty and outer momentum clipping to prevent divergence and improve training stability, which has been verified effective via extensive experiments.\n3) The Overlap-Local SGD is only tested on the CIFAR-10 image classification task using ResNet-18, while CO2 has been widely verified on multiple tasks on both CV and NLP fields, including image classification, semantic segmentation, 3D point cloud reconstruction, autoregressive language modeling and bidirectional language modeling.  \n\nTo better comparing the performance of Overlap-Local SGD and CO2, we reproduced Overlap-Local SGD on its open-source implementation and ported it into our codebase. We run the experiments in paper using Overlap-Local SGD and present the results as below. We also list the throughput results and the settings of $\\tau$ in all the convergence experiments we have conducted.\n\n| Task | Model| SGD (Adamw) | Local-SGD(Adamw) | Overlap-Local-SGD(Adamw) | SlowMo     | CO2 |\n|-|-|-|-|-|-|-|\n|      |             | Acc / Thpt  | Acc / Thpt / $\\tau$ | Acc / Thpt / $\\tau$ | Acc / Thpt / $\\tau$ | Acc / Thpt / $\\tau$ |\n| IC (A100)    | ResNet-50   | 76.92 / 108739      | 75.57 / 108758 / 1 | 76.28 / 108765 /1 | 77.12 / 108741 / 1       | 77.14 / 108753 / 1       |\n| IC (A100)   | ViT (Base)  | 81.33 / 39422        | 78.43 / 39512 / 3 | 78.04 / 39511 /3 | 79.83 / 39509 / 3       | 80.95 / 39533 / 3       |\n| IC (A100)    | VVT (Large) | 83.64 / 44375        | 81.09 / 44390 / 1  | 80.33 / 44392 /1 | 82.75 / 44376 / 1       | 83.38 / 44387 / 1       |\n| SS (3090)   | VVT (Large) | 47.82 / 5384        | 44.25 / 5528 / 6   | 45.21 / 5545 /6 | 47.51 / 5521 / 6       | 47.80 / 5562 / 6       |\n| PC (3090)   | Point-MAE   | 68.56 / 5859        | 64.25 / 5931 / 3   | 63.78 / 5950 /3 | 68.69 / 5904 / 3       | 68.89 / 5956 / 3       |\n\n\\* For IC and SS tasks, we present the throughput results in \"images/s\", the image resolution is 224x224; For PC task, we present the throughput results in \"point clouds/s\", each point cloud has 1024 points. \n\n| Task | Model| Adamw      | Local-Adamw | Overlap-Local-SGD(Adamw) | SlowMo     | CO2|\n|-|-|-|-|-|-|-|\n|      |                 | Acc / Thpt | Acc / Thpt / $\\tau$  | Acc / Thpt / $\\tau$ | Acc / Thpt / $\\tau$ | Acc / Thpt / $\\tau$ |\n| ALM (A100)  | GPT-2 (Small)   | 7.44 / 6.543e6       | 7.95 / 6.556e6 / 3        | 8.11 / 6.556e6 / 3 | 7.34 / 6.554e6 / 3       | 7.37 / 6.556e6 / 3       |\n| ALM (A100)  | GPT-2 (Medium)  | 6.61 / 2.084e6       | 7.49 / 2.094e6 / 3       | 7.26 / 2.092e6 / 3 | 6.41 / 2.091e6 / 3       | 6.36 / 2.092e6 / 3       |\n| ALM (A100)  | GPT-2 (Large)   | 6.26 / 1.052e6       | 7.00 / 1.059e6 / 6       | 7.18 / 1.057e6 / 6 | 6.29 / 1.053e6 / 6       | 6.13 / 1.056e6 / 6      |\n| ALM (A100)  | TN-LLM (7B)     | 16.82 / 0.281e6      | 18.63 / 0.303e6 / 12       | 17.83 / 0.306e6 / 12 | 16.95 / 0.301e6 / 12      | 16.78 / 0.308e6 / 12      |\n| BLM (3090)  | RoBERTa (Large) | 3.96 / 2262       | 4.38 / 2815 / 6        | 4.52 / 2877 / 6 | 3.98 / 2794 / 6       | 3.95 / 2892 / 6       |\n\n\\* For ALM and BLM tasks, we present the throughput results in \"tokens/s\".\n\n**Q2: About the convergence analysis**\n\nA2:\nWe thank for the comprehensive review. The convergence analysis was performed on CO2 with Local-SGD used in the inner loop. Staleness gap penalty and momentum clipping are not yet considered in the current convergence analysis. This is because we take these two techniques as plug-ins, a convergence analysis without them is more clean and easy to follow. The proof derivation in SlowMo is taken as a reference when we do convergence analysis for CO2, we will follow the suggestions to add the citation of it in the beginning of the proof."
                    }
                },
                "number": 12,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2582/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700656291838,
                "cdate": 1700656291838,
                "tmdate": 1700656985505,
                "mdate": 1700656985505,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]