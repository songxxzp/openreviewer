[
    {
        "title": "OctoPack: Instruction Tuning Code Large Language Models"
    },
    {
        "review": {
            "id": "3qceva9TQF",
            "forum": "mw1PWNSWZP",
            "replyto": "mw1PWNSWZP",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission635/Reviewer_eETk"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission635/Reviewer_eETk"
            ],
            "content": {
                "summary": {
                    "value": "The authors have compiled CommitPack, a 4TB dataset of permissively licensed git commits across 350 programming languages. They have strictly filtered CommitPack to derive clear imperative instructions, thus creating the instruction fine-tuning dataset, CommitPackFT.\n\nTo better evaluate instruction-tuned, large language models for code, they introduce HumanEvalPack. This extension of HumanEval encompasses three scenarios\u2014code repair, code explanation, and code synthesis\u2014and extends support to six programming languages.\n\nThey have conducted comparisons between different instruction tuning datasets using 5,000 random samples from CommitPackFT. The results demonstrate that combining CommitPackFT with OASST yields the best performance on HumanEvalPack.\n\nThey have released their datasets and the instruction-tuned code language models, OctoCoder and OctoCodeGeeX."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "- By ensuring that the data collected and the models tuned are permissively licensed and free of proprietary data, the authors make a significant contribution to the open-source research community.\n- They put a lot of effort into decontaminating the dataset and guaranteeing the soundness of HumanEvalPack (for example, by removing any solution overlap between the code and the generated explanation), which lends credibility to the results.\n- The ablation studies and qualitative analysis yield many interesting conclusions and offer insights for further research."
                },
                "weaknesses": {
                    "value": "- One thing I find unclear about the writing is the name of CommitPackFT.\nAs I understand, throughout the paper, the authors instruction-tuned the models using a 5000-sample subset of CommitPackFT, as mentioned on page 4\n>For instruction tuning our models, we select 5,000 random samples from COMMITPACKFT across the 6 programming languages that we evaluate on.\nSince you only used a subset of CommitPackFT to fine-tune the model, it might look a bit strange to call the entire dataset \"FT\"."
                },
                "questions": {
                    "value": "I wonder if instruction tuning the mode on more data from CommitPackFT can lead to even better performance."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission635/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission635/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission635/Reviewer_eETk"
                    ]
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission635/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698769277974,
            "cdate": 1698769277974,
            "tmdate": 1699635991317,
            "mdate": 1699635991317,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "QhBWUDF7Jn",
                "forum": "mw1PWNSWZP",
                "replyto": "3qceva9TQF",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission635/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission635/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thanks a lot for your review of the work.\n\n\nWeaknesses:\n\nWe actually intended the FT to stand for `filtered`, thus referring to CommitPackFT being a filtered version of CommitPack. It is a nice coincidence that it could also refer to finetuning. We only used 5,000 samples, because similar to prior work (such as LIMA from Meta AI), we find that very few samples are needed for instruction tuning. Future work may consider finetuning on the entirety of CommitPackFT!\n\nQuestions:\n\nAs mentioned above, we found that the models converge extremely quickly. In fact, the 5,000 samples are not even entirely seen during our instruction tuning of OctoCoder. We think that this is due to most of the capabilities being learned during pre-training, while instruction tuning mostly serves the purpose of teaching the model the expected input and output format."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission635/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700106987148,
                "cdate": 1700106987148,
                "tmdate": 1700106987148,
                "mdate": 1700106987148,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "BEhky3LWs3",
            "forum": "mw1PWNSWZP",
            "replyto": "mw1PWNSWZP",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission635/Reviewer_LDX4"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission635/Reviewer_LDX4"
            ],
            "content": {
                "summary": {
                    "value": "This work proposes to instruction-tune LLMs for code by using commit messages that clearly describe the change to the code in an imperative style, along with the original and new programs. It also introduces an extended version of HumanEval that spans 6 languages and three tasks as a benchmark. The results indicate that the proposed commit-based dataset in combination with OASST (from prior work) forms the strongest fine-tuning mixture, yielding strong results when fine-tuning StarCoder and CodeGeeX."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "4 excellent"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "This work makes multiple substantial and useful contributions to the domain of code-specific instruction-tuning. As it notes, many successful recent approaches have been based on data from proprietary models. Using commit messages from permissive repositories offers a large dataset of relatively easy-to-acquire, and apparently moderately useful, data. The benchmark it contributes is also quite useful, moving substantially beyond the standard HumanEval set.\n\nThe work is quite well written and the supplementary material offers a very thorough view of the methods and results. Overall, this is a good paper."
                },
                "weaknesses": {
                    "value": "The methodology makes a number of decisions that are not particularly well explained or defended. While none of these are critical, several of these would benefit from additional ablations and analyses, or an acknowledgement as a limitation. In no particular order:\n\nThe discussion around CommitPack leads with the rather enormous size of the initial dataset (~4TB). While this is accurate, the version used in this work is just 0.05% this size (2GB). This work offers no validation or experiments involving the original set. This both creates the impression that the 4TB set is likely to very noisy, and suggests that this work should really primarily emphasize the 2GB portion as far as concrete contributions of this paper are concerned. That would involve amending text like in the contributions on P2 and in the abstract, which don't mention the size of the subset that was actually used at all. This also relates to the \"orders of magnitude more\" comment on P9, which seems quite inconsequential.\n\nContinuing the discussion of instruction data, it is not clear from the work why just 5K samples were chosen for fine-tuning. Was the concern that the model would drift too far if more samples were used? It is also not clear why (a) StarCoder was granted 3 extra samples, but that seems pretty inconsequential, and (b) OASST used nearly twice as many examples. Is that because the OASST samples are of higher quality? Was an ablation performed to choose these ratios? This is perhaps a particularly salient issue because one takeaway from this work is that CommitPackFT is not usable on its own. The experiments only ever report results of CommitPackFT + OASST (or similar combinations). This combination mostly boosts \"Fix\" performance; the results on the other two datasets are about even or worse than just using OASST by itself (Tab. 13). Perhaps the idea is that OASST is of very high quality but too small (are the ~8.5K samples used here the entire usable available subset?), so adding reasonably good samples increases performance? In any case, as is, the impression I get is that CommitPackFT isn't of particularly high-quality, but helps because it provides a bit more coding knowledge to OASST. More experiments could help contradict (or proof) that impression.\n\nThe work makes a rather strong argument, that building on HumanEval is a positive since it is so common that it is typically filtered from training data. That argument seems quite challenging to back up, given the absence of insight into how many LLMs are trained and anecdotal observations that pretrained models perform worse on new coding problems (e.g. from CodeContests). I would suggest a more moderated discussion of this choice, acknowledging the use of HumanEval as a potential limitation.\n\nStarCoder is highlighted as performing very poorly in the explanation task, because it is unable to generate explanatory text. I wonder if this overlooks the obvious: query StarCoder to predict a docstring/javadoc/other comment using its FiM capabilities. The model has naturally not encountered samples were code is followed by a request for an explanation, but it would likely do relatively well when prompted to predict a comment above or at the start of a method. Although this somewhat stretches the definition of an \"explanation\", it does give the models more of a chance than the current setup.\n\nAppendix C notes that inputs were filtered to just 768 tokens in length, for the complete before-code + message + after-code series. That is a very low limit by modern language modeling standards. Tab. 8 reinforces that this leads to very short programs compared to the natural distribution of commits. What was the motivation for these limits, and how does this impact the dataset's usefulness for downstream use-cases, where programs are rarely as short as those in the HumanEval suite?\n\n\nMinor notes:\n\n- The center panel in Fig. 3 might benefit from a visual improvement. Without reading the text, it was not clear to me what was happening here; as presented, it looks like the model is prompted with the code, predicts text, than is prompted with more text and predicts the code again, all in one input sample. Perhaps consider inserting a blank space between the two tasks (i.e., before the second model input) and moving the arrow to connect between the two halves.\n- Sec. 3, P5: what experiments were conducted to confirm that GPT-4's accuracy only varies by 2% when sampling 1 sample vs. 20? I would imagine that the variation could be quite a bit more on some tasks. It might be worth sampling, say, 2-5 samples to balance cost and precision.\n- It would probably help the work to also report BLEU/METEOR scores on the explanation generation task. This might offer a complementary view to the proposed automated metric, which is potentially somewhat lossy.\n- A few odd notes from the appendix: why was \"can\u2019t you see i\u2019m updating the time?\" used as a prominent commit message filter (Tab. 5)? This doesn't seem to be a common phrase. Why was only data up till 2016 used? There are archives with more recent GitHub data."
                },
                "questions": {
                    "value": "To avoid redundancy, please consider the questions raised in the weaknesses section above. Primarily, focus on the question of CommitPackFT's value given the relatively limited results (e.g. compared to OASST) and the various places where limitations may need to be acknowledged more clearly."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission635/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698795429610,
            "cdate": 1698795429610,
            "tmdate": 1699635991241,
            "mdate": 1699635991241,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "VvNzS36yAQ",
                "forum": "mw1PWNSWZP",
                "replyto": "BEhky3LWs3",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission635/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission635/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thanks a lot for your very thorough review.\n\nWeaknesses:\n\n1. We do use the entirety of CommitPack for pretraining in `Appendix F`. We should have made this clearer, so we added a pointer to this appendix section in `Section 2. CommitPack: Code Instruction Data`. Given this, we would leave our claims as is, but please let us know if you would still adjust them.\n2. The main reason was that we did not find many samples to be needed for instruction tuning similar to LIMA from Meta AI, where they only used 1000 samples. OctoCoder is only finetuned for 35 steps with a batch size of 32 and packing (Appendix L) corresponding to ~1100 - 8000 samples (depending on the packing efficiency). Regarding (a) and (b), we only made sure all datasets had the same order of magnitude, thus as our filtered OASST and StarCoder were already in that regime, we left them as is and only subsampled the much larger CommitPackFT and xP3x. As training does not cover the entirety of the dataset, we also don\u2019t think that our filtered OASST is too small. Indeed CommitPackFT mainly boosts code fixing. One thing to note is that we only ablated on the Python split of HumanEvalPack. A key feature of CommitPackFT is its diversity across languages. We do not perform fine-tuning on CommitPackFT only, as it does not contain samples with natural language targets (See paragraph on `Importance of samples with natural language targets`).\n3. Thanks for pointing this out. Indeed, inventing entirely new problems would have been better than building on HumanEval. We have rephrased the end of Section 3 to be more moderate and acknowledge this limitation.\n4. This is a very interesting idea that we did not think of. We ran StarCoder with FIM on HumanEvalExplain and obtained the results below.\n\n| Model      | Python | JavaScript | Java | Go | C++ | Rust | Avg. |\n|------------|--------|------------|------|----|-----|------|------|\n| StarCoder  |   19.4   |   17.6     |  16.3   | 11.8  |  17.9  |  16.7   |   16.6  |\n\nWe have observed that StarCoder demonstrates the ability to generate easily readable docstrings (e.g., ``Returns True if there are two elements in the list that are within the threshold\u2019\u2019)  when prompted with FIM. The corresponding average pass@1 results across different programming languages is approximately 16.6%. We have also added these results to the Appendix. Thanks a lot for your awesome suggestion!\n\n5. Great point. The reason for this limit was that a large fraction of the code after is usually the same as the code before. Thus, much of the finetuning would be wasted on teaching the model to copy code from the before to the after. To increase the signal per token (and thus have the model learn faster) and avoid having a model that always repeats user input, we only finetune on relatively short commit pairs. We explain this in Appendix D - we have added some more details to that explanation.\n\nMinor notes:\n1. Thanks, we have updated the plot according to your suggestion.\n2. Good point, we have rephrased that sentence to `For GPT-4, we generate n=1 samples. Using n=1 instead of n=20 for GPT-4 only changed scores from 75.0% to 75.2% pass@1 on HumanEvalSynthesize Python while providing 20x cost savings.` which hopefully clarifies this?\n3. As suggested, we have added a comparison to BLEU and METEOR in Appendix N. Note that for BLEU we assume that the docstring is a ground-truth explanation which can be a problematic assumption as docstrings are not necessarily meant to be explanations.\n4. Surprisingly, \u201ccan\u2019t you see I\u2019m updating the time?\u201d is one of the most common commit messages in our GitHub dump. You can check this blog post where it also appears as the 6th most common message: https://dev.classmethod.jp/articles/my-favorite-bigquery-dataset-newshiro/ or this one from Google: https://codelabs.developers.google.com/codelabs/cloud-bigquery-csharp#5. We\u2019re not sure why this is the case, but decided to remove those samples, as it is not a useful commit message. The data we used unfortunately only contained data until 2016 (https://github.blog/2016-06-29-making-open-source-data-more-available/). We are working on releasing a new commit dataset with more recent data."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission635/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700106917144,
                "cdate": 1700106917144,
                "tmdate": 1700106917144,
                "mdate": 1700106917144,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "B7tWXbRSrZ",
                "forum": "mw1PWNSWZP",
                "replyto": "VvNzS36yAQ",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission635/Reviewer_LDX4"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission635/Reviewer_LDX4"
                ],
                "content": {
                    "comment": {
                        "value": "Thanks for your clarifications! I appreciated the added results & text. To respond to point 1: that's good to know. I would still encourage you to make mention of the 2GB number somewhere in the introduction just to set expectations, e.g., add that there is a curated/cleaned subset of 2GB at the end of the first contribution (on P2).\n\nOtherwise everything looks good now. I'm naturally still quite positive about the work and support its acceptance."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission635/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700677693405,
                "cdate": 1700677693405,
                "tmdate": 1700677693405,
                "mdate": 1700677693405,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "69pVlgx3bf",
            "forum": "mw1PWNSWZP",
            "replyto": "mw1PWNSWZP",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission635/Reviewer_SuJc"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission635/Reviewer_SuJc"
            ],
            "content": {
                "summary": {
                    "value": "This paper studies the training and evaluation of Code LLMs with instructions. It first creates COMMITPACKFT, 2GB of high-quality code with commit messages that assimilate instructions. Then it constructs HUMANEVALPACK, a human-written benchmark covering 3 different tasks for 6 programming languages. Afterward, this work ablates several instruction datasets and \ufb01nds out that COMMITPACKFT combined with natural language data leads to the best performance. Moreover, the models, OCTOCODER and OCTOGEEX, outperform GPT-4."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. The new proposed framework that enhances the instruction tuning on LLMs is impressive. \n2. The paper is well-organized and well-written with clear motivations, detailed discussion, nice figures, and sufficient comparison experiments, making it easy to follow and understand.\n3. This work performs comprehensive experiments over benchmark data to show the effectiveness in several settings.\n4. This work creates new datasets, i.e., COMMITPACK and COMMITPACKFT which are 4TB of permissively licensed code commits across 350 programming languages for pretraining and a \ufb01ltered variant containing high-quality code instructions. These datasets will make contributions to this field in future research."
                },
                "weaknesses": {
                    "value": "1. This work finds out that OCTOCODER and OCTOGEEX, perform best among permissive models. I am curious about the reason behind that. Besides, a detailed introduction about OCTOCODER and OCTOGEEX would help understand the experimental results.\n2. Still in experimental discussion, I am also curious about the performance of OCTOCODER and OCTOGEEX over the HUMANEVALEXPLAIN dataset. Why does OCTOGEEX have better performance in Go and Rust compared to  OCTOCODER? What are the differences between OCTOCODER and OCTOGEEX?"
                },
                "questions": {
                    "value": "1. Why do OCTOCODER and OCTOGEEX perform best among permissive models?\n2. What are the differences between OCTOCODER and OCTOGEEX?\n3. Why does OCTOGEEX have better performance in Go and Rust languages compared to  OCTOCODER?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "details_of_ethics_concerns": {
                    "value": "None"
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission635/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698821300566,
            "cdate": 1698821300566,
            "tmdate": 1699635991162,
            "mdate": 1699635991162,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "IemmWw3xDG",
                "forum": "mw1PWNSWZP",
                "replyto": "69pVlgx3bf",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission635/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission635/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thanks a lot for your review. We would like to point out that OctoCoder and OctoGeeX do not outperform GPT-4.\n\nWeaknesses:\n1. Thanks for noting this! We have added a reference to Appendix L at the end of Section 4.1, where the models (base model, hyperparameters, etc.) are better explained.\n2. The difference is the pre-trained base model and some minor hyperparameters. While OctoCoder is initialized from StarCoder, OctoGeeX is initialized from CodeGeeX2. There are tiny differences in the hyperparameters during finetuning, which are detailed in `Appendix O: Hyperparameters`. Indeed OctoGeeX outperforms OctoCoder on Go and Rust for HumanEvalExplain. The base model (CodeGeeX2) also performs better than OctoCoder\u2019s base model (StarCoder) for Go and Rust (https://github.com/THUDM/CodeGeeX2/blob/main/README_EN.md) which could be the reason for this.\n\n\nQuestions:\n1. See Weaknesses 1.\n2. See Weaknesses 1.\n3. See Weaknesses 2.\n\nLet us know if we can elaborate further on any part."
                    }
                },
                "number": 1,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission635/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700106515906,
                "cdate": 1700106515906,
                "tmdate": 1700106684014,
                "mdate": 1700106684014,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]