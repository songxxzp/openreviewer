[
    {
        "title": "Convolutions Through the Lens of Tensor Networks"
    },
    {
        "review": {
            "id": "26dKNZjreQ",
            "forum": "am9IxubLKV",
            "replyto": "am9IxubLKV",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2591/Reviewer_4fmq"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2591/Reviewer_4fmq"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes a simplifying perspective onto convolutions through tensor networks (TNs). The authors first demonstrate the expressive power of TN by deriving the diagrams of various auto-differentiation operations and popular approximations of second-order information with different hyper-parameters. Using TN also allows re-wiring and simplifying diagrams for faster computation. Based on established machinery for efficient TN contraction, experimental results demonstrate that using TN speeds up a recently-proposed KFAC variant and enables new hardware-efficient tensor dropout for approximate backpropagation."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "The authors propose a novel perspective on convolution operations from tensor network that can leads to faster computation"
                },
                "weaknesses": {
                    "value": "- The novelty of this work is a bit limited, specifically compared with (Hayashi et al. 2019). \n- This paper is a bit difficult to understand without enough prior knowledge on tensor networks\n- Empirical results may be further improved to better support the claim, details can be found in Questions part."
                },
                "questions": {
                    "value": "- From current draft, I am a bit confused on the difference between this work and (Hayashi et al. 2019). I suppose this paper proposes to compute some first-order and second-order information from tensor network as well. Then what is the difference between using standard auto-differentiation packages and the proposed method based on tensor network? It seems that in experiments, the authors only compare the proposed method with standard PyTorch implementations, but not tensor network combined with auto-differentiation packages. Some explanations may be needed here. \n- Based on the above concern, I also wonder if we need to store these computation patterns derived in this paper in implementation. If that is the case, then given new types of convolutions or differentiation operations, will we need to derive some formula again? That sounds not so flexible compared with standard auto-differentiation packages. \n- I also wonder how is the index tensor \\Pi stored in real applications. Since it should be a very sparse tensor, do we have to use some sparse formats? How will it affect the computation time? The authors may need to add more details here. \n- Experimental results are a bit limited from my perspective. While the proposed method based on tensor network really offers some speedup in computation, I suppose there are many other works on speed up inference time (e.g., [1]). Without such comparison, it is hard to see how the proposed method outperforms other works. \n- I also note that most experiments are performed with simple convolution operations, while there are also many different types of convolutions (e.g., separate convolution). It would be better if the authors can also compare with these operations to demonstrate the flexibility of tensor network. \n- Given that the authors have conducted many experiments on using tensor networks to compute higher-order information, it would be better if the authors can provide some more applications with such information to better demonstrate the applicability of proposed method. \n\nMinor: formatting issues. Some captions in the appendix seems to be overlap with the page head. \n\nReference:\n[1] Fast algorithms for convolutional neural networks. CVPR 2016"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2591/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1697692175229,
            "cdate": 1697692175229,
            "tmdate": 1699636196570,
            "mdate": 1699636196570,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "Akd4IJirVC",
                "forum": "am9IxubLKV",
                "replyto": "26dKNZjreQ",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2591/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2591/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to your questions (1/2)"
                    },
                    "comment": {
                        "value": "Dear Reviewer 4fmq,\n\nthanks for your detailed review, especially for taking the time to formulate all of your questions. We would like to address them in the following. Please let us know if you have follow-up questions or think we did not address all of them. We are happy to discuss and provide more details.\n\n**Difference to using auto-diff & Hayashi et al.:** By deriving the Jacobians, our goal was not to replace standard auto-diff. Rather, we wanted to demonstrate that using the TN formulation of convolutions yields white-box implementations, not only of many standard operations like vector-Jacobian products, but also less traditional operations used to approximate second-order information. We argue that this improves flexibility and performance:\n\n- KFAC-reduce is a great example for a non-standard operation that is interesting for second-order methods, but whose implementation in existing ML frameworks suffers from limitations. We showed that a TN implementation's performance improves over the default implementation (**New:** We have added memory benchmarks to address a request from Reviewer D3NB and showed that our TN version also has consistently lower peak memory with savings up to 3 GiB).\n\n- Our second main application, randomized autodiff, demonstrates the flexibility of a TN implementation: While ML frameworks support efficient multiplication with the Jacobian, randomizing the vector-Jacobian product is hard because its implementation is a black box. Our TN VJP is a white box that can be randomized more easily.\n\nThe applications we investigate in the main text are representatives of operations that are challenging to realize with existing frameworks. There are many others, e.g. approximating Hessian diagonals (Appendix B4), or diagonals and mini-block diagonals of GGN/Fisher matrices (Appendix B2 & C). Not only do we mention those in the introduction, but also do we provide their tensor diagrams in the appendix (see Appendix A and Table B2 for visual and pseudo-code overviews). By doing so, we make them accessible to the community, and allow other works to benefit from our proposed TN simplifications.\n\nIn summary, we believe that the focus of our work is different from Hayashi et al. in that it is concerned with investigating and improving computational performance, as well as significantly extending the amount of operations beyond the forward pass.\n\n**Support for different convolution types:** We believe that our framework is fully-compatible with structured convolutions like those mentioned in [1]. You mentioned separable convolutions which we believe are referred to as 'convolutions with channel groups' in our paper. Our formulation supports channel groups, and therefore separable convolutions. To improve clarity, we have added a half sentence in the paper which mentions the alternative name.\n\nOur derivations also carry over to other structured convolutions mentioned in Hayashi et al: From their Figure 1, we support\n- depthwise separable\n- bottleneck/Tucker-2\n- inverted bottleneck\n- flattened\n- CP\n- low-rank filter\n\nThe only difference is that the kernel used by those convolutions is factorized, i.e. a tensor network itself. We can simply substitute this tensor network into our derived expressions and proceed as usual, e.g. apply our symbolic simplifications.\nWe tried to explain this compatibility in Section 6. Let us know if you are satisfied with this clarification. In case you would like us to experiment with other factorized convolutions, it would be great if you could narrow down the scope of experiments we could provide to convince you further."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2591/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700065452209,
                "cdate": 1700065452209,
                "tmdate": 1700065452209,
                "mdate": 1700065452209,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "Bw1Of1iwXq",
            "forum": "am9IxubLKV",
            "replyto": "am9IxubLKV",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2591/Reviewer_Z3Mj"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2591/Reviewer_Z3Mj"
            ],
            "content": {
                "summary": {
                    "value": "The work studies how to represent the CNN layers efficiently using tensor networks. With this framework, the authors further studied efficient automatic differentiation, focusing on the  KFC and KFAC-reduce, two types of approximation of second-order information."
                },
                "soundness": {
                    "value": "4 excellent"
                },
                "presentation": {
                    "value": "4 excellent"
                },
                "contribution": {
                    "value": "4 excellent"
                },
                "strengths": {
                    "value": "1. The paper is quite well-written. I\u2019d like to highlight it because the papers of tensor networks (TNs) are typically mathematically complicated but this paper makes it very clear.\n2. Although this work is not the first to model CNN layers with TNs (see. Hayashi\u2019s work in Neurips\u201919), it highlights the usefulness of tensor modeling for computationally efficient automatic differentiation, which is very important in the computation of deep learning.\n3. The work connects TNs with several critical techniques in ML like KFAC and randomized autodiff. I think these ideas are very helpful to boost the activity of the tensor community to put more effort in machine learning."
                },
                "weaknesses": {
                    "value": "The novelty is relatively weak. For example,  Section 4.2 introduced not too much interesting tricks. It would be better to put this part in the Supp. and instead to illustrate more numerical results."
                },
                "questions": {
                    "value": "In Section 2.2, I cannot fully follow how to use the set operation with the index tuples to model the tensor contractions. Could you give a more intuitive explanation or examples?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2591/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698559048238,
            "cdate": 1698559048238,
            "tmdate": 1699636196501,
            "mdate": 1699636196501,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "JyJ25hJYze",
                "forum": "am9IxubLKV",
                "replyto": "Bw1Of1iwXq",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2591/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2591/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to your questions"
                    },
                    "comment": {
                        "value": "Dear Reviewer Z3Mj,\n\nthanks for your strong support! We agree that tensor networks have a great potential for machine learning and hope we can contribute to making them even more popular with this work.\n\n**Update on results:** In response to Reviewer D3NB, we have extended the run time evaluation by a theoretical and empirical analysis of KFAC-reduce's memory consumption (added as Appendix G). We showed that our TN implementation is not only consistently faster (up to 4.5x), but also has much lower peak memory (with memory savings up to 3GiB for the CNNs we benchmarked in the main text).\n\n**Clarification on Section 2.2:** You are right that the notation in Section 2.2 is complex and may be better explained by an example. For a matrix multiplication `C = einsum(\"ij,jk->ik\", A, B)` you can think of the index tuples as `S_A = (\"i\", \"j\")`, `S_B = (\"j\", \"k\")` and `S_C = (\"i\", \"k\")`. The set operations in Equations 3, 4 serve to identify which indices are summed out, i.e. are not part of the output index tuple: `(S_A \u222a S_B) \\ S_C = (\"j\")`.\n\nOur goal was to rigorously write down what `einsum` does and to convince the reader that drawing a tensor diagram is more intuitive and requires less cognitive load than using Equations 3, 4. We have added the above example to Appendix H2 and referenced it in the main text. Let us know if this improves your understanding of the presentation.\n\nPlease also let us know if you have any follow-up questions. We would be happy to discuss further."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2591/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700065276069,
                "cdate": 1700065276069,
                "tmdate": 1700065276069,
                "mdate": 1700065276069,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "j3o0r2sG7B",
                "forum": "am9IxubLKV",
                "replyto": "JyJ25hJYze",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2591/Reviewer_Z3Mj"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2591/Reviewer_Z3Mj"
                ],
                "content": {
                    "title": {
                        "value": "Thank you for the response."
                    },
                    "comment": {
                        "value": "The part of \"Clarification on Section 2.2:\" is very clear. Thank you for the explanation. I found that many reviewers mentioned their concerns about the novelty of this work: it seems to be similar to the work (Hayashi et al., 2019). On this point, I'd like to highlight again from my review that \"Although this work is not the first to model CNN layers with TNs (see. Hayashi\u2019s work in Neurips\u201919), it highlights the *usefulness of tensor modeling for computationally efficient automatic differentiation*, which is very important in the computation of deep learning.\""
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2591/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700714879740,
                "cdate": 1700714879740,
                "tmdate": 1700714879740,
                "mdate": 1700714879740,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "aM3B8x0bhp",
            "forum": "am9IxubLKV",
            "replyto": "am9IxubLKV",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2591/Reviewer_XFQf"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2591/Reviewer_XFQf"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes a perspective to simplify convolutions through tensor networks (TNs) which allow reasoning about the underlying tensor multiplications by drawing diagrams. To demonstrate its expressiveness, the diagrams of various autodiff operations and popular approximations of second-order information are derived. Finally, the computational performance improvement is proved under the proposed perspective."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1. The proposed perspective is significant to the development of convolution neural networks since it opens up potential research prospects.\n2. Based on the proposed perspective of the tensor network, the authors derive the Jacobians of convolution and automatic differentiation. These efforts are quite meaningful since both derivatives and automatic differentiation mechanisms always play an important role in ML research.\n3. Both implementation results relying on established machinery for efficient TN contraction and experimental results show the advantage of this perspective."
                },
                "weaknesses": {
                    "value": "The main concern is contribution. The authors point out the advantages of this perspective rather than developing a framework in a novel way. From this point of view, the contribution seems limited. Therefore, the authors' central contribution only lies in some derivation based on this perspective, such as automatic differentiation."
                },
                "questions": {
                    "value": "I'm not sure whether the proposal of perspective is a contribution and means much to the community or not. It would be helpful to provide some explanation about this point."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission2591/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2591/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2591/Reviewer_XFQf"
                    ]
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2591/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698765476759,
            "cdate": 1698765476759,
            "tmdate": 1699636196428,
            "mdate": 1699636196428,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "yx9Y3qAMCW",
                "forum": "am9IxubLKV",
                "replyto": "aM3B8x0bhp",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2591/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2591/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to your review"
                    },
                    "comment": {
                        "value": "Dear Reviewer XFQf,\n\nThank you for your feedback.\n\n**Contribution beyond new perspective:** We would like to tackle your point that the paper's only contribution is presenting a new perspective.\nSpecifically, we believe that our paper's experiments elaborate on concrete applications and advance the state of the art:\n\nWe can accelerate the pre-conditioner computation of a popular second-order method for deep learning by up to 4.5x. The run time improvements enable more frequent pre-conditioner updates which are so far not very popular due to the increased cost. As requested by Reviewer D3NB, we extended the run time results and measured the memory consumption, showing that our TN approach has consistently smaller peak memory with savings up to 3 GiB for KFAC-reduce. The authors of [1] mention KFAC-reduce's memory overhead caused by `im2col` as important limitation. By reducing the peak memory, our approach enables operating the algorithm at larger batch sizes. This is an important improvement because second-order methods seem to require larger batch sizes than first-order methods (see for instance [2, 3]).\n\nOur faster and more memory-efficient KFAC implementation for convolutions is not only relevant to the optimization community. KFAC is also a popular curvature approximation for Bayesian neural networks to construct Laplace approximations [4].\n\nPlease let us know if you have any follow-up questions. We would be happy to discuss them!\n\n**References:**\n\n[1] Eschenhagen, R., Immer, A., Turner, R. E., Schneider, F., & Hennig, P. (NeurIPS 2023): Kronecker-factored approximate curvature for modern neural network architectures.\n\n[2] Martens, J., & Grosse, R. (ICML 2015): Optimizing neural networks with Kronecker-factored approximate curvature.\n\n[3] Grosse, R., & Martens, J. (ICML 2016). A kronecker-factored approximate Fisher matrix for convolution layers.\n\n[4] Daxberger, E., Kristiadi, A., Immer, A., Eschenhagen, R., Bauer, M., & Hennig, P. (NeurIPS 2021). Laplace redux - effortless bayesian deep learning."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2591/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700065104766,
                "cdate": 1700065104766,
                "tmdate": 1700065152127,
                "mdate": 1700065152127,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "Jsc3ZBmbjE",
            "forum": "am9IxubLKV",
            "replyto": "am9IxubLKV",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2591/Reviewer_D3NB"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2591/Reviewer_D3NB"
            ],
            "content": {
                "summary": {
                    "value": "The paper discusses the analysis and simplification of convolutions in neural networks using tensor networks (TNs). Convolutional layers are found to be more challenging to analyze than other layers in deep learning architectures. The authors propose a new perspective using TNs, which allow for reasoning about tensor multiplications through diagrams. They demonstrate the expressive power of TNs by deriving diagrams for various automatic differentiation operations and approximations of second-order information. The document also introduces convolution-specific transformations based on connectivity patterns to simplify TN diagrams. The authors compare the computational performance of default implementations and TN implementations, showing potential speed-ups. They also mention the potential for hardware-efficient tensor dropout for approximate backpropagation."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. StrengthsRepresenting convolution operation as multiple tensor contractions, which is quite interesting and novel.\n2. By giving TN representation of convolution operation, the authors find that some memory-cost operations can be improved, e.g., KFC and its variants.\n3. This paper is easy to understand and presents many graphical operations to illustrate the operations under the TNs framework."
                },
                "weaknesses": {
                    "value": "1. This method is relatively straightforward and intuitive. The primary innovation of the paper lies in the use of tensor networks to represent CNN operations. However, when it comes to accelerating the KFC process, the paper lacks theoretical analysis on how much memory consumption is reduced. Furthermore, in the experiments, its effectiveness is only demonstrated based on the proportion of experimental runtime. Whether in theory or practice, the paper's description of the improvements in KFC is insufficient.\n2. The advantages of using tensor networks to represent CNNs are not thoroughly discussed in this article. The paper primarily focuses on the advantages in the context of KFC, leading me to believe that it is primarily aimed at addressing memory consumption issues within KFC. Therefore, it might be more appropriate to modify the paper's topic and title to \"Accelerating KFC with Tensor Network (TN) Methods.\u201d"
                },
                "questions": {
                    "value": "1. The main improvement of this paper is that it avoids to unfolding the input tensor [[X]] using  memory cost methods, e.g., im2col. However, in both theoretical and practical experiments, what amount of memory savings can be achieved by using tensor networks for KFC training?\n2. The paper provides a comprehensive guide on how to use Tensor Networks to represent CNNs, and offers detailed operations for various CNNs. However, in terms of the advantages of using Tensor Networks to represent CNNs, the paper lacks further analysis and discussion beyond a brief analysis in the context of KFC. For instance, once CNNs are represented in the form of TN, could this representation also be benefit to other second-order analysis and optimization methods, such as the Approximate Hessian diagonal, KBFGS, and Hessian rank mentioned in the Introduction? If this is possible, I would prefer to see the authors provide a more in-depth discussion."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2591/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698828753517,
            "cdate": 1698828753517,
            "tmdate": 1699636196311,
            "mdate": 1699636196311,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "SVv0ysHRcV",
                "forum": "am9IxubLKV",
                "replyto": "Jsc3ZBmbjE",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2591/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2591/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to your questions"
                    },
                    "comment": {
                        "value": "Dear Reviewer D3NB,\n\nthanks for your thorough review and detailed questions. We are happy to add more details to our answers below and discuss follow-up questions; please let us know if you have any.\n\n**Memory consumption (Q1):** You have a point that we do not support our claim of reduced peak memory for KFAC-reduce with evidence. To alleviate this concern, we added a theoretical analysis and empirical evaluation in Appendix G:\n\nFor KFAC-reduce, the main difference between default and TN implementation is the computation of the averaged unfolded input $[[\\mathbf{\\mathsf{X}} ]]^{(\\text{avg})} := \\frac{1}{(O_1 O_2)} 1_{O_1 O_2}^{\\top} [[ \\mathbf{\\mathsf{X}} ]]$ which consists of $C_{\\text{in}} K_1 K_2$ numbers.\n\n- The default implementation needs to build up the unfolded input. This requires extra storage of $C_{\\text{in}} K_1 K_2 O_1 O_2$ numbers.\n\n- Our proposed TN implementation uses the averaged index patterns, directly computed via a modification of Algorithm D1. They consist of $I_1 K_1 + I_2 K_2$ numbers. In contrast to the default implementation, spatial dimensions are de-coupled and there is no dependency on $C_{\\text{in}}$.\n\n- For structured convolutions, we can use our proposed simplifications to express the pattern tensor action through `reshape`s and `narrow`s that often do not require additional memory. This completely eliminates the need to store additional tensors.\n\nTo empirically demonstrate this memory reduction inside the computation of the KFAC-reduce factor, we measured its peak memory and subtracted the memory of storing the input $\\mathbf{\\mathsf{X}}$ and the result $\\hat{\\mathbf{\\Omega}}$. This serves as a proxy for the extra memory that is temporarily required. We consistently observe that the default implementation requires more extra memory than the TN implementation, whose demand is further reduced for structured convolutions if we enable our simplifications.\n\n**For example, our TN implementation uses 3 GiB less memory on ConvNeXt-base's `features.1.0.block.0` convolutions.** This is a considerable fraction of the 16-32 GiB available on most contemporary GPUs.\n\nThese results further substantiate our claims as they complement our demonstrated run time improvements. Our work leads to direct improvements of KFC in that it not only enables more frequent pre-conditioner updates (currently, updating every $10-100$ steps is popular), but also extends the regime of feasible batch sizes such an optimizer can operate in. This is important as second-order methods seem to require larger batch sizes than first-order methods (e.g. [1, 2]).\n\n**Applications other than KFC (Q2):** We take your point that our performance evaluation focuses on KFC. This is because it makes a great example for a non-standard operation that is interesting for the design of new algorithms, but whose implementation in existing ML frameworks suffers from limitations. Our second application, randomized autodiff, is another---yet orthogonal---instance that demonstrates the flexibility of a TN implementation: While ML frameworks support efficient multiplication with the Jacobian, randomizing the vector-Jacobian product is hard because its implementation is a black box. By deriving the VJP as a TN, we provide a white box implementation which can be randomized more easily.\n\nThe applications we provide in the main text are representatives of operations that are challenging to realize with existing frameworks, e.g. approximating Hessian diagonals (Appendix B4), or diagonals and mini-block diagonals of GGN/Fisher matrices (Appendix B2 & C). Note that we not only mention them in the introduction, but also provide their tensor diagrams in the appendix (see Appendix A and Table B2 for visual and pseudo-code overviews). By doing so, we make them accessible to the community, and allow other works to benefit from our proposed TN simplifications. Please let us know if you would like us to provide more details on one of these operations in the appendix, or add the discussion of a new quantity that is currently not addressed.\n\nOur faster and more memory-efficient KFAC implementation for convolutions is not only relevant for optimization. KFAC is also a popular curvature approximation for Bayesian applications with neural networks, such as constructing Laplace approximations (e.g. [3] and references within).\n\n**References:**\n\n[1] Martens, J., & Grosse, R. (ICML 2015): Optimizing neural networks with Kronecker-factored approximate curvature.\n\n[2] Grosse, R., & Martens, J. (ICML 2016). A kronecker-factored approximate Fisher matrix for convolution layers.\n\n[3] Daxberger, E., Kristiadi, A., Immer, A., Eschenhagen, R., Bauer, M., & Hennig, P. (NeurIPS 2021). Laplace redux - effortless bayesian deep learning."
                    }
                },
                "number": 1,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2591/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700064942693,
                "cdate": 1700064942693,
                "tmdate": 1700064942693,
                "mdate": 1700064942693,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]