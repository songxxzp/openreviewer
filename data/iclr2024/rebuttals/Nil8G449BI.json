[
    {
        "title": "Block-local learning with probabilistic latent representations"
    },
    {
        "review": {
            "id": "UnU1z7l4pA",
            "forum": "Nil8G449BI",
            "replyto": "Nil8G449BI",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission5612/Reviewer_ACie"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission5612/Reviewer_ACie"
            ],
            "content": {
                "summary": {
                    "value": "In this paper, a new training method is proposed for neural network architectures. Also, the authors provide a novel theoretical framework to analyze deep neural networks as parameters of probability distributions. Based on it, a new training method is proposed, with theory and numerical experiments on classification tasks."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "4 excellent"
                },
                "strengths": {
                    "value": "The theoretical analysis to interpret DNN for probability distribution viewpoint is interesting. Also, the paper is well organized and well written to prove the new concept and method."
                },
                "weaknesses": {
                    "value": "Please see the questions in the following part. There are some details not clear enough. Also, the numerical experiment results are not satisfying."
                },
                "questions": {
                    "value": "Here are some questions for this paper:\nQ: How to the principle or theory to select split blocks for each architecture? \nQ: How to deal with models with multiple branches? Is it possible to split the network for each branch? \nQ: What is the reason for the large performance gap on Cifar10 and ImageNet tasks, compare with BP method? Are there using same data preprocessing and augmentations? \nQ: What is the training time and convergence speed compared with BP method?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission5612/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission5612/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission5612/Reviewer_ACie"
                    ]
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission5612/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698556274600,
            "cdate": 1698556274600,
            "tmdate": 1699636579346,
            "mdate": 1699636579346,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "56WTexEVVO",
                "forum": "Nil8G449BI",
                "replyto": "UnU1z7l4pA",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5612/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5612/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "*Q: How to the principle or theory to select split blocks for each architecture?*\n\nIn general, the number of blocks will be determined based on the requirements of distributing the model (model size, no. of devices, memory per device etc.). There is a trade-off in number of splits and sacrifice in performance which depends on learning task and network architecture (See Figure S1).\n\n*Q: How to deal with models with multiple branches? Is it possible to split the network for each branch?*\n\nWe did not test models with multiple branches yet. However, the theory would support such models. Will be interesting to test that in future work.\n\n*Q: What is the reason for the large performance gap on Cifar10 and ImageNet tasks, compare with BP method? Are there using same data preprocessing and augmentations?*\n\nYes, they use the same preprocessing and augmentation. We think there are two main reasons for the gap: 1) due to time and resource limitations we were not able to do any hyper-parameter search for ImageNet. 2) For tasks with number of classes in the range of the batch size, the greedy update of the backward network may not be suitable (backward messages are estimated by 1-2 samples on expectation which doesn't provide rich enough statistics). Non-greedy updates of backward nets would likely fix that, which we are currently developing. We still thought it is beneficial for the paper to include the ImageNet experiments in the current, since the performance is at least not trivial. We will update the discussion and clarify these shortcomings of the current form of the algorithm.\n\n*Q: What is the training time and convergence speed compared with BP method?*\n\nWe implemented 2 versions of our algorithm, one a naive implementation which is as expensive as backprop (with additional linear layers for the backward network) and second , as the reviewer rightly suggested to put different blocks on multiple devices. However the updates are still locked due to pytorch\u2019s limitations. We consider these implementations as proof of concept and to fully utilize the speed-up of unlocked updates will require a c++ (libtorch) implementation."
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5612/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700556191104,
                "cdate": 1700556191104,
                "tmdate": 1700556191104,
                "mdate": 1700556191104,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "zRSZy2DIAb",
            "forum": "Nil8G449BI",
            "replyto": "Nil8G449BI",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission5612/Reviewer_ckuE"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission5612/Reviewer_ckuE"
            ],
            "content": {
                "summary": {
                    "value": "his paper presents two ideas.\nThe first is the bidirectional (forward and backward) propagation over a set of synaptic weights.\nA part of the network propagates a signal in the forward direction.\nThe other part propagates the signal in the backward direction. \nThe second is local blocking or breaking down of a deep network into smaller blocks. \nThis promotes parallel processing."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "This paper is well-organized."
                },
                "weaknesses": {
                    "value": "1). The main contributions or claims of this paper seem minimal relative to existing work in this area.\n\nHere are my reasons:\n\nThe bidirectional propagation overlaps with the work presented in the paper titled \"Bidirectional Backpropagation\".\nIt uses a set of synaptic weights for forward and backward propagation.\nThis generalizes to the case of using two separate networks.\nThe two separate network case is a special case that uses a deterministic dropout along the forward and backward propagation. \n\n\nThey also present deep-neural blocking as a method for breaking down deep-neural networks into blocks of smaller networks.\nThey used the multiplication theorem for probability to factor the complete likelihood to a product of block likelihoods.\nYou can find this in their paper on \"Bidirectional backpropagation for high-capacity blocking networks\".\nEquations (1) and (2) of their paper show the likelihood factorization.\nThis is similar to what you have listed as one of the main contributions.\nYou can also check equation (133) in the paper on \"Noise can speed backpropagation learning and deep bidirectional pretraining\".\n\nFinally, their paper on \"Bidirectional backpropagation for high-capacity blocking networks\" combines bidirectional backpropagation with blocking.\nThis is a combination of bidirectional propagation and deep-neural blocking."
                },
                "questions": {
                    "value": "Please can you identify the distinction(s) between your work and the prior work listed above on bidirectional backpropagation and neural blocking?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission5612/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission5612/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission5612/Reviewer_ckuE"
                    ]
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission5612/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698736129381,
            "cdate": 1698736129381,
            "tmdate": 1699636579240,
            "mdate": 1699636579240,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "Z8X9E9iMel",
                "forum": "Nil8G449BI",
                "replyto": "zRSZy2DIAb",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5612/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5612/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "The main contribution of our model is to show that using separated forward and backward networks, in a variational learning setup, local learning rules can be derived (Equations 6 and 7), that do not suffer from the locking and weight transport problem.  Updates are calculated and applied on a per-block basis after a forward pass through the network. The backward network can have any architecture including sharing parameters with the forward network, however we didn't consider that case yet. Hence we would consider this to be the most general case. Also Bidirectional backpropagation doesn't interpret the outputs of the network as exp. family distribution parameters. Furthermore, our method doesn't include a network-wide finetuning phase as in Bidirectional backpropagation. The goal of Bidirectional backpropagation also doesn't seem to be solving the locking and weight transport problem. We will be happy to point out these differences in more details in a revised version of the paper."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5612/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700555105997,
                "cdate": 1700555105997,
                "tmdate": 1700555105997,
                "mdate": 1700555105997,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "e1N6GwbLaL",
            "forum": "Nil8G449BI",
            "replyto": "Nil8G449BI",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission5612/Reviewer_g9PU"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission5612/Reviewer_g9PU"
            ],
            "content": {
                "summary": {
                    "value": "The paper introduces a probabilistic framework for block/layer-wise learning, such that a network encodes (parameters of) conditional distributions between latent variables that sequentially go from input to output."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. As far as I know, the idea is novel and is reasonably backed by the variational methods literature. \n2. The idea works on simple tasks, and doesn't fail (although doesn't excel) on ImageNet, which is a good sign."
                },
                "weaknesses": {
                    "value": "1. I found the paper rather hard to read. I think the main issue is that the network architecture and its specific computations are unusual, but they're never presented in one place. It takes from page 4 to page 7 to introduce the full architecture/losses. This is fine, since there are many non-trivial steps, but having them in one place would help a lot (perhaps in an extended Tab. 1, which by the way should be labelled as an algorithm). \n\n2. The following claim from the abstract: \"demonstrating state-of-the-art performance using block-local learning\" is not correct -- ~54% top1 accuracy on ImageNet from Tab. 2 with a ResNet50 is not very good. It's nice to see that the model doesn't fail, but it's not SoTA at all (even AlexNet reaches 56% top1 accuracy). \n\n3. It's also worth noting that block/layer-wise learning can perform as well as backprop, and with a similar idea of using small backward error networks. See Fig. 1 and overall results in [Belilovsky et al., 2019] (cited in this paper). It's not clear if the performance difference is due to inherent problems with the probabilistic interpretation in this paper or some other reasons."
                },
                "questions": {
                    "value": "**Comments**:\n1. First of all, the authors should use the ICLR style (currently the typeface is wrong and citations are not highlighted) and fit the paper into 9 pages. \n2. Top-3 for MNIST/CIFAR10 is not a standard metric. Moreover, given 10 classes and the simplicity of the datasets, anything but top-1 is mostly meaningless.\n3. In S1.3, I think the first expectation should be just an integral over $z_k$. Expectation adds $p(z_k)$ which shouldn\u2019t be there.\n4. Citation issue: Jimenez Rezende et al. (2016) citation accidentally includes the author\u2019s middle name.\n5. Eqs. S12-13 and later: should there be brackets starting after the first sum?\n\n**Clarification questions**\n\n2. Eq. 7 should have $\\beta_k$ instead of $q_k$, right?\n\n3. This bit on page 6 is confusing:\n> furthermore, the loss is local with respect to learning, i.e. it doesn\u2019t require global signals to be communicated to each block. In this sense, our approach differs from previous contrastive methods that need to distinguish between positive and negative samples. In our approach, any sample that passes through a block can be used directly for weight updating and is treated in the same way\n\nThe paper was about supervised learning up until now, right?\n\n**Conceptual questions**:\n\n1. What\u2019s the actual speed-up compared to backprop? With a naive implementation that doesn't account for unlocked updates, it should be as expensive. I guess it might be possible to put different blocks on different devices so the backward pass in earlier blocks will happen early on, but that wouldn\u2019t work on a single GPU (right?) and also wouldn\u2019t be easy to implement in PyTorch. How was it implemented by the authors?\n\n2. Judging by Fig. 2, posterior bootstrapping introduces backward locking. Is that correct?\n\n\n\n\n-----------\n**Post-rebuttal**: since my questions were addressed, but the weaknesses like performance are still there, I'm increasing the score from 5 to 6."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission5612/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission5612/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission5612/Reviewer_g9PU"
                    ]
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission5612/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698784077814,
            "cdate": 1698784077814,
            "tmdate": 1700682196889,
            "mdate": 1700682196889,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "lbEPlaz4oA",
                "forum": "Nil8G449BI",
                "replyto": "e1N6GwbLaL",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5612/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5612/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "*Comments*\nThank you for pointing out these style issues. We have corrected them and revise the pdf.\n\n*Clarification questions*\n2. Actually, it should be $\\rho_k$ as in Eq. (4). Technically $q_k$ is correct here, however, the definition of $q_k$ comes only late in the supplement. We noticed an ambiguity in our use of the distribution $q$. We will simplify the notation to resolve that issue.\n\n3. Correct. However, a number of previous methods used a contrastive step to arrive at block-local learning rules. Here, no such contrastive step is needed. We will clarify this.\n\n*Conceptual questions*\n1. As mentioned in the response to ACie, we implemented 2 versions of our algorithm, one a naive implementation which is as expensive as backprop (with additional linear layers for the backward network) and second , as the reviewer rightly suggested to put different blocks on multiple devices. However the updates are still locked due to pytorch\u2019s limitations. We consider these implementations as proof of concept and to fully utilize the speed-up of unlocked updates will require a c++ (libtorch) implementation.\n\n2. No there is no backward locking in our method. All updates can be computed in forward mode and can be parallelized. The only required synchronization is in the forward path through the network, which is unavoidable. We explained the precise structure of the parallelism in Fig.3."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5612/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700554403749,
                "cdate": 1700554403749,
                "tmdate": 1700555305105,
                "mdate": 1700555305105,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "zngiRqmsZA",
                "forum": "Nil8G449BI",
                "replyto": "lbEPlaz4oA",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5612/Reviewer_g9PU"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5612/Reviewer_g9PU"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for the response and clarifications! I have further questions though.\n\nFirst, I think it might be a good idea to updated the pdf during the discussion period to fix the style issues.\n\nSecond, I'm still confused about backward locking and bootstrapping. Fig. 2, as I understand it, should the optimal bootstrapping schedule that propagates errors backwards, which naturally introduces backwards locking (right?). Fig. 3 shows the simplified bootstrapping schedule that doesn't have that issue, but as mentioned in the appendix is only an approximation. From what I understood the experiments are done for both the simplified and the optimal schedules (e.g. Tab. S1 mentions the optimal one). Is this correct?"
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5612/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700593066584,
                "cdate": 1700593066584,
                "tmdate": 1700593066584,
                "mdate": 1700593066584,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "PQMZEqE6vQ",
                "forum": "Nil8G449BI",
                "replyto": "ICz4VWaGxx",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5612/Reviewer_g9PU"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5612/Reviewer_g9PU"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you! Yes, that clarifies the confusion. I've increased the score from 5 to 6."
                    }
                },
                "number": 11,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5612/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700682247962,
                "cdate": 1700682247962,
                "tmdate": 1700682247962,
                "mdate": 1700682247962,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "7r4bWPabHR",
            "forum": "Nil8G449BI",
            "replyto": "Nil8G449BI",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission5612/Reviewer_nrns"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission5612/Reviewer_nrns"
            ],
            "content": {
                "summary": {
                    "value": "This paper introduces a probabilistic interpretation of the input-output mapping defined by a neural network, together with a variational inference method used to optimize the log-likelihood.\nThe variational loss is an upper bound on the actual log-likelihood, and thus optimizing this variational loss to zero guarantees the optimization of the log-likelihood.\nThe variational loss can be decomposed into block local loss terms, making the optimization of this surrogate objective amenable to parallelization, removing both forward and backward locking of the back-propagation algorithm.\nIt also solves the weight transport problem as the feedback from labels, usually computed with back-propagation, is provided by a separate neural network.\nThe resulting algorithm shows promising performances on standard classification benchmarks, with accuracy being rather low with respect to vanilla gradient descent implemented with the back-propagation algorithm.\nThe proposed method being however well-posed and grounded in variational inference, where practical issues are well documented, it is likely that further improvements could be achieved by optimizing all the hyperparameters such as the design of the feedback network, the expressivity of the exponential family considered as an intermediate representation, or simply the optimization hyperparameters such as the learning rate or the type of optimizer used.\n\nThe paper allocates a long portion of the main body to the description of the proposed method and only shows a brief summary of the experiments performed, with experimental details and some additional experiments (i.e. ablation study) deferred in the appendix."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1) The probabilistic interpretation of input-output mapping allows the derivation of a variational inference method to tackle the optimization of the model weights. The reviewer is not aware of such formulation in the literature but is however not an expert in this particular field.\n2) The proposed method is broadly applicable to most feedforward architectures used in deep learning applications.\n3) The results on classification benchmarks are on par with other local learning methods without extensive hyperparameter tuning."
                },
                "weaknesses": {
                    "value": "1) The proposed probabilistic interpretation of the input-output mapping appears new and is a bit hard to follow at first glance.\n2) It is difficult to understand how the variational distribution $q$ is actually defined. Only backward messages $\\beta_k = q(y | z_k)$ and it is unclear how the full posterior $q(z_k | x, y)$ is defined. My best guess is that it is implicitly defined through the bayes rule by combining the messages $\\beta_k$ for all $1 \\leq k \\leq N$.\n3) Some notations are only implicitly defined, such as $q_k$, or not defined at all such as $a_{kj}$ and $z_{kj}$.\n4) It is difficult to understand in which case the variational posterior could recover the true posterior. In other words, it is unclear which messages $\\beta_k$ would lead to a perfect reconstruction of the true posterior, as well as how to compute them.\n5) There are no guidelines on how to design the different components of the proposed algorithm. For example, there is no ablation study on the expressivity of the EF distribution used as a latent representation, nor on the expressivity of the feedback network.\n6) [Minor comment] Equation S2 of Section S1.2 in the supplement material defines an upper bound of the log-likelihood and refers to equation (1) of the main text. However, equation (1) of the main text refers to the gradient of the log-likelihood."
                },
                "questions": {
                    "value": "1) The distribution $q$ is only defined implicitly through the definition of backward messages $\\beta_k = q(y | z_k)$. Could the author either confirm that it is only implicitly defined because we only need to compute messages $\\beta_k = q(y | z_k)$ or specify the definition of the full posterior $q(z_k| x, y)$?\n2) In equation (5), I don\u2019t understand what the index $j$ stands for. Are $\\alpha_{kj}$ and $\\beta_{kj}$ parameters of the distribution $\\alpha_k$ and $\\beta_k$ or actual distributions in their own right?\n3) Does equation (6) make use of the assumption that $p_k$ and $\\alpha_k$ are Gaussian or from a distribution in the exponential family?\n4) Could the author clarify the approximation gap between the true log-likelihood and their variational surrogate? In particular, when does the variational loss recover the true log-likelihood?\n5) Could the authors give some intuition on the design of the latent representation and the expressivity needed in the feedback network?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission5612/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission5612/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission5612/Reviewer_nrns"
                    ]
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission5612/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699035085216,
            "cdate": 1699035085216,
            "tmdate": 1700679274308,
            "mdate": 1700679274308,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "MGib8QoATp",
                "forum": "Nil8G449BI",
                "replyto": "7r4bWPabHR",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5612/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5612/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "1. We tried to keep the initial part of the derivation general, therefore $\\beta$ is initially only defined as any distribution $q(y|z_k)$. We use a variational posterior that factorizes into the parts $\\alpha$ and $\\beta$ according to Eq.(4). $\\alpha$ is the true forward message computed by the forward network. $\\beta$ is the approximate backward message that determines how well the network activation at block $k$ predicts the labels $y$.\nBased on this general derivation, to arrive at a concrete implemenation we used the exponential family assumption. The variational posterior that was used in our experiemnts is defined in Eq. S19.\n\n2. $\\alpha_{kj}$, $\\beta_{kj}$ are the independent components corresponding to activations of individual units of the forward and backward network, respectively. They determine the natural parameters  of distributions $\\alpha_k$, $\\beta_k$.\n\n3. Eq. 6 is the general form for any member of the exp. family. Conveniently, only the first and second order statistics are needed to compute the divergence and $\\mu$ and $\\sigma$ refer here to these sufficient statistics. We establish this result in section S1.4 in detail. In experiments we used a Gaussian distribution, for which the derivation is in S1.5.\n\n4. The approximation becomes exact when if $\\beta_k = p(y|z_k)$, i.e. the true posterior of the targets $y$, given the network output at block $k$, according to the forward network (its true Bayesian inversion). However, with the simplified form of variational distribution that we use, where $\\beta_k$\u2019s are given by backward network activity, a gap between the true log-likelihood  and the variational surrogate will always remain, as is the case in standard variational methods.\n\n5. We chose the simplest possible feedback network that did not need additional gradient based updates for efficiency. Early tests showed that more sophisticated architectures were not needed in those cases but it is still a future work. However, more complex tasks like ImageNet may require more complex backward network structures, which may explain the gap in performance."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5612/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700553524591,
                "cdate": 1700553524591,
                "tmdate": 1700553524591,
                "mdate": 1700553524591,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "kTJD00S8GC",
                "forum": "Nil8G449BI",
                "replyto": "MGib8QoATp",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5612/Reviewer_nrns"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5612/Reviewer_nrns"
                ],
                "content": {
                    "comment": {
                        "value": "I thank the author for clarifying some of my concerns.\nIn general, I still have concerns on how to efficiently tune the proposed method to optimize model performance, however, the presented results are encouraging given that the formulation of the learning problem is local and that the variational upper bound allows to implicitly optimize the true classification loss, contrary to other local learning approach.\nI will raise my score to 6 since I think this paper should be accepted because, to my knowledge, such variational framework for local learning is novel in the literature and the interpretation of the activation of the different modules are also novel.\nThus, I consider that the provided amount of work is enough for further research to be conducted by peers.\nI am not increasing my score further as there are not enough ablation on the flexibility of the proposed method, particularly on trainable feedback network with higher statistical capacity.\nIt should be noted that DGL method achieved higher test accuracies on ImageNet despite optimizing a greedy objective at each block [1].\n\n[1] Belilovsky, Eugene, Michael Eickenberg, and Edouard Oyallon. \"Decoupled greedy learning of cnns.\" International Conference on Machine Learning. PMLR, 2020."
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5612/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700679258348,
                "cdate": 1700679258348,
                "tmdate": 1700679258348,
                "mdate": 1700679258348,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]