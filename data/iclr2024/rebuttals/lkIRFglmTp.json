[
    {
        "title": "Resolving Partial Observability in Decision Processes via the Lambda Discrepancy"
    },
    {
        "review": {
            "id": "kmZsBl0ZkF",
            "forum": "lkIRFglmTp",
            "replyto": "lkIRFglmTp",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6034/Reviewer_zLef"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6034/Reviewer_zLef"
            ],
            "content": {
                "summary": {
                    "value": "For partial observable reinforcement learning problems, the paper introduces $\\lambda$-discrepancy as the difference between the TD($\\lambda$) returns of two different $\\lambda$ values. Several properties of $\\lambda$-discrepancy are analyzed and they suggest the discrepancy might serve as a measure of partial observability for a POMDP. Based on the idea, the paper further proposes memory optimization methods by minimizing $\\lambda$-discrepancy. Empirical results show performance improvement with memory functions learned by the proposed methods compared with the memoryless case."
                },
                "soundness": {
                    "value": "1 poor"
                },
                "presentation": {
                    "value": "1 poor"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "- The idea of using the difference between TD($\\lambda$) returns as a partial observability measure is very interesting, and it has the potential to help construct practical efficient algorithms for partial observable problems.\n\n- The paper attempts to analyze when the $\\lambda$-discrepancy would be zero, and the analysis suggests that $\\lambda$-discrepancy is zero when the observation has some Markovian properties.\n\n- The paper proposes an approach to learn a memory function for POMDP by minimizing $\\lambda$-discrepancy, and it also provides two algorithms based on the approach with different levels of oracles available. Experiments show that learned memory function can indeed provide performance improvement over the memoryless case."
                },
                "weaknesses": {
                    "value": "- The notations are very confusing, and many parts of the technical presentations are very difficult to follow. The products of tensors are presented as regular matrix multiplications without specifying which dimensions are used in the multiplications. Many definitions are not precise, like effective policy over latent state, and some augment representations of some tensors. In the proofs, it is very difficult to follow when the indices are meaningless $i, j, k, l, ...$ without specifying their domains.\n\n- There are issues in many definitions in Section 3.1. As mentioned in the background section, the value functions of partial observable problems generally depend on the agent's entire history. But in Section 3.1, the Q-function is given as a function of the observation and action without any justification. This observation-action Q-function may be some useful approximation, but it is used throughout the paper as the correct value estimation without any discussion. Several variables of conditional probabilities like Pr$(s|\\omega)$ are presented as given constants, but they are not provided by the observation model like Pr$(\\omega|s) = O(\\omega|s)$; the probability Pr$(s_t|\\omega_t)$ depends on the policy and the time instant $t$ in general.\n\n- The theoretical analysis in Appendix A seems incorrect. Below the first big equation in Appendix A, it is claimed that one can bootstrap by replacing the last line with a term with $Q(\\omega_2, a_2)$ when $n=2$, but the claim means that \n$$\\sum_{w_2, a_2} P(\\omega_2 |s_2) P(a_2|\\omega_2) Q(\\omega_2, a_2) = \\sum_{w_2, a_2} P(\\omega_2 |s_2) P(a_2|\\omega_2)\n\\sum_{s_3, r_2} P(s_3|s_2, a_2)P(r_2|s_2, a_2, s_3) r_2$$\nThis equation does not look correct. Even if what the authors mean is to include all the later terms in $...$, the bootstrap does not seem to hold given the time-homogenous definition of the Q-function unless with further justification. \n\n- There some other likely errors in Appendix A. There is a missing summation over $l$ in the second big equation in Appendix A. In the equation for $Q^\\lambda$, $Q_n$ is replaced by the equation derived above, but the inner $Q_n$ in that equation is directly replaced by $Q^\\lambda$ without any argument.\n\n- Definition 1 defines $\\lambda$-discrepancy by an unspecified norm. It is revealed in Appendix E.2 that the norm is l2, but this is not consistent with the proof in Appendix B where the $\\lambda$-discrepancy is a weighted difference between the two Q-functions without squares.\n\n- Even if the some of the analysis is true, they only provide properties when $\\lambda$-discrepancy is zero. They still cannot explain whether decreasing $\\lambda$-discrepancy can reduce the issue of partial observability in some sense. This kind of property may be explored via numerical experiments, but its not done in the paper.\n\n- In the numerical experiments, the proposed method achieves the optimal performance only in the cheese environment. Since increasing the memory size might lead to optimal policy in principle, the inability to achieve optimal performance with more memory in many environments makes the ability of the proposed methods questionable."
                },
                "questions": {
                    "value": "- Can the authors address the technical issues mentioned above, particularly in Section 3.1 and Appendix A?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6034/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698298079814,
            "cdate": 1698298079814,
            "tmdate": 1699636648927,
            "mdate": 1699636648927,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "nZLSm6WQaO",
                "forum": "lkIRFglmTp",
                "replyto": "kmZsBl0ZkF",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6034/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6034/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your feedback.\n\n$ $\n\n-----\n### Mathematical presentation\n\n$ $\n\n> - notations are very confusing\n> - The products of tensors are presented as regular matrix multiplications without specifying which dimensions are used in the multiplications\n> - many definitions are not precise, like effective policy over latent state\n> - indices are meaningless i,j,k,l,...\n\n$ $\n\nWe have fixed the mathematical presentation in the paper to make it easier to follow. Specifically,\n\n1. We changed the indices from $i,j,k,l,...$ to indices that indicate their domain, such as $a_1, o_1,$ and $s_1$.\n2. We have clarified the contractions used in the proof of Appendix A. We kept the matrix multiplications written as-is because they make sense as long as one follows the following guideline, which we included in the original paper: in the main paper equations, each tensor contraction is a single contraction except in the products involving $R^{SA}$ and $T$ on the right hand side, which are double contractions. We also tried writing the contractions with dots, but decided this tensor notation offered the best compromise between clarity and succinctness.\n3. The effective policy over latent state $\\Pi^S$ is an $S \\times S \\times A$ representation of the matrix $\\phi \\pi$, where $\\phi$ is the $S \\times \\Omega$ observation function, and $\\pi$ is the $\\Omega \\times A$ observation policy. Formally, $\\Pi^S_{s,s\u2019,a} = \\delta_{s,s\u2019} \\phi_{s,o} \\pi_{o,a}$.\n\n$ $\n\n-----\n### Value definitions\n\n$ $\n\n> The value functions of partial observable problems generally depend on the agent's entire history. But in Section 3.1, the Q-function is given as a function of the observation and action without any justification. This observation-action Q-function may be some useful approximation, but it is used throughout the paper as the correct value estimation without any discussion.\n\n$ $\n\nThe MC Q-function is indeed well defined, but it is distinct from the Q-function conditioned on the agent\u2019s full history. We define $Q(\\omega,a)$ in the usual way: the expected discounted return starting from observation $\\omega$, taking action a, and following the current policy thereafter. This expectation averages over all possible agent histories consistent with reaching observation $\\omega$. We do not claim that this is equivalent to either the state value function $Q(s,a)$ or the history value function $Q(h,a)$, but it is nevertheless \u201ccorrect\u201d in that MC is an unbiased estimator of $Q(\\omega,a)$, whereas TD($\\lambda$) is not, for any $\\lambda < 1$.\n\n$ $\n\n-----\n### Clarifying conditionals\n\n$ $\n\n> Several variables of conditional probabilities like $Pr(s|\\omega)$ are presented as given constants, but they are not provided by the observation model like $Pr(\\omega|s)=O(\\omega|s)$; the probability $Pr(s_t|\\omega_t)$ depends on the policy and the time instant $t$ in general.\n\n$ $\n\nWe now describe in Appendix A that $P(s|\\omega)$ reflects the average of $P(s_t|\\omega_t)$ over all timesteps, weighted by visitation probability and discounted by $\\gamma$. This is a well-defined stationary quantity, and it can be computed as follows. First solve the system $Ax = b$ to find the discounted state occupancy counts $x = c(s)$, where $A = (I - \\gamma (T^\\pi)^\\top)$ accounts for the policy-dependent state-to-state transition dynamics $T^\\pi$, and $b = P_0$ is the initial state distribution over $s$. Then $P(s|\\omega) \\propto c(s) * P(\\omega|s)$, so we can just multiply these terms together and renormalize.\n\nWe will release the code alongside the paper so that these and other such computations will be clear.\n\n$ $\n\n-----\n### Clarifying bootstrapping\n\n$ $\n\n> Below the first big equation in Appendix A, it is claimed that one can bootstrap by replacing the last line with a term with Q(\u03c9_2,a_2) when n=2... the bootstrap does not seem to hold given the time-homogenous definition of the Q-function unless with further justification.\n\n$ $\n\nYes, we did mean for all the latter terms in \"$\\dots$\" to be included. We rewrote the equations to make this clearer. We agree that using the time-homogenous Q-function bootstrap as is given here results in a quantity not equal to $\\mathbb{E}[G_n|\u03c9_0,a_0]$; that corresponds to the fact that the Q-value estimates are biased. The Q-values are commonly used this way, and doing so does not invalidate the results."
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6034/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700702036532,
                "cdate": 1700702036532,
                "tmdate": 1700702036532,
                "mdate": 1700702036532,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "Zci7xU7il5",
            "forum": "lkIRFglmTp",
            "replyto": "lkIRFglmTp",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6034/Reviewer_Rr9Z"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6034/Reviewer_Rr9Z"
            ],
            "content": {
                "summary": {
                    "value": "The paper discusses solving POMDP RL problems through memory augmentation. The authors introduce a $\\lambda$-discrepancy, which captures the degree of non-Markovian systems. Based on this property, the authors utilize it as an optimization target to augment the agent's observations based on the memory functions to reduce such a discrepancy. Empirical results are included in the paper to verify the performance."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "This paper proposes the $\\lambda$-discrepancy to measure the discrepancy between two Q-value functions under the same policy but different \u03bb. They further show that this measure is useful for detecting and mitigating partial observability in a POMDP. They then prove several theoretical properties that make the $\\lambda$-discrepancy a reasonable optimization objective for learning effective memory functions, which can be used to reduce such a discrepancy. Simulation results also verify the performance of the proposed algorithms."
                },
                "weaknesses": {
                    "value": "This paper mentions that the POMDP problem is inherently complex. While memory augmentation is shown to improve performance, it doesn't directly address the computational complexity of solving POMDPs. The efficiency of the proposed approach in more challenging POMDP scenarios is not fully explored.\n\nIt is still not clear to me why we need to reduce the $\\lambda$-discrepancy, and at least an improved result should be shown by using this technique compared to using a single $\\lambda$."
                },
                "questions": {
                    "value": "- POMDPs are hard to solve due to the large space of the belief states, and thus the algorithms are usually computationally and time-inefficient. However, the complexity of the algorithms is not discussed, and no baselines are included in the experiments.\n\n- Does the algorithm require the full information of the POMDP? If so, we can get the optimal solution with a POMDP solver.\n\n- The condition in Lemma 2 is a sufficient condition; can a necessary condition be provided? That may help in designing the memory function.\n\n- It seems that you approximate Equation (7) with Equation (10), what is the justification for that?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6034/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698632114511,
            "cdate": 1698632114511,
            "tmdate": 1699636648831,
            "mdate": 1699636648831,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "Ox7f2yAeDo",
                "forum": "lkIRFglmTp",
                "replyto": "Zci7xU7il5",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6034/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6034/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your feedback.\n\n$ $\n\n-----\n### Complexity\n\n$ $\n\n> While memory augmentation is shown to improve performance, it doesn't directly address the computational complexity of solving POMDPs.\n\n$ $\n\nThe computational and sample complexity of computing the $\\lambda$-discrepancy are asymptotically the same as computing either of the two Q functions. The algorithm we present is only intended to provide an initial demonstration of the concept; it is not intended to be optimal. Our paper is focused solely on showing (both theoretically and empirically) that minimizing the $\\lambda$-discrepancy leads to useful memory functions. The approach is applicable to any POMDP for which we can obtain an accurate observation-based Q function, but obtaining such a Q function is the subject of a large body of work and is outside the scope of this paper.\n\n$ $\n\n-----\n### Scalability\n\n$ $\n\n> The efficiency of the proposed approach in more challenging POMDP scenarios is not fully explored.\n> \n> $ $\n> \n> POMDPs are hard to solve due to the large space of the belief states, and thus the algorithms are usually computationally and time-inefficient. However, the complexity of the algorithms is not discussed\n\n$ $\n\n(See \"Scalability concerns\" above.)\n\n$ $\n\n-----\n### Single-$\\lambda$?\n\n$ $\n\n> It is still not clear to me why we need to reduce the $\\lambda$-discrepancy, and at least an improved result should be shown by using this technique compared to using a single $\\lambda$.\n\n$ $\n\nWe are not aware of any method that can learn a memory function from a fixed TD($\\lambda$) value function. TD($\\lambda$) implicitly makes a Markov assumption for all $\\lambda<1$, but there is no way to determine from a single value function whether the Markov assumption is a reasonable one. This is precisely why we need the second $\\lambda$. The discrepancy between value functions reliably reveals partial observability and allows us to find a memory function that corrects for it.\n\n$ $\n\n-----\n### Baselines\n\n$ $\n\n> no baselines are included in the experiments.\n\n$ $\n\n(See \"Comparisons to baselines\" above.)\n\n$ $\n\n-----\n### Partial/Full Information\n\n$ $\n\n> Does the algorithm require the full information of the POMDP? If so, we can get the optimal solution with a POMDP solver.\n\n$ $\n\nNo, we do not require the full information of the POMDP. The lambda discrepancy can be constructed only from observable quantities. Our method does not require the use of *any* environment information, not even knowledge of the complete *set* of states, let alone the current one. By contrast, belief-state planning methods require an accurate model of the transition dynamics, rewards, observation function, and the full set of states over which the belief has its support. Moreover, belief-state methods assume the agent has enough memory capacity to fully distinguish all possible belief states from each other, whereas our method is effective for limited-memory agents as well. This is why we normalize our performance results for each domain relative to the range from a uniform random policy (y=0) and the unrealistic POMDP-solver solution (y=1).\n\nWe only use the environment model in Section 4.2 to show that descending the gradient of the lambda discrepancy leads to useful memory functions. In Section 4.3 we show that using only accurate point estimates of the value function to minimize $\\lambda$-discrepancy is as effective as using the  environment model to find gradients.\n\n$ $\n\n-----\n### Necessary Condition?\n\n$ $\n\n> The condition in Lemma 2 is a sufficient condition; can a necessary condition be provided? That may help in designing the memory function.\n\n$ $\n\nYes, we have the following necessary condition: Given a fixed policy and $\u03bb_1$, $\u03bb_2$ values, for almost all discount factor values $\\gamma$, the converse holds, namely the condition in Lemma 2 implies that there is zero $\\lambda$-discrepancy. We have added this to the updated paper, and included the proof in Appendix D.\n\n$ $\n\n-----\n### Approximation\n\n$ $\n\n> It seems that you approximate Equation (7) with Equation (10), what is the justification for that?\n\n$ $\n\nThank you for bringing this up. The approximation was not central to any of the claims in the paper, so we have since removed Equation (10) from the work and replaced all experimental results that used the approximation with results computed exactly, following Equation (7). This only affected the results for the gradient-based optimization in Section 4.2, and the new results match or exceed the previous performance."
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6034/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700701728662,
                "cdate": 1700701728662,
                "tmdate": 1700702191161,
                "mdate": 1700702191161,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "Iwpj5EimG7",
            "forum": "lkIRFglmTp",
            "replyto": "lkIRFglmTp",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6034/Reviewer_ni5q"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6034/Reviewer_ni5q"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes the $\\lambda$-discrepancy, a theoretical measure for determining the Markovness of observations or memory-estimated Markov states in POMDPs. The measure is based on TD$(\\lambda)$. \n\nAs a brief summary, TD(0) is based on one-steps returns (i.e. bootstrapping) $Q(s_t,a_t) = r_t + \\gamma Q(s_{t+1} a_{t+1})$). TD(1), also known as Monte Carlo estimation, is written as $Q(s_t, a_t) = \\sum_{t=0}^\\infty \\gamma^t r_t$. TD($\\lambda$) is a generalization of TD(0) and TD(1). The $\\lambda$ parameter in TD($\\lambda$) interpolates between TD(0) when $\\lambda = 0$ and TD(1) when $\\lambda = 1$.\n\nThe authors propose that using error between two Q approximations of differing $\\lambda$ to measure how non-Markovian a state is. The intuition is that an agent with poor memory will have differing estimations of TD($\\lambda_1$), TD($\\lambda_2$). The authors' optimization objective is to minimize the discrepancy.\n\nThe authors demonstrate their approach on classical POMDPs, showing they can get close-to-optimal performance on certain tasks."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "- The paper is generally well written\n- The paper is well motivated -- a metric denoting the Markovness of a POMDP is a very useful tool\n- The approach is novel"
                },
                "weaknesses": {
                    "value": "- The experiment section is lacking, only comparing against a memory-free baseline\n- The tested environments and models are very low dimensional, and it's not clear such a method would scale to more interesting problems\n- If I am understanding this correctly, the proposed metric is flawed in that errors in the Q function (not the state estimator) will result in a $\\lambda$-discrepancy. For example, given a perfect state estimator $M^*(o_1, o_2, ..., o_n) = s_n$ and two imperfect Q functions $Q_\\theta, Q_\\phi$: $ \\lVert Q_{\\theta}^{\\lambda_1}(s_n) - Q_{\\phi}^{\\lambda_2}(s_n) \\rVert > 0$. In this case, I do not see how $\\lambda$-discrepancy is a better metric of Markovness than the traditional TD(0) Q learning error."
                },
                "questions": {
                    "value": "- What makes the $\\lambda$-discrepancy specific to partial observability? A policy trained on a fully-observable MDP will also have a $\\lambda$-discrepancy if the Q function is even slightly less-than-optimal."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6034/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698849797711,
            "cdate": 1698849797711,
            "tmdate": 1699636648747,
            "mdate": 1699636648747,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "9PNMg3Cjn7",
                "forum": "lkIRFglmTp",
                "replyto": "Iwpj5EimG7",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6034/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6034/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your feedback.\n\n$ $\n\n-----\n### Baselines\n\n$ $\n\n> The experiment section is lacking, only comparing against a memory-free baseline\n\n$ $\n\n(See \"Comparisons to baselines\" above.)\n\n$ $\n\n-----\n### Scalability\n\n$ $\n\n> The tested environments and models are very low dimensional, and it's not clear such a method would scale to more interesting problems.\n\n$ $\n\n(See \"Scalability concerns\" above.)\n\n$ $\n\n-----\n### TD Error\n\n$ $\n\n> I do not see how $\\lambda$-discrepancy is a better metric of Markovness than the traditional TD(0) Q learning error.\n> \n> $ $\n> \n> What makes the $\\lambda$-discrepancy specific to partial observability? A policy trained on a fully-observable MDP will also have a $lambda$-discrepancy if the Q function is even slightly less-than-optimal.\n\n$ $\n\nIn POMDPs, value error comes from two places: estimation error (as in MDPs) and partial observability. Any method that estimates a value function will have some estimation error, and good value estimation approaches will hopefully drive this error to zero over time. The results we present here show that even if we achieve zero estimation error (which is the case for our value function oracle), there would still be error due to partial observability. Whereas Bellman error is currently the main method we use to reduce the former, it does nothing to reduce the latter. Using the $\\lambda$-discrepancy, we are able to reduce the error due to partial observability.\n\nTo provide further evidence of this, we show in Appendix F that $\\lambda$-discrepancy is positively correlated with value error in every domain we considered."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6034/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700701600903,
                "cdate": 1700701600903,
                "tmdate": 1700702155611,
                "mdate": 1700702155611,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "eXIo8h7cuY",
                "forum": "lkIRFglmTp",
                "replyto": "9PNMg3Cjn7",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6034/Reviewer_ni5q"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6034/Reviewer_ni5q"
                ],
                "content": {
                    "comment": {
                        "value": "> Whereas Bellman error is currently the main method we use to reduce the former, it does nothing to reduce the latter.\n\nReally? Isn't the Bellman error just the combination of the two errors you state? If I train an LSTM and a Q function jointly until the Bellman error is zero for all transitions, wouldn't you say that the LSTM has learned to produce a Markov state from the observations, and that the Q function has learned the Q values for all state/action pairs?\n\nIf we assume we already have a value oracle ($Q^*$), but do not have mappings from observations to states, we could freeze the weights of $Q^*$ and learn an LSTM to map $o_1, o_2, \\dots o_n \\to s_n$ using Bellman error, no? Why would using the Lambda discrepancy here be more effective than the Bellman error?"
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6034/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700735842626,
                "cdate": 1700735842626,
                "tmdate": 1700735842626,
                "mdate": 1700735842626,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "A1R91tqIk5",
            "forum": "lkIRFglmTp",
            "replyto": "lkIRFglmTp",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6034/Reviewer_QHWA"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6034/Reviewer_QHWA"
            ],
            "content": {
                "summary": {
                    "value": "This paper studies resolving partial observability through learning memory in non-Markov Decision Processes. The authors propose to use the discrepancy between TD($\\lambda$) with different $\\lambda$s to measure if the extracted states are Markovian. This discrepancy, termed $\\lambda$-discrepency, is then used as an objective to learn memory states. The authors analyze the cases where the $\\lambda$-discrepancy vanishes. Lemma 1 introduces a simplest case. Lemma 2 analyzes a particular correlation between the reward and the state-action distribution. Theorem 1 examines that such a specific correlation is very rare. Together they show that it is possible in practice to test with one policy whether the $\\lambda$-discrepancy is nonzero for all policies, hereby prove that $\\lambda$-discrepency can be an effective learning objective. Concrete algorithms are designed for both analytical estimation and deep learning. Empirical results show that the proposed method can successfully learn memory states in a series of classic POMDP tasks, and achieve better performance than TD methods."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "Markovianizing nMDPs is a classic problem in the literature of sequential decision-making. The authors propose a novel method to tackle this problem using well-developed tools such as TD($\\lambda$).\n\nThe quality of this work is good. The strongly analytical narrative makes it convincing. The logic flow is smooth. Proves are solid. The authors did a great job balancing the theoretical formulation and intuition. \n\nThe proposed problem and solutions for nMDPs are both relevant. Relaxing the Markovian assumption in sequential decision-making is an active topic recently, see Abel et al. 2021, Janner et al. 2021, Chen et al. 2021., Qin et al. 2023. The author may consider citing these prior works if they haven't done that yet. \n\nAbel et al. On the expressivity of markov reward. NeurIPS 2021. \nJanner et al. Offline reinforcement learning as one big sequence modeling problem. NeurIPS 2021. \nChen et al. Decision transformer: Reinforcement learning via sequence modeling. NeurIPS 2021.\nQin et al. Learning non-Markovian Decision-Making from State-only Sequences. NeurIPS 2023."
                },
                "weaknesses": {
                    "value": "I am a bit concerned with the scalability of the proposed method. The empirical results do not include a gradient-based method for model-free implementation of $\\lambda$-discrepency. I wonder if the authors would like to discuss the concrete challenges they met in such experiments."
                },
                "questions": {
                    "value": "I happened to have reviewed an earlier version of this work. I am very glad to see the authors have taken some suggestions from the reviewers into account and reframed the paper. However, I also find the authors haven't resolved one of those questions in this revised version. \n\nIn the previous version, the proposed method was shown to be struggling to acquire satisfying performances in two tasks. In this version, the authors have shown their success in one of them, Network. However, it seems the result of the other, Hallway, is omitted. I hope the authors would like to provide an explanation in their response."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6034/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699346170924,
            "cdate": 1699346170924,
            "tmdate": 1699636648647,
            "mdate": 1699636648647,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "dmpUYthEs4",
                "forum": "lkIRFglmTp",
                "replyto": "A1R91tqIk5",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6034/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6034/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your feedback, both here and for our previous submission. We agree that this version of the paper is a substantial improvement over the previous draft, and we are grateful for the role that your comments played in making that happen.\n\n$ $\n\n-----\n### Scalability\n\n$ $\n\n> I am a bit concerned with the scalability of the proposed method.\n\n$ $\n\n(See \"Scalability concerns\" above.)\n\n$ $\n\n-----\n### Gradients\n\n$ $\n\n> The empirical results do not include a gradient-based method for model-free implementation of $\\lambda$-discrepency. I wonder if the authors would like to discuss the concrete challenges they met in such experiments.\n\n$ $\n\nThere are a few potential ways to scale this up, and gradient-based methods are one example. As you saw in our previous draft, the $\\lambda$-discrepancy can be computed using neural networks, which means that with the proper architecture, we can learn memory functions model-free via gradient descent. The experiments in our previous draft showed some initial success, but we decided to remove them from this version to focus purely on the tabular setting. We still believe that the neural network direction has promise, but we wanted the first paper on the $\\lambda$-discrepancy to tell a theory-driven story. We felt that the engineering challenges associated with including neural networks warranted their own paper and were worried that they would overly complicate the story we are telling here.\n\nNote that scaling up may also be possible gradient-free, via a policy-gradient-style approach; however, our initial investigation into this direction has revealed that this too would warrant its own separate paper, as the derivation is substantially more complicated here than for the MDP setting due to the lack of Markov property.\n\n$ $\n\n-----\n### Hallway\n\n$ $\n\n> In the previous version, the proposed method was shown to be struggling to acquire satisfying performances in two tasks. In this version, the authors have shown their success in one of them, Network. However, it seems the result of the other, Hallway, is omitted. I hope the authors would like to provide an explanation in their response.\n\n$ $\n\nThe Hallway results included in the previous draft were misleading for a few reasons.\n\nFirst, because the problem is too large for a closed-form POMDP solver, those results were instead normalized relative to the impossible standard of an optimal fully-observable state-based policy. We have since run the SARSOP solver, which does work and is a much more realistic comparison, but normalizing relative to multiple baseline algorithms further complicated the discussion.\n\nSecond, we found that the small improvement that we had previously achieved over the memoryless baseline was primarily due to the stochasticity introduced by the earlier stochastic form of memory functions we had investigated. Switching the policy optimization to policy gradient allowed us to better optimize over stochastic policies, and the memoryless policy achieves much better performance.\n\nThird, once policy gradient revealed the optimal memoryless policy, it became clear to us that the Hallway domain simply does not benefit from the small amounts of memory we consider here. The domain involves highly-stochastic, agent-centric observations that must be integrated over multiple time steps, and then remembered across multiple stochastic state transitions, all while tracking more distinctions than are possible with such a small number of bits."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6034/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700701445148,
                "cdate": 1700701445148,
                "tmdate": 1700702119392,
                "mdate": 1700702119392,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]