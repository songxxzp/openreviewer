[
    {
        "title": "Unlocking Tuning-free Generalization: Minimizing the PAC-Bayes Bound with Trainable Priors"
    },
    {
        "review": {
            "id": "iWGdBN4ZV3",
            "forum": "EWcybWr3MR",
            "replyto": "EWcybWr3MR",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6106/Reviewer_Htid"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6106/Reviewer_Htid"
            ],
            "content": {
                "summary": {
                    "value": "The paper proposes a principled PAC-Bayes framework for optimizing neural networks in classification. Specifically, the paper first extends the current PAC-Bayes bound for bounded loss functions to unbounded loss functions and introduces trainable priors. The end result is a practical AC-Bayes bound consisting of learnable parameters: model weights, prior parameters, posterior parameters, and a moment parameter. The algorithm jointly optimizes over all learnable weights. Compared to the existing optimization framework, the PAC-Bayes framework does not require extensive learning rate tuning and comes with built-in learnable regularization capabilities. Experimentally, the proposed framework achieves similar performance with extensively tuned existing pipelines."
                },
                "soundness": {
                    "value": "4 excellent"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "* **Principled approach**: most of the proposed framework stems from rigorous derivation and extension to the PAC-Bayes learning theory. Specifically, the paper derives the PAC-Bayes bounds for both preset and learnable priors and discusses why it is reasonable to learn a prior in a data-driven way. \n\n* **Practical novelty**: from a practical perspective, the proposed framework can potentially automatically learn its regularization strength during optimization without turning. Specifically, the KL divergence term $KL(Q|P)$ between the parametrized posterior and prior, using Gaussian distributions, reduces to learnable weight decays and noise injection. The regularization strength is controlled by the variance parameters in the prior and posterior respectively. \n\n* **Distributional output**: Conventional optimization pipeline only yields a MLE point estimation, the proposed method returns a posterior distribution over model weights, which could be utilized for Bayesian inference with improved robustness and better uncertainty quantification."
                },
                "weaknesses": {
                    "value": "* **Poor compatibility with data augmentation**: a major downside of the method is its poor compatibility with data augmentation techniques, which are important and beneficial to boost a model's performance. The reason is that the algorithm needs the exact number of training data sizes and data augmentation breaks this assumption. This is discussed by the authors in the appendix. Nevertheless, this is an important limitation of the approach. \n\n* **Lack experiments**:  On CIFAR10 and CIFAR100 experiments, the proposed method is on par with existing optimization methods, which need extensive hyper-parameter tuning, especially for regularization heuristics. Given the theory-oriented nature of this paper, this is reasonable. However, it would be great to scale up experiments to medium/large datasets. More importantly, given the claim that the proposed framework automatically learns regularization, it is *necessary* to test its performance under a low-data regime for example using only 10% of CIFAR10 and CIFAR100. This will make the claim of being *nearly tuning-free* much more convincing. \n\n* **Need more clarity on $K(\\lambda)$**: The loss function derived from the PAC-Bayes bound has three important terms, the empirical data-driven loss, the KL divergence between the posterior and the prior, and $K(\\lambda)$. It's not clear what role $K(\\lambda)$ plays in the overall algorithm. Since it is estimated before training, it is also not clear how it affects the learning in terms of gradient."
                },
                "questions": {
                    "value": "My major concern is over the experiments. While it is reasonable to have small-scale experiments, I would really like to see how the proposed method works for low-label situations since a major claim is its tunning-free capability. This means that it can adjust its built-in regularization strength to different dataset sizes. \n\nIt would make the claim much more convincing if the algorithm showed promise in adapting to varying numbers of training data. I would suggest the authors run a study on varying the number of training data, e.g., 10%, 50%, and report the performance and the learned variances for the prior and posterior. What do you expect the prior and posterior variances to be when the dataset size is small and how do the results support this? \n\nI will be happy to raise my score if this concern is addressed convincingly."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission6106/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission6106/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission6106/Reviewer_Htid"
                    ]
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6106/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698593690513,
            "cdate": 1698593690513,
            "tmdate": 1700495354797,
            "mdate": 1700495354797,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "5e203VnVtq",
                "forum": "EWcybWr3MR",
                "replyto": "iWGdBN4ZV3",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "`1. Poor compatibility with data augmentation.`\n\nFrom our experiment in the appendix, the method works well with data augmentation, even though we don't have the theoretical explanation. Since data augmentation violates the i.i.d. assumption, having $10$ times augmented data does not mean having $10$ times new independent data. So, in the future, it would be good to explore if we can compute some sort of \"effective\" dimension of the data augmentation, which characterizes how much new information the data augmentation introduces, or what is the equivalent number of i.i.d. data that brings the same amount of information as the given data augmentation.\n\n`2. Lack experiments for the low-data regime.`\n\nWe strongly agree that the small data and large model regimes are the hardest for PAC-Bayes training because the KL term would be large in this case. Running new experiments with our method is relatively fast, but performing the baseline search is quite time-consuming. We tried fine-tuning the pre-trained large language models to validate our method in the low-data regime. Unlike the experiments we did in the appendix, where the large pre-trained part of the model is fixed, and only the small classification layer is to be trained on the small fine-tuning dataset, we now allow both the pre-trained model and the classification layer to be trained using the small fine-tuning dataset. This is what people do in practice because its performance is much better than freezing the pre-trained model. However, this will make PAC-Bayes training challenging because the number of training samples is around 100 while the total number of training parameters is as large as $110$ million. Table 1 contains the result. It shows that PAC-Bayes training works better than all baselines for fine-tuning.\n\nTable1. Experimental Results for BERT-base-uncased Backbone Model. \n||CoLA |SST |MNLI-m| QNLI| RTE|\n|---|---|---|---|---|--|\n|metrics|MCC|Accuracy|Accuracy|Accuracy|Accuracy| \n| | | | | |\n|Vanilla-tuning| .235| .773 |.369 |.702 |.589 |\n|Data Augmentation[1]|.171 |.817 |**.395**| .705 |.594| \n|Noise Injection[2]|.233 |.783 |.371 |.706 |.588| \n|LoRA[3]| .298 |.792| .385 |.669 |.592 |\n|Prefix-training[4]| .191 |.704 |.375 |.649 |.565| \n|BitFit[5]| .267 |.768 |.376| .647 |.588| \n|Ours| **.335** |**.834** |.387 |**.709** |**.601**|\n\n[1]. Sennrich, Rico, et al. \"Improving neural machine translation models with monolingual data.\" \n\n[2]. Orvieto, Antonio, et al. \"Explicit regularization in overparametrized models via noise injection.\"\n\n[3]. Hu, Edward J., et al. \"Lora: Low-rank adaptation of large language models.\"\n\n[4]. Liu, Xiao, et al. \"P-tuning: Prompt tuning can be comparable to fine-tuning across scales and tasks.\"\n\n[5]. Zaken, Elad Ben, et al. \"Bitfit: Simple parameter-efficient fine-tuning for transformer-based masked language-models.\"\n\n\n\n`3. Need more clarity on $K(\\lambda)$`\n\n$K(\\lambda)$ is a function of $\\lambda$, and $\\lambda$ is the trainable parameters of the prior representing the variance. So $K(\\lambda)$ affects what $\\lambda$ can be achieved in training, and the prior variance $\\lambda$, in turn, affects the posterior variance and the model parameters through their interaction in the bound.\n\n`4. Experiments with medium/large datasets.`\n\nWe have obtained additional numerical results for image classification tasks. Our comparison of PAC-Bayes training with SGD, using a batch size of 128 on the TinyImageNet dataset, involved 100,000 images across 200 classes. Using ResNet18, the test accuracy of PAC-Bayes training is 53.2%, while the best test accuracy achieved with SGD/Adam/AdamW after hyperparameter searching is 46.4%/46.7\\%/46.8\\%. This further demonstrates the advantages of our proposed PAC-Bayes training."
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1699996902100,
                "cdate": 1699996902100,
                "tmdate": 1700491879488,
                "mdate": 1700491879488,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "2eYif9gZU0",
                "forum": "EWcybWr3MR",
                "replyto": "iWGdBN4ZV3",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "`5. adapting to varying numbers of training data`\n\nWe compared PAC-Bayes training with SGD/Adam/AdamW on CIFAR10, using a batch size of 128, and allocated 10% of the training data for training and the remaining 90% for hyper-parameter searching in SGD/Adam/AdamW. With ResNet18, the test accuracy of PAC-Bayes is 67.8%, while the best test accuracies for SGD, Adam, and AdamW, after hyper-parameter searching, are 64.00%, 64.96%, and 65.59%, respectively. When training ResNet18 with all the training data using a batch size of 128, SGD typically achieves the best test accuracy among the baselines. However, AdamW outperforms SGD when using only 10% of the training data. This demonstrates the necessity of both hyper-parameter searching and choosing the appropriate optimizer for baselines. With the same setting and model on CIFAR100, the accuracies are as follows: SGD - 22.16\\%, Adam - 24.95\\%, AdamW - 25.68\\%, and PAC-Bayes - 26.22\\%."
                    }
                },
                "number": 11,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700263989106,
                "cdate": 1700263989106,
                "tmdate": 1700264273093,
                "mdate": 1700264273093,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "Wgr8By4sEz",
                "forum": "EWcybWr3MR",
                "replyto": "5djjlwWwyx",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Reviewer_Htid"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Reviewer_Htid"
                ],
                "content": {
                    "title": {
                        "value": "Question"
                    },
                    "comment": {
                        "value": "Thank you for the additional experiments. I have increased my score to reflect this. However, I still have one question. As I asked in the initial review, could the authors also provide the statistics on the learned posterior and prior with varying numbers of training data? because they directly demonstrate how the proposed Bayesian framework adapts to varying degrees of evidence, e.g., training data."
                    }
                },
                "number": 19,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700495636578,
                "cdate": 1700495636578,
                "tmdate": 1700495636578,
                "mdate": 1700495636578,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "70GxwD6Jr5",
                "forum": "EWcybWr3MR",
                "replyto": "iWGdBN4ZV3",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you very much for raising the score! \n\nAs suggested, we conducted additional experiments and observed that the variances of the learned posterior and prior change due to the different numbers of training samples.\n\nWith batch size 128, by training with full/10\\% of CIFAR10 on VGG13, the final standard deviations of posteriors are 0.032/0.010, and the mean of the standard deviations of priors are 0.042/0.0158. Training with full/10\\% of CIFAR10 on ResNet18, the mean of the final variances of posteriors are 0.031/0.010, and the final variances of priors are 0.044/0.008."
                    }
                },
                "number": 20,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700584065300,
                "cdate": 1700584065300,
                "tmdate": 1700668617935,
                "mdate": 1700668617935,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "G9ADnKCCwk",
                "forum": "EWcybWr3MR",
                "replyto": "70GxwD6Jr5",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Reviewer_Htid"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Reviewer_Htid"
                ],
                "content": {
                    "title": {
                        "value": "Re: questions"
                    },
                    "comment": {
                        "value": "Does this make sense from a Bayesian perspective though? Shouldn't we expect a smaller variance of the posterior (i.e., uncertainty) given more data because we can be more certain about which weight/function generated the data?"
                    }
                },
                "number": 22,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700585212988,
                "cdate": 1700585212988,
                "tmdate": 1700585212988,
                "mdate": 1700585212988,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "bYrR6CXF6G",
                "forum": "EWcybWr3MR",
                "replyto": "iWGdBN4ZV3",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for the intriguing question! We feel it makes sense based on the following explanation. In order to fit more training data, the (final) model needs to be able to go further away from the random initial model,  which means smaller confidence should be given to the prior (i.e., larger prior variance) to allow this to happen (otherwise if we're very certain about the prior, then the model will just stay near the initial model and won't be able to fit the data). \nSince the prior and posterior variances are positively correlated, the posterior variance will also be larger. This is a possible explanation of why larger data leads to larger variance. \n\nHowever, we feel that there is another scenario, that is, when we have a very large amount of data compared to the model (i.e., the under-parametrized regime). Then, adding more data wouldn't pull the model much further from the initial model than it already is. In this case, more data should reduce the uncertainty and, therefore, lead to a smaller variance. We're currently doing more experiments on various amounts of training data of CIFAR10 and will report the result soon. However, we feel since CIFAR10 on ResNet/VGG is in the over-parametrized regime, we probably are not going to see this latter scenario."
                    }
                },
                "number": 24,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700607250771,
                "cdate": 1700607250771,
                "tmdate": 1700610509912,
                "mdate": 1700610509912,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "lua3gF9Fmk",
            "forum": "EWcybWr3MR",
            "replyto": "EWcybWr3MR",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6106/Reviewer_YdhE"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6106/Reviewer_YdhE"
            ],
            "content": {
                "summary": {
                    "value": "This paper examines training of deep neural networks via directly optimizing their PAC-Bayes bounds. This is done with the secondary goals of reducing reliance on hyperparameter searches and investigation of which regularization tricks/implicit biases can be omitted without compromising generalization performance. In doing so, the authors extend earlier results of Dziugaite & Roy to relax the assumption of bounded loss, by appealing to an exponential moment bound. While this assumption is not typically considered to be an issue, its relaxation may be of interest on its own."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "The paper identifies that a weakness of many PAC-Bayes type bounds is the assumption of a bounded loss. Conditions that allow for this assumption to be relaxed are identified, and connections to sub-Gaussian bounds are highlighted."
                },
                "weaknesses": {
                    "value": "Although the terminology surrounding prior and posterior distributions is consistent with Maurer 2004 and parts of the PAC-Bayes literature, the more recent prominence of Bayesian methods in the machine learning literature and their more specific use of these terms leaves room for confusion. Distinguishing between the distributions appearing in the bounds and the specific choice of the Gibbs posterior, for example, would be helpful (see e.g. https://arxiv.org/pdf/1605.08636.pdf, https://arxiv.org/pdf/2110.11216.pdf).\n\nThe overall contribution of this work seems minimal, since there is previous literature loosening the bounded loss assumption, and there is little additional information provided in the current work.\n\nThe posterior distribution given by $\\mathcal{Q}_{\\sigma}(h)$ does not appear to be a valid probability distribution, as defined in the paper."
                },
                "questions": {
                    "value": "Can you please address the issues raised in the weaknesses section."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "details_of_ethics_concerns": {
                    "value": "-"
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission6106/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission6106/Reviewer_YdhE",
                        "ICLR.cc/2024/Conference/Submission6106/Senior_Area_Chairs"
                    ]
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6106/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698748821595,
            "cdate": 1698748821595,
            "tmdate": 1700635780279,
            "mdate": 1700635780279,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "nmSU97XtxO",
                "forum": "EWcybWr3MR",
                "replyto": "lua3gF9Fmk",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "`1. The overall contribution of this work seems minimal, since there is previous literature loosening the bounded loss assumption, and there is little additional information provided in the current work.`\n\nThank you very much for the question. **We want to emphasize the gap between the theoretical bounds and applying them to training deep neural networks in practice.** \n\nEven though there are many existing PAC-Bayes bounds in the literature, to the best of our knowledge and according to our experiment, none of them works in this difficult setting (training deep CNN networks on Cifar10 with cross-entropy loss). More explicitly, when putting these bounds into practice, they are either non-applicable or too vacuous that the model does not even train (i.e., the training accuracy stays at $10\\\\%$ and does not increase). Therefore, we did not find a method that gives OK performance to compare with our method.\n\nFor example, in the paper https://arxiv.org/pdf/1605.08636.pdf, the reviewer mentioned that Corollary 4 has a PAC-Bayes bound for unbounded loss. However, the $s^2$ is too large in practice. If we train the model with this bound, then the training accuracy stays at $10\\\\%$ and does not increase.\n\nAnother example mentioned in the paper, \"Efron-stein pac-bayesian inequalities,\" has a PAC-Bayes bound for unbounded loss. $E_{h\\sim Q}\\ell(h;D)\\leq E_{h\\sim Q}\\ell(h;S)\n        + \\sqrt{\\frac{1}{m} E_{h\\sim Q} \\left[\\ell_1(h;S) + E_{z'\\sim D} \\ell^2(h;z')  \\right]\\mathrm{KL}(Q||P)} +\\frac{1}{m}$. \n        \n$\\ell_1(h;S):=\\frac{1}{m} \\sum_{i=1}^m \\ell^2(h;z_i)$, and $z'\\sim D$ is a test sample drawn from the data distribution. This bound holds for any unbounded loss with a finite second-order moment. However, this bound is semi-empirical, meaning that the bound contains a term, $E_{h\\sim Q}E_{z'\\sim D} \\ell^2(h;z')$, that is hard to estimate from data. \n\nAnother example is in the paper [1], where the bound requires the loss to be bounded, and works for two-class classification, rendering it unsuitable for direct use with CIFAR10/CIFAR100.\n\n[1] Dziugaite, Karolina, et al.. \"Computing Nonvacuous Generalization Bounds for Deep (Stochastic) Neural Networks with Many More Parameters than Training Data.\"\n\n**To the best of our knowledge, we did not find any other available bounds that are suitable to train deep neural networks directly with unbounded loss and trainable priors.**\n\n`2. The posterior distribution given by $Q_\\sigma(h)$ does not appear to be a valid probability distribution, as defined in the paper.`\n\nDoes the reviewer refer to the definition here?  $Q_\\sigma(h):=h+Q_\\sigma(0)$. We apologize for the confusion and have changed the notation in the revision (please see the highlighted part in red on page 4). Here, by this notation, we meant $Q_\\sigma(h)$ is the distribution of $Y = X+h$, with $X\\sim Q_\\sigma(0)$, and $Q_\\sigma(0)$ is an arbitrary 0 mean distribution parametrized by $\\sigma$. So $Q(h)$ is a valid distribution. In the case of Gaussian posteriors in later sections of the paper, this definition leads to $Q_\\sigma(h):=N(h, diag(\\sigma))$, where $N(h, diag(\\sigma))$ refers to the multivariate Gaussian with mean 0 and covariance $diag(\\sigma)$"
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1699994928242,
                "cdate": 1699994928242,
                "tmdate": 1700267320443,
                "mdate": 1700267320443,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "YAMzcfGS3h",
                "forum": "EWcybWr3MR",
                "replyto": "lua3gF9Fmk",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "`3. Although the terminology surrounding prior and posterior distributions is consistent with Maurer 2004 and parts of the PAC-Bayes literature, the more recent prominence of Bayesian methods in the machine learning literature and their more specific use of these terms leaves room for confusion. Distinguishing between the distributions appearing in the bounds and the specific choice of the Gibbs posterior, for example, would be helpful (see e.g. https://arxiv.org/pdf/1605.08636.pdf, https://arxiv.org/pdf/2110.11216.pdf).`\n\nWe're not sure if we have understood your question correctly. We believe our notation is consistent with the literature you mentioned https://arxiv.org/pdf/2110.11216.pdf. More explicitly, our Theorem 4.1 is of a similar type to Theorem 2.1 in the referenced paper, which deals with general posteriors. The referenced paper also includes several theorems for Gibbs posterior, but our work does not. This is because, according to our method, the final posterior we used for prediction is computed as the minimizer of the PAC-Bayes bound,  which does not admit a closed-form expression like Gibbs posterior.  \n\nIn addition, because we also optimize during the optimization over the prior, there is no existing bound in the literature that can be used to bound the population error of this posterior. Therefore, we build Theorem 4.2 to characterize the algorithm's performance. We believe this is the first bound of this type which allows data-dependent prior (previous work all require fixed prior).  Please let us know if this response addresses your question, or if we have completely missed the point you were making."
                    }
                },
                "number": 12,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700269029392,
                "cdate": 1700269029392,
                "tmdate": 1700584967179,
                "mdate": 1700584967179,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "5hFOJwx1gY",
                "forum": "EWcybWr3MR",
                "replyto": "46BnDxMHyB",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Reviewer_YdhE"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Reviewer_YdhE"
                ],
                "content": {
                    "comment": {
                        "value": "Thanks for your response, I have adjusted my score accordingly."
                    }
                },
                "number": 26,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700635756533,
                "cdate": 1700635756533,
                "tmdate": 1700635756533,
                "mdate": 1700635756533,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "tBwP40iPlM",
            "forum": "EWcybWr3MR",
            "replyto": "EWcybWr3MR",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6106/Reviewer_geV1"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6106/Reviewer_geV1"
            ],
            "content": {
                "summary": {
                    "value": "This work proposes minimising a novel PAC-Bayes bound as a new objective instead of the usual cross entropy loss. This novel PAC-Bayes bound applies for unbounded losses and further allows for (weakly) training the prior. Besides the benefits of minimising an upper bound to the generalisation error, the authors further observe that such an objective is significantly more stable with respect to the choice of various training hyper-parameters such as learning rate, batch size, weight decay etc. This thus alleviates a tedious hyper-parameter search, leading to speed-ups of a single training cycle."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1. Improving upon the optimisation objectives in deep learning is a very under-studied avenue. Especially PAC-Bayes bounds moreover are very principled theoretically as they serve as upper bounds to the generalisation error. Making such techniques more practical and showing benefits over standard training would be very important and potentially impactful.\n2. The paper is very well-written and gives a very accessible introduction to PAC-Bayes bounds, how they have been used and what weaknesses of prior work the authors aim to address. I really enjoyed reading this part of the paper! The extension to trainable priors also seems non-trivial (although I have some questions on this later in the review) and the authors manage to match performance of baselines without too much tuning of hyper-parameters."
                },
                "weaknesses": {
                    "value": "1. The authors develop a novel and arguably tighter PAC-Bayes bound but never put it to test (at least from what I could see). I don\u2019t see any generalisation bounds reported in the paper, so it is hard to gauge how much of a contribution the novel bound is in terms of tightness, compared to the previous works cited in this paper. I understand that this is not the main focus of the paper but it would definitely strengthen its technical contribution, i.e. the bound itself. I would have also liked to see a discussion regarding the trade-offs of having a learnable prior. What if the set of priors is so large that it includes the posterior, i.e. the KL term could be set to zero perfectly. How large would the resulting penalisation term be? Is there ever a scenario where this could lead to a non-vacuous bound? \u2028Also, how does this learnable prior compare to methods that perform a (discrete) grid search over the prior and then perform a union bound, resulting in an additional  penalty term (e.g. [1])? \n2. The paper focuses on the efficiency of their proposed method, which arises due to the absence of hyper-parameter tuning. I am not convinced by these claims based on the empirical experiments performed in this work:\n\\\n\\\n    a) There seems to be a certain arbitrariness as to what hyper-parameters are simply chosen ad-hoc and turn out to work well. The $\\gamma_1$ and $\\gamma_2$ values are for instance set to values that work well for the vision tasks but they actually need adaptation for the graph and text tasks, suggesting that some tuning is actually needed. I also could not find a stability analysis for the default choices, were those just the first values tried or was an initial grid search actually needed to find those values? There is also a warmup period only detailed in the Appendix to ensure faster convergence, how was the duration of this set? \u2028I also would like to see a comparison to SGD/Adam/AdamW, where the default hyper-parameter settings are used. For instance, I very rarely see anyone changing the default momentum value for simple tasks such as CIFAR10/CIFAR100. I would also like to see a plot depicting how sensitive the baselines are to individual parameters such as the learning rate, momentum etc, I think the results are already in Figure 1 but need to be re-grouped accordingly.\n\\\n\\\n    b) The method is strongly more involved conceptually than the standard objectives. First, K_min needs to be estimated before-hand and it\u2019s not clear how the quality of such an approximation affects results. The optimisation has to be split into two phases, where the objective is reduced in the second part to ensure better convergence properties. The objective itself is naturally also more complicated although this might be fine as it also comes with theoretical guarantees. The hurdle for practitioners to use this framework might be rather high and I\u2019m not convinced at this point if it is worth the effort.\n\\\n\\\n    c) My biggest concern however is due to the training time required for the proposed method. A single run on CIFAR10, according to Table 8 in the Appendix takes roughly 7000 seconds, while for SGD the same takes roughly 600 seconds. This means that one can roughly perform 12 SGD runs in the time it takes to perform a single run with the PAC-Bayes technique. I would argue first that (1) it does not take 12 runs of SGD to find an acceptable hyper-parameter setting, especially not on simple tasks such as CIFAR10/CIFAR100. (2) Even if 12 runs are required, I would argue that one has obtained a better understanding of the task in the sense of what techniques work etc, and subsequent re-runs of the same method will be very cheap. Moreover, one could even make use of those 12 runs and build an ensemble, perform uncertainty quantification etc. I also believe that this should be discussed more transparently in the main text, instead of the Appendix.\n\n\n[1] Dziugaite and Roy, Computing Nonvacuous Generalization Bounds for Deep (Stochastic) Neural Networks with Many More Parameters than Training Data"
                },
                "questions": {
                    "value": "See above section"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6106/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698753511047,
            "cdate": 1698753511047,
            "tmdate": 1699636659353,
            "mdate": 1699636659353,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "g4dwV5IJ0l",
                "forum": "EWcybWr3MR",
                "replyto": "tBwP40iPlM",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "`1. I don\u2019t see any generalisation bounds reported in the paper, so it is hard to gauge how much of a contribution the novel bound is.` \n\nThank you very much for the question. The short answer is that despite many existing PAC-Bayes bounds in the literature, none of them works in our settings (training deep CNN networks on Cifar10 with cross-entropy loss). More explicitly, when putting these bounds into practice, they are too vacuous that the model does not even train (i.e., the training accuracy stays at $10\\%$ and does not increase). Therefore, we did not find a method that gives OK performance to compare with.\n\n**We want to emphasize that there is a gap between the theoretical bounds and applying them in training deep neural networks in practice.**\n\nFor example, in the paper \"Efron-stein pac-bayesian inequalities,\" the bound is provided as:    \n\n$E_{h\\sim Q}\\ell(h;D)\\leq E_{h\\sim Q}\\ell(h;S)\n    + \\sqrt{\\frac{1}{m} E_{h\\sim Q} \\left[\\ell_1(h;S) + E_{z'\\sim D} \\ell(h;z')^2  \\right]\\mathrm{KL}(Q||P)} +\\frac{1}{m}$. \n\n$\\ell_1(h;S):=\\frac{1}{m} \\sum_{i=1}^m \\ell(h;z_i)^2$, and $z'\\sim D$ is a test sample drawn from the data distribution. This bound holds for any unbounded loss with a finite second-order moment. However, the term \n$E_{h \\sim Q} E_{z' \\sim D} \\ell(h;z')^2$ is almost as difficult to estimate as the generalization error itself. \n\n**To the best of our knowledge, we did not find any other available bounds that are suitable to train deep neural networks directly with unbounded loss and trainable priors.**\n\nIn the paper (Dziugaite and Roy) mentioned by the reviewer, the bound requires that the loss be bounded for two-class classification, which can not be used for CIFAR10/CIFAR100 directly.\n\n`2. I would have also liked to see a discussion regarding the trade-offs of having a learnable prior. `\n\n Thanks for bringing up this critical point. In the theoretical guarantee (Theorem 4.2), it says our PAC-Bayes training is valid if the correction terms $\\eta +\\frac{\\log(n(\\epsilon)}{\\hat \\gamma m}$ is small. Note that the $\\log(n(\\epsilon))$ in the correction term represents how rich the set of priors is. So, if the set of priors we're searching over is too rich/large, then this $\\log(n(\\epsilon)$ would make the correction term large, and the PAC-Bayes training will no longer be reliable. In practice, we observe that for deep network on cifar10, setting the prior to having 1 degree of freedom per layer is fine, but setting the prior to having 1 degree of freedom per weight is too much. This is the motivation of the proposed layerwise prior. \n\n`3.The $\\gamma_1$ and $\\gamma_2$ values are, for instance set to values that work well for the vision tasks, but they actually need adaptation for the graph and text tasks, suggesting that some tuning is actually needed.`\n\nWe used the same range of $\\gamma$ $[0.5,10]$ across different tasks.  We can add a sensitivity analysis of the upper and lower bounds of this range to the paper. In short, the result is quite insensitive to the lower bound $\\gamma_1$ and is relatively more sensitive to the upper bound $\\gamma_2$. So, we ran the CIFAR10 experiment several times to obtain a good value of $\\gamma_2$ and fixed it to this value in all other settings."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1699993687540,
                "cdate": 1699993687540,
                "tmdate": 1700252419936,
                "mdate": 1700252419936,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "uwYUUcv2XW",
                "forum": "EWcybWr3MR",
                "replyto": "tBwP40iPlM",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "`4. There is also a warmup period only detailed in the Appendix to ensure faster convergence, how was the duration of this set?`\n\nThe warmup is not necessary and is only used to accelerate convergence. Please refer to the answer to the next question for more explanation of the warmup.\n\n`5. My biggest concern however is due to the training time required for the proposed method.`\n\nThe long wall time of our method is due to the coding issue.  Pytorch\nis not optimized for the PAC-Bayes training. Currently, we use for-loops in Python to inject the posterior noise in each iteration, and that makes the algorithm slow. The conclusion will change if we look at the actual complexity of the algorithms. For both the normal SGD/Adam training and our method, the computation bottleneck in each iteration is the backpropagation, so we may use the total number of backpropagations to represent the complexity.  Although our method needs the gradients for both the model and the variance, they can be computed from the same quantity obtained by a common backpropagation. Therefore, our method also only requires 1 backpropagation per iteration.  The total number of backpropagations in a single run is thus equal to the total number of iterations, that is:\n\nthe number of epoch $* \\frac{\\textrm{training data size}}{\\textrm{batch size}}$\n\nThe table below (Table 9 in the appendix) provides this number for CIFAR10/CIFAR100 with ResNet18.\n\n||CIFAR10\t| CIFAR100|\n|---|---|--|\n|SGD\t|11501\t|17095|\n|Adam\t|28508\t|28335|\n|AdamW\t|24761\t|9560|\n|scalar\t|15912\t|15216|\n|layer\t|15960\t|15168|\n\nIt can be seen that the complexity of the methods is similar. We can expect with code optimization, the wall-time issue can be fixed. \n\nThe \"trick\" like the warm-up iteration mentioned in the supplementary, is used to accelerate the convergence without affecting the final result. Once the code optimization is done, this trick can be removed."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1699993712170,
                "cdate": 1699993712170,
                "tmdate": 1700252916895,
                "mdate": 1700252916895,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "npdFD6rVq9",
                "forum": "EWcybWr3MR",
                "replyto": "tBwP40iPlM",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "`7. Performance of default settings of baselines.`\n\nSince for SGD, Pytorch has 0 as the default momentum, we guess by default, you mean the setting people commonly use, i.e., momentum $= 0.9$ (please correct us if we're wrong). We are not sure about the common choice of weight decay, so we found the default configuration for ResNet from [1], where it sets the learning rate to 0.1, weight decay to 1e-4, and momentum to 0.9, and uses a learning rate scheduler (reducing by a factor of 10 when the error plateaus). But with this parameter setting, the test accuracy of ResNet18 on CIFAR10 and CIFAR100 is only 85.21\\% and 60.66\\%, respectively, which is approximately 4\\% to 5\\% lower than that achieved with the best-tuned settings. This suggests when changing network type or dataset, in order to achieve the best performance, hyper-parameter tuning is still needed. \n\nThe default learning rate for Adam is 1e-3, and the default weight decay is 0. Using Adam's default settings, the test accuracies for VGG13 and ResNet18 on CIFAR10 and CIFAR100 are displayed in Tables 1 and 2. Although the best test accuracy is similar to that obtained with Adam's default settings at a batch size of 128, the discrepancy is more pronounced with a batch size of 2048. Optimal test accuracy for VGG13 is attainable only with larger batch sizes, where the default settings are ineffective. Our PAC-Bayes training achieves the best test accuracy across various settings.\n\nTable1. The test accuracy when using the default setting of Adam with a batch size of 128. The accuracy inside the $()$ denotes the best test accuracy with a batch size of 128.\n||CIFAR10|CIFAR100|\n|---|---|---|\n|VGG13|88.3 (88.5)|63.3 (63.7)|\n|ResNet18|87.5 (87.5)|61.5 (61.6)|\n\nTable2. The test accuracy when using the default setting of Adam with batch size as 2048. The accuracy inside the $()$ denotes the best test accuracy with a batch size of 2048.\n||CIFAR10|CIFAR100|\n|---|---|---|\n|VGG13|86.6 (90.7)|58.2 (66.2)|\n|ResNet18|84.3 (87.7)|56.3 (65.4)|\n\nThe default learning rate for AdamW is 1e-3, and the default weight decay is 1e-2. Under AdamW's default settings, the test accuracies for VGG13 and ResNet18 on CIFAR10 and CIFAR100 are presented in Tables 3 and 4. Although these default settings generally yield the best test accuracy for AdamW when using small batch size, they are not as effective as Adam/SGD, making optimizer selection essential. Our PAC-Bayes training achieves better test accuracy than AdamW.\n\nTable3. The test accuracy when using the default setting of AdamW with a batch size of 128. The accuracy inside the $()$ denotes the best test accuracy with a batch size of 128.\n||CIFAR10|CIFAR100|\n|---|---|---|\n|VGG13|88.4 (88.4)|61.8 (61.8)|\n|ResNet18|87.9 (87.9)|60.2 (61.4)|\n\nTable4. The test accuracy when using the default setting of AdamW with batch size as 2048. The accuracy inside the $()$ denotes the best test accuracy with a batch size of 2048.\n||CIFAR10|CIFAR100|\n|---|---|---|\n|VGG13|86.7 (87.2)|57.7 (61.0)|\n|ResNet18|84.5 (84.9)|56.1 (58.9)|\n\n[1] He, Kaiming, et al. \"Deep residual learning for image recognition.\""
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700107014890,
                "cdate": 1700107014890,
                "tmdate": 1700276209054,
                "mdate": 1700276209054,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "lopteblLWo",
                "forum": "EWcybWr3MR",
                "replyto": "tBwP40iPlM",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "`8. Sensitivity analysis of baselines. (Part 2)`\n\nWe also compared PAC-Bayes training with SGD/Adam/AdamW on CIFAR10, using a batch size of 128, and allocated 10\\% of the training data for training and the remaining 90\\% for hyper-parameter searching in SGD/Adam/AdamW. With ResNet18, the test accuracy of PAC-Bayes is 67.8\\%, while the best test accuracies for SGD, Adam, and AdamW, after hyper-parameter searching, are 64.00\\%, 64.96\\%, and 65.59\\%, respectively. When training ResNet18 with all the training data using a batch size of 128, SGD typically achieves the best test accuracy among the baselines. However, AdamW outperforms SGD when using only 10\\% of the training data. This demonstrates the necessity of both hyper-parameter searching and choosing the appropriate optimizer for baselines."
                    }
                },
                "number": 10,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700107571997,
                "cdate": 1700107571997,
                "tmdate": 1700108043602,
                "mdate": 1700108043602,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "MUuyvNrJvV",
                "forum": "EWcybWr3MR",
                "replyto": "evZUlpE0z1",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Reviewer_geV1"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Reviewer_geV1"
                ],
                "content": {
                    "title": {
                        "value": "Reply"
                    },
                    "comment": {
                        "value": "I thank the authors for their very extensive feedback!\n\n**Generalisation bound**: Thank you for the clarification. (1) Even if there is no baseline to compare against, the generalisation bounds themselves would still be interesting (e.g. how tight are they etc). (2) If I recall correctly, (Dziugaite and Roy) did evaluate their algorithm on a binary version of MNIST, which authors could compare against if I don't miss anything?\n\n**$\\gamma_1$ and $\\gamma_2$**: So if I understand correctly, $\\gamma_2$ did indeed need some tuning? If yes, how many attempts were needed on CIFAR10 to find a stable value?\n\n**Training time**: I understand that if properly optimised, the approach might be more competitive but what is stopping the authors from doing so? Right now, the method is roughly 12 times slower, which is really not attractive for practitioners which might not even have the compute to perform such a long run. The fact that the authors did not implement an optimised version seems to again highlight that the suggested approach is not straight-forward and introduces some additional overhead on the user's side. Of course there is a trade-off here between complexity and computational gains obtained due to less hyper-parameter optimisation, but in its current shape I remain unconvinced that the proposed method is useful to practitioners right now.\n\n**Stability of hyper-parameters:** I thank the authors for running this experiment, this indeed helps to strengthen the contribution. Given this analysis, how many runs of SGD/ADAM(W) are needed to obtain reasonable performance? Are their any other works/heuristics that could guide hyper-parameter search that one should compare against? I'm unsure how the baselines should be compared against, i.e. how many hyper-parameter searches should be done. What about randomly sampling from potential hyper-parameter settings without replacement and test how many draws are needed to reach a certain performance? Right now I find it very hard to assess how much could be potentially saved by the suggested method (given that it can be implemented more efficiently). \n\n\nAll in all I'm still reluctant to increase my score. The theoretical contribution seems nice but it is not really evaluated empirically, i.e. the advantages of the PAC-Bayes bound itself over prior work (or even whether it's vacuous or not) cannot be assessed. The authors focus more on the practical relevance regarding hyper-parameter search, but the current implementation is very slow, allowing for 10 runs of the same experiment using SGD. While theoretically, the implementation can be improved, I find this a bit a weak argument as the focus of this paper is on providing a faster and more stable way to avoid hyper-parameter search but currently this is not the case."
                    }
                },
                "number": 18,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700484091319,
                "cdate": 1700484091319,
                "tmdate": 1700484091319,
                "mdate": 1700484091319,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "mHqrtBN5wZ",
                "forum": "EWcybWr3MR",
                "replyto": "tBwP40iPlM",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "**Thank you very much for thinking our theoretical contribution is nice!** \n\nHere, we want to further address the reviewer's questions.\n\n`1. Tightness of the generalization bound.`\n\n(1) As shown in the first 500 epochs (Stage 1) of Figures 10e-15e in the Appendix, the test loss decreases along with the training loss (our PAC-Bayes bound), and the training loss (our PAC-Bayes bound) is always higher than the test loss. Therefore, our PAC-Bayes bound is tight because: 1. it is a valid bound, and 2. the network can be optimized effectively with this bound.\n\n(2) In Dziugaite and Roy, authors used 1 and -1 to represent classes $\\{0,...,4\\}$ and $\\{5,...,9\\}$. So, it is a binary classification problem with bounded loss. We target multi-class classification tasks with unbounded loss. So, our PAC-Bayes bound is essentially different from the one in the paper (Dziugaite and Roy).\n\n`2.` $\\gamma_1$ `and` $\\gamma_2$\n\nWe only tried $10$, $20$ for $\\gamma_2$ on ResNet18 with CIFAR10. After checking the numerical results, **we selected $10$ as the default and fixed it for all experiments and all models (including NLP models such as GPT, GNN models for citation graphs, and CNN models for image classification)**. So, there is no searching on $\\gamma$.\n\n`3. Training time`\n\nThere are currently two challenges for us to achieve the theoretically predicted speed and make the PAC-Bayes training as fast as SGD: software and hardware limitations.\n\na. Limited access to the source code of PyTorch: Implementing noise injection in PyTorch can be challenging and time-consuming. Adding noise to algorithms like SGD or Adam slows each iteration down to the same speed as PAC-Bayes training, which is around three times slower than a standard SGD iteration. The training time for one epoch needed for noise injection and our PAC-Bayes training are both 27s for ResNet18 on CIFAR10 with one RTX3090 GPU. For pure Adam without noise injection, it only takes 10s for one epoch. This is despite the fact that the complexity of these methods is the same. Noise injection in Julia does not suffer from this issue, but we're less familiar with Julia. \n\nb. GPU memory limitations impact our training speed. While our PAC training benefits from using large batch sizes without performance loss, and larger batch sizes could speed up the algorithm by processing more data simultaneously, our GPU memory limits us. For example, we use a batch size of 2048 for PAC-Bayes training and 128 for SGD. Ideally, training with a batch size of 2048 should be 16 times faster than with 128, but due to GPU memory constraints, it's only twice as fast.\n\nThese are soft constraints to the community but are hard constraints to us.\n\n`4. Stability of hyper-parameters\n\n**The current tuning seems efficient thanks to existing knowledge, which allows people to follow established hyper-parameters. However, this is not the case if we lack such knowledge about which hyper-parameters are effective.** In the next two sets of experiments, we used the same set of hyper-parameters for searching, as mentioned in the paper for CIFAR10/CIFAR100, showing sensitivity when lacking the knowledge for searching. \n\nOn CIFAR10 with a batch size of 128, we allocated 10\\% of the training data for actual training and the remaining 90\\% for hyper-parameter searching in baselines. With ResNet18, the test accuracy of PAC-Bayes is 67.8\\%, while the best test accuracies for SGD/Adam/AdamW are 64.00\\%/64.96\\%/65.59\\%. *When training ResNet18 with all the training data and a batch size of 128, SGD typically achieves the best test accuracy among the baselines. However, with only 10\\% of the training data, AdamW outperforms SGD.*\n\nWe also trained ResNet18 with a batch size of 128 on the TinyImageNet. The test accuracy of PAC-Bayes training is 53.2\\%, while the best test accuracy achieved with SGD/Adam/AdamW after hyperparameter searching is 46.4\\%/46.7\\%/46.8\\%. *This further demonstrates the advantages of our proposed PAC-Bayes training.*\n\nWhile SGD is faster on image tasks, it doesn't consistently deliver the best performance. Even with some knowledge about hyper-parameter searching, it might still be inadequate. Moreover, there are 4 parameters to tune for SGD and 5 for Adam, making it relatively easy to conduct over 12 tuning iterations in total, even if we ignore Adam needs longer training time than SGD."
                    }
                },
                "number": 23,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700587402384,
                "cdate": 1700587402384,
                "tmdate": 1700613208933,
                "mdate": 1700613208933,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "2kdntAtdpx",
                "forum": "EWcybWr3MR",
                "replyto": "tBwP40iPlM",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "`Tightness of the generalization bound. (numerical comparison)`\n\nIt is difficult to compare our bound with those for bounded loss (e.g., Dziugaite and Roy) because if the loss is bounded, then our bound has similar tightness as theirs, and if the loss is unbounded, their bound (for bounded loss) cannot be applied. But to partially address your concern, we have numerically compared our bounds with some recent bounds in the literature for unbounded loss, as mentioned by Reviewer YdhE. Those bounds are crude and do not enable PAC-Bayes training because the model does not see an update by minimizing those bounds. \n\nNevertheless, as you correctly mentioned, we can still compare them as pure bounds instead of training algorithms. Figure (https://tinyurl.com/ycksnjvb) displays the result. More explicitly,  we numerically compared our new PAC-Bayes bound with the existing one in the reference (Corollary 4, https://arxiv.org/pdf/1605.08636.pdf) mentioned by the reviewer, which is also for unbounded loss. Even though the forms of the bounds look similar, their actual numerical values are significantly different. As shown in this figure, our proposed bound is far tighter than this baseline one. The sub-Gaussian norm term ($s^2$) in this baseline bound alone is larger than $100$, making it not appealing in practice."
                    }
                },
                "number": 28,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700671209233,
                "cdate": 1700671209233,
                "tmdate": 1700675113313,
                "mdate": 1700675113313,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "YEVpv3HYrU",
            "forum": "EWcybWr3MR",
            "replyto": "EWcybWr3MR",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6106/Reviewer_DC8a"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6106/Reviewer_DC8a"
            ],
            "content": {
                "summary": {
                    "value": "The paper proposes an approach for PAC Bayesian approach for training deep neural nets that automates the determination of the model hyperparameters based on a learning-theoretic bound instead of performing combinatorial search. The developed PAC Bayesian bound has novel aspects such as being applicable to unbounded losses by making more plausible assumptions than the prior art. The paper evaluates the practical benefit of the developed bound on diverse and challenging use cases such as training neural nets with a depth of 10+ layers on image classification and graph neural nets on five different graph prediction benchmarks. The proposed method appears to reach state-of-the-art performance or above in most of these use cases."
                },
                "soundness": {
                    "value": "4 excellent"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "4 excellent"
                },
                "strengths": {
                    "value": "The paper does a really good job at identifying the bottlenecks of the existing approaches, such as how the assumed range of exponential moment inequality leads to vacuous bounds. There are many other such to-the-point statements clearly justifying and motivating the proposed solution.\n\nThe proposed way of developing a PAC Bayes bound for unbounded loss is novel and very interesting. The way it moves from bounded loss to bounded moment generating functions is truly creative and elegant.\n\nThe algorithm derived from the bound addresses a fundamental problem of machine learning: tuning hyperparameters of large-scale predictors. The enterprise is very ambitious and the reported results are very promising."
                },
                "weaknesses": {
                    "value": "There is ample room to improve the clarity of Section 6. The current version is missing a good amount of essential information. As far as I understand, a key message of the paper is \u201cdo not do grid search, do PAC Bayes training instead\u201d. Then grid search appears as the main baseline to improve on. Wouldn\u2019t it then make senses to reserve some space in Section 6 to describe how they build the grid, why it is a strong alternative to PAC Bayes (i.e. how do we know that it contains competitive hyperparam values), and how much computation overhead it brings?"
                },
                "questions": {
                    "value": "It looks to me possible to use an existing PAC Bayes bound, such as one from Dziugaite et al. or Haddouche et al. for the same purpose: hyperparameter tuning. How does the proposed bound compare to them on the same experiment setup? I believe that I see what is novel with the bound but I do not immediately see why it should be a better bound, better in the sense of both being tighter and being a training objective that gives improved generalization accuracy. How do the current experiment results help us make this comparison? If they cannot, could the authors report additional results during the rebuttal phase to make this comparison possible?\n\n\nI also have difficulties interpreting Figure 1. What does the x axis correspond to? What does \u201cindex\u201d stand for in this context?\n\nThe conclusion section makes the claim that the proposed method also mitigates the curse of dimensionality. How do we conclude this from the rest of the paper, especially from the experiment results?\n\nSolid work overall."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6106/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698770870630,
            "cdate": 1698770870630,
            "tmdate": 1699636659197,
            "mdate": 1699636659197,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "01oUBRfGdu",
                "forum": "EWcybWr3MR",
                "replyto": "YEVpv3HYrU",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you very much for the constructive suggestions. We will take your comments into consideration in the revision.\n\n`1. How does the proposed bound compare to Dziugaite et al. or Haddouche et al. on the same experiment setup?`\n\nThanks for the question, which also highlights our contribution: we bridged the gap between theory and practice while using PAC-Bayes bound. For example, Haddouche et al. (PAC-Bayes Generalisation Bounds for Heavy-Tailed Losses through Supermartingales) have data-free prior to searching the hyper-parameter, which is time-consuming and needs extra validation data to enable the selection.\nDziugaite et al. (On the role of data in pac-bayes bounds) need extra data to train the prior, which could also be expensive in practice, e.g., collecting medical data. We have also tried to use existing PAC-Bayes bounds derived for unbounded losses, e.g., [1][2]. However,  the cross entropy loss does not satisfy the bound in [1] without putting extra assumptions on the data, while [2] is too difficult to estimate in practice since it requires estimating the expectation of the second-order moment of the loss by drawing a test sample.\n\n**In summary, we did not find an existing PAC-Bayes bound that can be directly applied to the classification task without hyper-parameter searching or extra data for the prior.** The primary purpose of this paper is to bridge the gap between theory and practice.\nFor our method, we proposed a data-dependent prior that can be trained with the training dataset without requiring extra data to learn the prior or extra tuning to find a good prior. \n\n[1].  Haddouche, Maxime, et al. \"PAC-Bayes unleashed: Generalisation bounds with unbounded losses.\" \n\n[2]. Kuzborskij, Ilja, et al. \"Efron-stein pac-bayesian inequalities.\"\n\n`2. What does \u201cindex\u201d stand for in this context?`\n\nWe sorted the test accuracy of different searched hyper-parameters. The x-axis denotes the sorted index of the experiment. \n\n`3. The conclusion section makes the claim that the proposed method also mitigates the curse of dimensionality. How do we conclude this from the rest of the paper?`\n\nThe curse of dimensionality refers to the fact that when the model gets large, the KL term (and therefore the PAC-Bayes bound) could potentially get very large. Experiments show our method can achieve state-of-the-art results, indicating this curse of dimensionality is mitigated. We also tried other bounds, which cannot handle models as large as resnet18 (on cifar10), as the bound gets too large to be practical."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1699992520981,
                "cdate": 1699992520981,
                "tmdate": 1700262635451,
                "mdate": 1700262635451,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "YOUSvySQOI",
                "forum": "EWcybWr3MR",
                "replyto": "vfVonzcIMw",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Reviewer_DC8a"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Reviewer_DC8a"
                ],
                "content": {
                    "title": {
                        "value": "Thanks"
                    },
                    "comment": {
                        "value": "Thanks, your answers address my concerns satisfactorily. I keep my grade as an accept."
                    }
                },
                "number": 34,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700727428447,
                "cdate": 1700727428447,
                "tmdate": 1700727428447,
                "mdate": 1700727428447,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "45BaffCdb2",
            "forum": "EWcybWr3MR",
            "replyto": "EWcybWr3MR",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6106/Reviewer_R7cX"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6106/Reviewer_R7cX"
            ],
            "content": {
                "summary": {
                    "value": "The paper introduces a training framework that improves the generalization ability of neural networks without extensive hyper-parameter tuning and regularization. By minimizing the PAC-Bayes bound with trainable priors, the framework achieves comparable performance to traditional methods like SGD/Adam, even without additional regularization. It eliminates the need for hyper-parameter search and reduces reliance on validation data. The paper highlights the importance of weight decay and noise injections as essential techniques. The approach shows promise for enhancing generalization in deep neural networks."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. This paper generally is well-written and easy to follow.\n2. The idea of tuning-free generalizaton with trainable prior is both interesting and theoretically grounded, and seems to be promising in training neural networks, especially when it can be extended to large-scale neural networks, e.g., transfermers.\n3. This paper has provided solid theoretical analysis, which can be inspiring for the follow-up works."
                },
                "weaknesses": {
                    "value": "1. The paper suggests that only weight decay and noise injections are essential for PAC-Bayes training. However, this conclusion seems premature and lacks comprehensive analysis. It would be beneficial to investigate and compare the impact of other regularization techniques commonly used in deep learning, such as dropout or batch normalization, within the proposed framework. This would provide a more comprehensive understanding of the interplay between different regularization methods and their contribution to generalization performance.\n2. The method proposed in this paper may require i.i.d. data and may not be able to deal with out-of-distribution tasks."
                },
                "questions": {
                    "value": "1. Could the authors elaborate more on why it is so important to give a generalization bound on unbounded loss? Existing bounded one can not work well in practice? An empirical compare with them when apply those bounds for training? From my understanding, the bounded part has now been shifted to the bounded $\\gamma$ with $\\gamma_1$ and $\\gamma_2$ in the unbounded bounds.\n2. Could the authors elaborate more on why optimizing prior on training dataset will be helpful for the generalization performance. Normally, we should fix prior or choose a good one using validation dataset."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 5,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6106/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698907853063,
            "cdate": 1698907853063,
            "tmdate": 1699636659092,
            "mdate": 1699636659092,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "0bUKSFye0D",
                "forum": "EWcybWr3MR",
                "replyto": "45BaffCdb2",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "`1. The paper suggests that only weight decay and noise injections are essential for PAC-Bayes training. However, this conclusion seems premature and lacks comprehensive analysis.`\n\nWe agree that studying the effect of the interplay between different kinds of regularization is still an important open problem, and we have mentioned it in the introduction. Here, we state that only noise injection and weight decay are essential from our derived PAC-Bayes bound. \n\nLike most commonly used implicit regularizations (large lr, momentum, small batch size), dropout and batch-norm are also known to penalize the loss function's sharpness indirectly. [1] studies that dropout introduces an explicit regularization that penalizes **sharpness** and an implicit regularization that is analogous to the effect of stochasticity in small mini-batch stochastic gradient descent. Similarly, it is well-studied that batch-norm [2] allows the use of a large learning rate by reducing the variance in the layer batches, and large allowable learning rates regularize **sharpness** through the edge of stability [3].  \n\nAs shown in the equation below, the first term (noise-injection) in our PAC-Bayes bound explicitly penalizes the Trace of the Hessian of the loss, which directly relates to sharpness and is quite similar to the regularization effect of batch-norm and dropout. During training, suppose the current posterior is $\\mathcal{Q}_{\\hat{\\sigma}}(\\hat h) = \\mathcal{N}(\\hat h,\\textrm{diag}(\\hat \\sigma))$, \n\nLet $h \\sim \\mathcal{Q}_{\\hat{\\sigma}}(\\hat h)$, \n\nand $\\Delta{h} \\sim \\mathcal{Q}_{\\hat{\\sigma}}(0)$.\n\nThe training loss expectation over the posterior is: \n\n$\\mathbb{E}_{h} \\ell(h;\\mathcal{D})$ \n\n$= \\mathbb{E}_{ \\Delta{h} } \\ell(\\hat{h}+\\Delta {h};\\mathcal{D})$ \n\n$\\approx \\ell(\\hat h;\\mathcal{D})+\\frac{1}{2} \\mathrm{Tr} (\\textrm{diag}(\\hat\\sigma) \\nabla^2 \\ell(\\hat{h};\\mathcal{D}))$\n\nThe second regularization term (weight decay) in the bound additionally ensures that the minimizer found is close to initialization. Although the relation of this regularizer to sharpness is not very clear, empirical results suggest that weight decay may have a separate regularization effect from sharpness. So, in brief, we state that the effect of sharpness regularization from dropout and batch norm can also be well emulated by noise injection with the additional effect of weight decay. \n\n  1) Wei, Colin, et al. \"The implicit and explicit regularization effects of dropout.\"\n  2) Luo, Ping, et al. \"Towards Understanding Regularization in Batch Normalization.\"\n  3) Cohen, Jeremy, et al. \"Gradient Descent on Neural Networks Typically Occurs at the Edge of Stability.\" \n\n`2. The method proposed in this paper may require i.i.d. data.`\n\nYes, that is correct. The PAC-Bayes analysis to study generalization is limited to in-distribution tasks. We do not think of it as a drawback but rather out of the scope of this paper. Analyzing out-of-distribution generalization is still a developing field and will need additional statistical tools to derive generalization bounds for OOD tasks. However, there are papers discussing using the PAC-Bayes bound to detect the out-of-distribution samples [4], which could be the future work.\n\n`3. Why is it so important to give a generalization bound on unbounded loss? Existing bounded one can not work well in practice? Any empirical comparison with them when applying those bounds for training?`\n\nSince the prevalent cross-entropy loss (CE) is unbounded, it is important to derive a PAC-bayes bound to deal with it. Existing ones for bounded loss (such as Theorem 2.1) do not work well on the CE loss because the $C$ in Theorem 2.1 has to be set to infinity for CE loss, which makes the bound meaningless.  We also tried to approximate the CE loss by a bounded loss first and then used the PAC-Bayes bound for bounded loss, which again failed to work when we explicitly tried to truncate/clip the cross-entropy loss to make the loss bounded. In the experiment, we observe that this will cause the training and test accuracy to plateau at very low levels around $10\\\\%$ to $20\\\\%$.\n\n`4. The bounded part has now been shifted to the bounded $\\gamma$ .`\n\nThe bounded part has been shifted to the $K(\\lambda)$ in Theorem 4.1. More explicitly, the $K(\\lambda)$ in Theorem 4.1 (our theorem) corresponds to the $C$ (the upper bound of the loss) in Theorem 2.1 (the one for bounded loss). So, we can understand $K(\\lambda)$ as an effective bound of the unbounded loss. Limiting the range of $\\gamma$ to $[\\gamma_1,$ $\\gamma_2]$ reduces the value of $K(\\lambda)$, which makes the bound tighter. For instance, if we don't limit this range, the $K(\\lambda)$ we found for cifar10 on resnet18 would be $4$ versus $0.3$ when we limit the range."
                    }
                },
                "number": 1,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1699991361556,
                "cdate": 1699991361556,
                "tmdate": 1699991361556,
                "mdate": 1699991361556,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "FR5LveF4qc",
                "forum": "EWcybWr3MR",
                "replyto": "egFCZaOhSU",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6106/Reviewer_R7cX"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6106/Reviewer_R7cX"
                ],
                "content": {
                    "title": {
                        "value": "Thank the authors for their detailed response"
                    },
                    "comment": {
                        "value": "I would like to thank the authors for their clear and detailed response. I truly encourage the authors to include these important discussion into their revised paper. \n\nHowever, I still have the concern about the validity of introducing a bounded $\\lambda$ to make unbounded loss able to be bounded. It sounds like giving the theoretical results in a smaller domain. I suppose that the range of $\\lambda$ may significantly impact the theoretical results and in certain cases the bound will be degenerated into the unbounded one? Overall, I would like to retain my score."
                    }
                },
                "number": 27,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6106/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700652735783,
                "cdate": 1700652735783,
                "tmdate": 1700652735783,
                "mdate": 1700652735783,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]