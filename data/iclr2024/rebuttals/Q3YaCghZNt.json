[
    {
        "title": "Lemur: Integrating Large Language Models in Automated Program Verification"
    },
    {
        "review": {
            "id": "SGybkF6N0J",
            "forum": "Q3YaCghZNt",
            "replyto": "Q3YaCghZNt",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission7652/Reviewer_mzY5"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission7652/Reviewer_mzY5"
            ],
            "content": {
                "summary": {
                    "value": "The paper presents a principled approach for combining LLMs with automated reasoning tools to perform automated program verification. Automated program verification typically proceeds by breaking down the overall proof goal into simpler proof sub-goals---each sub-goal establishes some invariant of the program which can help in proving/disproving the overall program assertion. The proposed technique uses LLMs to suggest candidate invariants as proof sub-goals; whether the suggested invariants hold or not is posed as a query to existing automated program reasoning tools. While the general paradigm of guessing and then checking invariants is well-known in the program verification literature, the paper presents a proof calculus that cleanly formalizes this style of reasoning and develops an algorithm based on this calculus. The calculus is proven sound and the algorithm is shown to be terminating under suitable conditions. Most importantly, the presented algorithm outperforms state-of-the-art automated program verification tools on standard benchmarks."
                },
                "soundness": {
                    "value": "4 excellent"
                },
                "presentation": {
                    "value": "4 excellent"
                },
                "contribution": {
                    "value": "4 excellent"
                },
                "strengths": {
                    "value": "1. This is a very well-written paper and presents a nice, clean formalization of the guess-and-check style of program reasoning via the Lemur calculus.\n\n2. The algorithm that operationalizes the calculus is elegant and easy to understand.\n\n3. Use of LLMs to suggest candidate program invariants is an obvious idea but it has been very well manifested into practice, both mathematically and algorithmically,  by this work.\n\n4. Some of the prompting tricks used to get the invariants from the LLM, such as placeholder lines, are interesting in their own right.\n\n5. Most importantly, the empirical results are very promising and suggest that LLMs and verification tools can be fruitfully combined."
                },
                "weaknesses": {
                    "value": "1. This is a relatively minor comment but the formalization and the algorithm seem geared towards imperative languages where the notion of associating a property/invariant with a line number makes natural sense. It would be helpful to acknowledge that the proposed calculus might not necessarily be applicable to all programming languages.\n\n2. There has a large body of literature on data-driven techniques for learning loop invariants [1,2]. Unlike Code2Inv and Lemur, these past works use dynamic values of loop variables. Adding references to this body of work would help paint a fuller picture about this area.\n\n[1] Garg, P., Neider, D., Madhusudan, P., & Roth, D. (2016). Learning invariants using decision trees and implication counterexamples. ACM Sigplan Notices, 51(1), 499-512.\n\n[2] Sharma, R., Gupta, S., Hariharan, B., Aiken, A., Liang, P., & Nori, A. V. (2013). A data driven approach for algebraic loop invariants. In Programming Languages and Systems: 22nd European Symposium on Programming, ESOP 2013, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2013, Rome, Italy, March 16-24, 2013. Proceedings 22 (pp. 574-592). Springer Berlin Heidelberg."
                },
                "questions": {
                    "value": "1. For the benchmark of difficult programs from SV-COMP, where are the placeholder lines added? Is it after every line in the program? If not, doesn't the location of the placeholder leak information, potentially aiding Lemur?\n\n2. It seems like the text and the formal expression for the second bullet point of Proposition 2.1 do not line up. Shouldn't the implication in the formal expression go the other way?\n\n3. I don't think the last line on Page 2 is correct. A program without loops can have an unstable property because the program can still have multiple paths due to branches. Also, how can a property that is not an invariant be stable? Is this the case where stability is due to the property always being false?\n\n4. Is the time in Table 1 in seconds? When you say timeout of 1 hr or 10 minutes, is that the timeout for the entire dataset or each program?\n\n5. Does each bar in Figure 4 correspond to a single value for the number of proposals or a set of values? It seems like it is the latter case. It would help to clarify the figure."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission7652/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698713737879,
            "cdate": 1698713737879,
            "tmdate": 1699636930799,
            "mdate": 1699636930799,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "r2bixAoJSR",
                "forum": "Q3YaCghZNt",
                "replyto": "SGybkF6N0J",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7652/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7652/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your comments and suggestions!\n\n\n**Q: This is a relatively minor comment but the formalization and the algorithm seem geared towards imperative languages where the notion of associating a property/invariant with a line number makes natural sense. It would be helpful to acknowledge that the proposed calculus might not necessarily be applicable to all programming languages.**\n\nWe will clarify that our approach is designed for imperative languages. Thank you for the clarification suggestion!\n\n\n**Q: There has a large body of literature on data-driven techniques for learning loop invariants [1,2]. Unlike Code2Inv and Lemur, these past works use dynamic values of loop variables. Adding references to this body of work would help paint a fuller picture about this area.**\n\nWe will include references to these papers and discuss them in the 'Related Work' section. Thank you!\n\n\n**Q: For the benchmark of difficult programs from SV-COMP, where are the placeholder lines added? Is it after every line in the program? If not, doesn't the location of the placeholder leak information, potentially aiding Lemur?**\n\nWe automatically insert placeholders at the beginning of each loop and right before the loop, which we deem a generally good heuristic in practice. We do not think we are leaking any information specific to the benchmarks to Lemur. \n\n\n**Q: It seems like the text and the formal expression for the second bullet point of Proposition 2.1 do not line up. Shouldn't the implication in the formal expression go the other way?**\n\n\nThank you for spotting that! Yes, it should be the other way in the formal expression.  We updated the paper.\n\n\n\n**Q: I don't think the last line on Page 2 is correct. A program without loops can have an unstable property because the program can still have multiple paths due to branches.**\n\nWe say the property is stable, if within a single execution of the program, the property always evaluates to true or always evaluates to false. If there are no loops, the property will be evaluated at most once. This also holds when the program has branches, as only one path will be executed.\n\n\n**Q: Also, how can a property that is not an invariant be stable? Is this the case where stability is due to the property always being false?**\n\nThe property is stable as long as it evaluates to the same truth value within a particular execution (please see the clarification on the definition of stability above). Therefore, if the property is always false, then the property is stable. However, it is also possible for a property to be stable if it holds in some executions, but does not hold in some other executions. \n\nConsider an illustrative example:\n\n```\nLine 1: x=rand(0,10)\nLine 2: assert(x==1)\n```\n\nThe property in Line 2 is stable. This property only holds for some executions.  We will add an example to the paper to illustrate the stability definition.\n\n**Q: Is the time in Table 1 in seconds? When you say timeout of 1 hr or 10 minutes, is that the timeout for the entire dataset or each program?**\n\nYes, the time is in seconds.  And the timeout is per program.\nWe will clarify that in the paper.\n\n**Q: Does each bar in Figure 4 correspond to a single value for the number of proposals or a set of values? It seems like it is the latter case. It would help to clarify the figure.**\n\n\nEach bar in Figure 4 corresponds to a set of values.  We will clarify this in the text."
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7652/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700518398802,
                "cdate": 1700518398802,
                "tmdate": 1700518398802,
                "mdate": 1700518398802,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "pehVYcEeDH",
                "forum": "Q3YaCghZNt",
                "replyto": "r2bixAoJSR",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7652/Reviewer_mzY5"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7652/Reviewer_mzY5"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for the response and the clarifications, specially, about the stability property."
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7652/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700546983613,
                "cdate": 1700546983613,
                "tmdate": 1700546983613,
                "mdate": 1700546983613,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "jcLqjgbfJm",
            "forum": "Q3YaCghZNt",
            "replyto": "Q3YaCghZNt",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission7652/Reviewer_ERFy"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission7652/Reviewer_ERFy"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes an approach to reachability verification, dubbed Lemur, which combines the invariance generation capabilities of LLMs with standard verification tools. The resulting procedure, which is sound albeit incomplete, comes with theoretical guarantees.\nLemur equipped with GPT4 can solve benchmarks that are currently out of reach of state-of-the-art standard reachability verification tools."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "- Clear presentation\n- Reachability is a pivotal problem in program verification\n- Promising preliminary results\n- (To the best of my understanding) Lemur's calculus and template algorithm can accomodate different combinations of invariant generators and verifiers"
                },
                "weaknesses": {
                    "value": "My main concerns are related to the empirical evaluation of Lemur. \nThe combination of LLMs and standard verification procedures is indeed promising, but I am left wondering how much the results are reliant on the specific LLM GPT4. \n\nThis is particularly important considering the economic cost of reproducing the experiment, which can be prohibitive for some.\n\nIf I understand correctly, Lemur is a template algorithm. I would then expect to see results for LEMUR(X, Y), where X = {GPT4, other free LLMs, other invariant generation techniques (Code2INV maybe?), and Y = {UAUTOMIZER, ESBMC}."
                },
                "questions": {
                    "value": "- How much is Lemur performance reliant on the invariant generator quality?\n- How does Lemur fare without GPT4 as an invariant generator? \n- Can Lemur be used with non-LLM invariant generators such as Code2Inv?\n\n--------\nMinors:\n\nThe derivation rules in Fig.1 are not 100% clear to me. What is the semantic of operator \": :\"?\n\nFigures 3 and 4 should have different (and self-explanatory) captions, i.e. explicitly mention the referred benchmarks."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission7652/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698763084505,
            "cdate": 1698763084505,
            "tmdate": 1699636930684,
            "mdate": 1699636930684,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "ahZM1Baafs",
                "forum": "Q3YaCghZNt",
                "replyto": "jcLqjgbfJm",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7652/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7652/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your comments and suggestions! \n\n\n**Q: How much is Lemur performance reliant on the invariant generator quality? How does Lemur fare without GPT4 as an invariant generator?**\n\nWe agree that this is an interesting question of how sensitive Lemur is to an LLM choice. We made a decision to build the first version of Lemur on GPT4 which are arguably the most powerful models and absorb the cost of using these models. \n\n*We ran additional experiments with the GPT-3.5 turbo model and updated the experimental evaluation in Tables 2a and 2b. We observe that GPT-4 outperforms GPT-3.5 turbo, especially on SV-COMP benchmarks. Based on these results, we hypothesize that the performance might drop if we use other open-source models (but this can change as these models are constantly improving).*\n\n**Q: This is particularly important considering the economic cost of reproducing the experiment, which can be prohibitive for some.**\n\nWe agree with the reviewer that it might be costly to use. To be more concrete, we spent ~2 cents per call for GPT4. We chose to use the best LLM model out there to see what is the potential of such integration. Our total budget was less than $1000 for the project.\n\n**Q: Can Lemur be used with non-LLM invariant generators such as Code2Inv?**\n\nCode2Inv is trained to find an invariant at a fixed location in a program, which is not suitable for our framework.\nOur framework requires an LLM oracle to be able to generate an invariant at any point in the program.\n\nIn principle, we can use any LLM and verification tools. For example, we added new results for GPT3.5 oracle instead GPT4 that are presented in the paper. As we mentioned above, our new results show that GPT-4 outperforms GPT-3.5 turbo on the tested benchmarks.\n\nWe are happy to run more experiments with open-source LLMs in the final version of the paper but we will not be able to provide these results during rebuttal, unfortunately.\n\n\n\n**Minors Q: The derivation rules in Fig.1 are not 100\\% clear to me. What is the semantic of operator \": :\"?**\n\n:: means that a list M is a concatenation of sublists, e.g. M = sublist1::sublist2\n\nFor example, we often use the following notation in Figure 1.\n```\nM= M'::p \n```\nThis means that a trail M is a concatenation of a trail M' and p, where p is the last element of M. We will further clarify this in the paper.\n\n\n**Minors Q: Figures 3 and 4 should have different (and self-explanatory) captions, i.e. explicitly mention the referred benchmarks.**\n\nThanks, we will fix."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7652/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700518145188,
                "cdate": 1700518145188,
                "tmdate": 1700523896800,
                "mdate": 1700523896800,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "WYz5geE5jx",
                "forum": "Q3YaCghZNt",
                "replyto": "ahZM1Baafs",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7652/Reviewer_ERFy"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7652/Reviewer_ERFy"
                ],
                "content": {
                    "title": {
                        "value": "Response to the authors"
                    },
                    "comment": {
                        "value": "Thank you for your reply. I think that the extra experiment with a different LLM are valuable.\n\nI tend to agree with Reviewer 2ahy's concerns on the fairness of a runtime comparison between the baselines and LEMUR using a LLM oracle running on external hardware. I understand that running the LLM oracle locally is not completely solving the issue, since most reachability tools do not make use of the GPU anyway (to the best of my understanding). Yet, in my opinion having LEMUR running completely on local would be more significant for practitioners, giving some insight on the performance gains that we can expect on limited hardware resources."
                    }
                },
                "number": 13,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7652/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700667186183,
                "cdate": 1700667186183,
                "tmdate": 1700667186183,
                "mdate": 1700667186183,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "R9iz9PBTtx",
            "forum": "Q3YaCghZNt",
            "replyto": "Q3YaCghZNt",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission7652/Reviewer_YmWA"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission7652/Reviewer_YmWA"
            ],
            "content": {
                "summary": {
                    "value": "The paper describes a system for program verification that queries CHATGp4 for axioms.\nThe idea is interesting and the results excellent,  \nThe main problem of the paper is that it is written in a way that is much more suitable fior a CAV venue  than fior ICLR. The authors carefully and fomally describe the program  analysis framework, but they take a loose approach about GPt"
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "1 poor"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "The main strength of the paper are the results in Section 5\\\n\n."
                },
                "weaknesses": {
                    "value": "Presentation\n\nOnly good results are shown? How likely is the fail case? ChatGPT seems a magic box, Above al, the way you present your work makes it unnecessarily hard to understand ypur ideas."
                },
                "questions": {
                    "value": "A small point: there is another lemur system in LLMs\n\n\"An important research question is whether modern AI models are capable of understanding .\" .. indeed, but can you claim you do that?\n\nAre you the first to ask LLMs to propose sub-goals?\n\nI'd much prefer a better survey that would make your contributions clear, and a graphical descriotion of the system that would allow me to position the different componrrntd\n\nI understand the process is fully automated?\n\n \"  -Finally, if the verifier V proves that the original property is not an invariant\" -> is the verifier cmplete?\n\nArguabythe prompts are what makes everything else worthwhile. Yet, they are in appendix?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission7652/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission7652/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission7652/Reviewer_YmWA"
                    ]
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission7652/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698811593506,
            "cdate": 1698811593506,
            "tmdate": 1699636930558,
            "mdate": 1699636930558,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "KutO58XzIv",
                "forum": "Q3YaCghZNt",
                "replyto": "R9iz9PBTtx",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7652/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7652/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your comments!\n \n\n**Q: \"An important research question is whether modern AI models are capable of understanding .\" .. indeed, but can you claim you do that?**\n\nIt has been shown in [1] that LLMs have potential understanding programs. We take these ideas to a new level, showing that we can leverage this understanding to help state-of-the-art verification tools verify more C programs. So, we believe that we make a step toward showing AI understanding of realistic C programs.\n\n[1] Kexin Pei, David Bieber, Kensen Shi, Charles Sutton, and Pengcheng Yin. Can large language models reason about program invariants? ICML23\n\n\n**Q: Are you the first to ask LLMs to propose sub-goals?**\n\nYes, we are the first to propose this idea.  We outlined our contributions in Introduction, we will emphasize that we are the first to propose these techniques. \n\n**I'd much prefer a better survey that would make your contributions clear, and a graphical descriotion of the system that would allow me to position the different componrrntd**\n\nWe will include a table that compares learning-based augmented verification techniques in Appendix E.\n\n\n**Q: I understand the process is fully automated?**\n\nYes, that is correct. The process is fully automated. We will highlight this point in our contributions.\n\n\n**Q: \" -Finally, if the verifier V proves that the original property is not an invariant\" -> is the verifier complete?**\n\nAs discussed in the paper, V needs to be sound and we do not assume it is complete. For example, if the program deals only with bit-vectors, then the underlying procedure is complete. But if the program contains arrays, then the verification problem is undecidable and the verifier is incomplete.\n\n\n\n**>? Arguabythe prompts are what makes everything else worthwhile. Yet, they are in appendix?**\n\n For our framework, we have a small set of predefined template prompts that correspond to our rules, which is why they are included in the appendix. We kindly disagree with the reviewer that the prompts are key components in our framework. While we did put effort into designing these templates, the main component is the theoretically sound integration of LLMs with automated reasoners. If space permits, we are happy to move the prompt templates to the main text."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7652/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700516633621,
                "cdate": 1700516633621,
                "tmdate": 1700516633621,
                "mdate": 1700516633621,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "r1KgNecjeF",
            "forum": "Q3YaCghZNt",
            "replyto": "Q3YaCghZNt",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission7652/Reviewer_2ahy"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission7652/Reviewer_2ahy"
            ],
            "content": {
                "summary": {
                    "value": "This paper presents an interesting way to use LLMs and automated program verification tools synergistically to prove properties of programs that may otherwise be difficult to prove by the verification tools themselves.  The core idea consists of using an LLM to generate potential assumptions that may help an automated program verifier discharge the proof goal.  Once such assumptions are found, the effort of the program verification tool is directed to proving the assumptions themselves.  The authors present a set of sound rules to transform \"configurations\" of the proof process involving LLM calls and program verifier calls.  The authors also present some heuristics for LLM prompt generation, and for deciding how to prioritize multiples responses that may be provided by the LLM.  Finally, the authors present experimental results that show the promise of the proposed technique vis-a-vis state of the art program verification tools."
                },
                "soundness": {
                    "value": "4 excellent"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "The paper is clearly written, modulo some typos.  This helps in taking the reader along with the flow of the presentation.  The core ideas are illustrated with a running example -- this helped me follow the ideas without much difficulty. The idea of using an LLM to propose assumptions that can then be used to simplify a verification task is promising and the experiments demonstrate this.  Being able to out-perform the winning entries in SV-COMP is a significant achievement, and I believe this sufficiently demonstrates the promise of the approach."
                },
                "weaknesses": {
                    "value": "The set of rules formulated by the authors doesn't add much value to the paper.  Algorithm 1 could itself have been presented directly, with explanations for the different steps.  In my opinion, the rules are kind of a force-fit to the paper.\nIt is good that the authors try to show that the proof rules are sound; however the soundness proofs are simple and not very insightful.  Indeed, finding a sound set of rules for simplifying/decomposing program verification is often not the difficult part of the process.  The more technically challenging part is to have completeness results for some subclass of programs/properties.  Unfortunately, the authors don't even try to do this.\nSince there are practical limits to prompt lengths for an LLM like GPT or GPT-4, this sets limits to how large a program can be verified using the proposed technique.  This is highly undesirable.  It would have been better if the authors attempted decomposition of the problem (perhaps guided by an LLM) and then applied the proposed technique to each decomposed part, and then stitched the results back together.  Unfortunately, the authors completely avoid any such attempt/discussion.\nSV-COMP has several tracks for verification.  The total count of programs in SV-COMP is significantly larger than that reported by the authors. It is not clear whether some cherry-picking was done in selecting the examples.\nAn LLM like GPT-4 makes use of immense computational power at the server end to come up with proposals/suggestions quickly.  It is not fair to discount this computational effort completely when comparing with the performance of other solvers that do not make LLM calls.  As a consequence, I believe the time comparison is not fair.\nA method like the one proposed, without any considerations of how the LLM is trained, may give dramatically different results based on what LLM is being used.  Therefore, a discussion on training the LLM should have been included."
                },
                "questions": {
                    "value": "1.  What actual value does the set of rules provide to this work?  Wouldn't it have sufficed to have Algorithm 1 directly, along with an explanation of the steps?\n2.  SV-COMP contains many, many more benchmarks.  How does LEMUR compare with UAutomizer or other tools on the other benchmarks?  Why are so few benchmarks chosen for comparison?\n3.  For what kinds of <program, property> combinations do LLMs fare badly as far as suggesting assumptions is concerned?  In some sense, this ought to depend on what kinds of data it has been trained on.   I didn't see any discussion in this regard -- I would tend to think that there are <program, property> combinations for which LLMs will have a very difficult time generating good assumptions.\n4. An LLM like GPT-4 makes use of immense computational power at the server end to come up with proposals/suggestions fast.  How do you propose to factor this in your comparisons for an apples-to-apples comparison.  Neither ESBMC not UAutomizer were provided access to such computational power; so how is the comparison fair?\n5. What are the assumptions on the training of the LLM that are being used?  Will the proposed method work with one's privately trained LLM?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "details_of_ethics_concerns": {
                    "value": "No ethics concerns"
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission7652/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission7652/Reviewer_2ahy",
                        "ICLR.cc/2024/Conference/Submission7652/Senior_Area_Chairs"
                    ]
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission7652/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699280941786,
            "cdate": 1699280941786,
            "tmdate": 1700717732836,
            "mdate": 1700717732836,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "d301pXInKs",
                "forum": "Q3YaCghZNt",
                "replyto": "r1KgNecjeF",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7652/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7652/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your comments and suggestions!\n\n\n**Q: What actual value does the set of rules provide to this work? Wouldn't it have sufficed to have Algorithm 1 directly, along with an explanation of the steps?**\n\nOur derivation rules define an underlying proof calculus, while Algorithm 1 represents one of many possible strategies for applying these rules. We believe that the proof system is significant, as it formally defines the interaction between the verifier and oracles in a sound and modular way. Note that we designed the rules to have a *clear separation of responsibility between two powerful technologies* to take the best of both worlds. We also have introduced the notion of *stability* and a rule that leverages this new concept. We believe that we are the first to propose such formalization, which can be built upon in the future.\n\n\n**Q: Scalability of verification**\n\n\nAs we mentioned in the \"Discussion of Limitations\" section, our approach currently works with smaller programs (<= 150 tokens after removing comments, unnecessary headers, and clang-formatting), and a decomposition approach might be good for scaling to larger programs, as the reviewer also suggested. \n\nDecomposing a large program into smaller pieces for verification purposes is known to be challenging. Using LLM to perform this task requires the representation of the program in some compact form, a specification language for pre-/post- conditions, and an efficient verification procedure to validate the correctness of those conditions. \n\n\n**Q: SV-COMP contains many, many more benchmarks. How does LEMUR compare with UAutomizer or other tools on the other benchmarks? Why are so few benchmarks chosen for comparison?**\n\nWe call UAutomizer/ESBMC first, before augmenting a verifier with GPT-based generated invariants. Hence, in theory, we can solve at least as many instances as UAutomizer can, provided there is an appropriate timeout for the initial call (Algorithm 1, line 5). \n\nHowever, our main goal was to demonstrate that GPT can aid UAutomizer/ESBMC in solving problems that *neither of these solvers can solve independently*. We selected 50 smaller benchmarks from reachability track that these tools cannot solve and demonstrated that GPT aid can help with 26 of these challenging benchmarks. We find it impressive that LLMs help to solve these benchmarks, even if we could only solve about half of them.\n\n\n**Q:  For what kinds of <program, property> combinations do LLMs fare badly as far as suggesting assumptions is concerned? In some sense, this ought to depend on what kinds of data it has been trained on. I didn't see any discussion in this regard -- I would tend to think that there are <program, property> combinations for which LLMs will have a very difficult time generating good assumptions.**\n\nAs shown in the experiment, there were 24 out of the 50 challenging benchmarks that we could not solve. Upon closer examination, we observed that it is challenging to 1)  generate complex invariants involving if-then-else logic; 2) generate invariants where a program contains multiple loops. We will expand the discussion of limitations section in the paper to clarify this point.\n\n    \n**Q:  An LLM like GPT-4 makes use of immense computational power at the server end to come up with proposals/suggestions fast. How do you propose to factor this in your comparisons for an apples-to-apples comparison. Neither ESBMC not UAutomizer were provided access to such computational power; so how is the comparison fair?**\n\n*We do not see our work as a competitor to modern program verifiers. Our goal is to explore whether LLM can help these tools perform better.*\n\n*Moreover, we point out that most existing verifiers (e.g., ESBMC and UAutomizer) are not designed to leverage immense computational power like GPUs or cloud computing, and our approach provides such means to empower the verifiers.*\n\n\n**Q:  What are the assumptions on the training of the LLM that are being used? Will the proposed method work with one's privately trained LLM?**\n\nWe used OpenAI GPT-4 API service (we will also add new results for the OpenAI GPT-3.5 turbo).  Unfortunately, exact training data is not known for GPT4. It might be the case that SV-COMP benchmarks were part of the training set but invariants are not available publically as far as we know."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7652/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700516786862,
                "cdate": 1700516786862,
                "tmdate": 1700523833874,
                "mdate": 1700523833874,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "0WnsamHB0Q",
                "forum": "Q3YaCghZNt",
                "replyto": "d301pXInKs",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7652/Reviewer_2ahy"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7652/Reviewer_2ahy"
                ],
                "content": {
                    "title": {
                        "value": "Thanks for the response"
                    },
                    "comment": {
                        "value": "Thanks to the authors for responding to my questions. Unfortunately, some crucial questions (for me) remain unsatisfactorily answered.\n\nThe answer to the question about the actual value of set of rules is unsatisfactory, in my opinion.  Proving soundness of the algorithm wouldn't have been hard even without the rules.  The real value of the system of rules would have been to help prove some kind of relative completeness result.  Unfortunately, the authors don't do this.\n\nThe authors mention that they do not see their work as a competitor to modern program verifiers.  And yet, they compare the number of cases solved by their tool (which uses a GPT with unspecified computing power) with state-of-the-art verifiers *within a given limit of computational power* (all SV-COMP participants are given only limited computational power).  I don't see how this is an apples-to-apples comparison. Can the authors really assert that UAutomizer or ESBMC would not be able to solve the problems on which the authors demonstrate their strengths, if UAutomizer/ESBMC had access to additional computing resources?  Sans this, how do we really know whether use of LLMs is the best way to go about spending additional compute power for verification.  The $1000 that the authors spent on GPT-4 would have given enough computing power on AWS or Google Cloud, for UAutomizer/ESBMC to crank for sufficiently longer (and perhaps solve all the problems).  I really don't see why we must try to force fit LLMs into verifiers if they don't present a cost-effective solution."
                    }
                },
                "number": 12,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7652/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700660266497,
                "cdate": 1700660266497,
                "tmdate": 1700660266497,
                "mdate": 1700660266497,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "g3wO0gYU8h",
                "forum": "Q3YaCghZNt",
                "replyto": "r1KgNecjeF",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7652/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7652/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your comments!\n\n**Q: Completeness of calculus rules**\n\n*We strongly disagree that the value of abstract calculus is only the proof of completeness*. \n\nMany highly impactful abstract calculus in SMT (e.g., notably Model-Constructing Satisfiability Calculus [1])  do not attempt to establish completeness results. In the context of formal methods, abstract calculus has the following benefits:\n* A separation between the implementation and the theory,\n* Highlighting the key features of the procedure in a modular manner,\n* Providing formalized grounds for future extension.\n\n[1] A Model-Constructing Satisfiability Calculus,  Leonardo de Moura & Dejan Jovanovi\u0107 \n https://link.springer.com/chapter/10.1007/978-3-642-35873-9_1\n\n\nWould the review agree that our calculus serves these purposes?\n\n\n**Q: Running program verification performance on a cloud/more resources**\n\nWe are not aware of any reported significant performance gains in software verification tasks with parallelization. In fact, a very recent paper shows that achieving parallelization of SMT solvers \u2014 the underlying solvers for both UAutomizer and ESBMC \u2014 is not trivial. For example, using 64 cores resulted in less than 2 times speed-up [2].  We therefore do not expect that allocating more computational resources to the verifier will significantly improve the number of instances solved within the given time bound.\n\n[2] Partitioning Strategies for Distributed SMT Solving\nAmalee Wilson, Andres Noetzli, Andrew Reynolds, Byron Cook, Cesare Tinelli, and Clark Barrett,\nFMCAD'23"
                    }
                },
                "number": 15,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7652/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700698130920,
                "cdate": 1700698130920,
                "tmdate": 1700698167836,
                "mdate": 1700698167836,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "aLGX4UBQ1M",
                "forum": "Q3YaCghZNt",
                "replyto": "g3wO0gYU8h",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7652/Reviewer_2ahy"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7652/Reviewer_2ahy"
                ],
                "content": {
                    "title": {
                        "value": "Response to authors"
                    },
                    "comment": {
                        "value": "I thank the authors for their response.\n\nI believe my comment about abstract rules has been mis-interpreted.  Let me clarify.  I am well aware of the value of formalization of abstract rules for various algorithms in the area of formal methods.  It would be unfair to interpret my comment as saying that the only value of abstract rules *in any context* is in proving completeness.  My comment was in the specific context of Lemur.  The algorithm presented by the authors can be proved sound without reference to the rules, in my opinion.  So, proving soundness of the algorithm is not a strong value addition (if at all) of the rules.  I agree that abstraction of steps allows scope for further generalizations in an elegant way.  A sterling example of this is [1], where Simplex was generalized to Reluplex.   The paper on model-constructing satisfiability calculus for SMT theories that the authors point out achieves a whole bunch of objectives through the abstract rules: it presents a unifying framework for a large collection of model-based SMT decision procedures, allows DPLL(T) and the nlsat proof calculus to be combined, and also allows a simpler correctness proof than nlsat.  I don't see any such value additions of the Lemur proof calculus beyond the correctness proof of the Lemur algorithm, and even there I don't see any simplifications that are obtained by the rule abstraction.  I agree that the rules in the case of Lemur provide modular highlighting of features of the algorithm.  However, I disagree that in the specific case of Lemur, the rules provide a significant separation between theory and implementation, beyond what the steps of the algorithm already provide.  This is why I had commented that a potential value addition of the set of rules *in the specific case of Lemur* could have been a step towards proving completeness.  To interpret this as saying that the only value of rule formalization *in all cases* is to prove completeness is completely taking my comment out of context.\n\n[1] \"Reluplex: An Efficient SMT Solver for Verifying Deep Neural Networks\",  Guy Katz, Clark Barrett, David L. Dill, Kyle Julian & Mykel J. Kochenderfer, CAV 2017\n\nRegarding the comment about use of parallelization, I wasn't referring only to parallelization.  If we are willing to spend more resources on computing, we might as well use the additional resources to run a tool for longer duration or with more memory than the limits imposed by SV-COMP.  Are the authors saying that this doesn't help in improving the tally of verification results?  This reviewer has to respectfully disagree, based on first-hand experience.  In fact, the paper pointed to by the authors already shows improvement, though not as much as a nicely parallelizable task would show.  This just shows that parallelization is difficult, though it does provide improvements.  Even if we go by the parallelization results pointed to by the authors, wouldn't a better comparison be to see how ESBMC or UAutomizer fares with the same $ budget used for GPT calls (as in Lemur) and for additional cores on a cloud platform? Unless we take the cost-benefit analysis of this into account, it may be a bit premature to assert that Lemur helps improve existing tools.  \n\nHaving said all of the above, I agree that the paper presents some interesting research directions.  I hope the authors take my comments in a constructive manner.  I believe this work would be much stronger (and would address some important research questions) if some of the concerns raised above are attended to, and if a fairer comparison taking into account the cost of LLM calls is presented."
                    }
                },
                "number": 16,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7652/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700717678357,
                "cdate": 1700717678357,
                "tmdate": 1700717678357,
                "mdate": 1700717678357,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]