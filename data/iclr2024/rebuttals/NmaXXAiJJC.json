[
    {
        "title": "COMPRESSION AND ACCELERATION OF DEEP NEURAL NETWORKS: A VECTOR QUANTIZATION APPROACH"
    },
    {
        "review": {
            "id": "smpDFboB3g",
            "forum": "NmaXXAiJJC",
            "replyto": "NmaXXAiJJC",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4105/Reviewer_hXiT"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4105/Reviewer_hXiT"
            ],
            "content": {
                "summary": {
                    "value": "The paper introduces a vector quantization technique that involves partitioning the weight matrix into several segments and constructing a global codebook. This approach quantizes the weights into many segmented vectors based on the global codebook. The authors claim that this method can significantly reduce the storage requirements of the model, as the weights only need few bits to store the codebook indices. Additionally, it can substantially decrease the computational operations of the model."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "Applying the global codebook and segmented vector quantization can significantly compress the model size."
                },
                "weaknesses": {
                    "value": "The content of this paper is not sufficiently clear and complete. Many aspects are either missing or are ambiguously addressed. For instance, the paper lacks details on how to handle activation values, how to quantize weights into segmented vectors, how to update quantized weights and codebooks, and how to perform matrix multiplications and convolutions on quantized weights and activation values. These critical aspects are left unaddressed. \nIn terms of the paper's novelty and motivation, the primary source of confusion lies in the paper's failure to clarify what problem in quantization or vector quantization it aims to address or improve. This paper claims to apply a global codebook to the entire model, as opposed to layer-wise application as did in previous studies, which theoretically could improve compression rates but might significantly impact model accuracy. However, the authors do not discuss this issue in the paper. Lastly, regarding the compression of operation counts, the method utilizing codebooks and indices primarily offers theoretical compression, and practical acceleration is challenging to achieve. This issue should be argued in the paper."
                },
                "questions": {
                    "value": "1\u3001How are activation values quantized?\n\n2. The paper employs a global codebook for the entire model instead of using one per layer. Does this affect accuracy?\n\n3. In the experimental results, the reported FLOPS and Params values are purely theoretical, correct? Can you discuss the practical acceleration or its applicability? Additionally, how was the base accuracy determined? Is the primary metric accuracy or accuracy reduction? Why is accuracy reduction considered more effective?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4105/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698548357607,
            "cdate": 1698548357607,
            "tmdate": 1699636375432,
            "mdate": 1699636375432,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "bYRZ8vxqcZ",
                "forum": "NmaXXAiJJC",
                "replyto": "smpDFboB3g",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4105/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4105/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for providing valuable feedback on our paper. We appreciate your thoughtful comments. It appears that some of the confusion may arise from the terminology used in our method, namely \"vector quantization,\" which, despite containing the term \"quantization,\" does not align with traditional low-precision encoding techniques commonly associated with quantization. we chose to adhere to the established concept of \"vector quantization\" in the data compression and deep learning literature and we didn't coin a new term.\n\nAs explicitly stated in our paper, our approach involves the vector quantization of weight parameters exclusively. We want to emphasize that we do not extend this quantization to activations. Our study demonstrates that employing a compact codebook for the entire model yields acceptable accuracy, and any reduction in accuracy is not deemed significant. Importantly, this reduction in accuracy is accompanied by a considerable decrease in both floating-point operations (FLOPs) and memory usage, as substantiated in our theoretical analysis.\n\nRegarding the practical speed-up, we would like to draw your attention to our response to question 1 from reviewer 1, where we delve into the specifics of achieving practical acceleration with our proposed method. We acknowledge the importance of discussing the practical implications.\n\nWe genuinely value your input and believe that these clarifications will contribute to a more coherent and comprehensive presentation of our work. If our paper is accepted, we are committed to incorporating these refinements to enhance the overall clarity and understanding of our method.\n\nHere are the responses to the questions:\n\n1: In the context of this paper, it's important to note that activation values remain in their full precision without quantization. The quantization specifically applies to the weight parameters of the model, which undergo vector quantization. This means that these weights are constrained to discrete values defined by the codebook. To enhance clarity, if our paper is accepted, we intend to provide a more detailed clarification regarding the differentiation between weight parameters and activations in terms of quantization.\n\n2: In our experiments, detailed in Appendix A.5 using the VGG model, we investigated the impact of employing either four codebooks or a single global codebook. Interestingly, we observed only a marginal difference in performance. Given this, we chose to emphasize the more extreme scenario of employing a single global codebook, which achieves the highest compression rate. We plan to provide additional clarification on this choice in the main body of the paper, should it be accepted.\n\n3: In addressing the question regarding FLOPs and Params values in our experimental results, it's crucial to note that these values, as well as those in the cited papers, are primarily theoretical. Achieving real acceleration demands either hardware implementation or alternative methods such as implementing CUDA modules. We provide a more comprehensive response to this concern in our reply to the first reviewer's initial questions. This discussion will be clarified in the final paper if accepted.\n\nThe determination of base accuracy varies depending on the method employed. For post-training approaches applied to pre-trained models, the base accuracy represents the model's accuracy before pruning. As we lack control over external methods, we report the specifics of their procedures. For instance, the base ResNet50/ImageNet model in PScratch (Wang et al., 2020b) exhibited an accuracy of 77.20%, while SG-CNN (Guo et al., 2020) had 76.13%. In the case of methods like our VQ method, which involves training a model from scratch, we ensure consistency by training two models\u2014one non-VQ as a baseline and one VQ model\u2014using identical hyperparameters (epochs, batch size, data augmentations, etc.).\n\nThe emphasis on accuracy reduction over absolute accuracy stems from the inherent variability in base accuracies across methods. Given constraints such as training ResNet50/Imagenet for 90 epochs with a batch size of 256 (refer to Appendix A.1 for details), our baseline accuracy is naturally lower than approaches utilizing well-trained public models. Consequently, we believe assessing the degree of accuracy degradation provides a fairer comparison, considering the varied starting points of different methods, rather than fixating on absolute accuracy figures."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4105/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1699902662931,
                "cdate": 1699902662931,
                "tmdate": 1699902662931,
                "mdate": 1699902662931,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "VwFHv3ZyOW",
            "forum": "NmaXXAiJJC",
            "replyto": "NmaXXAiJJC",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4105/Reviewer_JeiW"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4105/Reviewer_JeiW"
            ],
            "content": {
                "summary": {
                    "value": "This paper suggests using vector quantization for compressing the weights of convolutional layers in Convolutional Neural Networks (CNNs) and attention/Multilayer Perceptron (MLP) layers in Vision Transformers (ViTs). The weights are associated with learned codebooks. During the inference stage, computations occur between the features and the codebooks, which can significantly reduce parameters and Floating Point Operations Per Second (FLOPs). Experiments provide a comparison with the state-of-the-art."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "This work utilizes vector quantization to compress DNNs, it is good to consider both CNNs and ViTs in the experiments."
                },
                "weaknesses": {
                    "value": "1. The figures in this paper are really vague. In Figure 1, it is better to mark the size of the weight matrices and demonstrate which layers in which model are utilized to do the visualization.\n2. Experimental results are listed without any highlight, which is very unclear.\n3. The idea of adopting VQ in compressing DNNs is not new, so more effort could be made including giving the guidelines for designing the hyperparameters such as the group numbers."
                },
                "questions": {
                    "value": "1. It appears that the authors directly use the computation results from another VQ paper to determine the reduction in FLOPs. Is this method accurate for DNN compression? A related question is, given that the input and intermediate features in DNNs vary and are not predetermined, how are the lookup tables obtained in this context?\n2. Besides #parameters and FLOPs, how about the inference time? Could VQ accelerate DNN inference?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4105/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698836470260,
            "cdate": 1698836470260,
            "tmdate": 1699636375349,
            "mdate": 1699636375349,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "IyK4YetiyC",
                "forum": "NmaXXAiJJC",
                "replyto": "VwFHv3ZyOW",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4105/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4105/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Here are our brief responses to the reviewer's comments: \n\nWeaknesses \n\n\n1:\nThank you for highlighting this issue. In our revised draft, we have made significant enhancements to Figure 1 to provide a more lucid representation of the Vector Quantization concept. We've taken care to align the figure closely with the notations employed in the paper, ensuring a clearer depiction of the size of matrices. These adjustments aim to eliminate any ambiguity and enhance the overall comprehensibility of the figure.\n\n2:\nThank you for bringing this to our attention. We have addressed the clarity concern by incorporating highlights in the tables in our revised draft. This adjustment aims to improve the visual distinction of experimental results, making it easier for readers to interpret and understand the presented data.\n\n3:\nOur sincere thanks for your comment. While it's acknowledged that clustering weights for DNN compression isn't a novel idea, our paper uniquely contributes by being the first, to the best of our knowledge, to directly apply Vector Quantization (VQ) to neural network weights. This distinction is crucial as it pioneers a new application of VQ in the context of weight compression. Our approach introduces two key contributions: firstly, demonstrating the effectiveness of a single compact codebook in encoding layers of large architectures, exemplified by ResNet-50; and secondly, emphasizing the efficiency gains in computation through the use of a small, single codebook. This innovation allows for streamlined operations, multiplying the entire codebook by inputs in each layer, thereby circumventing redundant calculations. We acknowledge the existing work in weight clustering and stress that our unique application of VQ to network weights sets our approach apart, offering a fresh perspective and valuable contributions to the field.\n\nQuestions: \n\n\n1:\nThank you for your thoughtful inquiry. While our FLOP computation isn't directly borrowed from another paper, we have adhered to established practices in the literature for consistency. In Section 3.4, we provide a detailed explanation of our FLOP calculation methodology.\n\nConcerning lookup tables, it's important to note that these are determined on a per-layer basis. Unlike the global nature of the codebook, which remains consistent across layers, the lookup matrix is computed uniquely for each layer. This approach is necessary due to the varying nature of input and intermediate features in different layers of DNNs.\n\nDuring inference, at each layer, the input undergoes multiplication with the codebook, resulting in the creation of the lookup table. Once the layer's output is generated, the corresponding lookup table becomes obsolete and is discarded. This process is repeated at every layer. In the event of acceptance, we plan to provide further clarification on this process in the paper to ensure a comprehensive understanding of the lookup table generation.\n\n2:\nThank you for your inquiry regarding the inference time. If by \"inference time\" you are referring to the \"inference phase,\" then our response is as follows: The FLOPs computation in the paper specifically pertains to the inference time, demonstrating that Vector Quantization (VQ) does indeed accelerate Deep Neural Networks (DNNs) during this phase.\n\nIt's crucial to note a distinction between training and inference. During training, the original weight matrix remains in place, and the forward pass temporarily replaces weight parameters with the closest ones in the codebook. This process is dynamic during training, leading to a slightly slower training speed compared to inference. However, this is not a concern for the inference time, where the model weights are fixed, and a pre-computed index to the closest codebook is applied only once.\n\nWhile the FLOPs presented in the paper are specifically for the inference time, it's important to acknowledge that training involves a dynamic mapping process, which can't be pre-computed. No prior literature has reported the computation overhead during training or post-training for their approaches, making a direct comparison challenging. If the paper is accepted, we are committed to providing additional clarification on this process.\n\nIf by \"inference time,\" you are referring to the actual time spent on inference, please refer to our response to the first question from reviewer 1 for more details."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4105/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1699900989396,
                "cdate": 1699900989396,
                "tmdate": 1699900989396,
                "mdate": 1699900989396,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "OzpX9pZWir",
            "forum": "NmaXXAiJJC",
            "replyto": "NmaXXAiJJC",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4105/Reviewer_Be5z"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4105/Reviewer_Be5z"
            ],
            "content": {
                "summary": {
                    "value": "This work proposed a novel idea of applying vector quantization to the weights of deep neural networks. Vector quantization means a weight tensor in neural networks can be represented as the combination of multiple vectors, and the pattern types of the vectors are finite. Similar to network pruning and network quantization, Conducting vector quantization for a neural network is favorable for saving memory occupancy and potentially accelerating inference."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. The idea of conducting vector quantization on weights of neural networks is of novelty. \n2. The proposed training algorithm to form vector-quantized neural networks is simple yet effective"
                },
                "weaknesses": {
                    "value": "1. The conclusion regarding the speed-up performance is not convincing. There is no practical speed-up results presented in the work and the reported FLOPs reduction is only calculated theoretically. Moreover, traditional dense matrix multiplication has been highly optimized in recent years on modern GPUs, e.g., cuDNN. Whether or not a network with vector quantization infers faster than its dense counterparts on modern GPUs remains uncertain. Thus, the lack of inferring time and practical speedup results does not adequately justify their work.\n\n2. Some aspects of the VQ-DNN illustration require further clarification. For instance, the specific process of updating W_jb and e in equation (1) needs to be clarified. Are they updated alternately? Additionally, the method of mapping weights to the codebook is not clear. Does the mapping change during training? It is necessary to provide more detailed explanations for these concerns.\n\n3. The experimental section is confusing probably due to the unclear selection of compared methods. The related work section does not introduce the compared methods in Table 3, 5, and 6, making it difficult to understand the state of the arts. Furthermore, the authors introduce four categories of model compression in the related work section, such as pruning, and quantization, but they do not present the performance comparison between them and the proposed methods.\n\n4. The experimental setup could be improved. ResNet50 is not reasonable for being used on CIFAR10 since it is too large and prone to overfitting, potentially making the experimental results noisy. Additionally, all experiments are focused on classification. The proposed method should be extended to other tasks to provide more generalized results.\n\n5. The quality of figures and tables should be improved. For example, the quality of Figure 2 is poor, which makes it difficult to capture useful information. Similarly, the proposed method's key results in the tables should be highlighted for better readability."
                },
                "questions": {
                    "value": "Please see the weaknesses for revision."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission4105/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission4105/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission4105/Reviewer_Be5z"
                    ]
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4105/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699447073214,
            "cdate": 1699447073214,
            "tmdate": 1699636375257,
            "mdate": 1699636375257,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "AXYxJVkvoN",
                "forum": "NmaXXAiJJC",
                "replyto": "OzpX9pZWir",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4105/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4105/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Here are our brief responses to the reviewer's comments:\n\n1:\nWe appreciate the reviewer's feedback on the lack of practical validation in the paper. We want to clarify that our decision to focus on theoretical aspects is intentional and aligns with the specific scope defined for this study. While we acknowledge the importance of empirical evidence, we deliberately leave the exploration of practical implementation and performance to future research. The theoretical analysis presented here serves as a foundation for potential follow-up studies aimed at empirically validating and optimizing our approach.\n\nWe recognize the optimization of traditional dense matrix multiplication on modern GPUs, such as cuDNN. However, we believe that our emphasis on theoretical foundations is a roadmap for future optimizations.\n\nIt's important to note that our approach is not unique in this aspect; many SOTA papers in the literature report FLOPs without immediate practical validation (Li et al., 2016; He et al., 2019; Zhang et al., 2022; Lin et al., 2020a; Park et al., 2023; Liu et al., 2018; Wang et al., 2020b; Guo et al., 2020; Zhao & Luk, 2019; Tang et al., 2020; Zhu et al., 2021; Yu et al., 2022; Chen et al., 2021).\n\nImplementing custom Cuda modules may be possible, but a fair comparison would require similar efforts for all previous works, surpassing our current resources. To the best of our knowledge, no previous papers in this domain have implemented Cuda modules or hardware versions of their methods, and this challenge has been acknowledged by reviewers in the field, as exemplified in the discussion regarding \"TMI-GKP: Revisit Kernel Pruning with Lottery Regulated Grouped Convolutions\" (available at https://github.com/henryzhongsc/lottery_regulated_grouped_kernel_pruning#discussion-regarding-inference-speedup), which was accepted at ICLR 2022 without further implementation.\n\n2:\nWhile we commit to providing more detailed explanations in a revised version if the paper is accepted, we offer the following insights for the current discussion:\n\nIn eq(1), the update operations for W_jb and e are indeed distinct and are performed simultaneously at the end of each batch. This simultaneous update is facilitated by the use of stop-gradient operators, as described in the original paper by Van Den Oord et al. (2017).\n\nConcerning the mapping of weights to the codebook, it is essential to note that this mapping evolves during training. Specifically, the weight stored in the original model (W_jb) undergoes a comparison with the entire codebook and is subsequently replaced with the nearest codeword. This process essentially treats the original weight as an index. As training progresses, these weights undergo updates, causing the mapping to change dynamically.\n\n3:\nIn our related work section, we aimed for comprehensiveness by covering all categories of model compression found in the literature. Certain methods, such as knowledge distillation or matrix decomposition approaches, have not been included as their popularity is declining due to the superior performance of pruning methods.\n\nAlthough our method bears the name \"vector quantization,\" it is distinct from the more prevalent category of low-precision parameter methods or traditional quantization. The terminology may introduce some confusion, but we chose to adhere to the established concept of \"vector quantization\" in the data compression and deep learning literature. Traditional quantization approaches often measure metrics, such as energy consumption (Hubara et al., 2016), or actual latency (Jacob et al., 2018; Lee & Nirjon, 2019), which may not be directly comparable to our method or other pruning methods. Notably, SOTA pruning methods typically compare their performance exclusively with other pruning methods in the literature, given the intrinsic differences in evaluation metrics.\n\nIn the event of acceptance, we are committed to refining the related work section to explicitly cover the papers with which we compare our approach, providing a more comprehensive and coherent understanding of the state-of-the-art landscape in model compression.\n\n4:\nOur choice of experimental configuration aligns with prevalent practices in the literature, where SOTA papers commonly focus on CIFAR and ImageNet classification tasks, using VGG and ResNet for evaluation (Zhang et al., 2022; Park et al., 2023; He et al., 2019; Wang et al., 2020b). While there are exceptions (Lin et al., 2020a; Tang et al., 2020), the majority of ViT pruning studies adhere to the standard practice of evaluating on ImageNet (Zhu et al., 2021; Tang et al., 2022; Yu et al., 2022; Chen et al., 2021). We conducted experiments on both CNN and ViT types for a comprehensive evaluation.\n\nWe also have results for ResNet-18 in the paper. Even though CIFAR10 is associated with smaller models, we aimed at demonstrating the proposed method's versatility across different architectures.\n\n5:\nWe will improve the quality of tables and figures."
                    }
                },
                "number": 1,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4105/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1699899759686,
                "cdate": 1699899759686,
                "tmdate": 1699902875527,
                "mdate": 1699902875527,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]