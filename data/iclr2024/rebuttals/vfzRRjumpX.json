[
    {
        "title": "CODE REPRESENTATION LEARNING AT SCALE"
    },
    {
        "review": {
            "id": "hAyTXmty46",
            "forum": "vfzRRjumpX",
            "replyto": "vfzRRjumpX",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission3746/Reviewer_n8qP"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission3746/Reviewer_n8qP"
            ],
            "content": {
                "summary": {
                    "value": "This paper introduces a novel two-step pretraining methodology for encoder-only code language models (LMs). The approach starts with masked language modeling (MLM) and follows up with contrastive learning to foster robust code representations that can be effectively employed in downstream tasks such as retrieval or classification. The resulting model consistently outshines existing baselines across various downstream tasks, including notable ones from the widely recognized CodeXGLUE benchmark. Furthermore, comprehensive ablation studies are conducted to dissect and understand the individual contributions of each component within the proposed framework."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1. Code representation learning is a significant and often overlooked aspect of this domain.\n\n2. The evaluation methodology used in this study is solid, showing the proposed method's efficacy through extensive experiments on various downstream tasks from the well-established CodeXGLUE benchmark. Notably, the method exhibits remarkable performance, substantially outperforming established baselines such as CodeT5 and StarEncoder.\n\n3. The inclusion of detailed ablation studies is a strong point of the paper, shedding light on the impact and effectiveness of each component within the proposed method. The insights gleaned from these analyses, especially concerning the methodologies used for contrastive learning, are indeed meaningful."
                },
                "weaknesses": {
                    "value": "1. The naming convention for the model configurations is somewhat confusing. For instance, \"CodeSage-Small\" (6 layers, 1024 dim, and 130M params) is roughly equivalent to BERT-Base (12 layers, 768 dim, 110M params) in terms of its parameters, while \"CodeSage-**Base**\" is on par with BERT-**Large** (24 layers, 1024 dim, 330M params). This inconsistency could potentially lead to confusion when making comparisons.\n\n2. The LaTeX typesetting requires significant improvement, as there are inconsistencies in font styles and sizes throughout the paper, notably in Section 4, Figures 2(a) and 6, and Appendix A.5. Additionally, the small text in Figure 4(b) is difficult to read without zooming in, and there are redundant references for CodeBERT and CodeXGLUE.\n\n3. The paper's title, \"Code Representation Learning at Scale,\" is rather broad and lacks specificity.\n\n4. The evaluation could be more comprehensive by including additional tasks, such as POJ104 from the CodeXGLUE benchmark, which is relevant but absent from the current evaluation.\n\n5. The baselines utilized for comparison are generally smaller than the proposed model. It would be beneficial to include larger baselines, such as CodeT5+ (16B) and CodeLLaMa (34B), for a more balanced comparison."
                },
                "questions": {
                    "value": "1. Is there a reason why some tasks from the CodeXGLUE benchmark, like POJ104, were excluded from the evaluation?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission3746/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698559635535,
            "cdate": 1698559635535,
            "tmdate": 1699636330785,
            "mdate": 1699636330785,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "F3SQFnkFfX",
                "forum": "vfzRRjumpX",
                "replyto": "hAyTXmty46",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission3746/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission3746/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer n8qP"
                    },
                    "comment": {
                        "value": "Thank you for acknowledging the novelty and impact of our work, especially our efforts on diving deep into the key ingredients for code representation learning. We are also grateful for your constructive suggestions on additional benchmarks and baselines, and we have carefully addressed them in our general response (2/2) above. To complement the discussion, we also summarize our initial motivations for experiment design in our general response (1/2).\n\n**Naming Convention**\nIt was a hard decision for us. On the one hand, we did want to follow the BERT convention, while we also noticed the recent trend to name the 1B model as the Large model on the [MTEB Leaderboard](https://huggingface.co/spaces/mteb/leaderboard).  However, we are seriously considering your question and trying to find a sweet spot between our current names and CodeSage-Base, CodeSage-Large, and CodeSage-XLarge. \n\n**Latex Typesetting and Paper Title**\nWe will improve the formatting as you suggested. We also want to talk about our motivations for the current paper title.\n\n1. Our work is among the first (in addition to StarCoder, to the best of our knowledge) to train the encoder-based embedding model at a large scale of pretraining data and increased model size. We limit our model size to 1B to balance performance and inference cost in many practical settings, e.g., building a retrieval system over billions of examples.\n2. More can be different. As reported in Figure 3b of our paper, the dropout-based contrastive learning does not work well with large-scale pretraining data, though it works for UnixCoder and SimCSE, where less than 3M examples are used for training.\n3. We indeed hope our work can motivate more researchers to keep pushing the frontiers of code embedding models by advancing the pretraining strategy on a large scale of data, as what has been doing for text embeddings ([MTEB](https://huggingface.co/spaces/mteb/leaderboard)).\n\nWe are looking forward to hearing your thoughts and would appreciate it if you have better suggestions. \n\n**The Baseline Models Are Smaller**\nOne of our goals is to study if larger models would be effective for code representation learning since such models are missing in the literature. Therefore, we urge not to consider that as a weakness of this work.  On the other hand, larger decoders are often not primarily trained to serve retrieval or code understanding works. Those models often yield poor performance in our preliminary evaluations, and we exclude them from comparison as we think it\u2019s unfair to compare with them. However, we appreciate your question, which makes us realize that including these baselines would have made our paper more complete. We summarized the evaluation of CodeGen2.5 (7B), Starcoder (15.5B), and CodeT5+ (16B) in Tables (1a)&(1b) in our general response (2/2) above.\n\n**Evaluation on Clone Detection**\nWe did evaluate BigCloneBenchmark at the beginning of this project. However, we found the task very easy but inefficient to evaluate due to the large data size. Hence, we excluded it and focused on more challenging ones. Presumably, given that CodeSage shows strong performances over previous SOTA models on our chosen tasks across many languages, it will perform on par if not able to largely outperform the baselines. Instead, we dived deep and performed analysis to show the reasons behind the effectiveness of CodeSage (e.g., the effectiveness of MLM/DOBF and CL, performance with scaling), which can drive future research works.\n\nBut we are grateful for the suggestion, which motivates us to improve our paper's completeness and overall quality. We summarized our evaluation results on both POJ-104 and BigCloneBenchmark in Table 3 in our general response (2/2) above, where CodeSage-small performs slightly better than UniXCoder. \n\nWe sincerely thank you for the constructive feedback. We have taken your comments into serious consideration. We provided the evaluation results in our general response (2/2) accordingly, which we will also use for the next update of our paper to address your questions comprehensively. Let us know if you have any other comments."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission3746/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700237923840,
                "cdate": 1700237923840,
                "tmdate": 1700255026050,
                "mdate": 1700255026050,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "XBD9elRVgp",
            "forum": "vfzRRjumpX",
            "replyto": "vfzRRjumpX",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission3746/Reviewer_RZCJ"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission3746/Reviewer_RZCJ"
            ],
            "content": {
                "summary": {
                    "value": "The paper considers the problem of learning better representations of code. The authors propose a model called CodeSage which is based on the Transformer architecture trained on a large corpus of code (The Stack) with various techniques such as masked language modeling, deobfuscation pre-training, and bimodal contrastive learning with hard negative and hard positive examples. \n\nThe authors showed that the learned representations can be used for various downstream tasks such as zero-shot code-to-code, natural language-to-code search and code classification. They compared the performance of the proposed model with other prior models such as CodeBERT, GraphCodeBERT, StarEncoder, CodeT5, UniXcoder, and OpenAI's text-embedding-ada-002. The results show that the proposed model outperforms all the other models on nearly all the tasks except for the code classification on code defect detection benchmark."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "1 poor"
                },
                "strengths": {
                    "value": "- The paper is well written and the proposed model is well motivated. \n- The experiments are thorough and the results are convincing. \n- The paper is a good contribution to the field of code representation learning."
                },
                "weaknesses": {
                    "value": "- The paper is not very clear about the differences between the proposed model and the prior models. \n- For instance, it seems that the proposed model is a combination of the prior models (CodeBERT and DOBF) with some additional techniques, such as bimodal contrastive learning. It would be good to clarify the differences between the proposed model and the prior models.\n- page 3, line 27: remove the last comma in the following square brackets: [x_1, x_2, \\ldots, x_N ,]"
                },
                "questions": {
                    "value": "How would you explain why the performance of smaller models (e.g., CodeSage-Small and CodeSage-Base) is sometimes better than larger model? Does this mean that the proposed idea is not scalable to larger models or more effective for smaller models?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission3746/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698721868437,
            "cdate": 1698721868437,
            "tmdate": 1699636330695,
            "mdate": 1699636330695,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "xsPUkJQ4yM",
                "forum": "vfzRRjumpX",
                "replyto": "XBD9elRVgp",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission3746/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission3746/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer RZCJ"
                    },
                    "comment": {
                        "value": "Thank you for the feedback. To address your main question, we briefly summarize the fundamental contributions of our work below, which differentiate CodeSage from the existing work. \n\n1. We are the first to train different-sized code embedding models using a much larger amount of publicly available data and study their effectiveness as an off-the-shelf encoder model in downstream tasks.\n2. We innovate an effective two-stage pretraining strategy in the presence of large-scale data, which outperforms the previous SOTA model by significant margins on a wide range of tasks. In particular, \n     * we propose an effective MLM strategy for code, which is different from the existing literature (including CodeBERT and many others) that mainly follows 80-10-10 corruption convention proposed for text in BERT. We dive deep into why 80-10-10 is suboptimal for code through quantitive and qualitative experiments in Figure 2. \n    *  we identify the value of the DOBF objective that is not utilized in prior works for training code embedding models and cross the technical hurdles to make it work for training encoders (see Appendix A.5 for details). We further boost the performance by leveraging our proposed MLM with DOBF to complement each other (see Table 3 in our paper). \n    * we proposed an effective contrastive learning strategy with effective hard positive construction tricks that boost the performance over the baseline (see Figure 3a).  \n    * we deep dive into the key ingredients of code representation learning through an exhaustive ablation study, which we believe will help future works advance the performance further. \n\n\n**Differences Between CodeSage and The Combination of CodeBERT and DOBF**\n\nOur work is not a combination of CodeBERT and DOBF. CodeBERT adopted the original MLM objective proposed for text in the BERT paper. In contrast, we identified the caveat of such naive adoption for code and proposed an effective MLM variant, effectively boosting the performance (see Figure 2).  We are the first to identify the value of the DOBF objective that is not utilized in prior works for training code embedding models and cross the technical challenges to make it work for training encoders (see Appendix A.5). Moreover, we also innovate an effective contrastive learning strategy for stage-II pretraining of our two-stage pretraining scheme. We run exhaustive ablations to show why such two-stage pretraining is necessary and share our findings on the key ingredients for code representation learning. \n\n**Why Smaller Models Sometimes Outperform A Larger Model?**\n\nLarge models should generally outperform smaller ones on most tasks; we observe such a trend for CodeSage, especially in the zero-shot settings. However, there are no guarantees that larger models are universally better than smaller ones. We can also clearly see this on the [MTEB leaderboard](https://huggingface.co/spaces/mteb/leaderboard) for text; for example, bge-large-en-v1.5 outperforms bge-base-en-v1.5 (https://huggingface.co/BAAI/bge-large-en-v1.5) on average, but the opposite is also reported on some classification tasks and retrieval tasks, with similar findings for e5-large vs. e5-base (https://huggingface.co/intfloat/e5-large) and many other models.\n\nWe have taken your comments into serious consideration and hope our response can help address your question about the contributions of our work. We would be happy to take your other questions, if there are any."
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission3746/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700238405605,
                "cdate": 1700238405605,
                "tmdate": 1700261525722,
                "mdate": 1700261525722,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "d11MX4keDl",
            "forum": "vfzRRjumpX",
            "replyto": "vfzRRjumpX",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission3746/Reviewer_iHpZ"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission3746/Reviewer_iHpZ"
            ],
            "content": {
                "summary": {
                    "value": "The authors propose pre-training of encoder style for the domain of programming languages at a larger scale (pre-training data and model parameters) than most encoder style models. These models are then tested on tasks in the code understanding domain like text to code search (or semantic code search) and classification tasks on code. The authors also study the impact of different pre-training choices on the model's performance through their ablations to back their methodology."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "- Scaling the pre-training stage of an encoder only model is a very interesting idea, and hasn't received much attention compared to decoder only models that support generation tasks.\n\n- Exhaustive ablation studies that justify the need for different objectives proposed in pre-training.\n\n- Impressive performance in zero-shot settings on search tasks compared to previous encoder style models"
                },
                "weaknesses": {
                    "value": "- Missing comparison with decoder only models: Proposing to scale encoder style models is interesting, but the current results are not convincing as to why this is needed when large scale decoder style pre-trained models have been proposed. While pre-trained decoder only models like CodeGen2.5, CodeLlama, Llama are not specifically proposed for code search or classification, they could be adapted for all the downstream tasks studied by the authors in Sec 4.1. For instance, the last token's encoding from a decoder can be used for search related tasks. Fine-tuning for classification can be performed by framing the classification as a seq2seq problem or by training a classification head on top of the last token's representation. Zero-shot or few shot prompting performance of these decoder style models can be reported for comparison.\n\n- Common Code Understanding benchmarks ignored: The choice of benchmarks is consistent with contemporary literature for the text to code search task, but not for other tasks in the classification settings. This makes it hard for a reader to assess the quality of the pre-trained CodeSage model and compare it to other pre-training strategies from previous works. There are many code understanding tasks (eg. ones from the CodeXGlue benchmark) which have been used in previous works (CodeBERT, GraphCodeBERT, UniXCoder, CodeT5) that are not a part of the evaluation suite here. See Table 1 of https://arxiv.org/abs/2203.03850 - Clone Detection datasets.\n\n- Missing fine-tuned results on CSN, AdvTest and CoSQA: While the benchmark is consistent with previous work for text to code search, the setting chosen is zero shot whereas many previous works show fine-tuned results on the sizeable training datasets provided by these benchmarks (CodeSearchNet, CoSQA, AdvTest). Given that the size of these models is reasonable (130M - 1.3B params) compared to the models studied today (>6-10B params), fine-tuning is an important aspect to be studied with these models.\n\nFor instance, MRR scores in Table 2 on the CodeSearchNet benchmark are reported only in the zero-shot setting.  Fine-tuning improves many of these baselines substantially, and beats CodeSage's zero shot performance by significant margin. Post fine-tuning CodeT5+ is at 77 MRR overall, while CodeT5 is at 71, UniXCoder is at 74.4. See Table 6 of https://arxiv.org/abs/2305.07922. Same is the case with CoSQA and AdvTest results. Also, large scale pre-trained decoder only models CodeGen & Llama2 are missing when evaluating in the zero shot setting. While these are not encoder only models, their embeddings can be leveraged for search related tasks.\n\nAlso, it's strange why text-embedding-ada-002 is chosen as a baseline here. OpenAI's cpt-code (https://openai.com/blog/introducing-text-and-code-embeddings) would have been a stronger baseline to compare with instead of text-embedding-ada-002 model for code related search tasks.\n\nWriting:\nAbsract: unclear what downstream task is, is it gen?\nIntro: No discussion of next token pred objective from decoder only or encoder-decoder models\n\nTypos:\n\nWriting:\nAbsract: unclear what downstream task is, is it gen?\nstructure --> structural aspect\npretraining schemes decide --> dictate/influence/impact\n\nIntro:\npara 1: Don't agree that only encoder models are embedding models. Even Llama, CodeLlama, CodeGen can serve as embedding models.\npara 2: make it --> makes it\npara 3: representation's discriminative power\n\nCodeT5 appears twice in the bib"
                },
                "questions": {
                    "value": "- Why are decoder only models not studied as baselines for the code understanding tasks?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission3746/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission3746/Reviewer_iHpZ",
                        "ICLR.cc/2024/Conference/Submission3746/Senior_Area_Chairs"
                    ]
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission3746/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698916897576,
            "cdate": 1698916897576,
            "tmdate": 1700623194100,
            "mdate": 1700623194100,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "FvvpqJIURU",
                "forum": "vfzRRjumpX",
                "replyto": "d11MX4keDl",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission3746/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission3746/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer iHpZ"
                    },
                    "comment": {
                        "value": "Thank you for acknowledging our work's contribution and efforts in enhancing the zero-shot performance and diving deep into the problem through exhaustive analyses. We also appreciate your questions on additional experiments, which indeed motivate us to make our work more complete. Please see our general response (2/2) above for the evaluation results. We also summarized some key motivations of our current experiment design in (1/2) to complement the discussion. \n\n**Missing Comparison with Decoder-only Models** \nAs mentioned in our general response (1/2) #1, we tried to avoid unfair comparisons against the larger decoder-only models as they are not primarily trained for discriminative tasks and often yield suboptimal performance. As we can see in Tables (1a)&(1b) in our general response (2/2), CodeGen2.5 (7B), StarCoder (15.5B), and CodeT5+ (16B)-encoder all perform very suboptimal in the zero-shot setting, especially on NL-to-Code search tasks which often require properly designed training objective (e.g., contrastive learning) on the bimodal-data (text-code) to boost the performance.  However, we appreciate your question, which makes us realize we should include these results in our paper for completeness. \n\n**Why Not Code-CPT-001**\nWe chose Text-Ada002 models per OpenAI\u2019s suggestion on their website and claim that Ada002 is better or at least comparable to CPT-001 on both text and code tasks but at a much cheaper cost. We have validated their claim in tables (1a) and (1b) in our general response (2/2) above. \n\n**Some Classification Benchmarks Ignored**\nInstead of going through all benchmarks in CodeXGLUE, we preferred to dive deep and perform analysis to show why CodeSage learns effective code representations. We initially evaluated clone detection, which we found is easy for different models but has high evaluation cost due to the large data size. We excluded it and focused on other challenging classification tasks.  However, we have seriously considered your comments and summarized evaluations on POJ-104 and BigCloneBenchmark (BCB) in Table 2 in our general response (2/2). We can see that CodeSage maintains its strong performance. \n\n**Missing Fine-tuned Results on CSN, AdvTest, and CoSQA**\nOur primary goal was to build an off-the-shelf embedding model that does not require finetuning in many practical use cases; semantic search is one such case. Strong zero-shot performance would allow wider usage of the embedding models, as annotations for code are rare and very costly to collect. Our evaluation strategy also aligns with the recent trend in the text domain, where strong models have been actively developed to advance the [MTEB Benchmarks](https://huggingface.co/spaces/mteb/leaderboard). We hope our work can motivate a similar trend for code. \n\nHowever, we are grateful for your question, which motivates us to better connect with the previous work. We summarized the finetuning results in Table 2 in our general response (2/2), where CodeSage-base (356M) consistently outperforms CodeT5+(770M).  We want to point out that both CodeT5+ 220M and 770M optimize an additional \u201cmatching loss\u201d during finetuning (cross-encoder type finetuning of the decoder with pairs selected by the encoder). We hypothesize that if we finetune a copy of UnixCoder or CodeSage on such matching tasks and use them with the original encoders, we can also get a further performance boost for both models.  \n\n**Unclear Writing**\nThank you for pointing out the limitations of the abstract and introduction. We will work on them to clarify our writing in the camera-ready version. \n\nWe appreciate the opportunity to improve our paper based on your reviews. We will include these evaluation results reported in our general response above in the next update of our paper to address your questions comprehensively. Let us know if you have any other comments."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission3746/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700237645086,
                "cdate": 1700237645086,
                "tmdate": 1700261604637,
                "mdate": 1700261604637,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "OIZY9Rjlcy",
                "forum": "vfzRRjumpX",
                "replyto": "FvvpqJIURU",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission3746/Reviewer_iHpZ"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission3746/Reviewer_iHpZ"
                ],
                "content": {
                    "title": {
                        "value": "Response to rebuttal"
                    },
                    "comment": {
                        "value": "Thank you for your response addressing most of the concerns. I appreciate the thoroughness and additional experimental results provided in the rebuttal. I'm increasing my rating of this work to 6."
                    }
                },
                "number": 11,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission3746/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700623382841,
                "cdate": 1700623382841,
                "tmdate": 1700623382841,
                "mdate": 1700623382841,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "p6Hc21Hw9s",
            "forum": "vfzRRjumpX",
            "replyto": "vfzRRjumpX",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission3746/Reviewer_zUhF"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission3746/Reviewer_zUhF"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes CodeSage, a new series of models for learning representations of source code, ranging from 130M to 1.3B parameters. CodeSage is pretrained on the Stack dataset, with masked language modeling, identifier deobfuscation, and contrastive learning objectives, and all three objectives are carefully tailored specifically for code representation learning. Experiments are conducted on code search and classification tasks, against strong baselines. Results show that CodeSage not only outperforms all previous open-source code embedding models of similar sizes (i.e., ~125M), scaling it up to 1.3B further improves the performance and it also outperforms the `text-embedding-ada-002` embedding model from OpenAI."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "4 excellent"
                },
                "contribution": {
                    "value": "4 excellent"
                },
                "strengths": {
                    "value": "S1: All the pretraining objectives are specifically designed for code, the discussions on why such objectives need to be changed (e.g., no random token replacement) for code are very useful for future research in this domain;\nS2: To the best of my knowledge, CodeSage 1.3B is the largest (and best performing) code embedding model to date. Scaling up encoder-based models, especially for code representation learning, is an underexplored area;  \nS3: The experiments are very comprehensive. CodeSage is compared with strong baselines and it was able to beat all of them on the same model size, it also shows that the performance is significantly improved when scaled up to 1.3B. The ablations studies are rather thorough in showcasing the design choices;  \nS4: The writing of this paper is also great, making it very easy to follow, and conclusions from the figures and tables are very clear. For example, I found Figure 2(a) very helpful in showing why random token replacement makes less sense for code."
                },
                "weaknesses": {
                    "value": "I do not have any significant concerns about this work. But I do have a couple of questions, which are listed in the \"Questions\" section. \n\nOne suggestion: it would be great if we could have an ablation on how each of the training objectives affects the performance (e.g., remove one at a time and see how the performance changes). But I also understand that such ablation is quite expensive."
                },
                "questions": {
                    "value": "Q1: Do you plan to release the model and/or the code?  \nQ2: About not using random token replacement, this makes a lot of sense to me. But we would probably have the same problem for natural language, if we consider multiple languages, right? Is the same practice common in training multi-lingual text embeddings?  \nQ3: What is the pretraining hardware and compute?   \nQ4: Can you comment on the possibility to train even larger code embedding models using this method? It seems that most of the benchmarks are still improving by going from CodeSage-base to CodeSage-large in Table 1 and Table 2.   \nQ5: For Table 1, are the baseline models also trained on the 9 programming languages being evaluated here?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission3746/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699485418826,
            "cdate": 1699485418826,
            "tmdate": 1699636330510,
            "mdate": 1699636330510,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "z3AlQOZywM",
                "forum": "vfzRRjumpX",
                "replyto": "p6Hc21Hw9s",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission3746/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission3746/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer zUhF"
                    },
                    "comment": {
                        "value": "We sincerely thank the reviewer for acknowledging the novelty and impact of our work, especially your great attention to the details we mentioned in the paper. \n\nWe also appreciate your constructive suggestions and thoughtful questions. Please see our response below. \n\n**Removing One Objective At A Time** \nWe partially cover it through different experiments.\n\n1. Figure 4a shows that contrastive learning (stage-II pretraining) helps boost performance on top of stage-I pretraining with DOBF & MLM only. \n2. Figure 5 shows contrastive learning from scratch yields suboptimal performance and cannot benefit from large model sizes. Stage-I pretraining is essential to provide a good starting point for contrastive learning to be effective.\n3. Table 3 compares DOBF vs. MLM and effective ways to combine them for the stage-I pretraining.\n4. We initially also tried optimizing all three objectives from scratch. However, we observed suboptimal performance that can be explained by #2 above (which indicates that including contrastive learning from scratch is not effective). \n\nWe would like to explore further if we can get computation support for the camera-ready version. \n\n**Responses to Specific Questions**\n\n**Q1:** We plan to release the model checkpoints and the evaluation code. \n\n**Q2:** Your insights align with our hypothesis that random token replacement could hurt MLM training for multilingual text. However, this requires empirical validation; to the best of our knowledge, the existing multilingual MLM encoders are trained with the 80-10-10 practice. Another hypothesis is that the 80-10-10 corruption convention is proposed by the BERT paper, which pre-trained on a comparatively smaller dataset (BooksCorpus + Wikipedia En) over 40 epochs. In such a setting, corruption can help avoid overfitting and cause no significant performance drop. However, nowadays, scaling up the pretraining data allows us to reduce the training epochs, and the effectiveness of the 80-10-10 convention can change consequently. \n\n**Q3:** We used 128 A100 GPUs for pretraining CodeSage-Small&Base, which takes 3-5 days to finish the two-stage pretraining. We used 256 A100 GPUs for pretraining CodeSage-Large, which takes roughly six days. We will add those details in Appendix A.2. \n\n**Q4:** We can train even larger models. In this work, we limit the model size to 1B by considering the cost and latency for many practical settings, e.g., providing embeddings for building a retrieval system over billions of examples. However, if we can get enough support on resources, we are also interested in seeing how the performance can be further improved by scaling up both the data and model size, as we can first optimize for performance and then inference cost. \n\n**Q5:** CodeBERT and GraphCodeBERT are trained on 6 languages, UniXCoder (we used UnixCoder-Nine in this paper) and CodeT5+ embedding models are trained on 9 languages, Starencoder is trained on 86 languages. It is unknown how many programming languages are used to train text-embedding-ada-002."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission3746/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700237293326,
                "cdate": 1700237293326,
                "tmdate": 1700250782786,
                "mdate": 1700250782786,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "MvXoNohYDN",
                "forum": "vfzRRjumpX",
                "replyto": "z3AlQOZywM",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission3746/Reviewer_zUhF"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission3746/Reviewer_zUhF"
                ],
                "content": {
                    "title": {
                        "value": "Thanks for you response"
                    },
                    "comment": {
                        "value": "I'd like to thank the authors for the details response and the extra experiment results in the general response.\n\nI found the clarifications and answers to my questions clear and helpful. And I am glad to know that there are plans to release the model checkpoints and evaluation harness.\n\nI stand by my original assessment and will keep supporting this work. I will also keep monitoring the discussions with the other reviewers."
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission3746/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700541565910,
                "cdate": 1700541565910,
                "tmdate": 1700541565910,
                "mdate": 1700541565910,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]