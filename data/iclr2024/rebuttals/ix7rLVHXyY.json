[
    {
        "title": "Learning Performance-Improving Code Edits"
    },
    {
        "review": {
            "id": "zNxhW6pwmc",
            "forum": "ix7rLVHXyY",
            "replyto": "ix7rLVHXyY",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2928/Reviewer_jit6"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2928/Reviewer_jit6"
            ],
            "content": {
                "summary": {
                    "value": "This paper introduces a dataset for learning code performance improvements. Based on this dataset, the capabilities of both open-source (CodeLlama) and proprietary models (GPT3.5/GPT4) to optimize code were tested using various PROMOTING and FINETUNING methods. The effectiveness of different methods and the performance differences between open-source and proprietary models are analyzed based on the experimental data."
                },
                "soundness": {
                    "value": "4 excellent"
                },
                "presentation": {
                    "value": "4 excellent"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "This paper conducts comprehensive experiments on the task of improving code performance using LLM, and offers a comparative analysis of the effectiveness of various recent methods. This work will contribute to aiding researchers in the domain to better enhance the capabilities of code generation models."
                },
                "weaknesses": {
                    "value": "1. Regarding the experiment in Section 4.1: In Table 2, the performance of GPT-4 under the Few-Shot and CoT methods for code optimization was not tested.\n\n2. Data in Section 4.2 shows that after training on the synthetic dataset, there is a noticeable performance improvement in Best@1, but only a slight increase in Best@8. In fact, for the combination of < HQ+Self-Play, GPT-3.5 >, there is a minor performance decrease (95.42%->95.11%). The paper does not provide a convincing explanation for this.\n\n3. Different types of code have varying scopes and complexities for optimization. The paper does not clearly state the proportion of each language type in the training data nor in the test code."
                },
                "questions": {
                    "value": "1. How do you view the impact of training LLMs using synthetic data (generated either by the trained model itself or from other models)? Assuming synthetic data is generated by the trained model M and undergoes data filtering, how would the output distribution of M change?\n\n2. I noticed a statement regarding the comparison of LoRA training: \"We hypothesize that this gap may be because performance optimization examples do not occur naturally in the training data.\" Can you provide a clearer version of this statement, or offer a more specific explanation?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission2928/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2928/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2928/Reviewer_jit6"
                    ]
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2928/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698665890157,
            "cdate": 1698665890157,
            "tmdate": 1699636236607,
            "mdate": 1699636236607,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "lZ7s9DFWhX",
                "forum": "ix7rLVHXyY",
                "replyto": "zNxhW6pwmc",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for taking the time to understand the paper and provide feedback. We're glad to hear you feel the experiments are comprehensive and sound, and we're happy that you think our work will be beneficial to the community. \nWe've provided our responses below, and we're happy to address additional questions if anything is unclear!\n\n---\n\n### **[R4-Q1] How do you view the impact of training LLMs using synthetic data?**\n\nThe last three rows of fine-tuning results in Table 3 show the result of fine-tuning on synthetic data generated by GPT3.5 (in addition to data from PIE); we see increased generalization. The synthetic data was generated by the pre-trained GPT3.5 turbo model, and the optimized programs were then generated by GPT3.5 fine-tuned on 4K high-quality pairs. GPT3.5-turbo fine-tuned on the PIE dataset. Generally, training with this synthetic data enhances generalization ability. Please let us know if this does not answer your question, and we will be happy to provide additional clarifications.\n\n---\n\n### **[R4-Q2] Can you provide a clearer version of the statement regarding LoRA?**\n\nWe hypothesize that this gap may be because performance optimization examples do not occur naturally in the training data.\n\nRecent work has shown that the effectiveness of parameter-efficient methods depends on the training data. For example, [1] find that \"PEFT techniques are slower to converge than full tuning in low/medium-resource scenarios,\" and [2] find that LoRA is least effective for challenging tasks like mathematical reasoning. Together, these works indicate that the performance of PEFT may be heavily task-dependent. Our hypothesis is based on the fact that LoRA only changes a small subset of the model's parameters, and is likely most helpful when the base model has some proficiency for the task (due to pre-training), and LoRA can help \"adapt\" the model of the task further. Given that LLMs generally struggled in program optimization without retrieval or full fine-tuning, we hypothesize that the challenging nature of the problem and a potential lack of pre-trained proficiency pose challenges for LoRA. We will add these new citations in the next version and clarify this point.\n[1] He, Junxian, Chunting Zhou, Xuezhe Ma, Taylor Berg-Kirkpatrick, and Graham Neubig. \"Towards a unified view of parameter-efficient transfer learning.\" arXiv preprint arXiv:2110.04366 (2021).\n[2] Fine-Tuning LLMs: LoRA or Full-Parameter? An in-depth Analysis with Llama 2\n\n---\n\n### **[R4-Q3] The Performance of GPT-4 under Few-Shot and CoT were not tested**\n\nAt the time of writing, we did not have the funds to run all experiments with GPT-4. We were able to get the funds, and we have evaluated the outputs, and we will include them in the draft. For GPT4, both Few Shot and CoT prompting improve over Instruction prompting but underperform retrieval-based prompting. For example, Best@4 for CoT has a %Opt of 38.60% and a speedup of 1.51$\\times$, while Few-Shot has a %Opt of 30.83% and a speedup of 1.37$\\times$.\n\n\n| Prompting Method | %Opt | Speedup |\n|------------------|--------|---------|\n| Instruction Only (Best@4) | 16.58% | 1.23$\\times$|\n| CoT (Best@4) | 38.60% | 1.51$\\times$ |\n| Few-Shot (Best@4) | 30.83% | 1.37$\\times$ |\n| Dynamic Retrieval (Best@4) | 69.03% | 3.56$\\times$|\n\n\n---\n\n### **[R4-Q4] Different types of code have varying scopes and complexities for optimization. The paper does not clearly state the proportion of each language type in the training data nor in the test code.**\n\nOur training/validation/test sets consist entirely of C++ programs. We focus on C++ since it is a performance-oriented language compatible with the gem5 simulator. We will update the draft to make this more clear.\n\n---\n---\n\n## [Go to Reviews](https://openreview.net/forum?id=ix7rLVHXyY&noteId=zNxhW6pwmc)\n\n---\n---"
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700250887336,
                "cdate": 1700250887336,
                "tmdate": 1700611078005,
                "mdate": 1700611078005,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "tWNr2eGeNy",
                "forum": "ix7rLVHXyY",
                "replyto": "zNxhW6pwmc",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "### **[R4-Q5]  Data in Section 4.2 shows that after training on the synthetic dataset, there is a noticeable performance improvement in Best@1 (38.49 \u2192 45.62, 2.70 \u2192 3.02), but only a slight increase in Best@8 (86.66 \u219287.68, 6.74\u21926.86). In fact, for the combination of < HQ+Self-Play, GPT-3.5 >, there is a minor performance decrease (95.42%\u219295.11%).**\n\nTraining with HQ data helps increase the model's coverage, allowing it to optimize a large number of programs with just a single greedy sample. However, as more samples are drawn, both HQ and HQ + Self-play gradually converge to a similar level of performance. We verify this by computing the performance improvements as the number of samples gradually increases:\n\n\n| Number of Generations | % Opt Self-Play |  % Opt  HQ-Only | Diff  |\n|-----------------------|---------|---------|--------|\n| 1                     | 45.62%            | 38.49% | 7.13% |\n| 2                     | 62.42%            | 56.11% | 6.31% |\n| 3                     | 72.40%            | 67.62% | 4.79% |\n| 4                     | 77.39%            | 74.95% | 2.44% |\n| 5                     | 81.47%            | 80.04% | 1.43% |\n| 6                     | 83.50%            | 82.99% | 0.51% |\n| 7                     | 85.74%            | 84.93% | 0.81% |\n| 8                     | 87.68%            | 86.66% | 1.02% |\n\n\n| Number of Generations | Speedup Self-Play |  Speedup HQ-Only | Diff |\n|-----------------------|---------|-------------------|------|\n| 1                     | 3.02    | 2.70              | 0.32 |\n| 2                     | 4.09    | 3.83              | 0.26 |\n| 3                     | 4.85    | 4.66              | 0.19 |\n| 4                     | 5.43    | 5.24              | 0.19 |\n| 5                     | 5.91    | 5.70              | 0.21 |\n| 6                     | 6.16    | 6.17              | -0.01|\n| 7                     | 6.54    | 6.36              | 0.17 |\n| 8                     | 6.86    | 6.74              | 0.12 |\n\n---\n\n### **[R4-Q6] In fact, for the combination of < HQ+Self-Play, GPT-3.5 >, there is a minor performance decrease (95.42%$\\rightarrow$95.11%)**\n\nDespite the slight drop in correctness, the speedup and correctness increase from 6.74 \u2192 6.86 and 86.66 \u2192 87.68. This reveals a precision-recall style tradeoff: the model trained on synthetic data learns to try novel optimization strategies, but that comes at the cost of making more mistakes. We will add this analysis to the revision.\n\n---\n---\n\n## [Go to Reviews](https://openreview.net/forum?id=ix7rLVHXyY&noteId=zNxhW6pwmc)\n\n---\n---"
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700250971301,
                "cdate": 1700250971301,
                "tmdate": 1700611088812,
                "mdate": 1700611088812,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "HFCzxwtbZI",
                "forum": "ix7rLVHXyY",
                "replyto": "zNxhW6pwmc",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We hope that you are satisfied with our answers and the additional results we have provided. As the discussion period comes to an end, we would be grateful if you could let us know if we have adequately addressed your comments and if you have any further questions."
                    }
                },
                "number": 15,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700621258389,
                "cdate": 1700621258389,
                "tmdate": 1700621258389,
                "mdate": 1700621258389,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "vLeyg6r8nW",
            "forum": "ix7rLVHXyY",
            "replyto": "ix7rLVHXyY",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2928/Reviewer_VFMY"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2928/Reviewer_VFMY"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes a dataset called Performance-Improving Edits (PIE). It contains 77K pairs of C++ programs where one is a performance-improved version of the other, filtered from CodeNet. It also proposes to use gem5 simulator to simulate an Intel CPU as the runtime metric rather than running the programs and measuring wall time. The paper proposes a number of ways to use the PIE dataset to induce large language models to improve code performance, including prompt engineering, retrieval augmented generation, and fine-tuning. The best result is from fine-tuning GPT-3.5, with a surprising speedup of 6.86X, beating best human performance."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "This work is well motivated and addresses a meaningful task. The construction process described in section 2 seems reasonable. The different methods to adapt models in section 3 cover most main stream methods."
                },
                "weaknesses": {
                    "value": "The results are too good to be true. It's surprising to see that, for C++ competitive programming tasks, the fine-tuned GPT-3.5 beats the best human submission by a large margin: 6.86X speed up versus 4.06X speed up. So let's take a look at the examples in appendix A.1 which are code improvements generated by the model. Figure 3 of A.1 contains two programs that are functionally different. Figure 4(a) in A.1 is so bad that it seems unlikely in a C++ competition. Figure 5 contains two programs that are functionally different and also have different interfaces for execution (unclear how it passes correctness test). Figure 6 contains two programs that are functionally different and Figure 6(b) is missing an obvious break statement to help performance. Overall none of before-optimization examples seems plausible as competitive C++ programming submissions. By looking at these examples, I question the quality of the PIE dataset.\n\nI randomly looked at some entries in the supplementary material and they seem consistent with examples in appendix A.1 and not plausible for competitive C++ programming submissions.\n\nA side evidence for the issue can also be seen in Tables 1 and 2, where the correct percentages are high and indicate that the difficulty level of the programming tasks is low.\n\nIt is stated on page 6 that \"For generations that are either incorrect or slower than the original program, we use a speedup of 1.0 for that example, given that, in the worst case, the original program has a speedup of 1.0.\" This explains some of the 6.86X result: the evaluation setup is such that only good generations are considered in calculating the metric."
                },
                "questions": {
                    "value": "The following are questions in addition to the weakness section.\n\nThe rationale of using gem5 simulation instead of measuring wall time makes sense but won't this run the risk of overly focused on a single CPU (Inter Skylake)? Also gem5 simulation still does not capture big O complexity which is often a goal in optimizing code.\n\nIt is counter-intuitive that Section 3.2 only uses 4K out of the 77K pairs in PIE to fine-tune GPT 3.5. Then 3K synthetic data are created and used. Could you explain the rationale of these choices? This seems to contradict the quality claim of the PIE dataset."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission2928/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2928/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2928/Reviewer_VFMY"
                    ]
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2928/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698729558089,
            "cdate": 1698729558089,
            "tmdate": 1700671415199,
            "mdate": 1700671415199,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "ZGvOQJrsgs",
                "forum": "ix7rLVHXyY",
                "replyto": "vLeyg6r8nW",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for taking the time to review our paper. We were happy to read that you find PIE well motivated and its construction process reasonable, and appreciated the coverage of our experiments. We think that all your questions are addressable within this discussion period. Please see our response below. We would be more than happy to address additional questions during the discussion period if anything remains unclear.\n\n---\n\n> ### **[R3-Q1] Will using gem5 risk being overly-focused on a single CPU (Intel Skylake)?**\n\nIn Section 4, we analyzed 120 randomly selected programs in the test set, and all optimizations seemed generic with nothing specific to x86, let alone Skylake. Generally all optimizations we observed would execute faster on any backend: for example, using a faster sorting algorithm will almost always be faster on any backend. \n\nWe went further to check this systematically. To our knowledge the most plausible ways to customize C++ for a certain backend is through direct writing of assembly, SIMD/vector programming, and pragma statements (e.g. to specify memory prefetching). For the GPT3.5 model trained with self-play, **none** of the solutions contained assembly or vector programing, and only 0.3% of optimized generations contained pragmas that could affect execution time. It is intuitive that the model doesn\u2019t learn this behavior, because programers doing program competitions seem to rarely focus on optimizing for the program website backend. \n\n---\n\n> ### **[R3-Q2] Also gem5 simulation still does not capture big O complexity which is often a goal in optimizing code.**\n\nBig O complexities are impossible to automatically infer in the general case, and thus cannot be the basis for an automatic metric. Furthermore, Big O captures *asymptotic* complexities and can hide large constants. By measuring actual runtime on provided test cases, our evaluation best aligns with how user submissions are evaluated in practice.\n\n---\n\n> ### **[R3-Q3] Why do we only use 4K programs in section 3.2 and add more synthetic programs later, instead of real programs.**\n\nAs described in Section 3.2, the reason we did not finetune GPT-3.5-turbo on our full PIE dataset is due to our limited API budget. At a high level, our results in Table 3 demonstrate the following for the CodeLlama models:\n\n- Performance-conditioned models trained on PIE perform the best (by a wide margin)\n- Models trained on the 4K \"high quality\" subset of PIE perform second best\n- Models trained on all of PIE (without performance conditioning) are third\n\nThese results make sense, because finetuning on all of PIE without performance conditioning encourages the model to generate modest speedups. We ideally would have finetuned GPT-3.5-turbo using performance conditioning on the full PIE dataset, but we did not have the budget to do so. Thus, we used the second best option, which was to train GPT-3.5-turbo on the high quality examples, which was also significantly cheaper (~20x cheaper).\n\nThe synthetic data was introduced to solve a separate issue, which is the limited number of problems in the dataset. Even if we have a large number of submissions, they are all for the same 1474 problems. Our synthetic data consists of *new problems*, which helps our techniques generalize better to new problems (recall that our train/test split is at the level of problems, not code submissions). Because of this, synthetic data helps improve performance compared to just using PIE. On the page 8 footnote we report an ablation demonstrating the gains are from the type of data added, not the quantity of data.\n\n---\n---\n\n## [Go to Reviews](https://openreview.net/forum?id=ix7rLVHXyY&noteId=vLeyg6r8nW)\n\n---\n---"
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700248448804,
                "cdate": 1700248448804,
                "tmdate": 1700732864294,
                "mdate": 1700732864294,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "4kATt8VVeu",
                "forum": "ix7rLVHXyY",
                "replyto": "vLeyg6r8nW",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "> ### **[R3-Q4] The results are too good to be true. It's surprising to see that the fine-tuned GPT-3.5 beats the best human submission by a large margin: 6.86$\\times$ speed up versus 4.06$\\times$ speed up.**\n\nWe do not believe that our results are surprising or too good to be true. First, all examples in our dataset (including the ones in our paper) are from CodeNet, a widely used dataset in code generation and program synthesis [1, 2, 3]. Importantly, CodeNet contains a wide variety of submissions, including early drafts as well as submissions from novice programmers. This explains why some of the programs are slow or lower quality. In this light, we believe the 6.86$\\times$ speedup we obtain is highly plausible. Furthermore, we note that the 6.86$\\times$ speedup is only possible when using multiple samples. With only one sample, over 54% of the test set is not optimized more than 1.10$\\times$ and the mean speedup is 3.02$\\times$.\n\n\n[1] Guo, Daya, Shuai Lu, Nan Duan, Yanlin Wang, Ming Zhou, and Jian Yin. \"[Unixcoder: Unified Cross-modal Pre-training for Code Representation](https://arxiv.org/abs/2203.03850).\" arXiv preprint arXiv:2203.03850 (2022).\n\n[2] Li, Yujia, David Choi, Junyoung Chung, Nate Kushman, Julian Schrittwieser, R\u00e9mi Leblond, Tom Eccles et al. \"[Competition-level Code Generation with AlphaCode](https://arxiv.org/abs/2203.07814)\" Science 378, no. 6624 (2022): 1092-1097.\n\n[3] Nye, Maxwell, Anders Johan Andreassen, Guy Gur-Ari, Henryk Michalewski, Jacob Austin, David Bieber, David Dohan et al. \"[Show your work: Scratchpads for Intermediate Computation with Language Models](https://arxiv.org/abs/2112.00114)\" arXiv preprint arXiv:2112.00114 (2021).\n\n---\n\n> ### **[R3-Q5] High correctness implies that the difficulty of programming tasks is low**\n\nWe created the \u201cslow\u201d-\u201dfast\u201d example pairs in our dataset by taking **only accepted submissions** that pass all test cases. Because the input is already correct, a model that only copies the input verbatim is 100% correct. Thus, high correctness in isolation is trivial to achieve. In contrast, %Opt and Speedup (which both require all test cases to pass) can be difficult; especially with formulaic prompting strategies. We included correctness to help with analysis and understanding of general model performance characteristics. \n\n---\n\n> ### **[R3-Q6] Examples in the appendix are \u201cfunctionally different\u201d**\n\nAll three of these functions pass all of our unit tests described in Section 2. Moreover, we exhaustively tested all three based on the accepted range of inputs from the problem description: all three program pairs are equivalent. \n\nThe problems in our benchmark come with input ranges, and programs are only required to provide the correct output on inputs inside these ranges; we will clarify this point in our paper. We give details below; we are also happy to share the scripts that we used to exhaustively test the problems.\n\nRegarding the broader issue of how we check correctness, we emphasize that the use of unit tests to check correctness is the standard way to check correctness in competitive programming, and is also standard in the program synthesis literature (under the name \u201cprogramming by example\u201d); indeed, example-based synthesis has been integrated into commercial tools such as the FlashFill tool for Excel [1]. We would also like to note that CodeNet by default comes with only 5 test cases per program, and we increased the coverage to a median of over 100 test cases per program by augmenting additional test cases from Alphacode (Section 2).\n\n[1] Sumit Gulwani, [Automating String Processing in Spreadsheets using Input-Output Examples](https://dl.acm.org/doi/abs/10.1145/1925844.1926423?casa_token=_p-wn3-qwpwAAAAA:lMSWSPoREj_71zl3Di3vuq79-eY67y2F-tEzu1L72gXWmtWfjw07lGkVgrBw2mKbXHRtCoInN79IUw). In POPL, 2011.\n\n---\n---\n\n## [Go to Reviews](https://openreview.net/forum?id=ix7rLVHXyY&noteId=vLeyg6r8nW)\n\n---\n---"
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700248512358,
                "cdate": 1700248512358,
                "tmdate": 1700732880973,
                "mdate": 1700732880973,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "oJAm9FWv9z",
                "forum": "ix7rLVHXyY",
                "replyto": "vLeyg6r8nW",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "> ### **[R3-Q7] \u201cFigure 3 of A.1 contains two programs that are functionally different\u201d**\n\nProblem URL: https://atcoder.jp/contests/abc127/tasks/abc127_c\n\nInput Space: $$1 <= N <= 1e5; 1 <= M <= 1e5; 1 <= L_i <= R_i <= N$$\n\nIn addition to ~100 unit tests, we randomly generated 10,000 tests within the provided input bounds, and found that the two programs produced equal outputs on all of these inputs. Both programs aim to find the range between the maximum of the first set of elements and the minimum of the second set of elements. If the maximum of the first elements is greater than or equal to the minimum of the second elements, they both output 0. Otherwise, they output the difference plus 1. The first program sorts two vectors containing all $a$s and $b$s to find these values, while the second program directly computes the maximum $a$ and minimum $b$ during the input phase. However, the second program is more efficient, as it operates in linear time, avoiding the sorting overhead present in the first program.\n\n---\n\n> ### **[R3-Q8] \u201cFigure 5 contains two programs that are functionally different and also have different interfaces for execution (unclear how it passes correctness test)\u201d**\n\nProblem URL: https://atcoder.jp/contests/abc055/tasks/abc055_b\n\nInput Space: $$1 <= N <= 1e5$$\n\nAfter brute-force enumerating over all possible inputs in the specified input range, both programs are equivalent. Both programs calculate the factorial of an integer $n$ modulo $10^9 + 7$, but the second program is significantly faster, as it eliminates the overhead of precalculation and array storage, resulting in a faster execution for each individual input of $n$.\n\n---\n\n> ### **[R3-Q9] Figure 6 contains two programs that are functionally different** \n\nProblem URL: https://atcoder.jp/contests/abc060/tasks/abc060_b\n\nInput Space: $$1<= A <= 100; 1 <= B <= 100; 0 <= C < B$$\n\nAfter brute-force enumerating over all possible inputs in the specified input range, both programs were equivalent. Both programs determine if an integer solution exists for the equation $(A \\times i) - (B \\times j) = C$, but the second program is significantly more efficient by leveraging modular arithmetic, reducing the problem to a single loop with a maximum of $B$ iterations, compared to the first program's exhaustive search with nested loops.\n\n---\n\n> ### **[R3-Q10] The submission in Figure 4(a) in A.1 seems unlikely from a C++ competition**\n\nThe submissions are all from CodeNet (Puri et al., 2021). The dataset obtained from the [AtCoder](https://atcoder.jp/) or [AIZU](https://judge.u-aizu.ac.jp/) websites, and DeepMind\u2019s [AlphaCode paper](https://arxiv.org/pdf/2203.07814.pdf) refers to the CodeNet dataset as a \u201ccompetitive programming dataset.\u201d This dataset deliberately contains a wide variety of different submissions, including early drafts that coders improved over time, as well as submissions from both beginners and experts. This diversity makes the dataset useful as a performance optimization benchmark, since we can examine how to help beginners and experienced programmers improve the performance of their code.\n\nFor reference, here is the URL to the problem in Figure 4: [B - One Clue](https://atcoder.jp/contests/abc137/tasks/abc137_b)\n\nHere are some other URLs to problems in the PIE test set: \n\n- [F - Fractal Shortest Path](https://atcoder.jp/contests/panasonic2020/tasks/panasonic2020_f)\n\n- [E - Jigsaw](https://atcoder.jp/contests/agc017/tasks/agc017_e)\n\n- [Problem B: Compress Files](https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2080)\n\n---\n\n> ### **[R3-Q11] Fig 6b is missing an obvious break statement to help performance**\n\nThanks for pointing out the additional opportunity for optimization. While the models are trained to generate faster programs, there may still be room for improvement. We will clarify this point in the caption that: `the example on the right is faster, but the generated code could have been even faster if it included a break statement.`\n\n---\n\n> ### **[R3-Q12] \"The evaluation setup is such that only good generations are considered in calculating the metric.**\n\nThis strategy reflects the natural way a program optimization tool would be used: keep the best program collected, including the initial program. In particular, if a programmer realizes the generated program is incorrect or slower, they can simply revert to the original and have a speedup of 1.0. This approach aligns with standard software development practices, where unproductive changes are discarded. In fact, for GPT-3.5 with self-play (SP), this strategy actually has less impact than other models because so many programs are optimized: GPT-3.5 (SP) improved performance for 87.68% of programs in the benchmark by at least 10%. Thus, the strategy was only applied to a small fraction of programs (at most 12.32%).\n\n---\n---\n\n## [Go to Reviews](https://openreview.net/forum?id=ix7rLVHXyY&noteId=vLeyg6r8nW)\n\n---\n---"
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700248666760,
                "cdate": 1700248666760,
                "tmdate": 1700732902130,
                "mdate": 1700732902130,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "6qljoW23Y7",
                "forum": "ix7rLVHXyY",
                "replyto": "vLeyg6r8nW",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We hope that you are satisfied with the answers we have provided. As the discussion period comes to an end, we would be grateful if you could let us know if we have adequately addressed your comments and whether you have any further questions."
                    }
                },
                "number": 14,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700621204912,
                "cdate": 1700621204912,
                "tmdate": 1700621204912,
                "mdate": 1700621204912,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "yUKU5ufNZ2",
                "forum": "ix7rLVHXyY",
                "replyto": "vLeyg6r8nW",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Reviewer_VFMY"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Reviewer_VFMY"
                ],
                "content": {
                    "title": {
                        "value": "thanks for the explanations"
                    },
                    "comment": {
                        "value": "I have read the rebuttal. Thanks for providing links to the original problems of some examples used, and they help clarify some of the doubts. I do still have doubts on the data quality as well as the claim of 6.86X speed up versus 4.06X of best human solution. Maybe showing examples of model-generated vs best-human-solution would help; maybe reporting percentiles in additional to averages will help. I am also not convinced by explanation of correctness percentage, which is again a data quality doubt.\nI have updated my rating based on the new information."
                    }
                },
                "number": 16,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700672241287,
                "cdate": 1700672241287,
                "tmdate": 1700672241287,
                "mdate": 1700672241287,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "hveZSe8gXj",
                "forum": "ix7rLVHXyY",
                "replyto": "vLeyg6r8nW",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Thanks for your time and feedback!"
                    },
                    "comment": {
                        "value": "Dear Reviewer VFMY, \n\nWe are pleased that we could clarify doubts you had and that you found the information we provided useful. Thank you again for all your time, which will help us improve our work. With the time remaining, we\u2019ve tried to provide the following responses below to your recent suggestions. \n\n\n\n> ### **[R3-Q13] Maybe showing examples of model-generated vs best-human-solution would help**\n\nThe following are some examples where the model-generated solution was at least 5$\\times$ faster than the best human solution:\n\n---\n---\n\n### *Example 1 $\\rightarrow$ CodeLlama 13B with Performance Conditioning*\n\nFastest Human Solution ($\\mathbf{\\underline{5.2\\times}}$) vs. Model Generated Solution ($\\mathbf{\\underline{26.9\\times}}$)\n\n$\\downarrow\\downarrow$ Fastest Human Solution for the Submission (5.2$\\times$) $\\downarrow\\downarrow$\n\n```cpp\n#include <iostream> \nusing namespace std;\n\nint main()\n{\n    int s;\n    cin >> s;\n    int list[1000000];\n    int index = 0;\n    int a_i;\n    int a_pre = s;\n    list[0] = s;\n    index = index + 1;\n    bool search_flag = false;\n    while( true){\n        if ( a_pre % 2 == 0){\n            a_i = a_pre / 2;\n        } else {\n            a_i = 3 * a_pre + 1;\n        }\n        list[index] = a_i;\n        index = index + 1;\n        for ( int i = 0; i< index-1; ++ i ){\n            if ( list[i] == a_i) {\n                search_flag = true;\n                break;\n            }\n        }\n        if (search_flag==true){\n            break;\n        } \n        a_pre = a_i;\n\n    }\n    cout << index << endl;\n    return 0;\n}\n``` \n\n$\\downarrow\\downarrow$ Model Generated Solution (26.9$\\times$) $\\downarrow\\downarrow$\n\n```cpp\n#include<stdlib.h>\n\nint main(){\n  int s;\n  scanf(\"%d\", &s);\n  int* a = (int*)calloc(1000000, sizeof(int));\n  a[s]++;\n  for(int i=2; i<1000000; i++){\n    if(s%2 == 0){\n      s /= 2;\n      a[s]++;\n    }else{\n      s *= 3;\n      s++;\n      a[s]++;\n    }\n    if(a[s] == 2){\n      printf(\"%d\", i);\n      break;\n    }\n  }\n}\n```\n---\n---\n\n### *Example 2 $\\rightarrow$ GPT3.5 Fine-Tuned with Synthetic Data*\n\nFastest Human Solution ($\\mathbf{\\underline{5.12\\times}}$) vs. Model Generated Solution ($\\mathbf{\\underline{27.5\\times}}$)\n\n$\\downarrow\\downarrow$ Fastest Human Solution for the Submission (5.12$\\times$) $\\downarrow\\downarrow$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint editDistance(string x,string y){\n  int n=x.length(),m=y.length();\n  int INF=1LL<<55LL;\n  vector<vector<int> > dp(n+1,vector<int>(m+1,INF));\n  for(int i=0;i<=n;i++) dp[i][0]=i;\n  for(int i=0;i<=m;i++) dp[0][i]=i;\n  for(int i=1;i<=n;i++){\n    for(int j=1;j<=m;j++){\n      dp[i][j]=min(dp[i][j],dp[i-1][j]+1);\n      dp[i][j]=min(dp[i][j],dp[i][j-1]+1);\n      dp[i][j]=min(dp[i][j],dp[i-1][j-1]+(x[i-1]!=y[j-1]));\n    }\n  }\n  return dp[n][m];\n}\nsigned main(){\n  string s1,s2;\n  cin>>s1>>s2;\n  cout<<editDistance(s1,s2)<<endl;\n  return 0;\n}\n```\n\n$\\downarrow\\downarrow$ Model Generated Solution (27.5$\\times$) $\\downarrow\\downarrow$\n\nWe note that the problem description restricts inputs to be within a length of 1000.\n\n```cpp\n#include <cstdio>\n#include <cstring>\nconst int N=1005;\nint n,m,dp[N][N];\nchar a[N],b[N];\nint min(int a,int b){return a<b?a:b;}\nint main()\n{\n\tscanf(\"%s%s\",a+1,b+1);\n\tn=strlen(a+1),m=strlen(b+1);\n\tfor(int i=1;i<=n;i++) dp[i][0]=i;\n\tfor(int i=1;i<=m;i++) dp[0][i]=i;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tdp[i][j]=dp[i-1][j-1];\n\t\t\tif(a[i]!=b[j]) dp[i][j]++;\n\t\t\tdp[i][j]=min(dp[i][j],min(dp[i-1][j]+1,dp[i][j-1]+1));\n\t\t}\n\tprintf(\"%d\",dp[n][m]);\n\treturn 0;\n}\n```\n\n---\n---\n\n### *Example 3 $\\rightarrow$ GPT3.5 Fine-Tuned with HQ-Only Data*\n\nFastest Human Solution ($\\mathbf{\\underline{5.18\\times}}$) vs. Model Generated Solution ($\\mathbf{\\underline{27.3\\times}}$)\n\n$\\downarrow\\downarrow$ Fastest Human Solution for the Submission (5.18$\\times$) $\\downarrow\\downarrow$\n\n```cpp\n#include <iostream> \n\nint main()\n{\n    int s;\n    std::cin >> s;\n    int list[1000000];\n    int index = 0;\n    int a_i;\n    int a_pre = s;\n    list[0] = s;\n    index = index + 1;\n    bool search_flag = false;\n    while( true){\n        if ( a_pre % 2 == 0){\n            a_i = a_pre / 2;\n        } else {\n            a_i = 3 * a_pre + 1;\n        }\n        list[index] = a_i;\n        index = index + 1;\n        for ( int i = 0; i< index-1; ++ i ){\n            if ( list[i] == a_i) {\n                search_flag = true;\n                break;\n            }\n        }\n        if (search_flag==true){\n            break;\n        } \n        a_pre = a_i;\n\n    }\n    std::cout << index << std::endl;\n    return 0;\n}\n```\n\n$\\downarrow\\downarrow$ Model Generated Solution (27.3$\\times$) $\\downarrow\\downarrow$\n\n```cpp\n#include <stdio.h>\n\nint f(int n) {\n\tif (n % 2 == 0) {\n\t\treturn n / 2;\n\t} else {\n\t\treturn 3 * n + 1;\n\t}\n}\n\nint main() {\n  int s, count = 1;\n  scanf(\"%d\", &s);\n\n\n  while (true) {\n  \tif (s == 4 || s == 2 || s == 1) {\n  \t\tcount += 3;\n  \t\tbreak;\n\t  }\n  \ts = f(s);\n  \tcount++;\n  }\n  printf(\"%d\", count);\n  return 0;\n}\n```"
                    }
                },
                "number": 22,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700726655798,
                "cdate": 1700726655798,
                "tmdate": 1700734237074,
                "mdate": 1700734237074,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "P76AECRXlE",
                "forum": "ix7rLVHXyY",
                "replyto": "vLeyg6r8nW",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "> ### **[R3-Q14] maybe reporting percentiles in additional to averages will help**\n\nThank you for your suggestion. The table below reports the fraction of all generations falling in 10 different speedup categories. The majority of generations are $>=$ 5.0$\\times$ speedup and $<$ 10.0$\\times$ speedup, which helps to explain the 6.86$\\times$ result. \n\n| Speedup   | % Percent Programs with the Speedup (Best@8) |\n|---------------------|--------------------------------------|\n| >= 1.1$\\times$              | 87.68%                               |\n| >= 1.25$\\times$             | 87.07%                               |\n| >= 1.5$\\times$              | 82.89%                               |\n| >= 1.75$\\times$             | 82.59%                               |\n| >= 2.0$\\times$              | 79.12%                               |\n| >= 2.5$\\times$              | 77.39%                               |\n| >= 3.0$\\times$              | 76.07%                               |\n| >= 4.0$\\times$              | 74.64%                               |\n| >= 5.0$\\times$              | 73.01%                               |\n| >= 10.0$\\times$             | 9.06%                                |\n\n\nWe hope that these responses provide further clarification. Thanks again for your feedback.\n\n\nBest, \n\nAuthors"
                    }
                },
                "number": 23,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700726683667,
                "cdate": 1700726683667,
                "tmdate": 1700734387872,
                "mdate": 1700734387872,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "ieRhpxAzdk",
            "forum": "ix7rLVHXyY",
            "replyto": "ix7rLVHXyY",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2928/Reviewer_nenm"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2928/Reviewer_nenm"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes a new benchmark for training and evaluating LLMs to generate performance-improving code edits given an existing unoptimized program as well as an evaluation of current and novel prompting/finetuning methods for adapting LLMs for this task. The benchmark is constructed from CodeNet tasks and the authors annotate the runtimes using the gem5 environment along with caveats that this performance measurement can be very difficult in other benchmarking setups. The authors show improvements over the human baselines on speedups with a variety of methods, and show a systematic ablation with various models, prompting, and retrieval schemes on both open-source and private large language models."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "The benchmark is an important artifact that the community will continue to build upon, especially as code-generating/editing large language models continue to be developed and deployed in research and production environments. The analysis and ablations are very thorough and further justify the benchmark and prompting strategies as important contributions."
                },
                "weaknesses": {
                    "value": "The experiments are very thorough, but it seems that the correctness of the models degrades with introduced methods. While it seems that the paper's primary contribution is the dataset, further analysis of correctness (as opposed to just pure speedups/optimization %) would further solidify the adaptation methods sections of the paper."
                },
                "questions": {
                    "value": "Are the speedups reported only on edited programs that are verified to be correct?\nHow does the model generalization scale with the amount of synthetic data used?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission2928/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2928/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2928/Reviewer_nenm"
                    ]
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2928/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698810733014,
            "cdate": 1698810733014,
            "tmdate": 1699636236424,
            "mdate": 1699636236424,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "GtbHG4GheL",
                "forum": "ix7rLVHXyY",
                "replyto": "ieRhpxAzdk",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for taking the time to review the paper and provide feedback! We are happy that you believe the benchmark is an important artifact that will be useful to the broader community. We're also glad that you think the methods evaluated are comprehensive.\n\n---\n \n> ### **[R2-Q1] Are the speedups reported only on edited programs that are verified to be correct?**\n\nYes, only speedups from programs that pass all test cases are included. If a program is incorrect even for a single unit test, we discard it and do not include it in calculating speedup. \n\n---\n\n> ### **[R2-Q2] How does the model generalization scale with the amount of synthetic data used?**\n\nWe are running another experiment to investigate this, and we will report the result. We will fine-tune with 50% less synthetic data to explore this. \n\n---\n\n> ### **[R2-Q3] Where do the LLMs fail and why?**\n\nThank you for the suggestion to investigate error analysis! We performed this analysis for GPT-3.5 fine-tuned with synthetic data. Specifically, we analyzed the generated programs that PIE fails to optimize and the root cause of each failure. Our findings are summarized below:\n\n| Result | Percentage |\n|-|-|   \n| Failed to compile (syntax/type errors) | 12.51% |\n| Compiled, but got [95-100%] of test cases wrong | 27.59% |\n| Compiled, but got (75, 95%] of test cases wrong | 12.08% |\n| Compiled, but got (25, 75%] of test cases wrong | 10.84% | \n| Compiled, but got (0-25%] of test cases wrong (at least 1 test case was wrong) | 6.90% |\n| Ran all test cases, but the program was slower than the original | 9.93% |\n| Ran all test cases, but the program was the same speed as the original | 9.40% |\n| Ran all test cases, the program was faster, but not 1.1$\\times$ speedup or higher | 10.75% |\n\nIn summary, a large fraction (~60%) of the failures happen because the proposed changes break a unit test. In about 30% of the cases, the model produces a correct, but the generated program is either slower (10%) or doesn't meet our threshold for speedup (10%). Finally, in about 10% of the cases, the generated program has a syntax error. \nAdditionally, with test cases, we find that when the model gets the program wrong, it seems to most often get it \"quite wrong\" by missing most test cases. We will update the existing analysis (Appendix A) with these new findings.\n\n\nFinally, we conduct additional analysis to investigate the properties of programs that PIE fails to optimize. The results show a mild negative correlation between the problem description length and average accuracy (-0.15) and between the source program length and average accuracy (-0.26), suggesting longer inputs slightly reduce accuracy. Additionally, the average speedup has a mild negative correlation with both the problem description length (-0.16) and the source program length (-0.11), indicating a minimal impact of length on speedup compared to correctness. Overall, this analysis reveals that language models struggle to generate a correct program when faced with larger source programs and challenging problems, but their ability to optimize programs is minimally impacted. This motivates a future work direction where techniques from program repair may be combined with PIE for better results.\n\n\n---\n---\n\n## [Go to Reviews](https://openreview.net/forum?id=ix7rLVHXyY&noteId=ieRhpxAzdk)\n\n---\n---"
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700249925128,
                "cdate": 1700249925128,
                "tmdate": 1700610751587,
                "mdate": 1700610751587,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "idsrJ5Ci0V",
                "forum": "ix7rLVHXyY",
                "replyto": "ieRhpxAzdk",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Results for [R2-Q2] $\\rightarrow$ Using less synthetic data"
                    },
                    "comment": {
                        "value": "> ### **[R2-Q2-Results] How does the model generalization scale with the amount of synthetic data used?**\n\nWe\u2019ve obtained the results from this experiment: we trained the same GPT3.5 Model with 50% of the synthetic data pairs and included it in the tables below (Experiment: HQ + 50% Self-Play).\n\n\n**Best@1 Results**\n\n| Experiment   | Setup      | %Opt (>1.10 speedup) | Average Speedup | %Correct |\n|--------------------|------------|----------------------|-----------------|----------|\n| HQ-Only            | Fine-tuned | 38.49%               | 2.70            | 59.16%   |\n| HQ + 50% Self-Play | Fine-tuned | 40.22%               | 2.87            | 58.35%   |\n| HQ + Self-Play     | Fine-tuned | 45.62%               | 3.02            | 61.71%   |\n\n\n**Best@8 Results**\n\n| Experiment   | Setup      | %Opt (>1.10 speedup) | Average Speedup | %Correct |\n|--------------------|------------|----------------------|-----------------|----------|\n| HQ-Only            | Fine-tuned | 86.66%               | 6.74            | 95.42%   |\n| HQ + 50% Self-Play | Fine-tuned | 85.95%               | 6.47            | 94.70%   |\n| HQ + Self-Play     | Fine-tuned | 87.68%               | 6.86            | 95.11%   |\n\n\nBest@1, the results for %Opt, Speedup, and %Correct interpolate between using all of the synthetic data and none of the synthetic data. Best@8; the model fine-tuned with less synthetic data seems to underperform both models. \n\nAlthough we use the same hyperparameters for sampling, HQ + 50% Self-Play seems to generate with less diversity  and scales poorly with more generations, potentially due to a lack of diversity in the new subset of training data.\n\n---\n---\n\n## [Go to Reviews](https://openreview.net/forum?id=ix7rLVHXyY&noteId=ieRhpxAzdk)\n\n---\n---"
                    }
                },
                "number": 11,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700609976273,
                "cdate": 1700609976273,
                "tmdate": 1700611009584,
                "mdate": 1700611009584,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "Ts4a4GYHgL",
                "forum": "ix7rLVHXyY",
                "replyto": "ieRhpxAzdk",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We hope that you are satisfied with our answers and the additional results we have provided. As the discussion period comes to an end, we would be grateful if you could let us know if we have adequately addressed your comments and whether you have any further questions."
                    }
                },
                "number": 13,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700620951850,
                "cdate": 1700620951850,
                "tmdate": 1700620951850,
                "mdate": 1700620951850,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "wcfXIL3Ejl",
                "forum": "ix7rLVHXyY",
                "replyto": "Ts4a4GYHgL",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Reviewer_nenm"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Reviewer_nenm"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for the thorough follow-up and analysis! Thank you for clarifying when and why the failures happen in your evaluation. The follow-up experiment on scaling down the amount of synthetic data used is very interesting, although it would be more informative if we also saw the result of increasing the amount of self-play data (e.g. 200%), does it continue to improve?\n\nThank you for answering these questions. I will maintain my score."
                    }
                },
                "number": 18,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700687310227,
                "cdate": 1700687310227,
                "tmdate": 1700687310227,
                "mdate": 1700687310227,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "4kKMLSbXoP",
                "forum": "ix7rLVHXyY",
                "replyto": "ieRhpxAzdk",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Thanks for your time and feedback!"
                    },
                    "comment": {
                        "value": "Dear Reviewer nenm,\n\n\nThanks for your time and feedback, which will help us improve our work. We are pleased to see that we were able to address your concerns. Thank you for the suggestion on increasing the amount of self-play data to 200%. As the experiment will take around 4 days and some extra budget, we will add these results in the next version.\n\nBest, \nAuthors"
                    }
                },
                "number": 20,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700725222016,
                "cdate": 1700725222016,
                "tmdate": 1700725348523,
                "mdate": 1700725348523,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "rgBN5tF6tF",
            "forum": "ix7rLVHXyY",
            "replyto": "ix7rLVHXyY",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2928/Reviewer_8KXu"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2928/Reviewer_8KXu"
            ],
            "content": {
                "summary": {
                    "value": "The paper proposes PIE dataset. Each sample in the dataset is basically a pair, showing a program and its optimized counterpart. \nThe impact of PIE dataset is further studied on several LLMs (both open and closed), including the family of CodeLlama and GPT3.5 and GPT-4. Moreover, a broad range of adaptations is used to improve the results of the LLMs, such as instruction, few shot, chain of thoughts, dynamic few shot, and fine-tuning. \nThe experimental results indicate that each adaptation strategy improves the results, with fine-tuning having the most significant improvement over the others."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "+ The problem of performance editing is important. Not only should the generated code be correct, but also it should be as efficient as possible. Therefore, the paper targets an important problem. \n\n+ The range of adaptations considered is wide, and the experimental results give the reader a clear image of how each adaptation strategy can be used to improve the results. \n\n+ The paper uses top closed-sourced (GPT3.5 and 4) and open-sourced (CodeLLama 7B, 13B, 34B) to study the impact of PIE dataset. It clearly shows the gap between closed and open LLMs and how different adaptations can narrow this gap."
                },
                "weaknesses": {
                    "value": "- The study mostly focuses on the percentage of performance, and in cases where the runtime of the generated program is slower or the code is incorrect, speed up is considered one. This is not a good approach. In particular, a study is needed on what category of programs LLMs often fail to produce correct code or optimized code. In such a study, it will be easier to infer in which cases it is better not to use the LLMs. Or which category of programs needs to be further improved. \n\n- For synthetic data, it is mentioned that semantic duplicates are tracked, but no information is provided on how semantic similarity is conducted. Is it also based on CodeBertScore? \n\n- It is interesting to see that Perf-Cond has decreased the percentage of correctness. Any reason why Perf-Cond degrades the ability of the LLMs to produce the correct code? \n\n-  The presentation could be improved as an example, Table 1 is not referenced anywhere in the text, or in Table 2, it is better to group the Dynamic Retrievals together. The additional horizontal line is confusing. \n\n- In Table 2, why is the choice of models not consistent across different methods? Like, there is no few shots learning or COT for GPT-4."
                },
                "questions": {
                    "value": "For detailed questions, please refer to the weakness section.\n\n- The authors have not discussed enough about the cases where the LLMs fail or why they fail. Could they add further experiments and clarify it?\n\n- In Table 2, why is the choice of models inconsistent across different methods? Like, there are no few shot learning or COT for GPT-4. \n\n- Why does Perf-Cond degrade the ability of the LLMs to produce the correct code? \n \n- How semantic similarity is conducted where semantic duplicates are tracked?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2928/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699069099013,
            "cdate": 1699069099013,
            "tmdate": 1699636236342,
            "mdate": 1699636236342,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "3feXtTEEP3",
                "forum": "ix7rLVHXyY",
                "replyto": "rgBN5tF6tF",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for taking the time to review our paper. We were happy to read that you find the problem area important and that we experiment with a large range of models and techniques. We think that all your questions are addressable within this discussion period. Please see our response below. We would love to address additional questions during the discussion period if anything needs to be clarified.\n\n---\n\n> ### **[R1-Q1] Where do the LLMs fail and why?**\n\nThank you for the suggestion to investigate error analysis!\nWe performed this analysis for GPT-3.5 fine-tuned with synthetic data. Specifically, we analyzed the generated programs that PIE fails to optimize and the root cause of each failure. Our findings are summarized below:\n| Result | Percentage |\n|-|-|   \n| Failed to compile (syntax/type errors) | 12.51% |\n| Compiled, but got [95-100%] of test cases wrong | 27.59% |\n| Compiled, but got (75, 95%] of test cases wrong | 12.08% |\n| Compiled, but got (25, 75%] of test cases wrong | 10.84% | \n| Compiled, but got (0-25%] of test cases wrong (at least 1 test case was wrong) | 6.90% |\n| Ran all test cases, but the program was slower than the original | 9.93% |\n| Ran all test cases, but the program was the same speed as the original | 9.40% |\n| Ran all test cases, the program was faster, but not 1.1$\\times$ speedup or higher | 10.75% |\n\n\nIn summary, a large fraction (~60%) of the failures happen because the proposed changes break a unit test. In about 30% of the cases, the model produces a correct, but the generated program is either slower (10%) or doesn't meet our threshold for speedup (10%). Finally, in about 10% of the cases, the generated program has a syntax error. Additionally, with test cases, we find that when the model gets the program wrong, it seems to most often get it \"quite wrong\" by missing most test cases. We will update the existing analysis (Appendix A) with these new findings.\n\nFinally, we conduct additional analysis to investigate the properties of programs that PIE fails to optimize. The results show a mild negative correlation between the problem description length and average accuracy (-0.15) and between the source program length and average accuracy (-0.26), suggesting longer inputs slightly reduce accuracy. Additionally, the average speedup has a mild negative correlation with both the problem description length (-0.16) and the source program length (-0.11), indicating a minimal impact of length on speedup compared to correctness. Overall, this analysis reveals that language models struggle to generate a correct program when faced with larger source programs and challenging problems, but their ability to optimize programs is minimally impacted. This motivates a future work direction where techniques from program repair may be combined with PIE for better results.\n\n---\n\n> ### **[R1-Q2] Why did we leave out Few-shot and CoT for GPT4?**\n\nAt the time of writing, we did not have the funds to run all experiments with GPT-4. We were able to get the funds, and we have evaluated the outputs, and we will include them in the draft. For GPT4, both Few Shot and CoT prompting improve over Instruction prompting but underperform retrieval-based prompting. For example, Best@4 for CoT has a %Opt of 38.60% and a speedup of 1.51$\\times$, while Few-Shot has a %Opt of 30.83% and a speedup of 1.37$\\times$.\n| Prompting Method | %Opt | Speedup |\n|------------------|--------|---------|\n| Instruction Only (Best@4) | 16.58% | 1.23$\\times$ |\n| CoT (Best@4) | 38.60% | 1.51$\\times$ |\n| Few-Shot (Best@4) | 30.83% | 1.37$\\times$ |\n| Dynamic Retrieval (Best@4) | 69.03% | 3.56$\\times$ |\n\n---\n\n> ### **[R1-Q3] Why does Perf-Cond degrade the LLM\u2019s ability to produce correct code?**\n\nWe believe that conditioning the model only to generate programs with a 10/10 optimization rate may constrain the number of optimizations available for any given input. To verify this, we experimented using the first 6 generations from the 7b Perf-Cond model when conditioned on 10/10 versus combining the first 2 generations when conditioned on 10/10, 9/10, and 8/10. When we did this, we saw a %Correct increase from 59.95% to 64.36%. These figures support the explanation that performance labels may restrict which generated programs are correct.\n\n---\n---\n\n## [Go to Reviews](https://openreview.net/forum?id=ix7rLVHXyY&noteId=rgBN5tF6tF)\n\n---\n---"
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700249414111,
                "cdate": 1700249414111,
                "tmdate": 1700610686909,
                "mdate": 1700610686909,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "DFjxzAOAQL",
                "forum": "ix7rLVHXyY",
                "replyto": "rgBN5tF6tF",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "> ### **[R1-Q4] How is filtering out semantic duplicates conducted for Self-Play?**\n\nIn Section A.4 of the Appendix, we describe how we check semantic similarity. In detail, because our goal is to only demonstrate inequivalence, not equivalence, we use a set of test cases, and ensure that at least 1 output is different from programs in the PIE dataset. We use 200 test cases for all programs, and the generated program must run without errors on at least 20 of these. To achieve this, we had to execute more than 1.4 million binary input pairs and track all the outputs.\n\n---\n\n> ### **[R1-Q5] The presentation could be improved as an example...**\n\nThank you for pointing these presentation details out to us; we will update the draft based on your feedback! \n\n---\n\n> ### **[R1-Q6] \u201c1.00\u201d is used for speedup when a generation is incorrect or slower**\n\nThis strategy reflects the natural way a program optimization tool would be used: keep the best program collected, including the initial program. In particular, if a programmer realizes the generated program is incorrect or slower, they can simply revert to the original and have a speedup of 1.0. This approach aligns with standard software development practices, where unproductive changes are discarded.\n\n---\n---\n\n## [Go to Reviews](https://openreview.net/forum?id=ix7rLVHXyY&noteId=rgBN5tF6tF)\n\n---\n---"
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700249489099,
                "cdate": 1700249489099,
                "tmdate": 1700610708424,
                "mdate": 1700610708424,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "9DGUivERg7",
                "forum": "ix7rLVHXyY",
                "replyto": "rgBN5tF6tF",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We hope that you are satisfied with our answers and the additional results we have provided. As the discussion period comes to an end, we would be grateful if you could let us know if we have adequately addressed your comments and whether you have any further questions."
                    }
                },
                "number": 12,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700620870314,
                "cdate": 1700620870314,
                "tmdate": 1700620870314,
                "mdate": 1700620870314,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "51QjJrfsxz",
                "forum": "ix7rLVHXyY",
                "replyto": "9DGUivERg7",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Reviewer_8KXu"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Reviewer_8KXu"
                ],
                "content": {
                    "comment": {
                        "value": "I read the rebuttal. My major concerns are clarified, and thank you for the explanation."
                    }
                },
                "number": 17,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700674481133,
                "cdate": 1700674481133,
                "tmdate": 1700674481133,
                "mdate": 1700674481133,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "RLPARDdk0t",
                "forum": "ix7rLVHXyY",
                "replyto": "rgBN5tF6tF",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2928/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Thanks for your time and feedback!"
                    },
                    "comment": {
                        "value": "Dear Reviewer 8KXu,\n\nThanks for your time and feedback, which will help us improve our work. We are pleased to see that we were able to address your concerns.\n\nBest,\n\nAuthors"
                    }
                },
                "number": 19,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2928/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700725132819,
                "cdate": 1700725132819,
                "tmdate": 1700725275368,
                "mdate": 1700725275368,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]