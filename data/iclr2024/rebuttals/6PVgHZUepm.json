[
    {
        "title": "Rep-Adapter: Parameter-free Automatic Adaptation of Pre-trained ConvNets via Re-parameterization"
    },
    {
        "review": {
            "id": "ojxJQOw0Ac",
            "forum": "6PVgHZUepm",
            "replyto": "6PVgHZUepm",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission625/Reviewer_xJSa"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission625/Reviewer_xJSa"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposed an adaption tuning method for ConvNets. The learnable parameters of can be re-parameterized to the original conv module to achieve parameter-free adaption. On different pre-trained models, the authors demonstrate the proposed method can achieve good performance."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1. The proposed method indeed provide some interesting experiments for parameter-free adaption of ConvNets, especially on few-shot setting,"
                },
                "weaknesses": {
                    "value": "1. The proposed method has limited novelty. A similar adaption and re-parameterization method has been proposed in earlier methods. [1]\n2. The proven \"layers tuning at any learning rate via Rep-Adapter\" does not make too much sense. Adding scaling factors is equivalent to the adaptive learning rate, and has nothing to do with the proposed Rep-Adapter.\n3. While the proposed method can be re-parameterized after training, the modules equivalent to the original network size still need to be fully tuned during training. I don't see any advantage of this compared to parameter-efficient tuning methods except the performance gain reported in the paper. \n4. The reported results are not verified using different random seeds. No error bar is reported.\n\n\n[1] Sylvestre-Alvise Rebuffi et al. Efficient parametrization of multi-domain deep neural networks. CVPR 2018."
                },
                "questions": {
                    "value": "1. Can you explain why Rep-Adapter outperforms the full fine-tuning in Table 3?  The details of the initial learning rate for fine-tuning and rep-adapter are missing. Also, does full fine-tuning conduct the same number of epochs as the Rep-Adapter?  10000 steps seem not enough for fine-tuning, can you justify it?  \n2. For ablation study (e), it would be of more interest to see different initialization of $w_{R}$ rather than $w_0$."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission625/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698765725552,
            "cdate": 1698765725552,
            "tmdate": 1699635990219,
            "mdate": 1699635990219,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "fhv9UztrlG",
                "forum": "6PVgHZUepm",
                "replyto": "ojxJQOw0Ac",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission625/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission625/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Author response to Reviewer xJSa (Part 1)"
                    },
                    "comment": {
                        "value": "Thank you for your detailed and constructive comments. We respond to all the issues you pointed out in details below. We hope our response and rebuttal revision will address your concerns.\n\n**Weakness 1. Novelty over [1].**\n\nThank you for pointing out the related literature! We would like to summarize our novelty over this work as below. \n\n1. Technical difference. In [1], the authors propose an adapter to modify the \u201cdiagonal\u201d elements of the filters additively. In this paper, we propose an adapter to modify the learning rate of every element of the filters.\n2. Structure difference. In [1], the adapter is simply a scaling layer in parallel with the convolutional layer. Different from this, our Rep-Adapter contains a tuning branch with a new convolutional layer with two scaling layers in each branch to balance the learning rate. \n3. Re-parameterization difference. Different from [1], Rep-Adapter also optimizes the pre-trained model in a larger network capacity with non-linearity BN in the branch. This is similar to the advantage of structural re-parameterization training over traditional training and has been generally proved by the success of ACNet (Ding et al., 2019), RepVGG (Ding et al., 2021c), etc. This advantage of structural re-parameterization can also be proved by our ablation study (c), where we study the important component of structural re-parameterization (Ding et al., 2021c;b), the batch-wise statistics in BN during training.\n\n\n**Weakness 2. Adding scaling factors is equivalent to the adaptive learning rate, and has nothing to do with the proposed Rep-Adapter.**\n\nThank you for this comment. The scaling factors are the crucial components of the proposed Rep-Adapter. As shown by Proposition 3.1, the optimization of learning can be relaxed to the optimization of the scaling factors. However, using scaling factors without other components in Rep-Adapter (two branches, BN in the branch) or using Rep-Adapter without scaling factors are both inferior to our proposed Rep-Adapter. We have performed an Ablation study by using scaling factors without other components in Rep-Adapter to demonstrate the effectiveness. The results are shown in the Table below. The result of w/o scaling and w/o BN is the result of cases (a) and (d) in Table 8. By comparing the results of Rep-Adapter with (b) w/o scaling, we can see that scaling is an important component of Rep-Adapter. Results of (a) only scaling shows that the scaling needs the other design of Rep-Adapter to be effective. Results of (c) w/o BN show that the BN in the branch is also an important factor to achieve good results with Rep-Adapter.\n\n\n| Method | Caltech101 | CIFAR-100 | DTD | Flowers102 | Pets|\n| :---|:----:| :----: | :----: | :----: | :----: |\n| Rep-Adapter| 84.7 (1.4)  | 59.6 (0.2) | 64.2 (2.4) | 92.7 (0.3) | 90.3 (2.6)|\n| (a) Only scaling| 81.7 (4.4)  | 58.1 (1.6) | 60.5 (3.1) | 91.3 (1.3) | 84.0 (5.1)|\n| (b) w/o scaling| 83.8 (1.4)  | 59.6 (0.1) | 63.1 (3.0) | 92.5 (0.2) | 87.1 (2.8)|\n| (c) w/o BN| 82.1 (3.5)  | 59.6 (0.2) | 61.6 (3.1) |  91.8 (0.4) | 85.9 (5.4) |\n| Fine-tuning| 81.6 (5.1)  | 57.8 (1.6) | 60.2 (5.4) | 91.5 (1.6) | 83.5 (7.7)|\n\nTherefore, scaling factors and other designs of Rep-Adapter are closely related and rely on each other. We have added these results and analysis to Appendix A.5 of the rebuttal revision (marked by purple)."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission625/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700695290800,
                "cdate": 1700695290800,
                "tmdate": 1700700553105,
                "mdate": 1700700553105,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "Ihlji8P1X1",
                "forum": "6PVgHZUepm",
                "replyto": "ojxJQOw0Ac",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission625/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission625/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Author response to Reviewer xJSa (Part 2)"
                    },
                    "comment": {
                        "value": "**Weakness 3. Advantage over parameter-efficient tuning methods.**\n\nThank you for this comment. We would like to address this concern from four aspects.\n\n1. Hyper-parameter tuning. Parameter-efficient tuning methods usually require a higher learning rate than fine-tuning and could suffer from tedious Hyper-parameter search. Our Rep-Adapter can automatically adjust the learning rate to avoid manual hyper-parameter search. Remarkably, we use one default learning rate for Rep-Adapter on all the datasets in experiments.\n\n2. We would like to point out that our method does not aim at fast adaptation, but aims at the transfer learning performance, which is in line with L2-SP, DELTA, AutoLR, and SpotTune. Also, previous structural re-parameterization works usually achieve performance improvements at the cost of training efficiency. Compared to AutoLR (Ro & Choi, 2021), Rep-Adapter trains 1.67\u00d7 faster and achieves 2.3% performance improvement on average of 4 different datasets with PIRL (Table 5).\n\n3. Rep-Adapter achieves significant performance improvements over parameter-efficient tuning methods with minor differences in training speed. For example, Rep-Adapter brings 11.1% mean top-1 accuracy improvements on supervised VTAB-1k compared to a parameter-efficient tuning method, Visual Prompt Tuning (Table 4 in the paper).\n\n4. We would also like to point out that most other parameter-efficient tuning methods, such as Tip-Adapter and VPT, could not achieve fast adaptation, as the gradient of all the parameters still needs to be calculated in the back-propagation and saved for the update of that small set of parameters. This issue has also been pointed out in previous literature [*1].\n\n[*1] Sung, Yi-Lin, et al. ``LST: Ladder Side-Tuning for Parameter and Memory Efficient Transfer Learning.\" NeurIPS, 2022.\n\nIn summary, Rep-Adapter significantly outperforms parameter-efficient tuning methods with minor difference in training cost and does not need tedious Hyper-parameter search. We hope these advantages over parameter-efficient tuning methods could address your concern.\n\n**Weakness 4. Results are not reported with deviation.**\n\nThank you! Sorry for the confusion. For clarity, we only report the results in the ablation study with standard deviation. In fact, all of our results reported in the paper are the mean results over 3 independent runs using different random seeds. We will clarify this in the section on experimental details.\n\nWe have calculated the standard deviation of the numbers over 3 independent runs of the few-shot transfer learning experiments. When taking the variance into account, Rep-Adapter still achieves clear improvements over other methods. For example, on Caltech101 dataset, the standard deviation is 0.4, which is much smaller than the gap between the results of Rep-Adapter and baseline methods (3% improvements over Tip-Adapter). We will add the standard deviation of all our results in the paper."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission625/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700695379242,
                "cdate": 1700695379242,
                "tmdate": 1700700608821,
                "mdate": 1700700608821,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "5GlkJblBQi",
                "forum": "6PVgHZUepm",
                "replyto": "ojxJQOw0Ac",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission625/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission625/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Author response to Reviewer xJSa (Part 3)"
                    },
                    "comment": {
                        "value": "**Question 1. Why Rep-Adapter outperforms the full fine-tuning in Table 3? Training details?**\n\nThanks for this valuable question. Rep-Adapter outperforms full fine-tuning due to the following reasons.\n\n1. During Rep-Adapter tuning, every filter of ConvNets can be seen as tuning at a different learning rate, while in fine-tuning, every filter uses the same predefined learning rate, which could be sub-optimal as early layers may need a lower learning rate than later layers.\n\n2. Compared to fine-tuning, our Rep-Adapter automatically finds the optimal transfer learning protocol that saves the tediously searching for hyper-parameter settings.\n\n3. Rep-Adapter also benefits from the structural re-parameterization design of Rep-Adapter. Structural re-parameterization eases network optimization and improves network performance by increasing network capacity and complexity during training. This advantage of structural re-parameterization has been generally proved by the success of ACNet (Ding et al., 2019), RepVGG (Ding et al., 2021c), etc.\n\nAblation study Table in Weakness 2 demonstrates the improvement brought by automatic learning rate tuning (scaling factor) and structural re-parameterization design.\n\nFor the training setting of Rep-Adapter, fine-tuning, and linear probing, we follow closely to the original paper of the benchmark VTAB. We use the lightweight sweep setting proposed in VTAB (Zhai et al., 2020) that sweeps the following hyperparameters:\n- Learning rate: {0.1, 0.01}\n- Training schedule: In all cases, we decay the learning rate by a factor of 10 after 1/3 and 2/3 of the training time, and one more time shortly before the end. We try {2500, 5000, 10000} training steps.\n\nFull fine-tuning conducts the same number of epochs as the Rep-Adapter. As we are performing experiments on relatively small datasets with large batch sizes, 10000 training steps are enough when converted to epochs. For example, when performing 1000-shots transfer learning, as we use a total batch size of 256\u00d78=2048, 10000 training steps are equal to 2048\u00d710000/1000=20480 epochs. Therefore, we follow the same setting proposed in VTAB (Zhai et al., 2020).\n\n**Question 2. Ablation of different initialization of $\\omega_R$**\n\nThank you for this suggestion! We perform the experiment by randomly initializing $\\omega_R$. As shown in the table, random initializing the tuning branch would clearly damage the performance of Rep_Adapter, demonstrating that the pre-trained initialization is important to the tuning branch. We have added these results and analysis to Appendix A.5 of the rebuttal revision (marked by purple).\n\n| $\\omega_R$ init | Caltech101 | CIFAR-100 | DTD | Flowers102 | Pets   |\n| :--- |    :----:   | :----: | :----: | :----: | :----: |\n| random  | 74.8 (5.9)  | 52.5 (1.4) | 53.9 (3.6) |  88.1 (1.1) | 79.1 (4.5) |\n| $\\omega_0$ | 84.7 (1.4)  | 59.6 (0.2) | 64.2 (2.4) | 92.7 (0.3) | 90.3 (2.6)|"
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission625/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700695409200,
                "cdate": 1700695409200,
                "tmdate": 1700700691999,
                "mdate": 1700700691999,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "YzOq2zCrKz",
                "forum": "6PVgHZUepm",
                "replyto": "5GlkJblBQi",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission625/Reviewer_xJSa"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission625/Reviewer_xJSa"
                ],
                "content": {
                    "comment": {
                        "value": "Thanks for the detailed response from the authors. My concerns of weakness 3 and weakness 4 have been well addressed. However, I still don't think adding a scaling factor is of significance in the proposed Rep-Adapter since it is a very common technique used in many backbones.  Also, most of the results w/o scaling are very similar to full Rep-Adapter, imho, this makes the statement/section of this work on adaptive learning rate more invalid. Based on these, I will maintain my original rating."
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission625/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700703983160,
                "cdate": 1700703983160,
                "tmdate": 1700703983160,
                "mdate": 1700703983160,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "eRugQO3MBJ",
            "forum": "6PVgHZUepm",
            "replyto": "6PVgHZUepm",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission625/Reviewer_XwS8"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission625/Reviewer_XwS8"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes to use Structural Re-parameterization for transfer learning. Specifically, an extra branch comprising a learnable conv layer and a BN is added to the original frozen conv layer during training. After training, such a structure is equivalently transformed into a single conv layer for inference. The effectiveness is explained as adaptively adjusting the equivalent learning rate of filters. Reasonable results are reported."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. The idea of using Structural Re-param for transfer learning is novel.\n2. The structural design is easy to understand and thoroughly validated.\n3. The results are impressive.\n4. The explanation (the structure is equivalent to adjusting lr for different filters) is impressive."
                },
                "weaknesses": {
                    "value": "1. Structural Re-parameterization is not correctly discussed. The authors seem to mistake it with the traditional re-parameterization (e.g., CondConv). Traditional re-parameterization first derives a parameter with some other parameters and uses the derived parameter for computation, for example, a conv layer (y = x conv W) with traditional re-parameterization may compute W = W1 + W2, then y = x conv W. But Structural Re-parameterization uses regular layers during training and converts the structures (i.e., merges some layers) for inference. This work should be categorized into Structural Re-parameterization, but in the paper only \"re-parameterization\" is used to describe the method. And in Section 2, Structural Re-param should be discussed in a subsection (for example, it should at least mention that Structural Re-param is proposed by [RepVGG] ...) and traditional re-param (e.g., DiracNet, CondConv) should be mentioned in another subsection.\n\n2. The proposition is proved in a vectorized form, which seems a bit messy. I would suggest the authors show a simplified version with a specified arbitrary channel (or a single-channel conv). \n\nI also suggest the authors show the proposition from another equivalent perspective. I guess the authors would like to prove that in the following two simplified scenarios\n\nA. the structure is  y = frozen_conv(x) + trainable_conv(x) * alpha, the learning rate is lamda\n\nis equivalent to\n\nB. the structure is  y = trainable_conv(x), the learning rate is alpha ** 2 * lamda\n\nThis may be easier to understand. Then tell the reader what alpha represents (BN.weight / BN.std) so that the reader will understand that the BN realizes adaptive lr. Then naturally discuss the behavior of BN."
                },
                "questions": {
                    "value": "1. How is Rep-Adapter used with transformer? Is it used to replace every linear layer? Is BN still used in this case? BatchNorm-1d or 2d? \n\n2. Is the usage of Rep-Adapter with a linear layer (nn.Linear) simply the same as the usage of a 1x1 conv in a CNN? Their inputs are of different shapes so I wonder if there are some differences.\n\nPlease show some code and I will understand it."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission625/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698772105950,
            "cdate": 1698772105950,
            "tmdate": 1699635990143,
            "mdate": 1699635990143,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "gsp7fmoqoj",
                "forum": "6PVgHZUepm",
                "replyto": "eRugQO3MBJ",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission625/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission625/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Author response to Reviewer XwS8"
                    },
                    "comment": {
                        "value": "Thank you for your recognition of our paper and your detailed and constructive comments. We respond to all the issues you pointed out in detail below. We hope our response and rebuttal revision will address your concerns.\n\n**Weakness 1. Discuss Structural Re-param and Traditional Re-param separately.**\n\nThank you for this valuable suggestion! We have rewritten this part in Section 2 of the rebuttal revision to discuss Traditional Re-parameterization and Structural Re-parameterization in different subsections. Rep-Adapter belongs to Structural Re-parameterization. Please check the rebuttal revision for the changes (denoted by purple). We hope the revision will address your concern on this.\n\n**Weakness 2. Show a simplified version of the proposition with a single channel. Also, show the proposition in a simplified scenario for better understanding.**\n\nThank you for this suggestion! Following your suggestion, we present a simplified case of Proposition 3.1 and write a proof with single channel. The Proposition and proof are added to Appendix A.1 (marked as purple) of the rebuttal revision to provide a better understanding for the readers.\n\n**Question 1. Details of the Rep-Adapter used with transformer.**\n\nThank you for this question. We replace every linear layer in transformers with Rep-Adapter, including the ones in multi-head attention and MLP. In transformers, we use Rep-Adapter *without* BN. The scaling factors in transformers are implemented separately as learnable parameters, instead of directly using the weight of BN as in ConvNets (code is shown in Question 2). The original LayerNorm layers in the transformer are not part of Rep-Adapter and are left intact.\n\n**Question 2. Details of the Rep-Adapter used with linear layer. (code)**\n\nThank you. The usage of Rep-Adapter with a linear layer (`nn.Linear`) is very similar to the usage of Rep-Adapter with a 1x1 conv in a CNN. The implementation is changed accordingly as their inputs are of different shapes.\n\nHere, we show an example of the implementation of RepAdapter in PyTorch as you suggested:\n\n```\nclass RepAdapter(nn.Module):\n    def __init__(self, in_dim, out_dim, init_values):\n        super().__init__()\n        self.branch_1 = nn.Linear(in_dim, out_dim)    # this branch is frozen\n        self.branch_2 = nn.Linear(in_dim, out_dim)\n        self.gamma_1 = nn.Parameter(init_values * torch.ones((out_dim)),requires_grad=True)\n        self.gamma_2 = nn.Parameter(init_values * torch.ones((out_dim)),requires_grad=True)\n    def forward(self, x):\n        # x shape is : batch, length, dim\n        x1 = self.gamma_1 * self.branch_1(x)\n        x2 = self.gamma_2 * self.branch_2(x)\n        return x1 + x2\n```\nIn transformer, `nn.Linear(in_dim, out_dim)` is replaced by `RepAdapter(in_dim, out_dim)`."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission625/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700684161027,
                "cdate": 1700684161027,
                "tmdate": 1700700511049,
                "mdate": 1700700511049,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "hHkuyqCF3v",
            "forum": "6PVgHZUepm",
            "replyto": "6PVgHZUepm",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission625/Reviewer_ZcYB"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission625/Reviewer_ZcYB"
            ],
            "content": {
                "summary": {
                    "value": "The paper addresses the challenges in transfer learning, emphasizing the impact of factors like dataset size and label fraction on different transfer learning protocols. It highlights the efficacy of linear probing and fine-tuning in semi-supervised and fully-supervised scenarios, respectively. The proposed solution, Rep-Adapter, introduces an approach by adding a learnable side branch alongside a frozen pre-trained branch. This strategy aims to strike a harmonious balance between pre-trained and fine-tuned weights. To simplify the process, learnable hyper-parameters for each layer are introduced, eliminating the need for manual tuning. Additionally, a re-parameterization method is employed during inference to merge the two branches while preserving the structure of the pre-trained model."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "* The combination of learnable and frozen branches to find the balance between pre-trained weights and fine-tuned weights.\n* Learnable hyper-parameters for each layer, reducing the need for manual adjustments.\n* Efficient re-parameterization during inference, ensuring minimal additional computational cost."
                },
                "weaknesses": {
                    "value": "* Increased computational cost during training due to the addition of learnable branches and hyper-parameters, especially for heavy-weight models.\n* In theory, the final results of the proposed fintuning can be achieved by the traditional fintuning, i.e. the difference of original weights and the final weights can be achieved by traditional fintuning. Thus, it is arguable this method is significantly different or better than traditional finetuning."
                },
                "questions": {
                    "value": "Could it be applied on other architectures, like attention-based ones?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission625/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698781079354,
            "cdate": 1698781079354,
            "tmdate": 1699635990062,
            "mdate": 1699635990062,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "WLHStY4lwu",
                "forum": "6PVgHZUepm",
                "replyto": "hHkuyqCF3v",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission625/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission625/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Author response to Reviewer ZcYB"
                    },
                    "comment": {
                        "value": "Thanks for your detailed and constructive comments and your recognition on our paper. We respond to all the issues you pointed out in detail below. We hope our response and rebuttal revision will address your concerns.\n\n**Weakness 1. Increased training cost.**\n\nThank you for pointing that out! We would like to address this concern from two aspects.\n\n1. As we do not increase the depth of the network or the total training steps during training, the computational overhead on modern GPUs is much lower than expected. We have tested our training cost on A100 GPUs. The training cost of Rep-Adapter is around 1.2\u00d7 compared to fine-tuning. In contrast, other adaptive lr method, e.g. AutoLR (Ro & Choi, 2021), requires more than 2\u00d7 training cost for repeated training. \n\n2. We would like to point out that our method does not aim at fast adaptation, but aims at the transfer learning performance, which is in line with L2-SP, DELTA, AutoLR, and SpotTune. Also, previous structural re-parameterization works usually achieve performance improvements at the cost of training efficiency. Among them, Rep-Adapter achieves remarkable performance with a relatively small increase in training costs. For example, Rep-Adapter cost only around 1.2\u00d7 during training, bringing 11.1% mean top-1 accuracy improvements on supervised VTAB-1k compared to Visual Prompt Tuning (Table 4 in the paper).\n\n**Weakness 2. Difference and advantage over fine-tuning.**\n\nThank you for this valuable comment! We would like to point out that the final results of our tuning method could not be easily achieved by traditional fine-tuning. The reasons are three-fold.\n\n1. During Rep-Adapter tuning, every filter of ConvNets can be seen as tuning at a different learning rate, while in traditional fine-tuning, every filter uses the same predefined learning rate.\n\n2. Compared to fine-tuning with filter-wise learning rate settings, our Rep-Adapter is an automatic transfer learning protocol that saves the tediously searching for hyper-parameter settings.\n\n3. Rep-Adapter also optimizes the pre-trained model in a larger network capacity and complexity compared to fine-tuning, which is an advantage of structural re-parameterization. This is similar to the advantage of structural re-parameterization training over traditional training and has been generally proved by the success of ACNet (Ding et al., 2019), RepVGG (Ding et al., 2021c), etc. This advantage of structural re-parameterization can also be proved by our ablation study (c), where we study the important component of structural re-parameterization (Ding et al., 2021c;b), the batch-wise statistics in BN during training.\n\nGiven the above reasons, we believe our Rep-Adapter has a clear difference and advantage over fine-tuning.\n\n**Question 1. Application on other architectures.**\n\nThank you! Although Rep-Adapter is mainly designed for ConvNets, it can also be applied to attention-based architectures. For example, in Section 4.5, we explore our Rep-Adapter on CLIP with a vision transformer as the visual encoder. We apply Rep-Adapter on every fully-connected layer in the visual encoder of CLIP-ViT-B/32. Our method outperforms CoOp by 1.6% on average."
                    }
                },
                "number": 1,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission625/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700672628001,
                "cdate": 1700672628001,
                "tmdate": 1700700432169,
                "mdate": 1700700432169,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]