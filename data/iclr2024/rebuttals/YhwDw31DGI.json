[
    {
        "title": "MIPGen: Learning to Generate Scalable MIP Instances"
    },
    {
        "review": {
            "id": "uNF6dkpvHr",
            "forum": "YhwDw31DGI",
            "replyto": "YhwDw31DGI",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2681/Reviewer_X6GL"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2681/Reviewer_X6GL"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposed a learning based method to generate MIP instances, which could be benefit for training machine learning based MIP solving policies. Based on the bipartite graph representation, it learns to cluster the training instances. It then adopts a step-by-step approach to reconstruct the graph structure, which also facilitates generating large-scale instances. Experiments show that the generated instances are similar to the training ones."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "I agree with the research motivation. How to generate sufficient training data is indeed an important problem for training practical deep learning based MIP solving techniques."
                },
                "weaknesses": {
                    "value": "1. The technical novelty is somewhat limited. The key components are based on existing works, for example the random feat based method is from (Chen et al., 2022), the instance clustering is based on a simple EM procedure based on Gaussian Mixture Model, and the node splitting and merging is based on (You et al., 2019).\n\n2. MIP instance clustering has already been studied in the literature, e.g., in [Kadioglu2010] and [Song2023]. These approaches can already effectively clustering heterogeneous MIP instances, and the techniques are much simpler than the proposed one. The authors did not give a proper discussion and comparison regarding existing MIP clustering methods.\n\n[Kadioglu2010] Kadioglu, S., Malitsky, Y., Sellmann, M., & Tierney, K. (2010). ISAC\u2013instance-specific algorithm configuration. In ECAI 2010 (pp. 751-756). \n\n[Song2023] Song, W., Liu, Y., Cao, Z., Wu, Y., & Li, Q. (2023). Instance-specific algorithm configuration via unsupervised deep graph clustering. Engineering Applications of Artificial Intelligence, 125, 106740.\n\n3. The experiments are small-scale. For example, in Table 2, only three instances are considered, each is augmented to 20 instances. \n\n4. The authors did not compare with simple data augmentation techniques, such as randomly perturb the MIP instance parameters."
                },
                "questions": {
                    "value": "Please see the above weaknesses."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission2681/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2681/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2681/Reviewer_X6GL"
                    ]
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2681/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698632720952,
            "cdate": 1698632720952,
            "tmdate": 1699636209155,
            "mdate": 1699636209155,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "Yw0OzgWYwg",
                "forum": "YhwDw31DGI",
                "replyto": "uNF6dkpvHr",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2681/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2681/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Reply to reviewer X6GL (1/2)"
                    },
                    "comment": {
                        "value": "Thank you for your constructive comments and suggestions, which have greatly aided in enhancing the quality of our paper. We have diligently integrated your feedback into the revised manuscript. Below, we restate your comments and provide our detailed responses:\n\n>1. The technical novelty is somewhat limited. The key components are based on existing works, for example the random feat based method is from (Chen et al., 2022), the instance clustering is based on a simple EM procedure based on Gaussian Mixture Model, and the node splitting and merging is based on (You et al., 2019).\n\nIn response to your first comment, we have further elaborated on the novel aspects of our work. Building upon the foundational work in [2], we introduced a split-merge framework tailored for generating MIP problems. This framework is complemented by our innovative data augmentation experiments, designed to validate the efficacy of our method. Additionally, our method, MIPGen, uniquely incorporates the capability to amalgamate tree-like structures for generating large-scale MIP problems. This feature is particularly beneficial in training ML-based frameworks on smaller MIP instances to subsequently tackle larger-scale problems of the same type. We acknowledge the current framework's limitations and plan to explore more intricate generation strategies in our future work.\n\n\n>2. MIP instance clustering has already been studied in the literature, e.g., in [Kadioglu2010] and [Song2023]. These approaches can already effectively clustering heterogeneous MIP instances, and the techniques are much simpler than the proposed one. The authors did not give a proper discussion and comparison regarding existing MIP clustering methods.\n\nThank you for highlighting this issue.\n\nThe method for MIP instance clustering in [3] involves designing Instance Features for MIP problems, followed by clustering the normalized instance features using the g-means algorithm. The effectiveness of this approach heavily relies on the design of the Instance Features. The instance features in [3] include statistical indicators of MIP problems, such as the percentage of binary (integer or continuous) variables, a vector of coefficients of the objective function, and a vector representing the number of constraints for each variable ii. However, this method lacks a representation of the key structural aspect of the MIP problem's coefficient matrix. We believe that basic statistical indicators are insufficient to distinguish complex MIP problems encountered in the real world.\n\nIn [4], the method for MIP instance clustering begins with identifying a subgraph in the bipartite graph representing MIP problems using a random walk approach. The information of nodes and edges from this subgraph is then converted into a sequence $Y$, and an Auto Encoder is trained on these sequences $Y$ from all MIP problems, followed by clustering using the k-means algorithm based on the inferred features of each problem. In contrast, the clustering method in MIPGen directly employs a VGAE to train on the bipartite graphs representing MIP problems, followed by clustering with the EM algorithm. We consider the clustering method in MIPGen to be somewhat more streamlined than the method in [4]. Additionally, the experiments in [4] involved clustering four standard benchmark problems: Indset, Setcover, Cautions, and Facilities. Since these MIP benchmark problems have clear definitions and distinct differences, differentiating between them is relatively straightforward. The MIP instance clustering experiment in MIPGen utilizes the MIPLIB benchmark [6], which includes 240 complex, real-world MIP problems of significant research value. As the MIPLIB benchmark lacks an official classification, we validated whether MIPGen's clustering method could categorize problems from the MIPLIB benchmark with similar sources and descriptions into the same group. Furthermore, we have included visualizations of the intermediate results of clustering the MIPLIB benchmark in our paper. For details on the clustering experiments, please refer to Appendix B of our paper.\n\nMoreover, [5] explores a method for computing similarities between MIP problems. It proposes representing MIP problems based on the structure of their coefficient matrices, depicting the positions of non-zero elements in these matrices as 640x480 black and white images. These feature images are then trained using a VAE, with the distance between the feature vectors of different problems output by the VAE representing their similarity. We believe that [5]'s method loses important information such as the MIP problem's RHS, optimization objective coefficients, and values of non-zero elements in the coefficient matrix. In contrast, the clustering method for MIP problems in MIPGen, which employs VGAE to directly represent the encoded bipartite graphs, is a straightforward and effective approach."
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2681/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700731768445,
                "cdate": 1700731768445,
                "tmdate": 1700731768445,
                "mdate": 1700731768445,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "Oz44xvSLNO",
            "forum": "YhwDw31DGI",
            "replyto": "YhwDw31DGI",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2681/Reviewer_yz8X"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2681/Reviewer_yz8X"
            ],
            "content": {
                "summary": {
                    "value": "This paper introduces a new generative framework for autonomous MIP instance generation, which can autonomously produce isomorphic\nMIP problems from existing instance, and this will effectively enhance the solution effect of the ML-based framework for solving MIP problems."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "This paper is the first one to propose a deep generative model designed to generate isomorphic MIP instances, which facilitates the ML-based frameworks to solve large-scale MIP problems. Extensive numerical experiments also validate the effectiveness of the proposed framework. Overall I find the work presented in this paper is very original and appears to have high quality, the contribution is also fundamental since the framework does not reply on the particular MIP problem or the ML-based MIP solving framework."
                },
                "weaknesses": {
                    "value": "I find that authors can do a better job in introducing the setup, analysis and discussion for the experiments. More detailed questions are listed in the next section."
                },
                "questions": {
                    "value": "Minor questions/comments:\n1. Beginning of Section 2: a_ij should denote \"the participation of the j-th decision variable in the i-th constraint\"\n2. Equation (3): second h^i_x should be h^j_y\n3. In Table 3, MVC column, MIPGen-100% also has better result than the baseline, since here MVC is a minimization problem\n4. Section 4.2, \"suggests that the generated scaling instances closely match those of the large-scale training dataset\". I cannot tell.\n\nMain questions/comments:\n1. In the experiment section, one of the main target should be to examine whether the generated MIP instances still preserve the combinatorial structure of MIS, CA, and MVC. The approaches you mentioned like MIP solver performance, graph statistics can give good estimation, but more importantly, is there any way to directly verify if the generated MIP instances are still also MIS, CA, or MVC? I believe that some auxiliary polynomial time algorithms can be given to check if a MIP instance is the MIP formulation of MVC (or MIS, CA). Then you can run the algorithm over all MIP instances, and report the percentage of generated instances that still preserve the exactly combinatorial structure of the benchmark problems.\n2. In table 3, here you are comparing the objective value of the best available solution within a fixed time limit. Have you tried comparing the solving time to reach optimality?\n3. Section 4.1.1. \"Our experiment confirms that the generated MIP in stances have similar solving difficulty to the original input problem\": I'm not sure about that. As far as I can see, the solving difficulty of the original input problem is not similar to the 100% version. \n4. Section 4.1.1. \"as the reconstruction percentage surges, more and more math structures in the problem are destroyed.\" Here you make the assumption that, more math structures will increase the solving difficulty of the MIP problem. However, this is not necessarily true. Adding constraints with random non-zero coefficients at every variable can also significantly increase the solving difficulty but it has no math structure as well."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2681/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698640759792,
            "cdate": 1698640759792,
            "tmdate": 1699636209080,
            "mdate": 1699636209080,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "Ccwnvwj18e",
                "forum": "YhwDw31DGI",
                "replyto": "Oz44xvSLNO",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2681/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2681/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Reply to reviewer yz8X"
                    },
                    "comment": {
                        "value": "We sincerely thank Reviewer yz8X for their positive feedback and valuable suggestions! We have corrected all the errors pointed out in the \"Minor questions/comments\" section. For the other issues, below we address every comment in detail:\n\n>1. In the experiment section, one of the main target should be to examine whether the generated MIP instances still preserve the combinatorial structure of MIS, CA, and MVC. The approaches you mentioned like MIP solver performance, graph statistics can give good estimation, but more importantly, is there any way to directly verify if the generated MIP instances are still also MIS, CA, or MVC? I believe that some auxiliary polynomial time algorithms can be given to check if a MIP instance is the MIP formulation of MVC (or MIS, CA). Then you can run the algorithm over all MIP instances, and report the percentage of generated instances that still preserve the exactly combinatorial structure of the benchmark problems.\n\nOur MIPGen is currently based on a split-merge process framework. Throughout this process, no new variables or constraints are introduced, nor are new features generated. For the problem classes MIS, CA, and MVC, we can assure that the generated problems remain within their original categories. Taking the MIS problem as an example, the process of MIPGen generating new problems is akin to altering the positions of non-zero elements in the problem's coefficient matrix. For the original problem, this equates to redistributing the constraints of all vertices in the MIS problem graph.\n\nAdditionally, our current method for verifying the type of generated problems involves re-encoding these problems using the VGAE encoder and then re-clustering their encoded representations to confirm whether they belong to the same category as the original training problems. This approach is more universally applicable, as for other real-world MIP problems, not just standard benchmark problems, it is challenging to find a polynomial-time algorithm that can verify their category.\n\n>2. In table 3, here you are comparing the objective value of the best available solution within a fixed time limit. Have you tried comparing the solving time to reach optimality?\n\nThe reason for not providing complete solving times in our experimental data is due to the selection of benchmark problems like the MIS problem, which are NP-hard and cannot be optimally solved in a short time. In our trials using SCIP to solve MIS problems from our dataset (10,000 variables, 30,000 constraints), we did not obtain an optimal solution even after 24 hours. Therefore, we chose a relatively reasonable wall time of 1200s to compare the optimal gap and demonstrate the problem-solving difficulty.\n\n>3. Section 4.1.1. \"Our experiment confirms that the generated MIP in stances have similar solving difficulty to the original input problem\": I'm not sure about that. As far as I can see, the solving difficulty of the original input problem is not similar to the 100% version.\n\nThank you for the suggestion. In the newly submitted paper, we have revised the corresponding statement at section ^xx^ to \"Our goal is to generate problem instances with similar solving difficulties as much as possible.\"\n\n>4. Section 4.1.1. \"as the reconstruction percentage surges, more and more math structures in the problem are destroyed.\" Here you make the assumption that, more math structures will increase the solving difficulty of the MIP problem. However, this is not necessarily true. Adding constraints with random non-zero coefficients at every variable can also significantly increase the solving difficulty but it has no math structure as well.\n\nOur conclusion is a preliminary one based on observations from the experimental results presented in the paper. Indeed, there are cases where solving difficulty increases without the generation of complex mathematical structures. We plan to further analyze and research this phenomenon in future work on other problems."
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2681/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700731677217,
                "cdate": 1700731677217,
                "tmdate": 1700731677217,
                "mdate": 1700731677217,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "GKNOg1ZzXk",
            "forum": "YhwDw31DGI",
            "replyto": "YhwDw31DGI",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2681/Reviewer_XqyP"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2681/Reviewer_XqyP"
            ],
            "content": {
                "summary": {
                    "value": "The paper describes MIPGen, a generative model for Mixed Integer Programming (MIP) instances that can autonomously produce isomorphic MIP problems from existing instances. MIPGen's three-stage problem generation process includes instances classification, node splitting and merging, and scalable problem construction. The authors evaluate MIPGen on three standard MIP instances and demonstrate that it can efficiently learn problem characteristics and produce high-quality isomorphic instances. Moreover, MIPGen introduces a novel approach for ML-based frameworks to transcend limitations imposed by training data. The paper concludes that MIPGen can help overcome the challenges faced by ML-based frameworks in acquiring sufficient isomorphic instances for practical training."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. Novelty: The paper introduces a novel generative framework for autonomous MIP instance generation, which can produce isomorphic MIP problems from existing instances.\n\n2. Three-stage problem generation: MIPGen's three-stage problem generation process is well-designed and effective, including instances classification, node splitting and merging, and scalable problem construction."
                },
                "weaknesses": {
                    "value": "1. Limited evaluation: While the authors evaluate MIPGen on three standard MIP instances, they do not provide more specific examples of how MIPGen has been used to generate scalable MIP instances or the exact results of these experiments beyond what is mentioned in the paper.\n\n2. Lack of comparison: The authors do not compare MIPGen with other generative models for MIP instances, which limits the ability to assess its relative performance.\n\n3. Lack of implementation details: The paper does not provide detailed implementation information, which may make it difficult for others to replicate the results or build on the proposed framework."
                },
                "questions": {
                    "value": "1. What is the purpose of using the EM algorithm? Why not choose other clustering algorithms? The EM assumes the cluster is based on Mixture Gaussian, which may not be the real representation. How about the spectral clustering? How do you choose the number of clusters? How do you know the clustering result is perfect? What are your criteria? \n\n2. It looks like 240 cases is a really small dataset for training deep neural networks. What is the hyperparameter for the VGAE model?\n\n3. It is not clear in the paper how algorithm 1 converts the bipartite graph into a tree structure.\n\n4. What is the purpose of using GBDT?\n\n5. What is NNZ in Table 6"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission2681/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2681/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2681/Reviewer_XqyP"
                    ]
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2681/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698790436021,
            "cdate": 1698790436021,
            "tmdate": 1699636209006,
            "mdate": 1699636209006,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "ZWFaY6TKhG",
                "forum": "YhwDw31DGI",
                "replyto": "GKNOg1ZzXk",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2681/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2681/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Reply to reviewer XqyP"
                    },
                    "comment": {
                        "value": "Thank you for your constructive comments and suggestions, which have greatly aided in enhancing the quality of our paper. We have diligently integrated your feedback into the revised manuscript. Below, we restate your comments and provide our detailed responses:\n\n>1. Limited evaluation: While the authors evaluate MIPGen on three standard MIP instances, they do not provide more specific examples of how MIPGen has been used to generate scalable MIP instances or the exact results of these experiments beyond what is mentioned in the paper.\n\nThe experiments for generating scalable MIP instances are detailed in Section 4.2 of the paper, where we demonstrate that the generated large-scale MIP problems present increased solving difficulty.\n\n\n>2. Lack of comparison: The authors do not compare MIPGen with other generative models for MIP instances, which limits the ability to assess its relative performance.\n\nThank you for your recommendation. We have now included a baseline comparison with the method outlined in [1]. Our model is compared against this baseline in terms of problem-solving difficulty, problem similarity, and data augmentation experiments. Please refer to Section 4.1.2 of the revised paper for further details.\n\n>3. Lack of implementation details: The paper does not provide detailed implementation information, which may make it difficult for others to replicate the results or build on the proposed framework.\n\nThe paper is currently under blind review. Upon acceptance, we plan to open-source our code.\n\n>4. What is the purpose of using the EM algorithm? Why not choose other clustering algorithms? The EM assumes the cluster is based on Mixture Gaussian, which may not be the real representation. How about the spectral clustering? How do you choose the number of clusters? How do you know the clustering result is perfect? What are your criteria?\n\nThank you for highlighting this issue. In MIPGen, the method for clustering MIP problems is divided into two stages: first, a Variational Graph Auto-Encoder is trained to extract feature representations of the MIP problems, followed by the use of the Expectation-Maximization algorithm to cluster these feature representations. We opted for the EM algorithm because its Gaussian Mixture Model is well-suited for adapting to clusters of complex shapes and is easily applicable to large datasets. Moreover, spectral clustering is quite sensitive to outliers in the input data. The MIPLIB benchmark, which includes a diverse range of real-world problem scenarios and varying scales, contains numerous outliers in its problem representations, thus making spectral clustering a less favorable option for us at this time.\n\nThe MIP instance clustering experiment in MIPGen uses the MIPLIB benchmark [2], comprising 240 complex, real-world MIP problems of significant research value. However, for a mixed set of training instances, it is not practical to assume that the value of 'k' (number of clusters) is pre-known. In our clustering experiment with MIPLIB, we set the number of clusters to 100, approximately corresponding to the types and number of problems in MIPLIB. As there is no official classification in the MIPLIB benchmark, we validated whether MIPGen's clustering method could categorize problems from the MIPLIB benchmark with similar sources and descriptions into the same group. Additionally, we have included visualizations of the intermediate results of clustering the MIPLIB benchmark in our paper. For more details on the clustering experiments, please refer to Appendix B of our paper.\n\n>5. It looks like 240 cases is a really small dataset for training deep neural networks. What is the hyperparameter for the VGAE model?\n\nThe dataset for clustering MIP problems comprises only 240 problems, as it utilizes the benchmark set from MIPLIB. The hyperparameters for our VGAE model are as follows:\n\n| in_channels | hidden_channels | out_channels | epoch | batch_size | lr   |\n| ----------- | --------------- | ------------ | ----- | ---------- | ---- |\n| 8           | 32              | 16           | 10    | 8          | 0.01 |\n\n\n>6. It is not clear in the paper how algorithm 1 converts the bipartite graph into a tree structure.\n\nAlgorithm 1 converts the bipartite graph into a tree-like structure by selecting the node with the highest degree for node splitting. This process is repeated until the number of edges equals the number of nodes. We have also updated the pseudocode for Algorithm 1 in the paper to enhance clarity.\n\n>7. What is NNZ in Table 6\n\nNNZ stands for 'Number of Non-Zero', referring to the count of non-zero elements in the coefficient matrix of the MIP problems.\n\n\n**Reference**\n\n[1] Bowly, S., Smith-Miles, K., Baatar, D., & Mittelmann, H. (2020). Generation techniques for linear programming instances with controllable properties.\u00a0_Mathematical Programming Computation_,\u00a0_12_(3), 389-415.\n\n[2] https://miplib.zib.de/tag_benchmark.html"
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2681/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700731606375,
                "cdate": 1700731606375,
                "tmdate": 1700731606375,
                "mdate": 1700731606375,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "LsMEwjkLld",
            "forum": "YhwDw31DGI",
            "replyto": "YhwDw31DGI",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2681/Reviewer_Y5jX"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2681/Reviewer_Y5jX"
            ],
            "content": {
                "summary": {
                    "value": "The paper provides an MIP instance generation method. Bipartite graph embedding is used with VGAE and EM algorithms for instance classification. Node splitting and merging are used to generate isomorphic MIP problems, which is also applicable to generate scalable MIP instances. Experiments are conducted to assess the graph modularity and optimality gap, indicating the preservation of MIP properties by the generation method."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "It is an interesting research to generate similar instances given limited instances. The augmented instances can be used to assist in the machine learning framework which needs considerable data for training. The proposed techniques borrow the current bipartite graph neural network, GVAE and self-supervised learning, which are sound for learning representations of instances."
                },
                "weaknesses": {
                    "value": "The description is not very good in this paper with some parts not explained well. The definition of graph modularity is not given and commonly used metrics for fidelity are not introduced. The infeasibility of instances are not well addressed. It is not clear what ML-based framework is used in experiments to evaluate the  MIPGen and how it works. The details are important to get insights on the effect of the generated data in improving the ML models.\n\nAdditionally, the experiments are not enough to verify the significance of MIPGen. First, only graph modularity may not be sufficient to gauge the graph fidelity and more metrics are necessary to ensure a comprehensive similarity comparison. Second, the whole MIPGen are complex with many heavy modules. The simple instance generation ought to be compared to underscore the effect of MIPGen. For example, simply fitting the degrees and parameters in instances into a distribution that may be already enough to generate new instances.\n\nThe key techniques in this paper are not novel. The bipartite graph neural network still follows an early work, which can not well differentiate the integer and continuous variables. Moreover, there is no MIP but only IP instances in MIS, CA, MVC. GVAE and EM with GMM are also not new. It would be more convincing if authors show the intermediate outputs in the MIPGen like the clustered instances by EM and latent representations learned by GVAE, to showcase the effects of the chosen techniques."
                },
                "questions": {
                    "value": "1. Given the excerpt \"As a lossless representation for MIP instances (Gasse et al., 2019), Bipartite Graph Representation (BGR) seamlessly transforms MIP instances into bipartite graphs...\", can authors explain why the bipartite graph embedding in (Gasse et al., 2019) is lossless? Is there any proof for that?\n2. During node merging, the authors claim \"the feature set $A_i$ or $B_j$ of the newly merged node is randomly selected from one of the two nodes being merged.\" Can random selected features cause infeasible instances? I didn't see any description about how the infeasibility is avoided.\n3. In section 4.1.3, only 20 instances can increase the performance a lot. Does it mean the original training dataset is small? If so, how to train the heavy modules in MIPGen like GVAE, BGR? On the contrary, if the training instances are sufficient, is MIPGen still useful?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission2681/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2681/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2681/Reviewer_Y5jX"
                    ]
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2681/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699391329184,
            "cdate": 1699391329184,
            "tmdate": 1699636208925,
            "mdate": 1699636208925,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "NkENNLaWbZ",
                "forum": "YhwDw31DGI",
                "replyto": "LsMEwjkLld",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2681/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2681/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Reply to reviewer Y5jX (1/2)"
                    },
                    "comment": {
                        "value": "Thank you for your constructive comments and suggestions, which have been exceedingly helpful in improving our paper. We have carefully incorporated them into the revised manuscript. Below, we restate your comments followed by our detailed responses:\n\n>1. The definition of graph modularity is not given and commonly used metrics for fidelity are not introduced.\n>2. Additionally, the experiments are not enough to verify the significance of MIPGen. First, only graph modularity may not be sufficient to gauge the graph fidelity and more metrics are necessary to ensure a comprehensive similarity comparison.\n\nWe appreciate your insightful suggestion! We have now included additional experiments focusing on problem similarity. Alongside the original structural evaluation metrics, we have introduced new metrics such as coefficient density, node degree distribution, and the distribution of LHS/RHS. These metrics further assess the similarity between newly generated and original problems. For detailed information, please refer to section 4.1.2 of the updated paper.\n\n>3. The infeasibility of instances are not well addressed.\n\nOur paper's primary innovation lies in expanding the scale of generated problems. To achieve this objective, we implemented a split-merge strategy. While this approach, involving random splitting and merging, may lead to the creation of infeasible instances, it's noteworthy that all instances generated for this study were feasible. We recognize the potential for generating infeasible instances and intend to incorporate MILP duality in our future research to ensure the feasibility of generated problems. Additionally, it's important to note that infeasible problems can also be valuable. For instance, the MIPLIB benchmark includes several infeasible problems which require solvers to spend a considerable amount of time to determine their infeasibility. Your insightful advice is greatly appreciated.\n\n>4. Given the excerpt \"As a lossless representation for MIP instances (Gasse et al., 2019), Bipartite Graph Representation (BGR) seamlessly transforms MIP instances into bipartite graphs...\", can authors explain why the bipartite graph embedding in (Gasse et al., 2019) is lossless? Is there any proof for that?\n\nThe term \"lossless\" in this context means that the bipartite graph representation retains all information contained in a MIP problem. This representation is lossless because the nodes on each side of the bipartite graph encapsulate all information of the variables and constraints of the MIP problem, while the edges represent the coefficient matrix.\n\n>5. It is not clear what ML-based framework is used in experiments to evaluate the MIPGen and how it works.\n\nAs mentioned in section 4.1.3 of the paper, we utilized the framework described in [1] for our data augmentation experiments related to ML-based solutions.\n\n>6. The simple instance generation ought to be compared to underscore the effect of MIPGen. For example, simply fitting the degrees and parameters in instances into a distribution that may be already enough to generate new instances.\n\nThank you for your recommendation. We have included a baseline comparison with the method described in [3]. Our approach has been contrasted with this baseline in terms of problem-solving difficulty, problem similarity, and data augmentation experiments. For more details, please refer to section 4 of the updated paper."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2681/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700731308693,
                "cdate": 1700731308693,
                "tmdate": 1700731308693,
                "mdate": 1700731308693,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "IL0GyRquy0",
            "forum": "YhwDw31DGI",
            "replyto": "YhwDw31DGI",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2681/Reviewer_si4d"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2681/Reviewer_si4d"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes a MIP instance generation method. It first clusters the MIPs, and applies the node splitting-and-merging process. It also proposes to concatenate tree structures to get larger problems. Experiments show that the generated MIPs are similar to the original ones and can enhance the solution effect of the ML-based framework."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1. This paper successfully applies the split-and-merge process, which was originally for generating SATs, for generating MIPs.\n1. It can control the size of the new MIP instances."
                },
                "weaknesses": {
                    "value": "1. The method is an application of existing SAT generation method into MIPs. The novelty design for MIPs is not sufficient.\n1. In the split-and-merge process, the constraints and varaiables features are not newly generated. So it is more appropiate for generating SATs instead of MIPs.\n1. The considered graph statistics are only for structures, but not for coefficients. So the authors should consider new metrics for MIPs instead of SATs.\n1. The authors may want to add some baselines to demonstrate the effectiveness.\n1. A recent work [1], which appears in NeurIPS2023, also uses deep learning to generate MIPs. So this paper is not the first one for this topic.\n\n\n[1] [https://arxiv.org/pdf/2310.02807.pdf](https://arxiv.org/pdf/2310.02807.pdf)"
                },
                "questions": {
                    "value": "1. How to generate new node features and edge coefficients?\n1. Among the considered three datasets, MIS has all coefficients as 1, so it can be learned by the split-and-merge method like SAT problems. Do the other datasets have this characteristic?\n1. How long is the fixed wall time in Table 1? What do not report the solving time of the instances?\n1. What is the meaning of the reconstruction percentage?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission2681/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2681/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission2681/Reviewer_si4d"
                    ]
                }
            },
            "number": 5,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2681/-/Official_Review"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699663129669,
            "cdate": 1699663129669,
            "tmdate": 1699663129669,
            "mdate": 1699663129669,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "JpDYuu8krA",
                "forum": "YhwDw31DGI",
                "replyto": "IL0GyRquy0",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2681/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2681/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Reply to reviewer si4d (1/2)"
                    },
                    "comment": {
                        "value": "Thank you for your constructive comments and suggestions, and they are exceedingly helpful for us to improve our paper. We have carefully incorporated them in the revised paper. In the following, your comments are first stated and then followed by our point-by-point responses.\n\n>1. The method is an application of existing SAT generation method into MIPs. The novelty design for MIPs is not sufficient.\n\nBuilding upon the work in [2], we introduced the split-merge framework to the generation of MIP problems, complemented by data augmentation experiments to validate the efficacy of our method. Furthermore, MIPGen can amalgamate tree-like structures to generate larger-scale MIP problems. This enables the training of ML-based frameworks on smaller MIP problems to solve larger-scale problems of the same type. We plan to explore more complex generation strategies based on the split-merge framework in future work.\n\n>2. In the split-and-merge process, the constraints and variables features are not newly generated. So it is more appropriate for generating SATs instead of MIPs.\n>3. How to generate new node features and edge coefficients?\n\nWhile our current method does not generate new features, it effectively rearranges the bipartite graph structure and splices tree-like structures. This approach perturbs the coefficient matrix and RHS of MIP problems while maintaining characteristics similar to the original problem, thus generating MIP problems akin to those being learned. We will consider the generation of new features in our subsequent work.\n\n>4. The considered graph statistics are only for structures, but not for coefficients. So the authors should consider new metrics for MIPs instead of SATs.\n\nWe appreciate your suggestion! We have added experiments on problem similarity. In addition to the original structural evaluation metrics, we have now employed additional metrics, including coefficient density, node degree distribution, distribution of LHS/RHS to assess the similarity between the newly generated and the original problems. We refer to section 4.1.2 of updated paper for detailed information. \n\n>5. The authors may want to add some baselines to demonstrate the effectiveness.\n\nThank you for your recommendation. We have included the baseline from [3] for comparison. Our method has been compared with this baseline in terms of problem-solving difficulty, problem similarity, and data augmentation experiments. Please refer to section 4 of the updated paper for more details.\n\n>6. A recent work [1], which appears in NeurIPS 2023, also uses deep learning to generate MIPs. So this paper is not the first one for this topic.\n\nAcknowledging the work in [1], MIPGen is indeed not the first to use deep learning for generating MIP problems. However, it's important to note that this paper was released on ArXiv on 2023.10.4, which is after the ICLR submission deadline (2023.9.28). We have adjusted our statements accordingly in the revised paper.\n\n>7. Among the considered three datasets, MIS has all coefficients as 1, so it can be learned by the split-and-merge method like SAT problems. Do the other datasets have this characteristic?\n\nThe datasets we used, namely MIS, CA, and MVC, all have edge weights set to 1. Nevertheless, MIPGen is capable of handling problems with varying edge weights, as the edge weights in the bipartite graph are assigned corresponding coefficients. Additionally, the GNN model used by MIPGen is edge feature-aware."
                    }
                },
                "number": 1,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2681/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700731092616,
                "cdate": 1700731092616,
                "tmdate": 1700731092616,
                "mdate": 1700731092616,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]