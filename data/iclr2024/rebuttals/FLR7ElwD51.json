[
    {
        "title": "Learning Scalable Causal Discovery Policies with Adversarial Reinforcement Learning"
    },
    {
        "review": {
            "id": "S0pjRWAvA5",
            "forum": "FLR7ElwD51",
            "replyto": "FLR7ElwD51",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4466/Reviewer_L2qU"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4466/Reviewer_L2qU"
            ],
            "content": {
                "summary": {
                    "value": "This paper introduces AGCORL, a new method for learning causal graph structures from observational data. Unlike traditional search-based methods, AGCORL focuses on training reusable causal discovery policies that can generalize to larger tasks efficiently. It uses an OL agent to deduce variable order directly from data and an AD agent to enhance the OL agent's generalizability. The paper shows that AGCORL outperforms existing methods in terms of runtime and solution quality through theoretical and empirical evaluations."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "1 poor"
                },
                "strengths": {
                    "value": "- The introduction, related work, and preliminary parts are well organized and clearly conveyed.\n- Using an adversarial RL framework to learn the causal graph from observational data seems relatively novel in this field."
                },
                "weaknesses": {
                    "value": "Starting from section 4, the writing of this paper becomes quite chaotic. The authors did not introduce the technical background of how to combine RL and causal discovery, which left me feeling lost. Many symbols are used without prior definitions. I still do not understand what 'tasks' refers to in this paper."
                },
                "questions": {
                    "value": "- The most important aspect of this paper is the introduction of a method using adversarial samples to guide network training. Furthermore, it designs an AD agent to generate a ground-truth graph used as a reward. However, how can we ensure that the tasks generated by this AD agent are helpful to the learning of the OL agent?\n- In the paper, a combination of adversarial learning and reinforcement learning is used for training. It's well-known that the convergence of these two methods is a significant challenge. Are there any techniques that can help the convergence of the algorithm?\n- The generalizability of DAG learning is a rather werid concept. Why is it that actions can be generalized from a small graph to a larger one? Does this require certain assumptions? Do the causal mechanisms need to be consistent? Can actions learned on linear data be generalized to nonlinear data?\n- In the experimental section, the authors only used 500 observations for 50 nodes and 100 nodes. This setting is somewhat challenging. What if we increase the number of observations? Or reduce the number of nodes?\n- Why wasn't Notears-MLP compared for nonlinear data? In my experience, this method is actually more robust.\n- Do the authors consider this time comparison to be fair? You not only need to find the order but also apply methods like CAM for further pruning. As a DAG learning method, this time also needs to be counted in. Moreover, RL-based methods are indeed quite slow. It would be helpful if the authors could provide some training logs.\n- Maximizing the BIC score to learn a causal graph is theoretically grounded and can ensure identifiability. So, how can the method learned using the AD agent ensure that the ground-truth graph is learnable?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission4466/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission4466/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission4466/Reviewer_L2qU"
                    ]
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4466/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698287485482,
            "cdate": 1698287485482,
            "tmdate": 1700740903454,
            "mdate": 1700740903454,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "bJwxYr4WcH",
                "forum": "FLR7ElwD51",
                "replyto": "S0pjRWAvA5",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4466/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4466/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer L2qU (Part 1)"
                    },
                    "comment": {
                        "value": "We thank Reviewer L2qU for your useful feedback. Please see our responses below. \n\n**Q1:** On the readability of the paper.\n\n**A1:** We apologize for the confusion caused. The concept of 'task' was introduced in section 3 under 'Causal Discovery Task & BIC Score.' Actually, Section 3 provides some background of using RL for causal discovery. We would update our paper to provide more clear and comprehensive background information. Please check the new version of the paper later. \n\n**Q2:** The most important aspect of this paper is the introduction of a method using adversarial samples to guide network training. Furthermore, it designs an AD agent to generate a ground-truth graph used as a reward. However, how can we ensure that the tasks generated by this AD agent are helpful to the learning of the OL agent?\n\n**A2:** Referring to Algorithm 3 (Adversarial Training Framework), the OL agent and the AD agent are trained iteratively. The AD agent's reward is correlated with the OL agent's performance on adversarial tasks it generates at the previous interation. Thus, the AD agent is incentivized to generate challenging tasks that the OL agent struggles with. This adversatial training framework helps to improve the robustness of the OL agent so that it can solve unseen and poteitially larger tasks. \n\nOur experimental results in Table 1&2 also support this: AGCORL, with adversarial training, outperformed CORL-P, which is trained using tasks generated from a non-adversarial prior distribution. \n\n\n**Q3:** It's well-known that the convergence of these two methods is a significant challenge. Are there any techniques that can help the convergence of the algorithm?\n\n**A3:** Thanks for raising this good question. Actually, we implemented a task pool strategy to stablize training (see Figure 1). We found that training the OL agent solely on tasks generated by the AD agent in the last epoch caused instability and forgetting of previously learned DAGs. By creating a task pool that stores all tasks and from which the OL agent samples for training, we significantly stabilized the training process. Figure 4-left illustrates that the training process is successfully stablized.\n\n**Q4:** The generalizability of DAG learning is a rather werid concept. Why is it that actions can be generalized from a small graph to a larger one? Does this require certain assumptions? Do the causal mechanisms need to be consistent? Can actions learned on linear data be generalized to nonlinear data?\n\n**A4:** The concept of generalizability in DAG learning parallels research in combinatorial optimization where a generalizable solver could solve larger problems than that used for training. Even in the context of causal discovery, this concept is not new. For example, existing works use **supervised learning** to train reusable networks for solving larger tasks thank training [1,2,3]. But there is no reusable RL based methods for causal discovery. Our work fills this gap by developing a reusable and generalizable RL policy. Specifically, our work focuses on generalizing from tasks with small DAGs to those with larger DAGs, under the assumption that the local patterns of structures and the underlying SCM are shared between small the larger DAGs. This also aligns with the existing works mentioned above. We will describe the concept of generalization more clearly in the paper. Note that the generalization is not guaranteed if the data distributions are largely different (e.g., data generated under linear SCM and non-linear SCM)."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4466/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700405149001,
                "cdate": 1700405149001,
                "tmdate": 1700405149001,
                "mdate": 1700405149001,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "26Dkt2IB5I",
                "forum": "FLR7ElwD51",
                "replyto": "S0pjRWAvA5",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4466/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4466/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer L2qU (Part 2)"
                    },
                    "comment": {
                        "value": "**Q5:**  Why wasn't Notears-MLP compared for nonlinear data? In my experience, this method is actually more robust.\n\n**A5:** We recognize Notears-MLP[4]'s robustness in certain nonlinear contexts. Yet, we compare our AGCORL with a stronger baseline GraN-DAG [5] in the non-lienar experiments and also use Gaussian process with additive noise to generate the data. GraN-DAG has been proven much more effective than Notears-MLP. According to [5], in terms of SHD metric, GraN-DAG scores significantly better than Notears-MLP (1.7 vs. 12.2 in 10ER1 and 8.3 vs. 32.6 in 10ER4 settings). These results align with our findings, therefore we choose GraN-DAG as the more appropriate and robust baseline in our work.\n\n**Q6:** Do the authors consider this time comparison to be fair? You not only need to find the order but also apply methods like CAM for further pruning. As a DAG learning method, this time also needs to be counted in. Moreover, RL-based methods are indeed quite slow. It would be helpful if the authors could provide some training logs.\n\n**A6:** The run times reported in Table 1&2 are the whole time solving for the tesing tasks, including the pruning procedure. Therefore, we believe this is a fair comparison. \n\nUnlike existing RL methods such as CORL, our method learns a reusable causal discovery policy that requires only one forward inference during testing, which significantly saves time for solving multiple testing tasks. By contrast, non-reusable methods like Notears, Grad-DAG, CAM and CORL involve time-consuming procedures like gradient descent, heuristic and reward-guided searches for each testing task. \n\n\n**Q7:** Maximizing the BIC score to learn a causal graph is theoretically grounded and can ensure identifiability. So, how can the method learned using the AD agent ensure that the ground-truth graph is learnable?\n\n**A7:** Maximizing GTR indeed ensures that the true DAG order is identified. Note that GTR directly counts the reversed edges, so if there are wrong oders in inferred DAG, it will definitely be punished in the GTR score of the inferred DAG. Therefore, GTR is an effective and reliable metric that captures the order correctness of a DAG.\n\nSince the adversarial DAGs are generated by the AD agent during training, we know the ground truth structure of these DAGs and therefore could easily compute the GTR to measure the distance of inferred DAGs and adversarial DAGs.\n\n[1] Li et al. (2020). Supervised Whole DAG Causal Discovery. \n\n[2] Lorch et al. (2022). Amortized Inference for Causal Structure Learning. \n\n[3] Ke et al. (2022). Learning to Induce Causal Structure.\n\n[4] Zheng et al. (2019). Learning Sparse Nonparametric DAGs.\n\n[5] Lachapelle et al. (2020). Gradient-Based Neural DAG Learning."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4466/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700405210639,
                "cdate": 1700405210639,
                "tmdate": 1700405210639,
                "mdate": 1700405210639,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "w2mQNwcLup",
                "forum": "FLR7ElwD51",
                "replyto": "bJwxYr4WcH",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4466/Reviewer_L2qU"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4466/Reviewer_L2qU"
                ],
                "content": {
                    "title": {
                        "value": "Generalizability"
                    },
                    "comment": {
                        "value": "Thank you for your detailed response, which has clarified certain concerns for me.\n\nDespite this clarification, my concern about the generalizability of this method persists. The paper develops a generalizable RL policy on small causal discovery tasks with the goal of scaling up to learn large causal graphs. However, in practical scenarios, we typically lack prior information about the new task. Consequently, the disparity between the learned policy and the actual task remains uncertain. Additionally, the absence of theoretical assurances regarding the recovery of the ground-truth large graph in the presence of varying data distributions raises concerns.\n\nWhile it is reasonable to anticipate that this method could exhibit effective generalization in similar tasks, its practical applicability appears constrained when confronted with novel tasks featuring distribution shifts from the training set. In such cases, the method's utility seems to be limited."
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4466/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700709402137,
                "cdate": 1700709402137,
                "tmdate": 1700709402137,
                "mdate": 1700709402137,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "kY52QJkSHQ",
                "forum": "FLR7ElwD51",
                "replyto": "26Dkt2IB5I",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4466/Reviewer_L2qU"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4466/Reviewer_L2qU"
                ],
                "content": {
                    "title": {
                        "value": "Identifiability"
                    },
                    "comment": {
                        "value": "The identifiability that I said here is about the model identifiability on the new task since the identifiability is quite important for causal discovery."
                    }
                },
                "number": 10,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4466/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700709636810,
                "cdate": 1700709636810,
                "tmdate": 1700709636810,
                "mdate": 1700709636810,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "9ABYfUV8kL",
                "forum": "FLR7ElwD51",
                "replyto": "7JXu9xb41M",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4466/Reviewer_L2qU"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4466/Reviewer_L2qU"
                ],
                "content": {
                    "comment": {
                        "value": "Ensuring model identifiability entails two key aspects: (1) under appropriate assumptions on data distribution, the model can be uniquely determined, either in its true form or within a defined equivalence class; (2) **your proposed method has the capability to accomplish this identification.** My concern is that how your method can ensure to identify the model."
                    }
                },
                "number": 14,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4466/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700739978064,
                "cdate": 1700739978064,
                "tmdate": 1700739978064,
                "mdate": 1700739978064,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "S3gLjOtiCF",
                "forum": "FLR7ElwD51",
                "replyto": "4mVRa8aezl",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4466/Reviewer_L2qU"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4466/Reviewer_L2qU"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for your reply! I'm aware that you utilized the BIC score for agent selection. However, if the top-performing agent struggles to generalize to a new task, your method would fail to find the causal structure for the new task. I recommend incorporating additional related experiments and illustrating this as a limitation of your current method. This would provide a more comprehensive understanding while leaving the theoretical analysis for a future audience capable of handling them."
                    }
                },
                "number": 15,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4466/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700740710029,
                "cdate": 1700740710029,
                "tmdate": 1700740710029,
                "mdate": 1700740710029,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "xVHKMGWII1",
                "forum": "FLR7ElwD51",
                "replyto": "S0pjRWAvA5",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4466/Reviewer_L2qU"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4466/Reviewer_L2qU"
                ],
                "content": {
                    "comment": {
                        "value": "Thanks for your positive response! I decided to increase my score from 3 to 5."
                    }
                },
                "number": 16,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4466/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700740853970,
                "cdate": 1700740853970,
                "tmdate": 1700740853970,
                "mdate": 1700740853970,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "dxHfKlAuac",
            "forum": "FLR7ElwD51",
            "replyto": "FLR7ElwD51",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4466/Reviewer_GfFV"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4466/Reviewer_GfFV"
            ],
            "content": {
                "summary": {
                    "value": "The authors propose AGCORL, an RL based approach to directly output the topological order from an input dataset. The adversarial component generates graphs that are difficult for the ordering agent to learn. The training data is generated from a particular set of SCMs (e.g., linear or GP models)."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "The paper proposes a RL formulation of learning the topological order from an input observational dataset. At each step, the agent takes an action of taking a variable and adding it to the ordered set. The adversarial agent attempts to generate graphs such that the ordering agent achieves low reward. The authors in the experiments show that the agent generalizes to larger graph distributions than in training. They also show that on a real-world protein dataset, they achieve the lowest SHD, showing some promising generalization beyond the training distribution."
                },
                "weaknesses": {
                    "value": "### Clarity\n\nOverall, I found the paper easy to read and follow. However, I think the writing in certain sections can be improved. For example, the related work does not explain the prior works CORL in enough detail. It would be good if the text made more efforts to explicitly distinguish their work from CORL. It is not currently clear to me what precisely the innovation is relative to CORL. Moreover, it would also make it easier to interpret why AGCORL and CORL have such different runtimes.\n\n\n### Experiments\n\nOne weakness in the experiments is that the authors only attempt to test generalization to larger graph instances. However, one limitation of AGCORL is that the training data itself is synthetic (so limited to linear gaussain or GP SCMs). The authors only test on the same SCM distributions. It is not clear what would happen if a different distribution of SCMs arrives at test time (e.g., what if the test SCM used a different GP kernel than during training). In these cases, the baselines might do better. Or what if the graph distribution at test time is not ER or scale-free? More experiments understanding generalization would be useful.\n\nRe metrics:\nSince AGCORL only learns the topological ordering, why don't the authors use metrics that test the how good the ordering is relative to the true ordering? Using variable selection on top of the learned ordering seems to make the results harder to interpret as it is not clear whether the errors are due to the wrong ordering or wrong variable selection.  \n\nRe contribution of the adversarial component:\nIn Fig. 4 left, the authors show the impact of the adverarail training. However, the curves in Fig 4 do not in themselves suggest that adversarial training helps. What would be useful is training AGCORL with and without the adversarial parts and comparing the metrics. What we care about is whether the metrics at test time graphs improve or not.\n\nType in section 5.2: Table 3 -> Table 2."
                },
                "questions": {
                    "value": "Re reinforcement learning formulation:\nCan the authors comment on why they chose to formulate this as an RL problem as opposed to a supervised learning task? The state is a tuple of $ < s^{+}, s^{-} >$ which means that for a given action $a$, the next state can be deterministically computed. This is quite different from a standard RL setup where the states are stochastically generated by the environment using $p(s_{t+1}|s_t, a_t)$. Moreover, you only get a reward after the entire episode ends (i.e., you have the full ordering). So it seems like you could also just treat this is a supervised learning problem where you directly output an ordering. The challenge is probably computing a differentiable loss between the true ordering and predicted ordering. I think many existing losses exist in the literature for this task. Can the authors comment on this? It seems like directly using supervised formulations might be more efficient (since this RL formulation is essentially like zeroth-order optimization to learn the ordering). \n\nRe runtime:\nIn Table 2, why does AGCORL take 11m to run for a 30-node DAG? Whereas in Table 1, it takes 19.2s for a 100-node graph. At inference time, my understanding is that you take the trained policy agent and just take d-steps to compute the ordering. So why is it slower for a 30-node DAG?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4466/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698791753459,
            "cdate": 1698791753459,
            "tmdate": 1699636422201,
            "mdate": 1699636422201,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "riLqx2I1pR",
                "forum": "FLR7ElwD51",
                "replyto": "dxHfKlAuac",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4466/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4466/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response to Reviewer GfFV"
                    },
                    "comment": {
                        "value": "We thank the reviewer for your constructive feedback. Please see our responses below.\n\n**Q1:** Comparing with CORL.\n\n**A1:** While CORL also uses RL for causal discovery tasks, it is not scalable by design. For each given testing task, CORL will run a RL training process to find the optimal causal graph. By contrast, AGCORL uses adversarial tasks generated by the AD agent to learn a policy, which could directly output solutions for a given testing task (possibly larger than the training ones). Thus, since the AGCORL policy is reusable and scalable, it significantly reduces testing time compared to CORL. We will revise the related work section to more explicitly highlight these distinctions and their impact on runtime differences.\n\n**Q2:** On the transferability.\n\n**A2:** We thank the reviewer for raising this valuable question.\nActually, experimental results in Table 6 and Section 5.3 show that AGCORL achieves comparable transferability compared to baselines. However, note that AGCORL focuses on **scalability** (generalization from smaller to larger graphs) and most experiments are designed to justify this point. In addition, it is a common practice in causal discovery to pre-assume some specific SCM types and learn from synthetic data, especially when we do not have any prior knowledge on the testing tasks. However, we aggree with the reviewer that transferability is also an important question to explore. We will leave it for future work.\n\n**Q3:** Why do we use variable selection on the top of the algorithm, instead of directly test how good the ordering is relative to the true ordering? \n\n**A3:** Actually, the mapping from a DAG to its ordering is neither injective nor surjective, meaning multiple correct orderings can exist for a given DAG. Therefore, it is hard to design a metric to directly evaluate the inferred orderings. Therefore, followed by existing works, we first construct fully-connected DAG using the infered orderings and then use standard pruning algorithms to get the final DAG. In practice, the pruning algorithms can work efficiently with only minor mistakes, since the solution space of DAG has been substantially reduced by the infered orderings. By applying a consistent pruning algorithm across all testing methods, the comparision is more fair and reliable. \n\n**Q4:** On the contribution of the adversarial component: In Fig. 4 left, the authors show the impact of the adverarail training. However, the curves in Fig 4 do not in themselves suggest that adversarial training helps. What would be useful is training AGCORL with and without the adversarial parts and comparing the metrics. What we care about is whether the metrics at test time graphs improve or not.\n\n**A4:** Fig 4 illustrates how adversatial training (AD agent) helps to improve the training of the OL agent. The experiments on AGCORL with and without the adversarial parts, as the reviewer mentioned, is shown in Table 1 and Table 2, where the CORL-P is actually AGCORL without adversarial part. To train CORL-P, we sample training tasks from a prior distribution without adversary. The empirical results show that the CORL-P performs worse than AGCORL, which demonstrates the contribution of the adversarial component. We will rename CORL-P as AGCORL-without-AD to avoid the confusion caused. Thanks for pointing out this.  \n\n**Q5:** Why do we use reinforcement learning?\n\n**A5:** Compared with supervised learning based approaches which directly output a DAG solution for a given causal discovery task, RL based methods decompose the solution construction as a sequential decision making process. The decomposition of the task lowers the difficulty of the problem and potentially leads to higher quality of solutions. In addition, deterministic transition and episodic reward are very common in RL environments such as robotics. So this does not weaken the motivation of using RL.  \n\n**Q6:** On the runtime: In Table 2, why does AGCORL take 11m to run for a 30-node DAG? Whereas in Table 1, it takes 19.2s for a 100-node graph. Why is it slower for a 30-node DAG?\n\n**A6:** The runtime difference between a 30-node DAG and a 100-node graph in AGCORL is primarily due to the nature of the data being processed. For nonlinear data, as in the 30-node case, the pruning process is more time-intensive compared to linear data, which is the case for the 100-node graph. Since AGCORL, along with CAM and CORL, first determines the node order and then applies a variable selection algorithm for pruning, the complexity of the data type significantly impacts the overall runtime. Hence, the 30-node nonlinear task requires more time than the 100-node linear task."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4466/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700393280885,
                "cdate": 1700393280885,
                "tmdate": 1700393280885,
                "mdate": 1700393280885,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "GYBibBLGiD",
                "forum": "FLR7ElwD51",
                "replyto": "riLqx2I1pR",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4466/Reviewer_GfFV"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4466/Reviewer_GfFV"
                ],
                "content": {
                    "title": {
                        "value": "Response"
                    },
                    "comment": {
                        "value": "I thank the authors for their response. \n\nRe response to transferability:\nI agree that showing generalizability to larger graphs is valuable, it is only a single axis of generalization. The difference relative to nonparametric causal discovery (like the PC algorithm) is that when you only train on synthetic data, you are (probably) limited to generalizing to the same set of SCMs. So, for example, even if you train on linear SCMs, what would happen if you encounter a linear SCM with different parameters than the one seen in training? It is not clear that the proposed method would work. So it would have been interesting to see more experiments testing various failure modes of this approach.\n\nRe \"Actually, the mapping from a DAG to its ordering is neither injective nor surjective, meaning multiple correct orderings can exist for a given DAG.\"\nI agree that you would have to somehow account for ordering across the MEC. However, it seems like there are many ways to fix this. Quite simply, you could have reported an accuracy metric that denotes whether the ordering is valid for the true DAG or not. \nEquivalently, you could have used an oracle pruner (that prunes using the true d-separations). There are also many metrics that evaluate an estimated ordering against a true ordering (including partial ordering as determined via the MEC). I still think the variable selection makes the results harder to interpret. As you mention in a future response, for nonlinear data, pruning takes a long time and it is not obvious that in these cases the errors are dominated by the wrong ordering."
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4466/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700682384634,
                "cdate": 1700682384634,
                "tmdate": 1700682384634,
                "mdate": 1700682384634,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "QKtL4sdMY6",
            "forum": "FLR7ElwD51",
            "replyto": "FLR7ElwD51",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4466/Reviewer_Wgj3"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4466/Reviewer_Wgj3"
            ],
            "content": {
                "summary": {
                    "value": "The paper proposes an adversarial reinforcement learning framework for causal structure learning named AGCORL. \nAGCORL mutually trains an order learning agent (OL agent) and an adversarial agent (AD agent). \nThe OL agent learns a general policy that infers the causal order of variables, while the AD agent generates challenging tasks for the OL agent. \nThe trained OL agent avoids calculating the computationally expensive Bayesian Information Criterion (BIC score), making it suitable for large-scale tasks. \nExperiments show that the trained OL agent can generalize to new tasks that are different from the tasks used in training."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "- The proposed Ground Truth Reward (GTR) enables AGCORL to efficiently train both agents without calculating the time-consuming BIC score.\n\n- The OL agent shows good scalability ($t$ in Table 2). \nAdditionally, an OL agent trained on one task can transfer to other tasks. \nIn particular, it maintains good performance when transferred to tasks with different noise (Table 5)."
                },
                "weaknesses": {
                    "value": "- The OL agent is trained on synthetic data generated by an explicit Structural Causal Model (SCM).\nTherefore, the OL agent may not be suitable for real-world data tasks where we do not know the mathematical relationship between the variables.\nIn such cases, the authors suggest to use multiple OL agents trained with different function types to infer candidate orderings, and then calculate their BIC score to select the best one (Appendix E). \nHowever, this approach could compromise the fast running time, which is a main advantage of the proposed work.\n\n- The paper lacks theoretical and/or qualitative explanations that compare the BIC score and the newly proposed GTR. \nIt seems important to clarify whether GTR can always be a surrogate for BIC. \nIf so, AGCORL could replace frameworks that calculate the BIC score, even for small-scale tasks. \nIf not, in certain circumstances, it will still be necessary to use BIC score based algorithms, even for large-scale tasks.\n\n- Theorem 1 in Appendix A only shows that a random adversarial agent is the worst for training a generalizable order learning agent. \nIt does not provide any indication of how good the authors' proposed AD agent is. \nFor example, a theoretical analysis revealing how far the proposed AD agent's $\\zeta$ is from 0.5, with some probability, would be helpful."
                },
                "questions": {
                    "value": "- Is there any measure other than the Structural Hamming Distance (SHD) that can distinguish between missing edges and reversed edges? \nThe authors argue that the OL agent is generalizable to large tasks based on the observation that the True Positive Rate (TPR) only decreases slightly (Table 4). \nHowever, in the same table, the SHD increases. \nIf the SHD increases because of a large number of reversed edges, it is difficult to conclude that the OL agent generalizes to large tasks.\n\n- Does AGCORL outperform previous BIC score-based algorithms on small-scale tasks too? \nIf so, can we safely say that AGCORL replaces previous BIC score-based algorithms in all cases?\n\n- For the same $d$ and $\\theta$, how does the time complexity of computing the BIC score differ from that of Algorithm 1?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4466/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698829764070,
            "cdate": 1698829764070,
            "tmdate": 1699636422098,
            "mdate": 1699636422098,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "ntG85ZvryS",
                "forum": "FLR7ElwD51",
                "replyto": "QKtL4sdMY6",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4466/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4466/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We thank Reviewer Wgj3 for your constructive feedback.\n\n**Q1:** Using multiple OL agents compromise the fast running time, which is a main advantage of the proposed work.\n\n**A1:** It is common in literature to assume some specific SCMs and generalize to real-world data, since the variable relationships are usually unknown. Actually, using multiple OL agents to infer candidate orderings is a practical approach to adapt to different real-world data types. While this may increase the computational load, the time complexity for inference remains efficient at $O(ld^2)$, where $l$ is the number of OL agents and $d$ is the task size. This is notably more efficient than other methods with complexities of $\\Omega(d^3)$, especially for large $d$. Thus, our approach maintains a balance between adaptability to real-world data and the advantage of fast runtime, which is a key feature of our method.\n\n**Q2:** Whether GTR can always be a surrogate for BIC.\n\n**A2:** The key difference between GTR and BIC is that the computation of GTR requires ground-truth DAG, which is generated by the AD agent. Of course, in small scale tasks we can also apply AGCORL to achieve competitive performance (see Table 1&2). However, the necessity of appying AGCORL in small-scale tasks is not that significant, because AGCORL is designed for improving scalability. \n\n**Q3:** Theorem 1 in Appendix A only shows that a random adversarial agent is the worst for training a generalizable order learning agent. It does not provide any indication of how good the authors' proposed AD agent is. For example, a theoretical analysis revealing how far the proposed AD agent's $\\zeta$ is from 0.5, with some probability, would be helpful.\n\n**A3:** Since the AD agent's $\\zeta$ is closely related to experimental settings such as the number of nodes and SCMs, we can hardly estimate $\\zeta$ accurately. However, Theorem 1 reveals that improving $\\zeta$ by the AD agent could significantly reduce the number of required training tasks, hence successfully justifies the necessity of using the AD agent.\n\n**Q4:** Is there any measure other than the Structural Hamming Distance (SHD) that can distinguish between missing edges and reversed edges? The authors argue that the OL agent is generalizable to large tasks based on the observation that the True Positive Rate (TPR) only decreases slightly (Table 4). However, in the same table, the SHD increases. If the SHD increases because of a large number of reversed edges, it is difficult to conclude that the OL agent generalizes to large tasks.\n\n**A4:** The increase in SHD with larger graph sizes and more edges is a typical occurrence in causal discovery. To provide a more nuanced perspective, considering normalized SHD (SHD divided by the number of edges) offers a clearer view. This normalized metric exhibits only a slight increase on larger tasks, which is consistent with the changes observed in the True Positive Rate (TPR). This alignment suggests that the increase in SHD does not predominantly stem from a large number of reversed edges, supporting the generalizability of the OL agent to larger tasks.\n\n**Q5:** Does AGCORL outperform previous BIC score-based algorithms on small-scale tasks too? If so, can we safely say that AGCORL replaces previous BIC score-based algorithms in all cases?\n\n**A5:** In our experiments, AGCORL achieves competitive performance to existing BIC score-based algorithms on small-scale tasks (see Table 1&2). However, since the AGCORL is designed to improve scalability, we cannot guarantee that AGCORL outperforms baselines in all small-scale tasks. Therefore, it is more safe to try both algorithms in small-scale tasks and use AGCORL in large-scale tasks where BIC-based algorithms are not applicable.\n\n**Q6:** For the same $d$ and $\\theta$, how does the time complexity of computing the BIC score differ from that of Algorithm 1?\n\n**A6:** In the linear case, computing the BIC score for one node with $n$ parents is $O(n^3)$, making the overall complexity for an order $O(d^4)$. By contrast, Algorithm 1 uses a Transformer model, which has a time complexity of $O(t^2)$ at step $t$, resulting in a total complexity of $O(d^3)$."
                    },
                    "title": {
                        "value": "Response to Reviewer Wgj3"
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4466/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700407746432,
                "cdate": 1700407746432,
                "tmdate": 1700407778937,
                "mdate": 1700407778937,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "gFAYb6czfk",
                "forum": "FLR7ElwD51",
                "replyto": "ntG85ZvryS",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4466/Reviewer_Wgj3"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4466/Reviewer_Wgj3"
                ],
                "content": {
                    "title": {
                        "value": "Thanks"
                    },
                    "comment": {
                        "value": "Thank you for your responses. I will take these into account in the final evaluation."
                    }
                },
                "number": 13,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4466/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700739770977,
                "cdate": 1700739770977,
                "tmdate": 1700739770977,
                "mdate": 1700739770977,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "HTxvF0yiF3",
            "forum": "FLR7ElwD51",
            "replyto": "FLR7ElwD51",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4466/Reviewer_yLLZ"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4466/Reviewer_yLLZ"
            ],
            "content": {
                "summary": {
                    "value": "The paper proposes an adversarial reinforcement learning framework for efficient causal discovery on observational data. The framework consists of two agents, OL (ordering learning) and AD (Adversarial agent), respectively, in a zero-sum setting in which AD is adding the tasks that OL has most room to improve in performance. Authors show both theoretically and empirically that the adversarial agent helps for better generalisability with higher data efficiency, and their approach is comparable or better to the previous approaches."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "-The paper is very well written.  So clarity is in general very good. \n\n- This is a well-defined and a very important area of AI research, hence it is very relevant. \n\n-The approach is interesting and certainly original, and the results are in general promising. Significance is non-trivial although limited (see weaknesses)."
                },
                "weaknesses": {
                    "value": "-Code is not shared so the results are irreproducible. \n\n- So many nodes but so little edges. E.g. Only 2 and 5 Table 1. and 1 to 4 with Table 2. This makes me skeptical about the relevance of the results. (See questions)\n\n-   the construction of adversarial graph is unclear to me.  Caption of Figure 3 attempts to explain how does it work, but it is not clear to me still. It should be improved. (See the question)  In general would be great to write down the general procedure. (if it's already there, apologies).\n\n\n-It would be good give high level intuition on how the employed pruning algorithm works (especially at the end of the deployment subsection). Currently, just referring to the appendix without sharing the idea obscures it. \n\n\n\nMinor issues: \n\n-  typo at conclusion : AL -> AD"
                },
                "questions": {
                    "value": "-Maybe a silly question but  could you help me understand  Figure 3: how does the action sets and added nodes and the edge works?  (Please also revise the text to make it more clear.)\n\n-So many nodes but so little edges. E.g. Only 2 and 5 Table 1. and 1 to 4 with Table 2. I wonder how does your results are when  it comes to different sparsity, node vs edge is more balanced, or dense?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4466/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699382921961,
            "cdate": 1699382921961,
            "tmdate": 1699636422031,
            "mdate": 1699636422031,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "AbHOFBynh2",
                "forum": "FLR7ElwD51",
                "replyto": "HTxvF0yiF3",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4466/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4466/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Responses to Reviewer yLLZ"
                    },
                    "comment": {
                        "value": "We thank Reviewer yLLZ for your helpful feedback. Please see our responses below.\n\n**Q1:** Code is not shared so the results are irreproducible.\n\n**A1:** We promise to share our code upon acceptance of this paper.\n\n**Q2:** So many nodes but so little edges. E.g. Only 2 and 5 Table 1. and 1 to 4 with Table 2.\n\n**A2:** The term 'edge' in our experiment refers to the average degree of a node in a DAG, not the total edge count. So a 50-node-2-edge graph will have 50*2/2=50 edges in average. We will clarify this by replacing 'edge' with 'degree' in the paper.\n\n**Q3:** The construction of adversarial graph is unclear.\n\n**A3:** In our approach, the construction of adversarial graphs is based on the causal principle that the data of a child node is generated from its parent nodes according to Structural Causal Models (SCMs). The AD agent creates these DAGs where $\\mathbf{a}^i_{adv}$ specifies the parent nodes of the $i+1$-th node. For instance, in Fig 3, $\\mathbf{a}^3_{adv} = {0,1,0}$ indicates that $X_4$ has $X_2$ as its sole parent node. Consequently, the data for $X_4$ is generated using the SCM: $X_4 = f(X_2) + \\epsilon_4$. We apologize for any confusion caused by a labeling error in Fig 3, where $X_4$ was incorrectly marked as $X_2$. We will correct this in the figure caption to enhance clarity. This general procedure of adversarial graph construction underpins our methodology and aligns with established causal principles.\n\n**Q4:** It would be good give high level intuition on how the employed pruning algorithm works.\n\n**A4:** Our pruning algorithm, in essence, constructs a fully-connected DAG and then selectively removes edges to form the final DAG. This process involves evaluating the edge significance (e.g., using regression techniques), with a threshold to determine which edges to be pruned. For linear cases, we simple apply linear regression and a selected threshold (0.3 in our experiments). For nonlinear cases, we use a more complex pruning method outlined in CAM [1]. Since the pruning algorithms are not the focus of this work, we did not elaborate them in our paper. But we will add high-level descriptions of them in the deployment part. Thanks for your advice!\n\n[1] Peter B\u00fchlmann, Jonas Peters, and Jan Ernest. CAM: Causal additive models, high-dimensional order search and penalized regression. The Annals of Statistics, 42(6):2526\u20132556, 2014."
                    }
                },
                "number": 1,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4466/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700208340507,
                "cdate": 1700208340507,
                "tmdate": 1700208340507,
                "mdate": 1700208340507,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]