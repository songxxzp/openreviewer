[
    {
        "title": "FlashAttention-2: Faster Attention with Better Parallelism and Work Partitioning"
    },
    {
        "review": {
            "id": "67qRa7n4yf",
            "forum": "mZn2Xyh9Ec",
            "replyto": "mZn2Xyh9Ec",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4211/Reviewer_Jn9J"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4211/Reviewer_Jn9J"
            ],
            "content": {
                "summary": {
                    "value": "This paper describes FlashAttention-2 which improves upon FlashAttention by introducing \"tweaks\" to improve performance on GPUs.   The paper claims the tweaks improve performance by increasing occupancy and use of matrix-multiply hardware (tensor cores).  The paper reports a bit under $1.3\\times$ wall clock speedup versus FlashAttention."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "Improving training speed of LLMs is of great interest to many."
                },
                "weaknesses": {
                    "value": "Could do a better good job explaining how a given \"tweak\" helps achieve a given improvement (occupancy, use of tensor cores)."
                },
                "questions": {
                    "value": "Regarding the equation at the top of Page 5, I am unclear \"$\\mbox{diag}(l^{(1})^{-1}$\" is to the power -1.  Comparing to the prior equation seems like exponent of -1 should be 1.\n\nI think it would help some readers (like me) understand the contribution a bit better if the paper briefly summarized the key changes in the six (unnumbered) equations on Page 5 that are described as the \"online softmax trick\" versus the six on Page 3.  \n\nHow do the \"tweaks\" in Section 4.1.1 help reduce non-matrixmul FLOPs?  I know a fair amount about tensor cores, but it wasn't obvious to me.\n\nThe paper claims occupancy is increased on Page 6 but it was unclear: (i) what definition of occupancy is being used (GPU resources could mean many things and occupancy often just refers to number of warps that can concurrently run versus max number supported by hardware ); and (ii) whether any measurement has been made to confirm the claimed improvement (e.g., using NVIDIA Parallel Nsight or similar approaches for collecting performance counters).\n\nMuch of Algorithm 1 seems similar to the original FlashAttention.  It may help summarizing which lines are different.  It would also help the reader if there was a summary of which lines lead to the reduction in non-matrixmul FLOPs and improved occupancy.\n\n\"Only at the every end of the\" - typo.\n\nFor the backward pass (Section 3.1.2): It was unclear what the relevance of the paragraph on MQA and GQA is to the changes in FlashAttention-2 versus FlashAttention.  \n\nIn Figure 2, does an uncolored square mean no computation?  Does the backward pass for a given worker start right away or do workers need to synchronize between forward and backward pass?  Do you not need to compute the combined result for the forward pass before you can start the backward pass?    If you do need to wait, then how can one achieve greater than 50% use of peak performance if roughly half the compute cycles are spent waiting for the longest running forward/backward pass thread block to complete?   If you don't need to wait, why not?\n\nI'm not sure how to relate Figure 3 to Algorithm 1 (i.e., which lines it is meant to illustrate).  From the two paragraphs above Figure 3 I get it there are two potential sources of reduced execution time: fewer shared memory accesses and fewer synchronizations (__syncthreads, I assume).  Unclear which of those matters most and why given that shared memory accesses proceed about as fast as register file accesses and synchronization with a thread block is low overhead.  \n\nWhy is FlashAttention (version 1) missing in Figure 5?\n\nAs someone who knows GPUs well, I would have liked to see more performance counter data to backup the claims of the sources of performance improvements.   I understand space is limited in the main text, but in checking the supplemental material, while it is great to see all the code, there appeared to be no PDF providing additional data or details.  Including one might have helped."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "Yes, Other reasons (please specify below)"
                    ]
                },
                "details_of_ethics_concerns": {
                    "value": "Hard to say this submission conforms to double blind review standards given the title of the paper strongly suggests author overlap with the prior FlashAttention work.   Given the nature of unconscious bias, I cannot say whether this may have influenced me and if so how (which is the whole purpose of using double blind review)."
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission4211/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission4211/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission4211/Reviewer_Jn9J"
                    ]
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4211/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699074515782,
            "cdate": 1699074515782,
            "tmdate": 1699636388262,
            "mdate": 1699636388262,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "km6u2mfSLE",
                "forum": "mZn2Xyh9Ec",
                "replyto": "67qRa7n4yf",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4211/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4211/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Reponse"
                    },
                    "comment": {
                        "value": "Thank you for the constructive feedback to help improve our work!\n\nQ: How does the tweaks reduce non-matmul FLOPs.\n\nA: The amount of matmul FLOPs stay the same (e.g. Q @ K^T and attn_prob @ V). However, FlashAttention incurs more vector flops to rescale the output (equation at bottom of page 4): extra divisions by l^2 on both terms. FlashAttention2 gets rid of this division (top equation at top of page 5).\n\nIn addition, masking (non-matmul operation) is only done to 1 block and not every blocks, again reducing non-matmul FLOPs so that most of the time is spent on matmul FLOPs accelerated by tensor cores.\n\nThese changes generally reduce register pressure as an added benefit.\n\nQ: Figure 2, does an uncolored square mean no computation?\n\nA: Yes, we skip those blocks since they don't contribute to the outputs (i.e. masked out) any way.\n\nQ: backward pass synchronization with forward pass.\n\nA: The backward pass is done separately from the forward pass, so there's no overlap between them. As an example, in the model forward pass, the attention and MLP forward pass are performed, then we calculate a loss function, which then gives a gradient that gets propagated to the MLP backward pass and then attention backward pass.\n\nQ: Figure 3.\n\nA: Thanks for this clarification, we will add this to the paper. Figure 3 corresponds to line 8 and 10 in Algorithm 1: matmul Q K^T and matmul P V. Figure 3 illustrates how to map these matrix multiplications to 4 warps in the same threadblock.\n\nQ: FlashAttention in Figure 5.\n\nA: For decoding with long sequences, FlashAttention is actually slower than Pytorch due to lack of parallelism. As a result FlashAttention was only used for prompt processing (prefill) and not decoding (KV cache). FlashAttention-2 now speeds up both prompt processing (prefill) and decoding.\n\nWe will add this note to the paper.\n\nQ: performance counter data.\n\nA: Thanks for this great suggestion. We will add this to the paper to help clarify the effectiveness of our approaches."
                    }
                },
                "number": 13,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4211/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700741652075,
                "cdate": 1700741652075,
                "tmdate": 1700741710743,
                "mdate": 1700741710743,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "UmS7FpjK6j",
            "forum": "mZn2Xyh9Ec",
            "replyto": "mZn2Xyh9Ec",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4211/Reviewer_hPzR"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4211/Reviewer_hPzR"
            ],
            "content": {
                "summary": {
                    "value": "The authors present a new algorithm, FlashAttention-2, which builds in FlashAttention to improve the efficiency of the attention algorithm when executed on GPUs. The authors focus, in particular, on maximizing the amount of time spent in \"matrix-multiply\" FLOPs, that is, computation that is using matrix multiplication units, which are better lent to GPU hardware given particular division of work amongst warps and loose requirements around shared memory accesses.\n\nThese optimizations include:\n1. Deferring scaling of values in the online softmax computation to further reduce HBM utilization\n2. Save a logsumexp for online softmax backwards rather than max and sums to reduce the memory usage.\n3. The bulk of the changes present in FlashAttention-2 are related to scheduling. Parallelization over the sequence dimension results in better warp occupancy in cases where there are few attention heads or a low batch size. Further, the authors change how the backward pass shares computation in the query derivative update, which also reduce HBM utilization. Splitting the KV cache amongst thread blocks also helps to saturate memory bandwidth. Better partitioning amongst warps, overall, drives better utilization."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "- The proposed approach shows promising improvements in a performance-critical parts of end-to-end transformer computation.\n- The approach is symmetrically applicable for both training and inference with broad applications in both research and production settings.\n- It is important that engineering contributions such as FlashAttention-2 (which I will refer to FA-2) are part of conference literature, and the attention to detail therein is what drives the solid impact of this work rather than a special \"algorithmic contribution\" in a classical sense.\n- The devil is in the details: careful analysis of scheduling and an intuitive approach to laying out computation drives the approach's strong results.\n- The work builds on an already-strong baseline, FlashAttention.\n- The paper is well-written and organized and clearly lays out the authors' contributions; in particular, the paper is quite accessible to those without a low-level background in machine learning computation or GPU programming."
                },
                "weaknesses": {
                    "value": "- The baselines benchmarked in the paper can be stronger.\n  - For latency benchmarks in Figure 5, the only baselines are a FasterTransformer and PyTorch. The authors do not consider compilers\n  - Do the PyTorch benchmarks in Figure 5 use CUDA Graphs? PyTorch has significant framework overhead, and CUDA Graphs can give an order of magnitude speedup for some workloads, especially latency-sensitive ones.\n- The above applies more generally to the other evaluation in Section 4; FlashAttention-2 is compared to PyTorch, then implementations with Triton and Cutlass, but not with any other frameworks capable of code generation. For example: while XLA may not be memory-bandwidth-aware by default, it can still generate kernels with fused operators that significantly reduce total memory I/O.\n- While not needing to resort to approximations is a significant advantage of FlashAttention-2, this could be highlighted much more in the manuscript. Section 1 discusses many alternative attention approximations -- even speculation about why these aren't used (i.e. they are riskier when researchers have limited resources and don't adapt as easily) would strengthen the exactness boon of the authors' approach.\n\nSeveral improvements to writing might improve the paper:\n- The constant and equation in general in Sections 4.1 (i.e. 4) is not adequately explained (why is the sequence length squared? why 4?). Clarifying these might help new readers.\n- The usage of \"major problem\" in the first sentence of the abstract is unclear -- it's clear that scaling sequence lengths is difficult; are the authors suggesting the problem is difficult, significant, or both?\n- Section 1: \"However, context length increases\" <-- is missing \"**as** context length increases\"\n- Text in all of the provided diagrams can be made clearer, and the diagrams can be rendered more clearly. It is difficult to read them as is.\n- Section 3.2 might more clearly explain \"prefill\" and \"KV cache\" to readers. While somewhat ubiquitously understood amongst people doing performance engineering for large-scale transformers, some clarification would help the paper flow and increase its accessibility.\n- Figure 2 can be clearer with respect to rows and columns -- this is the attention matrix -- what is its size/can the axes be labeled?"
                },
                "questions": {
                    "value": "- Why are the gaps between FA/FA-2 different with Cutlass versus in Triton, if the authors were to speculate? Further, the comparison in section 4.1 can be clarified -- is the assertion that the performance of the vanilla CUDA implementation of FlashAttention and the Cutlass FlashAttention implementation in xformers are congruent?\n- The authors might also consider mentioning in the manuscript what they think trends in changing GPU hardware will mean for FA-2's general direction. Given that HBM bandwidth is not improving as quickly as SM arithmetic latency and that the amount of vram available on GPUs is not increasing, how will the approaches used in FA-2 change in relevance over time?\n- Do you think a compiler could realistically generate FA-2? What sort of cost models might be required?\n- How does FA-2 function when there is no explicit sequence length dimensions? In many training setups, tokens are padded without sequence boundaries, and models learn end-of-sequence tokens implicitly. What is the default behavior in this regime?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission4211/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission4211/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission4211/Reviewer_hPzR"
                    ]
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4211/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699147804403,
            "cdate": 1699147804403,
            "tmdate": 1699636388174,
            "mdate": 1699636388174,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "aJEl0I0mkG",
                "forum": "mZn2Xyh9Ec",
                "replyto": "UmS7FpjK6j",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4211/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4211/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response"
                    },
                    "comment": {
                        "value": "Thank you for the detailed and constructed feedback.\n\nQ: Figure 5 baselines.\n\nA: Here we measure just the attention decoding operation, not the end-to-end latency. We agree that CUDA graph helps end-to-end generation speed, especially for small models where the CPU overhead can be large.\nWe have benchmarked the kernel generated by torch.compile which is faster than Pytorch eager but still not as fast as the hand-written kernel from FasterTransformer. FA2 decoding kernel is faster still.\n\nQ: Comparison to compilers.\n\nA: Compilers can generally perform fusion. However, optimizations that require mathematical rewriting of the same expression (while maintaining numerical stability) are generally harder for compilers. Jax uses the powerful XLA compiler, but currently the best implementation of attention on TPUs is a version of FA2 implemented in Pallas, where the programmer still specifies some details (which elements should be in HBM vs SRAM) leaving the Pallas compiler to generate code to invoke the systolic array for matmuls or vector units for other computation.\n\nQ: gap between different implementations, e.g. xformers, Cutlass, Triton.\n\nxformers uses cutlass to implement a similar algorithm to FA, while Triton generates ptx directly. The differences in speed are due to low-level implementation: e.g. the Triton compiler only deals with power-of-2 block sizes, while with cutlass one can use non-power-of-2 block sizes. The triton compiler will use async memory copy automatically, while with Cutlass one has to spend more effort to use these hardware features.\n\nQ: Change in hardware trend.\n\nThis is a great question. HBM bandwidth not increasing as fast as matmul FLOPs means that techniques such as FA/FA2 will be even more relevant in the future. New hardware features (asynchronous computation, dataflow architecture) might require new ideas to efficiently use the hardware, and is an exciting future area.\n\nQ: FA2 with variable sequence lengths.\n\nFA2 does support variable sequence lengths. Sequences are concatenated with no padding token, with an array indicating the lengths of each sequences. This is convenient for settings where sequences can have different lengths, and avoids wasting computation on padded tokens."
                    }
                },
                "number": 12,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4211/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700740848440,
                "cdate": 1700740848440,
                "tmdate": 1700740848440,
                "mdate": 1700740848440,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "RchnThk41v",
            "forum": "mZn2Xyh9Ec",
            "replyto": "mZn2Xyh9Ec",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4211/Reviewer_RLZf"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4211/Reviewer_RLZf"
            ],
            "content": {
                "summary": {
                    "value": "This paper presents improvements to FlashAttention (Dao et al., 2022), a established method for efficiently computing attention through fused ops. These improvements are designed specifically for better parallelism and work partitioning in GPUs, resulting in the development of FlashAttention v2. Performance benchmarks have been conducted for both training and inference phases. Additionally, the authors provide comprehensive results from training end-to-end GPT-style models with 1.3 billion and 2.7 billion parameters and 2k and 8k context sizes."
                },
                "soundness": {
                    "value": "4 excellent"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "4 excellent"
                },
                "strengths": {
                    "value": "There are many things to like in this paper, such as:\n\n1. The paper is well-written\n2. The improvements are well-explained and justified\n3. The paper covers both training and inference time optimization\n4. The results are encouraging\n\nIn summary, I expect widespread adoption of FlashAttention v2 within the community. Furthermore, the methods proposed and utilized in this paper could inspire the creation of more efficient components in machine learning."
                },
                "weaknesses": {
                    "value": "FlashAttention v2 has a notable limitation: it relies on recent, specialized GPU architectures like the A100 (and H100). Additionally, the requirement for custom CUDA kernels adds a layer of complexity. \n\nA small critique is that Figure 3 could benefit from a more descriptive caption."
                },
                "questions": {
                    "value": "Which GPU architectures currently support FlashAttention v2?\nWhat are the minimum requirements for its use?\nWhat modifications are necessary to adapt FlashAttention v2 for use with relative positional encoding methods (e.g., RoPE and ALiBi)?\nDoes FlashAttention v2 offer compatibility with sparse block masks (as in v1)?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "10: strong accept, should be highlighted at the conference"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4211/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699400339142,
            "cdate": 1699400339142,
            "tmdate": 1699636388113,
            "mdate": 1699636388113,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "y3SNISHOlR",
                "forum": "mZn2Xyh9Ec",
                "replyto": "RchnThk41v",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4211/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4211/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response"
                    },
                    "comment": {
                        "value": "Thank you for the very encouraging feedback!\n\nQ: Which GPUs are supported?\n\nA: FA2 supports Ampere (e.g, RTX 3090, A100), Ada (e.g. RTX 4090), and Hopper GPUs (H100). FA2 has also been independently implemented on TPUs, AMD GPUs, and Intel CPUs. We included more details in the common response.\n\nQ: Relative position encoding support?\n\nRoPE is not technically part of the core attention operation (applied to Q and K before the inner attention). We do provide an optimized (fused) implementation of RoPE as part of the FA2 library. In addition, FA2 now supports ALiBi."
                    }
                },
                "number": 11,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4211/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700740037063,
                "cdate": 1700740037063,
                "tmdate": 1700740037063,
                "mdate": 1700740037063,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "QeaOL3CvbI",
            "forum": "mZn2Xyh9Ec",
            "replyto": "mZn2Xyh9Ec",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4211/Reviewer_AK2B"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4211/Reviewer_AK2B"
            ],
            "content": {
                "summary": {
                    "value": "Scaling Transformers for longer sequences holds the promise of enhancing language modeling and understanding complex inputs, but is hindered by the attention layer's quadratic scaling in memory and runtime. FlashAttention has mitigated this by bringing linear memory usage and considerable runtime speedup, yet it still lags behind the efficiency of optimized matrix multiplication operations. To address this, FlashAttention-2 is introduced with improved work partitioning, yielding a significant speedup and reaching closer to the efficiency of matrix multiply (GEMM) operations. Empirical validation shows that FlashAttention-2 significantly increases the training speed of GPT-style models on both A100 and H100 GPUs."
                },
                "soundness": {
                    "value": "4 excellent"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "* The proposed platform-specific optimizations are clever and sound.\n* The resulting software artifacts are useful and have has the potential to benefit both researchers and practitioners."
                },
                "weaknesses": {
                    "value": "* The work is mostly engineering-focused, with several \"tweaks\" made to FlashAttention.\n* The performance gains are relatively marginal, especially when compared to those of the original FlashAttention over the baseline.\n* The absence of an ablation study makes it difficult to pinpoint the exact sources of efficiency."
                },
                "questions": {
                    "value": "Thank you for submitting to ICLR 2024. FlashAttention-2 is a very useful artifact that has the potential to benefit both researchers and practitioners, and the proposed optimization techniques appear sound.\n\nHere are my questions I would like the authors to answer:\n* Perhaps the most significant omission in this paper is the lack of an ablation study. This makes it challenging to discern the contributions of individual optimizations. Among the proposed optimizations, which one has the highest impact?\n* In Section 3.1, is the technique of skipping blocks for \"causal masking\" also applied to FlashAttention? As the authors mention, this technique can be applied to both FlashAttention and FlashAttention-2, and I am curious about how the application of this technique would affect the performance gap between FlashAttention and FlashAttention-2 if it had not been applied to FlashAttention.\n* In Section 3.3, what is the performance impact of \"tuning block sizes\"? Was the same level of parameter tuning effort applied to FlashAttention? My question concerns the extent to which the performance gains over FlashAttention can be attributed to algorithmic improvements versus additional tuning effort, with the latter being less significant."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4211/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699604636530,
            "cdate": 1699604636530,
            "tmdate": 1699636388057,
            "mdate": 1699636388057,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "RDYyFNyqYk",
                "forum": "mZn2Xyh9Ec",
                "replyto": "QeaOL3CvbI",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4211/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4211/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response"
                    },
                    "comment": {
                        "value": "Thank you for the helpful suggestions on the ablation study to improve the work. We have included such a study in the common response.\n\nQ: The performance gains are relatively marginal, especially when compared to those of the original FlashAttention over the baseline.\n\nA: Attention is now one of the most optimized components as one of the core layers of Transformers training on massive clusters. FlashAttention-2 speeding up attention by up to 2x can directly benefit these large training runs (costing millions of dollars). It can also enable new capabilities such as long context models (for books and code, high-res images, audio signal). It also make it easier to deploy models locally on desktop GPUs or enable research into these models due to faster iteration speed.\n\nQ: Is skipping blocks for \"causal masking\" also applied to FlashAttention?\n\nA: Yes, in our benchmarks, we also apply the same technique to FlashAttention. The difference in speed is due to our 3 contributions.\n\nQ: What is the performance impact of \"tuning block sizes\"?\n\nThis was done at the very end to squeeze out a little more performance, on the order of 5%. It was not done with FlashAttention since its implementation was much more rigid and the block sizes were hard-coded. We do not expect block size tuning to play a major role here."
                    }
                },
                "number": 10,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4211/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700739539062,
                "cdate": 1700739539062,
                "tmdate": 1700739539062,
                "mdate": 1700739539062,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]