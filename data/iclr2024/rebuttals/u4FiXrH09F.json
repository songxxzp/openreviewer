[
    {
        "title": "Implicit Neural Network on Dynamic Graphs"
    },
    {
        "review": {
            "id": "92u91MsmcV",
            "forum": "u4FiXrH09F",
            "replyto": "u4FiXrH09F",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6680/Reviewer_qxmJ"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6680/Reviewer_qxmJ"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes a new graph generative model for dynamic graphs based on implicit neural networks. The proposed method generalizes IGNN to the dynamic graphs, extending its capability to solve a broader range of problems. The well-posedness property has been shown for the proposed model. A bi-level optimization algorithm is developed for an efficient training of the proposed model. With the new training algorithm, the proposed model shows better performances on graph classification and regression tasks than baseline models."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "- This is the first implicit model for dynamic graphs. The experimental results show that the implicit model for dynamic graphs can show better performances than non-implicit models.\n- The proposed bi-level optimization algorithm can reduce the training time while having a competitive performance with the naive gradient descent algorithm."
                },
                "weaknesses": {
                    "value": "- The paper proposes an implicit model for discrete-time *cyclic* dynamic graphs. I assume that the cyclic property is added to obtain the implicit representation of graphs, but the datasets used in the experiments do not have the cyclic property.\n    - Moreover, I doubt that the performance of the synthetic experiments comes from the implicit representation. Since the representation at time step $T$ is directly related to the representation at time step $1$, through the learning (back-propagation) process, the model can directly utilize the information at time step $1$ to infer the class label at time step $T$. Hence, it is unclear whether the long-range dependency is captured correctly or not.\n- The main theorem seems a direct consequence of Gu et al. (2020).\n- The claimed 1600x speed-up seems like an overstatement. Although the proposed algorithm achieves a 1600x speed-up for the Brain10 dataset, the improvement is much lower for the other datasets. Having said that, I found that the improvement from the other datasets is not insignificant (10x improvement is also great).\n    - Moreover, it would be much more meaningful if there were any analysis on why the algorithm performs well on the Brain10 dataset. What characteristics of the dataset lead to such an impressive performance increase?\n- The representation of the manuscript can be improved further. Several notations are confusing, and a few terms are explained without having proper definitions. Here, I list some of them.\n    - The notation $t$ is used for the depth of a layer and the time stamp of a graph (e.g., the first paragraphs of section 3). Although one may infer which t corresponds to which (based on location - superscript for layer and subscript for timestamp), it is difficult to follow the manuscript.\n    - Transpose is denoted with superscript $T$, which is confusing with the timestamp T. Using \\top latex command can alleviate the confusion.\n    - Omega is not defined (Page 3, third line). I guess it means V\n    - \\ell in the equation on page 6 (where \\nabla L(\\omega) is defined) is not defined. So, I couldn\u2019t follow the details after equation 8.\n    - Please add references for datasets.\n    - Use proper command for the citations. Use latex commands \\citet and \\citep for this.\n    - Typo in the first sentence on Page 3 (l and d are both used to denote the dimension of the node attributes).\n    - Typo in the matrix in Theorem 1 (the right-most column needs to be removed)"
                },
                "questions": {
                    "value": "- Why V in equation 2 is shared across time, and W is not?\n- What makes the optimization \u2018bi-level\u2019? It would be better to have some additional background on the bi-level optimization methods."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6680/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698289043295,
            "cdate": 1698289043295,
            "tmdate": 1699636765591,
            "mdate": 1699636765591,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "CmQOWcUaBo",
                "forum": "u4FiXrH09F",
                "replyto": "92u91MsmcV",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6680/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6680/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "To Reviewer qxmj,\n\nWe thank reviewer qxmj for the valuable feedback and recommendations for improving the manuscript.\n\n>\tThe paper proposes an implicit model for discrete-time cyclic dynamic graphs. I assume that the cyclic property is added to obtain the implicit representation of graphs, but the datasets used in the experiments do not have the cyclic property.\n>\tMoreover, I doubt that the performance of the synthetic experiments comes from the implicit representation. Since the representation at time step T is directly related to the representation at time step 1, through the learning (back-propagation) process, the model can directly utilize the information at time step 1 to infer the class label at time step T. Hence, it is unclear whether the long-range dependency is captured correctly or not.\n\nOur model's development hinges on the cyclic property; however, as evidenced by experiments, it demonstrates efficacy on dynamic graphs in general. In response to the reviewer's feedback, we refined our synthetic experiments by shifting label information from time stamp 1 to time stamp 5. This adjustment ensures uniform difficulty in utilizing label information across all models. Implementing this change postpones our method towards achieving 100% accuracy by approximately 50 epochs. However, even with this modification, the baselines still struggle to fit the data. We put the plot in the updated appendix. \n\n\n>\tThe main theorem seems a direct consequence of Gu et al. (2020).\n\nThe main theorem holds due to 1) the well-posedness result from Gu et al. (2020), as mentioned by the reviewer, and 2) the equivalent static representation of dynamic graphs. The contribution of our work lies in providing a framework to apply implicit graph neural network to dynamic graphs and proposing an efficient training algorithm for this problem. As we mentioned in the paper, using the na\u00efve gradient descent (Gu et al. (2020)) to optimize this problem is extremely slow. \n\n\n>\tThe claimed 1600x speed-up seems like an overstatement. Although the proposed algorithm achieves a 1600x speed-up for the Brain10 dataset, the improvement is much lower for the other datasets. Having said that, I found that the improvement from the other datasets is not insignificant (10x improvement is also great).\n>\tMoreover, it would be much more meaningful if there were any analysis on why the algorithm performs well on the Brain10 dataset. What characteristics of the dataset lead to such an impressive performance increase?\n\nThe bilevel algorithm achieves 1600x speed-up on Brain10 because of the number of nodes. Brain10 has 5000 nodes. As we mentioned in the paper, na\u00efve gradient descent has O(n^2) complexity per iteration, while bilevel method admits O(n) complexity. When the graph size is large, the speed-up grows quadratically. We also provided a detailed complexity analysis in the appendix. \n\n> The representation of the manuscript can be improved further. Several notations are confusing, and a few terms are explained without having proper definitions. Here, I list some of them.\n\n\n\nThank you for pointing out, and we will fix them to make it more readable and clearer.\n\n> Why V in equation 2 is shared across time, and W is not?\n\nIn fact, the variable V can be shared, leading to four distinct model configurations depending on whether both V and W are shared or not. It is crucial to emphasize that our convergence theorem is applicable across all these configurations. Our ablation study has revealed that the existing configuration is not only efficient but also competitive. However, it is noteworthy that sharing V may result in significant computational overhead, particularly considering the potential largeness of the original feature dimension.\n\n> What makes the optimization \u2018bi-level\u2019? It would be better to have some additional background on the bi-level optimization methods.\n\nIn Eq (8), we have the upper lever problem (objective), and we also have lower lever problem (constraints). The variables ${z^{(i)}}$ are the optimal solutions to the lower lever problem. Such formulation produces a bilevel optimization problem. Thank you for your suggestion; we will introduce some bilevel optimization background in the related work."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6680/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700587080144,
                "cdate": 1700587080144,
                "tmdate": 1700587080144,
                "mdate": 1700587080144,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "02SptNeE9r",
            "forum": "u4FiXrH09F",
            "replyto": "u4FiXrH09F",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6680/Reviewer_NhSL"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6680/Reviewer_NhSL"
            ],
            "content": {
                "summary": {
                    "value": "This paper focuses on graph learning for dynamic graphs. As the oversmoothing issues and the failure to capture long-range dependencies are more severe on dynamic graphs, the authors propose an implicit graph neural network model to mitigate the issues. To remedy the computationally expensive training issue, they propose a single-loop training algorithm by changing the original optimization problem to a bi-level optimization problem. The experimental results on both classification and regression tasks show the superiority of the proposed model in terms of both performance and efficiency."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. The idea of using implicit GNNs for dynamic graphs is sound and the motivation to mitigate the dilemma between capturing long-range dependencies and suffering from oversmoothing problems is reasonable and interesting. \n2. The construction of the new equation for dynamic graphs in Eq (4) is good and the related theorems are sound. \n3. The performance of synthetic experiments directly supports the claim that the proposed method can avoid over-smoothing and still be effective in capturing long-range dependencies."
                },
                "weaknesses": {
                    "value": "1. To me, the relation between Lemma 2 and the relationship between Lemma 2 and Eq (8) is not very clear. In Lemma 2, how does $M_i$ get involved in the formula about $z_j$. Additionally, Eq (8) suggests that the new constraint is only about the last timestamp. In this case, is it necessary to have Lemma 2 to arrive at Eq (8)? Why cannot directly iterate Eq (5) to have $\\phi(z, W, V; G_i)$. I would like to see more explanations regarding these. \n2. The literature review may not be sufficient. As the paper focuses on implicit GNNs, I think the author may want to introduce and briefly discuss a few more recent implicit GNN works (e.g., CGS [1], EIGNN [2], USP [3]). Especially, USP seems to have a similar bilevel optimization problem, though it focuses on static graphs. \n3. The descriptions for the experiments are not very clear. As mentioned in Table 3, the memory usage and the runtime are reported as per batch. But how batches are formed for a single graph? Randomly select some nodes or use some sampling methods (e.g., neighbor sampling)? \n\nOverall, I think it's an interesting submission. But I hope the authors can clarify some questions I raise here. \n\nReferences:\n\n[1] Park, Junyoung, Jinhyun Choo, and Jinkyoo Park. Convergent graph solvers. ICLR 2022.\n\n[2] Liu, Juncheng, Kenji Kawaguchi, Bryan Hooi, Yiwei Wang, and Xiaokui Xiao. Eignn: Efficient infinite-depth graph neural networks. NeurIPS 2021.\n\n[3] Mingjie Li and Yifei Wang and Yisen Wang and Zhouchen Lin. Unbiased Stochastic Proximal Solver for Graph Neural Networks with Equilibrium States. ICLR 2023."
                },
                "questions": {
                    "value": "1. Although the convergence guarantee is a good thing to see, I am just curious whether this is necessary to make the implicit graph model work well. Based on my understanding, existing implicit GNNs all have this property. In contrast, implicit models in other areas seem not always have this theoretical guarantee (e.g., DEQ [1] and MDEQ). They empirically work well. \n2. Could you explain more about Hassian-vector Product as mentioned in the last paragraph of Sec 4? Can it be directly handled by a modern autodiff package? At least provide some reference materials in the appendix. \n\nMinor ones:\n1. There is no Table 3 caption. Please fix it. \n\n\nReferences\n\n[1] Deep Equilibrium Models. Shaojie Bai, J. Zico Kolter and Vladlen Koltun (NeurIPS 2019)\n\n[2] Multiscale Deep Equilibrium Models. Shaojie Bai, Vladlen Koltun and J. Zico Kolter (NeurIPS 2020)"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission6680/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission6680/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission6680/Reviewer_NhSL"
                    ]
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6680/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698741557180,
            "cdate": 1698741557180,
            "tmdate": 1699636765482,
            "mdate": 1699636765482,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "2WRcQrEYOI",
                "forum": "u4FiXrH09F",
                "replyto": "02SptNeE9r",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6680/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6680/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "To Reviewer NhSL,\n\nWe thank reviewer NhSL for the valuable feedback and recommendations for improving the manuscript.\n\n> 1.\tTo me, the relation between Lemma 2 and the relationship between Lemma 2 and Eq (8) is not very clear. In Lemma 2, how does $M_i$ \n get involved in the formula about $z_j$\n. Additionally, Eq (8) suggests that the new constraint is only about the last timestamp. In this case, is it necessary to have Lemma 2 to arrive at Eq (8)? Why cannot directly iterate Eq (5) to have $\\phi(z,W,V;G_i)$\n. I would like to see more explanations regarding these.\n\nIn Lemma 2, we apply $T$ layers of GCN on $z_j$. When $j+k>T$, we let $M_{j+k}=M_i$ where $i=(i+k) mod T$. We will improve this Lemma and make it more readable.\n\nThe purpose of lemma 2 is to develop an equivalence between the optimization problems in Equations (5) and (8). This allows us to demonstrate that a solution to the problem in Equation (5) is also a solution to the problem in Equation (8). As the reviewer has indicated, we can iterate Eq (5) to obtain function \\phi. Lemma 2 serves as a rigorous certificate that such iterations do not change the problem.\n\nPlease note that the constraint is applied to each time-stamp t in the range 1 to T in Equation (8). This constraint (and a similar constraint in (5) follows from Theorem 1, which ensures that the original problem in Equation (3) has a unique solution.\n\n\n2.\tThe literature review may not be sufficient. As the paper focuses on implicit GNNs, I think the author may want to introduce and briefly discuss a few more recent implicit GNN works (e.g., CGS [1], EIGNN [2], USP [3]). Especially, USP seems to have a similar bilevel optimization problem, though it focuses on static graphs.\n\nThank you. We will introduce these papers in the related work.\n\n> 3.\tThe descriptions for the experiments are not very clear. As mentioned in Table 3, the memory usage and the runtime are reported as per batch. But how batches are formed for a single graph? Randomly select some nodes or use some sampling methods (e.g., neighbor sampling)?\n\n\nA batch in our experiments consists of a collection of continuous timestamps (i.e., time stamps that fall within a fixed window). The window size is constant for all the approaches. Hence, the running time comparison is fair. We do not use any sampling methods.\n\n\n> 4.\tAlthough the convergence guarantee is a good thing to see, I am just curious whether this is necessary to make the implicit graph model work well. Based on my understanding, existing implicit GNNs all have this property. In contrast, implicit models in other areas seem not always have this theoretical guarantee (e.g., DEQ [1] and MDEQ). They empirically work well.\n\nIt is true DEQ and MDEQ work well empirically. We think this might be because their architecture makes them perform like contraction operators. We observe that, if we ignore the constraints on W, we can still converge under appropriate initialization in some datasets., but the model will diverge in other ones (producing meaningless embedding). Overall, we think the convergence guarantee is important to the implicit graph model.\n\n\n> 5.\tCould you explain more about Hassian-vector Product as mentioned in the last paragraph of Sec 4? Can it be directly handled by a modern autodiff package? At least provide some reference materials in the appendix.\n\nTo compute the product of Hessian and a vector: $Hv$, and $H=\\frac{\\partial^2 f}{\\partial x^2}$. We compute the product by $Hv = \\frac{\\partial (\\frac{\\partial f}{\\partial x })^T v }{\\partial x}$. In this way, we are not explicitly computing the Hessian. Pytorch and other libraries support Hessian-vector Product directly: torch.autograd.functional.hvp().\n\nHere is a useful link illustrating the principles of Hessian\u2013vector product:\nhttps://jax.readthedocs.io/en/latest/notebooks/autodiff_cookbook.html\n\nThank you for your suggestion. We will add some references in the appendix."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6680/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700586801598,
                "cdate": 1700586801598,
                "tmdate": 1700586844664,
                "mdate": 1700586844664,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "lczWt4OwOO",
            "forum": "u4FiXrH09F",
            "replyto": "u4FiXrH09F",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6680/Reviewer_gbnb"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6680/Reviewer_gbnb"
            ],
            "content": {
                "summary": {
                    "value": "The paper addresses the limitations of graph convolution neural networks (GCNs) in capturing long-range dependencies and oversmoothing issues in dynamic graphs.\n\nThe authors propose IDGNN, a novel implicit neural network for dynamic graphs, which overcomes these issues and has a unique fixed point solution.\n\nTo efficiently train IDGNN, the authors pose an equivalent bi-level optimization problem and propose a single-loop training algorithm, achieving up to 1600x speed-up compared to the standard iterative algorithm.\n\nExtensive experiments on real-world datasets demonstrate the superiority of IDGNN over state-of-the-art baseline approaches in both classification and regression tasks. \n\nThe paper also discusses the challenges in training implicit models and introduces an efficient bilevel optimization algorithm to overcome these challenges, resulting in improved computational efficiency during training. \n\nThe contributions of the paper include proving the existence of fixed-point representations in dynamic graphs, designing an implicit model for general dynamic graphs, and developing an efficient training algorithm for IDGNN."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "Originality:\n\nThe paper introduces IDGNN, a novel implicit neural network for dynamic graphs, which addresses the limitations of existing graph convolution neural networks (GCNs) in capturing long-range dependencies and oversmoothing issues.\nThe authors propose a bi-level optimization framework and a single-loop training algorithm to efficiently train IDGNN, which is a novel approach in the context of dynamic graphs.\n\nQuality:\n\nThe paper provides a rigorous analysis of the proposed IDGNN model, demonstrating its well-posedness and unique fixed point solution.\nExtensive experiments on real-world datasets are conducted to evaluate the performance of IDGNN, comparing it to state-of-the-art baseline approaches.\n\nClarity:\n\nThe paper clearly presents the motivation, challenges, and contributions of the research.\nThe authors provide detailed derivations and explanations in the Appendix to support their claims and ensure clarity. \n\nSignificance:\n\nThe proposed IDGNN model and the efficient training algorithm have the potential to significantly improve the performance of dynamic graph neural networks, addressing the limitations of existing approaches. \n\nThe experimental results demonstrate the superiority of IDGNN over state-of-the-art baseline approaches in both classification and regression tasks, highlighting its practical significance."
                },
                "weaknesses": {
                    "value": "The paper lacks a comprehensive discussion on the limitations of the proposed IDGNN model and the potential challenges in its practical implementation.\n\nThe experimental evaluation could be further strengthened by including more diverse and challenging datasets, as well as comparing the performance of IDGNN with a wider range of state-of-the-art approaches.\n\nThe paper could benefit from providing more insights into the interpretability of the IDGNN model and how it captures the underlying dynamics of the dynamic graphs.\n\nThe clarity of the paper could be improved by providing more intuitive explanations and visualizations of the proposed model and its training algorithm.\n\nThe paper could provide more details on the computational complexity and scalability of the proposed single-loop training algorithm, particularly in large-scale dynamic graph scenarios.\n\nOverall, addressing these weaknesses would enhance the overall quality and impact of the paper."
                },
                "questions": {
                    "value": "Can the authors provide more insights into the limitations of the IDGNN model and potential challenges in its practical implementation?\n\nCould the authors consider including more diverse and challenging datasets in the experimental evaluation to further validate the performance of IDGNN?\n\nIt would be helpful if the authors could provide more details on the interpretability of the IDGNN model and how it captures the underlying dynamics of the dynamic graphs. \n\nCan the authors clarify the computational complexity and scalability of the proposed single-loop training algorithm, particularly in large-scale dynamic graph scenarios?\n\nCould the authors provide more intuitive explanations and visualizations of the proposed IDGNN model and its training algorithm to enhance the clarity of the paper? \n\nIt would be beneficial if the authors could discuss the potential applications and real-world use cases where IDGNN can be applied to address specific problems."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6680/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698859011409,
            "cdate": 1698859011409,
            "tmdate": 1699636765375,
            "mdate": 1699636765375,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "nj8LzhVWZq",
                "forum": "u4FiXrH09F",
                "replyto": "lczWt4OwOO",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6680/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6680/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "To Reviewer gbnb,\n\nWe thank reviewer gbnb for the valuable feedback and recommendations for improving the manuscript.\n\n> 1.\tCan the authors provide more insights into the limitations of the IDGNN model and potential challenges in its practical implementation?\n\nWe have mentioned some limitations of our method in the Conclusion section. The major limitation of our method is that it requires at least one GCN layer for each time stamp inside the window, which means picking a big window size can result in a large model. Another limitation is that predicting the current time stamp requires accessibility of all previous time stamps (within window size), which might not be practical in some cases since predictions might be required for future time stamp that is several days away. \n\n> 2.\tCould the authors consider including more diverse and challenging datasets in the experimental evaluation to further validate the performance of IDGNN?\n\nAs mentioned earlier, we believe we have added all standard benchmark datasets for node-level tasks (classification and regression) in dynamic networks. These datasets exhibit notable variations across domains, length, tasks, and scale, thereby ensuring a diverse and comprehensive coverage. It is worth highlighting that datasets specifically designed for discrete-time dynamic graphs in the context of node-level tasks are scarce [1]. Nevertheless, we have diligently curated and included the most prevalent ones in our analysis.\n\n[1] Xu, Da, et al. \"Inductive representation learning on temporal graphs.\" arXiv preprint arXiv:2002.07962 (2020).\n\n> 3.\tIt would be helpful if the authors could provide more details on the interpretability of the IDGNN model and how it captures the underlying dynamics of the dynamic graphs.\n\nThe main structure of our model is Z_{t+1}=\\sigma(A_t Z_{t}W_t  + VX_t). In our design, Z_t carries out the dynamic information of the topology and flows through all the time stamps. In each time stamp, we inject the feature information as bias.  \n\n> 4.\tCan the authors clarify the computational complexity and scalability of the proposed single-loop training algorithm, particularly in large-scale dynamic graph scenarios?\n\nSince our method uses Hassian-Vector-Product to avoid explicitly computing the Hessian matrix, the main computational overheads of our method are the matrix multiplication during forward and backward processes. For each time stamp, we need to perform aggregation, which takes O(nd^2 + n^2d) or O(nd^2 + Ed), where E is the number of edges, and n is the number of nodes. In total, we have T time stamps, and the complexity for our method is O(Tnd^2 + Tn^2d). In a nutshell, our algorithm scales like GCN, which is a scalable method. Moreover, we have provided a detailed complexity comparison in the appendix.\n\n> 5.\tCould the authors provide more intuitive explanations and visualizations of the proposed IDGNN model and its training algorithm to enhance the clarity of the paper?\n\nWe have included a model diagram in the revised appendix. Kindly review it at your convenience.\n\n> 6.\tIt would be beneficial if the authors could discuss the potential applications and real-world use cases where IDGNN can be applied to address specific problems.\n\nOur model is designed for general node-level tasks and can be applied to many real-world cases. To name just a few, traffic accident predictions, epidemiological forecasting, bio-medical relationships etc."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6680/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700585971118,
                "cdate": 1700585971118,
                "tmdate": 1700586828439,
                "mdate": 1700586828439,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "ZCR52prZTq",
            "forum": "u4FiXrH09F",
            "replyto": "u4FiXrH09F",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission6680/Reviewer_mjoJ"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission6680/Reviewer_mjoJ"
            ],
            "content": {
                "summary": {
                    "value": "The paper presents IDGNN, an Implicit Neural Network for Dynamic Graphs, aimed at overcoming the limitations of graph convolution neural networks (GCNs), such as over-smoothing and the failure to capture long-range dependencies, especially in dynamic settings. The authors introduce a novel bilevel optimization framework for training IDGNN, which shows superior performance on real-world datasets in both classification and regression tasks compared to state-of-the-art approaches. They also demonstrate a significant speed-up in training times without compromising performance."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "1 poor"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1. IDGNN is the first method to tackle the dynamic graph problem via an implicit neural network, filling a gap in the literature.\n2. The model outperforms state-of-the-art methods on various real-world datasets, and the authors provide experimental validation."
                },
                "weaknesses": {
                    "value": "1. The discussion about IGNN being able to avoid over-smoothing seems heuristic. IGNN ensures that the representation of the network is convergent, but it does not prevent over-smoothing problems.\n2. The reasonableness of the assumption in Lemma 2 needs further explanation. For example, it says that Formula 3 has a unique embedding z, but which z in Formula 3 is referred to and under which conditions it is unique.\n3. In Lemma 2, ``let W_{j+k} denote M_{i}``. needs further explanation.\n4. Due to the question regarding Lemma 2, I am unable to determine the reasonableness of bilevel problem (8). (8) utilizes multi-block bilevel optimization for solving, and when solving (8), the paper makes extensive use of approximations without explaining their validity or drawbacks. Additionally, the writing of the section on training IDGNN is poor, and there is insufficient clarity in comparing it with existing training methods.\n5. Lack of experimental results on common datasets, such as QM9 and TUdataset."
                },
                "questions": {
                    "value": "See weakness"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission6680/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699434258985,
            "cdate": 1699434258985,
            "tmdate": 1699636765262,
            "mdate": 1699636765262,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "3PfnhsL8pS",
                "forum": "u4FiXrH09F",
                "replyto": "ZCR52prZTq",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6680/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6680/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal 1/2"
                    },
                    "comment": {
                        "value": "To Reviewer mjoJ,\n\nWe thank the reviewer for your helpful feedback on the manuscript. Please find our detailed response below:\n\n\n> 1. The discussion about IGNN being able to avoid over-smoothing seems heuristic. IGNN ensures that the representation of the network is convergent, but it does not prevent over-smoothing problems.\n\n\nImplicit graph neural networks have been able to capture long-range dependency while alleviating over-smoothing issues [1] [2] [3]. While there is no theoretical guarantee that the converged implicit representations necessarily avoid over-smoothing issues (as pointed out by the reviewer), there is enough empirical evidence (including in our experiments) that the implicit graph neural networks help alleviate these.\n\n[1] Liu, Juncheng, et al. \"Eignn: Efficient infinite-depth graph neural networks.\" Advances in Neural Information Processing Systems 34 (2021): 18762-18773.\n[2] Chen, Qi, et al. \"Optimization-induced graph implicit nonlinear diffusion.\" International Conference on Machine Learning. PMLR, 2022.\n[3] Yang, Yongyi, et al. \"Graph neural networks inspired by classical iterative algorithms.\" International Conference on Machine Learning. PMLR, 2021.\n\n\n> 2. The reasonableness of the assumption in Lemma 2 needs further explanation. For example, it says that Formula 3 has a unique embedding z, but which z in Formula 3 is referred to and under which conditions it is unique.\n\n\nLemma 2 holds for any vector z that satisfies Equation 3 and Equation 3 is guaranteed a unique solution if the condition in Theorem 1 is satisfied (which we ensure during training). Please note that Lemma 2's purpose is to show equivalence between the problem in Equation 5 and the one in Equation 8 by demonstrating that the constraints imply the same fixed-point solution.  We will update Lemma 2 and make it more readable.\n\n\n> 3. In Lemma 2, let W_{j+k} denote M_{i}. needs further explanation\n\n\nWe believe the reviewer is referring to the line let M_{j+k} denote M_{i} : i=(j+k) mod T.  Our goal here was to define M_{j+k}=M_{i} when j+k > T, since M_{i} is only defined for i in {1,\u2026,T}. We realize there is a better way to express this: defining the mod operator \\Bar{j+k} =(j+k) mod T. We will update Lemma 2 and make it more readable.\n\n \n> 4.\tDue to the question regarding Lemma 2, I am unable to determine the reasonableness of bilevel problem (8). (8) utilizes multi-block bilevel optimization for solving, and when solving (8), the paper makes extensive use of approximations without explaining their validity or drawbacks. Additionally, the writing of the section on training IDGNN is poor, and there is insufficient clarity in comparing it with existing training methods.\n\n\nWe have given a justification about how our bilevel algorithm approximates the hypergradient. The goal of most gradient-based bilevel optimization algorithms is to accurately and rapidly estimate the hypergradient [1]. The difficulties in obtaining the hypergradient are: 1) the estimation of inverse Hessian matrix of lower-level problem, and 2) the accessibility to the optimal lower-level solution. Inspired by [2], we use moving average estimator for approximating the lower-level solution and the inverse Hessian-vector product. \n\nIn cases where the lower-level problem is strongly convex, the errors introduced by these approximations are well-contained, aligning with the approach in [2] and enabling optimal sample complexity. However, when dealing with a multi-block non-convex lower-level problem, as expressed in Eq (8), the algorithm presented in [2] is not directly applicable. Nevertheless, it is crucial to note that the optimal solution to our lower-level problem corresponds to the fixed point of Eq (3), as per Lemma 2. Leveraging this insight, we employ a fixed-point iteration to update the lower-level solution. Empirical results strongly support the efficacy of our approximations in practice.\n\n[1] Liu, Bo, et al. \"Bome! bilevel optimization made easy: A simple first-order approach.\" Advances in Neural Information Processing Systems 35 (2022): 17248-17262.\n[2] Hu, Quanqi, Yongjian Zhong, and Tianbao Yang. \"Multi-block min-max bilevel optimization with applications in multi-task deep auc maximization.\" Advances in Neural Information Processing Systems 35 (2022): 29552-29565."
                    }
                },
                "number": 1,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6680/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700579529535,
                "cdate": 1700579529535,
                "tmdate": 1700579529535,
                "mdate": 1700579529535,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "P62OFtMp35",
                "forum": "u4FiXrH09F",
                "replyto": "ZCR52prZTq",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission6680/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission6680/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal 2/2"
                    },
                    "comment": {
                        "value": "> 5. Lack of experimental results on common datasets, such as QM9 and TUdataset.\n\n\nOur paper focuses on node-level tasks on dynamic graphs. The QM9 is a static graphs dataset, and TUdataset only contains dynamic graphs for graph classification. Moreover, we believe that the datasets we used are common datasets in field of dynamic graphs learning as these were selected from influential papers [1] [2] on dynamic graphs. As indicated by [3], Publicly available datasets for node classification in the dynamic setting are rare. We have tried to cover a diverse collection of them.\n\n[1] Gao, Jianfei, and Bruno Ribeiro. \"On the equivalence between temporal and static equivariant graph representations.\" International Conference on Machine Learning. PMLR, 2022.\n[2] Xu, Da, et al. \"Inductive representation learning on temporal graphs.\" arXiv preprint arXiv:2002.07962 (2020).\n[3] Pareja, Aldo, et al. \"Evolvegcn: Evolving graph convolutional networks for dynamic graphs.\" Proceedings of the AAAI conference on artificial intelligence. Vol. 34. No. 04. 2020."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission6680/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700579562468,
                "cdate": 1700579562468,
                "tmdate": 1700579562468,
                "mdate": 1700579562468,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]