[
    {
        "title": "Sparse Cocktail: Every Sparse Pattern Every Sparse Ratio All At Once"
    },
    {
        "review": {
            "id": "m1tTHkjQzk",
            "forum": "HsJzGWvg7K",
            "replyto": "HsJzGWvg7K",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission5687/Reviewer_1N1a"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission5687/Reviewer_1N1a"
            ],
            "content": {
                "summary": {
                    "value": "Sparse Cocktail is a novel sparse co-training framework that can concurrently produce multiple sparse subnetworks across a spectrum of sparsity patterns and ratios, in addition to a dense model."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "Key technical contributions include:\n\n(S1) Simultaneously co-trains diverse sparsity patterns (unstructured, channel-wise, N:M) each with multiple sparsity ratios. The well-articulate problem is an important strength.\n(S2) Uses iterative pruning with weight rewinding to segregate subnetworks of different sparsity ratios\n(S3) Proposes a Unified Mask Generation technique to jointly produce masks of different patterns\n(S4) Employs Dense Pivot Co-training to align optimization of diverse sparse subnetworks \n(S5) Performs Sparse Network Interpolation to further boost performance (relatively old trick)\n\nKey experimental strengths include:\n\n(S6) Sparse Cocktail achieves comparable or better performance than SOTA sparse co-training methods that focus on single patterns only. It generalizes previous methods while producing more subnetworks at once. Its performance can be on par with or even better than strong baselines such as AST and MutualNet. \n(S7) Besides evaluation on CIFAR10/ImageNet with ResNet/VGG, it also transfers effectively to object detection and instance segmentation tasks.\n(S8) In ablation studies, key components like weight rewinding, network interpolation, Unified Mask Generation and Dense Pivot Co-training are shown to contribute to Sparse Cocktail's performance"
                },
                "weaknesses": {
                    "value": "(W1) The whole pipeline looks like a huge ensemble of existing techniques, such as the \"Dense Pivot Co-training\" stage from USNet and BigNAS, the \"Sparse Network Interpolation\" stage from AutoSlim and LotteryPool \u2026 However, the author did not make meaningful discussions in each stage, on their differences from prior arts. I would like to hear the authors clarify.\n\n(W2) I would like to see some more relevant metrics such as training time, memory savings, or inference speed ups if any. Without those, it is hard or meaningless to fetch any real benefit of training with sparsity. \n\n(W3) Is Dense Pivot Co-training just weight rewinding (which is a pretty standard trick), or are they different (in which way)?\n\n(W4) Why the three mask generations in Section 3.4. are called \u201cunified\u201d?"
                },
                "questions": {
                    "value": "See W1-W4"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission5687/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698632280613,
            "cdate": 1698632280613,
            "tmdate": 1699636594474,
            "mdate": 1699636594474,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "pePrwPHxbm",
                "forum": "HsJzGWvg7K",
                "replyto": "m1tTHkjQzk",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5687/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5687/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal for Reviewer 1N1a's review"
                    },
                    "comment": {
                        "value": "Dear reviewer,\n\nThank you for the time and effort you have invested in reviewing our manuscript. We appreciate your valuable comments and suggestions. Below, we address each of your points in detail.\n\n>Q1:  The whole pipeline looks like a huge ensemble of existing techniques, such as the \"Dense Pivot Co-training\" stage from USNet and BigNAS, the \"Sparse Network Interpolation\" stage from AutoSlim and LotteryPool \u2026 However, the author did not make meaningful discussions in each stage, on their differences from prior arts. I would like to hear the authors clarify.\n\nA1: We would like to argue that one of our major novelty is to expand the scope of sparse co-training to cover diverse sparsity patterns and multiple sparsity ratios at once. This research goal stands out as novel because previous works have not addressed such a wide range of sparse patterns and ratios. The harmony among different sparsity patterns is made possible by UMG and Dense Pivot Co-training. By using UMG as a universal pruning criterion and producing closely aligned sparse masks, we relieve the gradient conflicts of different sparsity patterns during training. Then by Dense Pivot Co-training that inserts a dense mini-batch step at every alternative sparse mini-batch step, we further enforce the optimizing directions of subnetworks of different sparsity patterns to be aligned with the same dense network. Meanwhile, the dense network at each IMP iteration has the same initialization as in the Lottery Ticket Hypothesis, thus the optimization directions from different IMP iteration are aligned because of the same dense network initialization. Thus, the optimization directions from different sparsity ratios and patterns are all regularized to be aligned together. We are also the first one to apply LTH for sparse co-training to amortize the sparse co-training pressure (we only co-trains subnetworks of a single sparsity ratio from different sparsity patterns at the same time in each IMP iteration, while finally it produces a lot more subnetworks in total without the need to co-train them together.), while related work such as Lottery Pool only considers aiming to produce a single stronger subnetwork.\n\n\nWe also do not simply reuse existing methods but develop novel adaptations for the sparse co-training circumstance. Specifically, (1) we adapt the refilling method in Chen et al[1] as UMG by incorporating N:M sparsity and letting both unstructured and N:M sparsity decide which channels to refill; (2) we adapt the AST[2](instead of USNet or BigNAS) as Dense Pivot Co-training by not just alternating mini-batches among sparse networks of the same sparsity ratio and pattern but inserting a dense mini-batch step and combine it with IMP to achieve optimization alignments across different sparsity ratios and patterns. (3) we adapt the network interpolation method in Lottery Pool[2] as our network interpolation for sparse co-training and the core difference is that they only aim to produce a single sparse network with an interpolated sparsity ratio, while we need to use the interpolation to produce multiple subnetworks with a shared parameter set.\n\n>Q2: I would like to see some more relevant metrics such as training time, memory savings, or inference speed ups if any. Without those, it is hard or meaningless to fetch any real benefit of training with sparsity.\n\nA2: Thanks for the question. we want to emphasize that the motivation of our sparse co-training is parameter efficiency instead of training or inference speed up. Since for each kind of sparsity pattern, the Sparse Cocktail produces multiple subnetworks with exactly the same sparsity ratios w.r.t. other corresponding methods, we thus have almost the same memory savings, and inference speed up and omit the comparison. We also empirically find that Sparse Cocktail has only around 1/8 extra total wall-clock training time primarily due to 1 extra distillation step every 2 mini-batches."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5687/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700621289421,
                "cdate": 1700621289421,
                "tmdate": 1700697610024,
                "mdate": 1700697610024,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "zAgM0ZgC4g",
                "forum": "HsJzGWvg7K",
                "replyto": "m1tTHkjQzk",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5687/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5687/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Follow-up response"
                    },
                    "comment": {
                        "value": ">Q3: Is Dense Pivot Co-training just weight rewinding (which is a pretty standard trick), or are they different (in which way)?\n\nA3: The dense pivot co-training is an orthogonal technique w.r.t. the weight-rewinding. The weight-rewinding means rewinding the weights to initialization weights(or very early epochs) at the start of each IMP iteration, which is operated on the epoch level. For example, if the IMP has 10 iterations and each iteration trains the network for 100 epochs, then the weight rewinding will be performed for 9 times at the start of each iteration, from the 2nd to the last iteration. \nIn contrast, the Dense Pivot Co-training inserts a dense network training step before each mini-batch of the sparse co-training, where parameters are shared and continuously updated without rewinding and it is operated on a mini-batch level. For example, at the i-th iteration of Sparse Cocktail, the mini-batch orders during training are arranged like this: dense \u2014> unstructured subnetwork \u2014> dense  \u2014> channel-wise subnetwork  \u2014> dense  \u2014> N:M subnetwork  \u2014> dense  \u2014> unstructured subnetwork ...\nTo summarize, weight rewinding is an epoch-level operation and dense-pivot co-training is a mini-batch-level operation, and they are thus orthogonal.\n\n\n>Q4: Why the three mask generations in Section 3.4. are called \u201cunified\u201d?\n\n\nA4: The mask generation is called \"unified\" primarily because now the selection of 3 masks are all based on individual weight magnitudes by changing the pruning criterion of channel-wise pruning. In traditional channel-wise pruning, the pruning criterion is usually based on the batch norm scale factor, which is different from individual weight magnitudes. If we combine this traditional channel-wise pruning criterion with weight magnitude-based unstructured and N:M pruning, there could be conflicts for sparse co-training with different sparsity patterns. Now in our proposed unified mask generation, this is changed by introducing the refilling criterion, which decides which channels to prune based on the magnitude sum of all individual weights in each channel. In this way, the sparse co-training can better orchestrate their shared parameters so that they will not produce conflicts in pruning criteria and cancel each other's performance."
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5687/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700621316283,
                "cdate": 1700621316283,
                "tmdate": 1700621316283,
                "mdate": 1700621316283,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "NL6GxoeWXv",
            "forum": "HsJzGWvg7K",
            "replyto": "HsJzGWvg7K",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission5687/Reviewer_TUJX"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission5687/Reviewer_TUJX"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposed a new joint sparse training algorithm called \u201cSparse Cocktail\u201d, that allows for the selection of the desired sparsity pattern and ratio at inference. The benefits of using Sparse Cocktail for training sparse neural networks include the ability to produce a diverse set of sparse subnetworks with various sparsity patterns and ratios at once, making it easier to switch between them depending on hardware availability."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "Overall, Sparse Cocktail can effectively generalize and encapsulate previous sparse co-training methods. Experiment results look promising, and paper writing is clear to follow (plus a lovely title :)\nIn more details:\n\n-\tSparse Cocktail differs from other sparse co-training approaches in that it can produce multiple sparse subnetworks across a spectrum of sparsity patterns and ratios simultaneously, while previous approaches only focus on one or two types of sparsity patterns and/or with different sparsity ratios. \n-\tThe approach alternates between various sparsity pattern training phases, incrementally raising the sparsity ratio across these phases. Underlying the multi-phase training is a unified mask generation process that allows seamless phase transitions without performance breakdown. \n-\tThe authors also complement a dense pivot co-training strategy augmented with dynamic distillation, aligning the optimization trajectories of diverse sparse subnetworks. In the end, all sparse subnetworks share weights from the dense network, culminating in a \"cocktail\" of dense and sparse models, offering a highly storage-efficient ensemble. \n-\tThe paper shows that Sparse Cocktail achieves great parameter efficiency and comparable Pareto-optimal trade-off individually achieved by other sparse co-training methods. Sparse Cocktail achieves comparable or even better performance compared to the state-of-the-art sparse co-training methods that only focus on one sparsity pattern per model. Additionally, Sparse Cocktail avoids the need for co-training multiple dense/sparse network pairs, making it a more storage-efficient ensemble."
                },
                "weaknesses": {
                    "value": "\u2022\tNo discussion of training time cost. The proposed joint/switchable training appears to take much longer time than any single sparse training method. Please report the details and provide a fair discussion on training cost.\n\u2022\tHyperparameter setting was missed in Appendix C (empty - though mentioned multiple times in the main paper)!! This paper has so many moving widgets and it seems challenging to get all the hyper-parameters and settings right in practice."
                },
                "questions": {
                    "value": "Overall the paper is clear, but several important pieces of information were missed, as pointed out in the weakness part."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission5687/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698633177710,
            "cdate": 1698633177710,
            "tmdate": 1699636594372,
            "mdate": 1699636594372,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "CKD34yXq8o",
                "forum": "HsJzGWvg7K",
                "replyto": "NL6GxoeWXv",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5687/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5687/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal for Reviewer TUJX's review"
                    },
                    "comment": {
                        "value": "Dear reviewer,\n\nThank you for the time and effort you have invested in reviewing our manuscript. We appreciate your valuable comments and suggestions. Below, we address each of your points in detail.\n\n\n>Q1: No discussion of training time cost. The proposed joint/switchable training appears to take much longer time than any single sparse training method. Please report the details and provide a fair discussion on training cost. \n\nA1: Thanks for your question. We have discussed the training cost in Appendix D and will make this point more clear in the revised version. Overall, we keep the batch size and total training epochs of all the methods, including Sparse Cocktail, AST, AC/DC, and MutualNet, as 1500 epochs to have a fair comparison. Specifically, (1) for Sparse Cocktail, we use 10 iterations for IMP and each iteration contains 150 epochs. (2) for AST and MutualNet, we directly perform the co-training for 1500 epochs. (3) for AC/DC we co-train each of the 10 dense-sparse network pairs for 150 epochs. In this way, all the methods have the same number of training iterations and batch size (regardless of which subnetwork will be trained at each mini-batch), and thus the same training cost.  We also empirically find that Sparse Cocktail has only around 1/8 extra total wall-clock training time primarily due to 1 extra distillation step every 2 mini-batches.\n\n\n>Q2: Hyperparameter setting was missed in Appendix C (empty - though mentioned multiple times in the main paper)!! This paper has so many moving widgets and it seems challenging to get all the hyper-parameters and settings right in practice.\n\nA2: We apologize for this problem, we have presented the hyper-parameters in Table 5 and Table 6 in the Appendix, but this is misplaced away from the Appendix C section title due to the typesetting problem. We will fix this issue and add textual references in Appendix C in the revised version."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5687/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700621107845,
                "cdate": 1700621107845,
                "tmdate": 1700621107845,
                "mdate": 1700621107845,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "wAiAordcx2",
            "forum": "HsJzGWvg7K",
            "replyto": "HsJzGWvg7K",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission5687/Reviewer_MPL5"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission5687/Reviewer_MPL5"
            ],
            "content": {
                "summary": {
                    "value": "This paper aims at performing sparse cotraining to obtain multiple sparse networks at once with different sparsity ratios and sparsity types (unstructured, structured or N:M). The authors propose to use a combination of iterative magnitude pruning, unifying masks and interspersed dense training in order to obtain multiple subnetworks within the same network for different sparsity ratios and sparsity types."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "The authors present a sparse cotraining method that can obtain subnetworks of different sparsity ratios and sparsity types at once."
                },
                "weaknesses": {
                    "value": "I am concerned about the novel contributions of this paper, and the results presented in this paper are the combination of existing works with little novelty of its own.\n\n1. The results are shown on different sparse subnetworks obtained from multiple sparse masks. However, it is likely that the performance of these sparse subnetworks is stable merely because of the relatively low sparsity reported in the paper. In order to see the effectiveness of the method, I would like to see the performance of the subnetworks with higher sparsity (> 90%) especially for unstuctured sparsity patterns.\n\n2. The algorithm is not entirely clear from the Figure and methodology section. For example, how many sparsities is each sparse pattern trained for, what are the performances of each sparsity pattern and how does a subnetwork\u2019s performance improve after merging (if it does).\n\n3. The author\u2019s don\u2019t comment on the loss landscape of each of the subnetworks obtained during training. From previous work by Paul et al [1] I would expect each of the obtained subnetworks to lie in the same loss basin. In order to assess the effectiveness of the dynamic distillation step I would expect to look at the Hessian or the linear mode connectivity between the subnetworks obtained.\n\n4. Additionally, the performance of the proposed method on ImageNet is poorer than AC/DC (in Table 1) which is a well established method. \n\nOverall my primary concern is that the novelty of this paper is limited as the authors have put together multiple existing methods (AST, AC/DC) in order to obtain multiple subnetworks at once. \nHowever, the attained subnetworks themselves have not been confirmed to be effective at higher sparsities.\n\n[1] Paul, Mansheej, et al. \"Unmasking the Lottery Ticket Hypothesis: What's Encoded in a Winning Ticket's Mask?.\" International Conference on Learning Representations 2022."
                },
                "questions": {
                    "value": "1. How does Network Interpolation help, and at what stage of training is it used. It seems to be similar to the implementation of Lottery Pools [1].\n\n2. Its not made clear how the N:M network and Unstructured networks obtained from IMP are kept similar to each other such that their weights can be interpolated. \n\n3. It is not clear to me why the authors choose to generate a total of 24 subnetworks by restricting the unstrcutured and structured sparse networks to 10 each. Is this a hyperparameter and why not choose additional networks at higher sparsity ratios?\n\n[1] Yin, Lu, et al. \"Lottery pools: Winning more by interpolating tickets without increasing training or inference cost.\" Proceedings of the AAAI Conference on Artificial Intelligence 2023."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission5687/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission5687/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission5687/Reviewer_MPL5"
                    ]
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission5687/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698741392480,
            "cdate": 1698741392480,
            "tmdate": 1699636594247,
            "mdate": 1699636594247,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "XDwZxq1a1W",
                "forum": "HsJzGWvg7K",
                "replyto": "wAiAordcx2",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5687/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5687/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Rebuttal to Reviewer MPL5's review"
                    },
                    "comment": {
                        "value": "Dear reviewer,\n\nThank you for the time and effort you have invested in reviewing our manuscript. We appreciate your valuable comments and suggestions. Below, we address each of your points in detail.\n\n>Q1: I am concerned about the novel contributions of this paper, and the results presented in this paper are a combination of existing works with little novelty of its own.\n\nA1: We would like to argue that one of our major novelty is to expand the scope of sparse co-training to cover diverse sparsity patterns and multiple sparsity ratios at once. This research goal stands out as novel because previous works have not addressed such a wide range of sparse patterns and ratios. The harmony among different sparsity patterns is made possible by UMG and Dense Pivot Co-training. By using UMG as a universal pruning criterion and producing closely aligned sparse masks, we relieve the gradient conflicts of different sparsity patterns during training. Then by Dense Pivot Co-training that inserts a dense mini-batch step at every alternative sparse mini-batch step, we further enforce the optimizing directions of subnetworks of different sparsity patterns to be aligned with the same dense network. Meanwhile, the dense network at each IMP iteration has the same initialization as in the Lottery Ticket Hypothesis, thus the optimization directions from different IMP iteration are aligned because of the same dense network initialization. Thus, the optimization directions from different sparsity ratios and patterns are all regularized to be aligned together. We are also the first one to apply LTH for sparse co-training to amortize the sparse co-training pressure (we only co-trains subnetworks of a single sparsity ratio from different sparsity patterns at the same time in each IMP iteration, while finally it produces a lot more subnetworks in total without the need to co-train them together), while related work such as Lottery Pool only considers aiming to produce a single stronger subnetwork.\n\nWe also do not simply reuse existing methods but develop novel adaptations for the sparse co-training circumstance. Specifically, (1) we adapt the refilling method in Chen et al[1] as UMG by incorporating N:M sparsity and letting both unstructured and N:M sparsity decide which channels to refill; (2) we adapt the AST[2] as Dense Pivot Co-training by not just alternating mini-batches among sparse networks of the same sparsity ratio and pattern but inserting a dense mini-batch step and combine it with IMP to achieve optimization alignments across different sparsity ratios and patterns. (3) we adapt the network interpolation method in Lottery Pool[3] as we state in A6 below.\n\n\n>Q2: The results are shown on different sparse subnetworks obtained from multiple sparse masks. However, it is likely that the performance of these sparse subnetworks is stable merely because of the relatively low sparsity reported in the paper. In order to see the effectiveness of the method, I would like to see the performance of the subnetworks with higher sparsity (> 90%) especially for unstructured sparsity patterns.\n\nA2: We would like to argue the compared sparse co-training methods all have performance degradation when the sparsity gets very high. In the two compared unstructured sparse co-training methods, AC/DC [4] has ~3.5% performance degradation (compared to vanilla dense network) at 95% sparsity and ~8.5% degradation at 98% sparsity; AST [2] has less performance degradation at high sparsity primarily likely because it doesn't involve co-training with different sparsity ratios and only focus on single sparsity ratio but different masks."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5687/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700620933731,
                "cdate": 1700620933731,
                "tmdate": 1700697442113,
                "mdate": 1700697442113,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "xf2WbOdOIQ",
                "forum": "HsJzGWvg7K",
                "replyto": "wAiAordcx2",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5687/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5687/Authors"
                ],
                "content": {
                    "title": {
                        "value": "follow-up rebuttal"
                    },
                    "comment": {
                        "value": ">Q3: The algorithm is not entirely clear from the Figure and methodology section. For example, how many sparsities is each sparse pattern trained for, what are the performances of each sparsity pattern and how does a subnetwork\u2019s performance improve after merging (if it does).\n\nA3: Thanks for your question. The number of sparsity ratios can be a variable hyper-parameter while in our setting, we use 10 sparsity ratios for both unstructured and channel-wise sparsity, and 3 sparsity ratios for N:M sparsity (1:2, 2:4, 4:8) following prior sparsity work as we discussed in the start of Section 4. The performance of each sparsity pattern are shown in Table 1 and Table 2, generally speaking, unstructured and N:M subnetworks have comparable performance to the dense network and channel-wise subnetworks have degraded performance due to the structural sparsity nature. Regarding the performance influence of network interpolation, we list the average performance before and after Interpolation of Sparse Cocktail on image classification datasets. The results show that there will be slight performance degradation after interpolation, but we consider this a necessary sacrifice since we aim to produce a single network with shared parameters of multiple subnetworks.\n\n\nOn CIFAR10 dataset:\n|  Sparsity Pattern  |   Dense |   Unstructured|  Channel-wise | N:M |\n|-------------:|----------:|-----------:|-----------:|-----------:|\n|Before Interpolation |  92.56 |   92.45 |   90.97  |    92.32  |\n|After Interpolation |    92.48 |   92.09 |   90.02  |    91.83  |\n\n\nOn ImageNet dataset:\n|   Sparsity Pattern |   Dense |   Unstructured|  Channel-wise | N:M |\n|-------------:|----------:|-----------:|-----------:|-----------:|\n|Before Interpolation | 76.45  |   74.64 |   74.02 |    76.13  |\n|After Interpolation |   76.32  |   73.23 |   72.22  |    75.19  |\n\n\n>Q4: The author\u2019s don\u2019t comment on the loss landscape of each of the subnetworks obtained during training. From previous work by Paul et al [1] I would expect each of the obtained subnetworks to lie in the same loss basin. In order to assess the effectiveness of the dynamic distillation step I would expect to look at the Hessian or the linear mode connectivity between the subnetworks obtained.\n\nA4: Thanks for your comment. We empirically find that different subnetworks of the same sparsity pattern obtained by IMP with weight rewinding are located in the same loss basin, i.e. there are no significant error barriers for interpolations similar to Figure 2 in [3], while subnetworks from different sparsity patterns have at most ~3.2% error barriers on average due to the divergence in sparse masks. We show the latter phenomenon in Figure 7 in appendix, by plotting the performance change using different interpolation factors as in Algorithm 1. However, by finding proper interpolations the error barrier problem can be mitigated or avoided."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5687/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700620984274,
                "cdate": 1700620984274,
                "tmdate": 1700697530884,
                "mdate": 1700697530884,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "SFFYUaRh8X",
                "forum": "HsJzGWvg7K",
                "replyto": "OId61FVS8V",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5687/Reviewer_MPL5"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5687/Reviewer_MPL5"
                ],
                "content": {
                    "title": {
                        "value": "Response to Rebuttal"
                    },
                    "comment": {
                        "value": "I thank the authors for providing comprehensive clarifications. Their response significantly makes clear a lot of details about the training method of Sparse Cocktail.\n\nHowever, I am still unconvinced of the novel contributions of the paper. It seems that the main goal still is to combine multiple existing methods by extensive hyperparameter tuning and engineering like Dense Co-pivot training.\n\nMoreover, only by training IMP, I could potentially obtain multiple sparse networks by removing $20$% of the nonzero parameters in each prune-train iteration of density $0.8, 0.8^2, 0.8^3, ...$ and so on. \nIn order to achieve a final sparsity of $0.8^l$, one would need to train all the previous sparsity levels ${1, 2, .., l-1}$, thus generating multiple sparse networks with increasing sparsity ratios. Each of these networks could then be transferred to a structured sparse network by using the work of Chen et al. [1]. And a similar approach could be followed for N:M sparsity.\nI don't see the benefit of combining these multiple methods at the cost of extensive hyperparameter tuning and significantly increased training time to achieve multiple sparse patterns. \n\nHence, I would still lean on rejection and keep my score.\n\n[1] Chen, Tianlong, et al. \"Coarsening the granularity: Towards structurally sparse lottery tickets.\" International Conference on Machine Learning. PMLR, 2022."
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5687/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700730489437,
                "cdate": 1700730489437,
                "tmdate": 1700730489437,
                "mdate": 1700730489437,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "94kvJRecJz",
                "forum": "HsJzGWvg7K",
                "replyto": "wAiAordcx2",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission5687/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission5687/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Reponse to reviewer MPL5's further comments"
                    },
                    "comment": {
                        "value": "Dear Reviewer,\n\nThanks for your further questions. We can address your concerns as follows:\n\n>Q9: However, I am still unconvinced of the novel contributions of the paper. It seems that the main goal still is to combine multiple existing methods by extensive hyperparameter tuning and engineering like Dense Co-pivot training.\n\nA9: As we have discussed in Section 1, our main goal is to train multiple sparsity ratios and patterns all at once, in order to achieve real-time switching with the need to store only one set of shared parameters, based on the inference platforms that may have different supports on accelerable sparsity patterns and their available resources may vary over time which needs switchable sparsity ratios.\n\nWe do not include extensive hyperparameter tuning. As we show in Table 5 and 6 in the Appendix, we just follow the default hyperparameters as in the original LTH paper [5] for producing unstructured lottery tickets, and keep the element-wise sparsity roughly the same  for channel-wise sparsity pattern by setting channel-wise pruning ratio as 0.1. The candidate pool is also not a hyperparameter but a search space of our greedy network interpolation algorithm. Other optimization hyperparameters are common default choices and we empirically find that they are not very sensitive to the final performance. The Dense Pivot Co-training does not include heavy engineering, as it can be simply implemented by inserting a dense training step and a distillation step every 2 mini-batches, and does not include any hyperparameter tuning. \n\n\n\n>Q10:Moreover, only by training IMP, I could potentially obtain multiple sparse networks...\n\nA10: As we have shown in our ablation study in Section 4.2, every part of Sparse Cocktail has an important contribution to the final performance. In essence, sparse co-training with IMP and weight-rewinding is necessary for a normal performance and every other part contributes to the performance boosts. \nWe do not think one can transfer from unstructured sparsity to N:M sparsity during IMP following the mentioned approach in Q10. \nNotably, we do not increase the training time or iterations compared to vanilla IMP which solely trains unstructured sparsity, as Dense Pivot co-training utilizes the ***graident alignment*** effect as in the AST paper[2] using the ***alternative sparse training***. For example, in the original LTH paper, they used 182 epochs at each IMP iteration while in Sparse Cocktail we use 150 epochs with the same mini-batch size on the CIFAR10 dataset. Compared to other sparse co-training methods that can co-train multiple sparsity ratios (i.e. Mutual Net and AST), we also find they require a nearly full training schedule of 1500 epochs when co-training only 10 subnetworks.\n\nHope our response can address your concerns!\n\n[5] The Lottery Ticket Hypothesis: Finding Sparse, Trainable Neural Networks, Jonathan Frankle, et al 2019."
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission5687/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700740517414,
                "cdate": 1700740517414,
                "tmdate": 1700741034981,
                "mdate": 1700741034981,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]