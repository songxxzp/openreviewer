[
    {
        "title": "Robust Network Pruning With Sparse Entropic Wasserstein Regression"
    },
    {
        "review": {
            "id": "EPC6bV2ID6",
            "forum": "LJWizuuBUy",
            "replyto": "LJWizuuBUy",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1463/Reviewer_yr3z"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1463/Reviewer_yr3z"
            ],
            "content": {
                "summary": {
                    "value": "Computation of the empirical Fisher Information Matrix (FIM) is an important part of neural network pruning and subjected to \nnoisy gradients. As a solution, this paper proposes an entropic Wasserstein regression (EWR) formulation to address the issue above. The method EWR is demonstrated to able to implicitly enacts gradient averaging using Neighborhood Interpolation, resulting in a balance in capturing gradient covariance and reducing gradient noise.  The paper demonstrates the proposed methods in combatting noisy gradients through theoretical analysis (section 3), and empirical evidence (section 4, 5). The empirical evidence is showcased using various models and vision datasets."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. Provide clear motivation about combating against noise that may comes from different aspects. \n2. Provide theoretical analysis for the proposed method and empirical evidence."
                },
                "weaknesses": {
                    "value": "1. Is it possible to show an analysis in term of computational expense incurred, as the scale of the model increases?"
                },
                "questions": {
                    "value": "1. Suggestion to change some of the cited references to be included in parentheses for better presentation. Eg in page 3 Computing the distance between .... (Nadjahi et al., 2020).\n2. In the introduction, GPT-4 is used an example of model with substantial size and complexity, Is it possible to show case such a pruning in a language model?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission1463/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1463/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1463/Reviewer_yr3z"
                    ]
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1463/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698532358777,
            "cdate": 1698532358777,
            "tmdate": 1699636075191,
            "mdate": 1699636075191,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "dkWxQ35NbF",
                "forum": "LJWizuuBUy",
                "replyto": "EPC6bV2ID6",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1463/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1463/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "**Question 1**: Suggestion to change some of the cited references to be included in parentheses for better presentation. Eg in page 3 Computing the distance between .... (Nadjahi et al., 2020).\n\n**Answer 1**: Thanks for the suggestion! We have changed the cited references to be included in parentheses as you suggested.\n\n**Question 2**: Is it possible to show an analysis in terms of computational expense incurred, as the scale of the model increases?\n\n**Answer 2**: We thank the reviewer for this good suggestion. We have added a new section (A.8 Algorithm Scalability) in the appendix of the updated manuscript. The content is as follows.\n\n*In this section, we analyze the scalability of Algorithm 1 with respect to the number of model parameters involved in pruning. \nThe result is shown in Figure 8. It can be observed that the execution time scales linearly with the number of pruning parameters. The extra cost of solving the OT is marginal. Theoretically, one could derive this linear scalability by inspecting Line 8, which is the most time-consuming step. The required operations can be decomposed as a sequential operations: matrix-vector multiplications $\\vec{Gw}$ and $\\vec{G\\bar{w}}$ in $O(np)$, the vector subtraction $\\vec{Gw}-\\vec{G\\bar{w}}$ in $O(n)$, a matrix-matrix multiplication $\\vec{\\Pi}(\\vec{Gw}-\\vec{G\\bar{w}})$ in $O(n^2)$, a matrix transposition and multiplication with $\\vec{G}$ in $O(np)$, and the vector subtraction and scalar multiplication $\\lambda(\\vec{w}-\\vec{\\bar{w}})$ in $O(p)$. Thus, the overall complexity is $O(np)$, with $p$ significantly larger than $n$ practically. Given fixed fisher sample size $n$, the loop of Algorithm 1 scales linearly with the number of pruning parameters $p$.*\n\n**Question 3**: In the introduction, GPT-4 is used an example of model with substantial size and complexity. Is it possible to show case such a pruning in a language model?\n\n**Answer 3**: In principle, the proposed method can be applied to prune a language model. Namely, the proposed method has no assumptions on the model\u2019s architecture. The formulations of (3) (i.e. the LR formulation) and (5) (i.e. the sparse EWR formulation) originate from approximating the Taylor Expansion of the loss function shown in (1). Both the LR and the EWR methods can be used as long as the loss function is differentiable, which is the common case for the majority class of deep learning models including language models that are based on neural networks and transformers. \n\nIn the revised version, we conducted an extra experiment on a larger model ResNet50, shown in Table 1. Our conclusions in the original paper still hold for the newly obtained results. We hence anticipate that the proposed method would be applicable for larger models including transformer architectures. This is definitely a direction worth exploring with significant efforts."
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1463/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700387319918,
                "cdate": 1700387319918,
                "tmdate": 1700387319918,
                "mdate": 1700387319918,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "OW5U6jGIdh",
                "forum": "LJWizuuBUy",
                "replyto": "dkWxQ35NbF",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1463/Reviewer_yr3z"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1463/Reviewer_yr3z"
                ],
                "content": {
                    "title": {
                        "value": "Thanks for the response"
                    },
                    "comment": {
                        "value": "Appreciate the response. Thank you"
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1463/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700657809619,
                "cdate": 1700657809619,
                "tmdate": 1700657809619,
                "mdate": 1700657809619,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "i2jBreCPP8",
            "forum": "LJWizuuBUy",
            "replyto": "LJWizuuBUy",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1463/Reviewer_u9iD"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1463/Reviewer_u9iD"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposed a new network pruning method based on Wasserstein distance. Under the convex hull distance equality, the problem is reformulated using Neighborhood Interpolation. Under this formulation, the authors analyzed that compared to the traditional LR formulation, this method learned a data-adaptive gradient averaging weights to smooth noise in gradient estimation. An iterative optimization method is provided. Experiments on several backbones and datasets demonstrated the utility."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1. The noise corruption in gradient estimation considered in this paper is an interesting and important problem. \n2. The idea of leveraging Wasserstein distance, especially the reformulation through neighborhood interpolation in combating noise is interesting. \n3. The authors have conducted supportive experiments to validate the advantages. Particularly, I like Figure 9 which illustrates the distribution of learned $\\Pi_t$ as the noise level varies. \n4. The paper is well-organized and written."
                },
                "weaknesses": {
                    "value": "1. Is it possible to conduct a convergence analysis for algorithm 1? If it is difficult, does the main challenge lie in the simultaneous optimization of $\\Pi_t$?\n2. It would be more interesting to compare with more baselines, in addition to the LR method."
                },
                "questions": {
                    "value": "Just to be curious, as the main contribution lies in better estimating the gradient under the existence of noise, is it possible to extend the proposed method to other applications beyond network pruning?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "details_of_ethics_concerns": {
                    "value": "Not applicable."
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1463/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698756986406,
            "cdate": 1698756986406,
            "tmdate": 1699636075089,
            "mdate": 1699636075089,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "7PGM3z7dRJ",
                "forum": "LJWizuuBUy",
                "replyto": "i2jBreCPP8",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1463/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1463/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "**Question 1**: Is it possible to conduct a convergence analysis for algorithm 1? If it is difficult, does the main challenge lie in the simultaneous optimization of $\\Pi_t$?\n\n**Answer 1**: Yes, we agree with the reviewer that the convergence analysis for problem (5) is difficult, and the main challenge lie in the simultaneous optimization of $\\Pi_t$ and $\\vec{w}$. Given fixed sparsity $k$, the convergence analysis of using block coordinated descent (i.e. alternating optimization) in solving (5) essentially lies on proving the block coordinate descent together with the iterative hard thresholding in Line 10 leads to convergence. To the best of our knowledge, this question remains open.\n\nThe most relevant work we\u2019ve identified so far are:\n- [1] Peng, Liangzu, and Ren\u00e9 Vidal. \"Block Coordinate Descent on Smooth Manifolds.\" arXiv preprint arXiv:2305.14744 (2023).\n- [2] Eisenmann, Henrik, et al. \"Riemannian thresholding methods for row-sparse and low-rank matrix recovery.\" Numerical Algorithms 93.2 (2023): 669-693.\n\nLiterature [1] shows that convergence can be guaranteed with Riemannian gradient descent. However it does not cover the case of using IHT. Literature [2] proposed a Riemannian version of IHT with local convergence. Whether integrating the Riemannian IHT into the block coordinate descent on manifold leads to local convergence remains open. This is definitely a direction worth exploring for future work.\n\nHowever, we would like to point out that for our particular problem in network pruning, the convergence of an algorithm solving problem (5) with given $k$ is not as relevant. The main reason is that in Algorithm 1 (or any gradual pruning strategies developed from (5)), the number of iteration steps is fixed. In each iteration, the target sparsity is different (i.e. $k$ is different) and we are solving different problems with one SGD iteration. \n\nThe computational cost in Algorithm 1 is mainly incurred by Line 8 (the stochastic gradient descent step). Notably, the cost of computing the OT plan $\\Pi_t$ is marginal. We added a section (A.8 Algorithm Scalability) in the Appendix. The content is as follows.\n\n*The result is shown in Figure 8. It can be observed that the execution time scales linearly with the number of pruning parameters. The extra cost of solving the OT is marginal. Theoretically, one could derive this ... The required operations can be decomposed as a sequential operations: matrix-vector multiplications $\\vec{Gw}$ and $\\vec{G\\bar{w}}$ in $O(np)$, the vector subtraction $\\vec{Gw}-\\vec{G\\bar{w}}$ in $O(n)$, a matrix-matrix multiplication $\\vec{\\Pi}(\\vec{Gw}-\\vec{G\\bar{w}})$ in $O(n^2)$, a matrix transposition and multiplication with $\\vec{G}$ in $O(np)$, and the vector subtraction and scalar multiplication $\\lambda(\\vec{w}-\\vec{\\bar{w}})$ in $O(p)$. Thus, the overall complexity is $O(np)$, with $p$ significantly larger than $n$ practically. Given fixed fisher sample size $n$, the loop of Algorithm 1 scales linearly with the number of pruning parameters $p$.*\n\n**Question 2**: It would be more interesting to compare with more baselines, in addition to the LR method.\n\n**Answer 2**: We thank the reviewer for pointing out the weakness, however the choice of comparing to mainly compare to the LR method is twofold. The main motivation is that we would like to investigate the effect of the optimal transport that we introduced to the problem formulation. Since LR can be seen as a naive case of EWR, it is natural to use LR as the baseline for EWR to see how effective the Wasserstein regression would be for combating the noise. The second reason is that LR is the current state of the art that outperforms other methods within the area of post-training network pruning , and our proposed method will not get worse even for noise-free scenarios. It will converge to LR with a large number of clean training data and therefore also outperform other methods.  \n\nMoreover, we have also listed the performance of other methods (MP, WF, and CBS) in Table 1. Since the results we reproduce for LR are consistent with the original paper, we believe the results for the other methods should be consistent as well. \n\n**Question 3**: Just to be curious, as the main contribution lies in better estimating the gradient under the existence of noise, is it possible to extend the proposed method to other applications beyond network pruning?\n\n**Answer 3**: Yes, this is possible, but we haven\u2019t tested all the possible applications and we are listing one of them here. A closely related scenario is when there is noise or corruption in computing the gradient of the trained network, as opposed to the noisy data that we are considering in this work. This naturally arises in federated learning scenarios where the gradient updates from the clients are not reliable."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1463/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700387317353,
                "cdate": 1700387317353,
                "tmdate": 1700387317353,
                "mdate": 1700387317353,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "ALRApVy471",
            "forum": "LJWizuuBUy",
            "replyto": "LJWizuuBUy",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1463/Reviewer_WJBJ"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1463/Reviewer_WJBJ"
            ],
            "content": {
                "summary": {
                    "value": "This paper reformulate the network pruning problem into an Wasserstein distance regularized sparse linear regression problem. The author shows that the ordinary sparse linear regression is just a special case when only diagnal entries exists in the transportation matrix. The authors also show that it can be viewed as neighborhood size control, which trade off between covariance capturing and gradient noise reduction. Numerical results show improvement on MLPNet, ResNet20 and MobileNetV1 architectures, over existing magnitude prunning or CVS approaches."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. The reformulation is novel as far as I know. The author successfully connect the reformulation to existing sparse regression set up, which makes a good story here.\n2. The analysis on neighborhood control is also insightful."
                },
                "weaknesses": {
                    "value": "1. The experiments are weak, without test on state-of-the-art architectures like transformers, or larger models like ResNet50, making it suspicious that the proposed approach does not work well on larger model sizes."
                },
                "questions": {
                    "value": "Why using 0.84, 0.74, 0.75, 0.63 ... values in Table 2 and 3? This is very uncommon and even in Table 1, the results are following traditional sparsity levels."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1463/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698813126875,
            "cdate": 1698813126875,
            "tmdate": 1699636075020,
            "mdate": 1699636075020,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "ybC8sL2P0B",
                "forum": "LJWizuuBUy",
                "replyto": "ALRApVy471",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1463/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1463/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We appreciate the reviewer for the acknowledgement of our contributions. \n\n**Question 1**: The experiments are weak, without test on state-of-the-art architectures like transformers, or larger models like ResNet50, making it suspicious that the proposed approach does not work well on larger model sizes.\n\n**Answer 1**: To make the experiment more comprehensive, we have added the pruning performance benchmarking for ResNet50 in Table 1. One could see that EWR outperforms LR for both ResNet20 and ResNet50 on the same dataset CIFAR10. Correspondingly, we revised our results and analysis for Table 1:\nThe advantages of EWR over the others are reflected by the three more challenging tasks: ResNet20 and ResNet50 on CIFAR10 and MobileNetV1 on ImageNet, especially in the presence of noisy gradients.\n\n**Question 2**: Why using 0.84, 0.74, 0.75, 0.63 ... values in Table 2 and 3? This is very uncommon and even in Table 1, the results are following traditional sparsity levels.\n\n**Answer 2** regarding the sparsity levels in Tables 2 and 3, in contrast to Table 1, is as follows.\n\nIn Table 1, all sparsity levels are \"target sparsity\" and all the pruning algorithms are fine-tuned on the training set after every pruning. This is to make our implemented LR and EWR align with the performance benchmarking results of MP, WF, and CBS, such that all algorithms are comparable to each other. The \u201cSparsity\u201d column is the target sparsity, such that every line in Table 1 is the final pruning result. \nTables 2 and 3 showcase the performance during one pruning process, where the loss and the accuracy values are taken immediately after pruning (without imposing any fine-tuning). The sparsity levels are intermediate levels. This was clarified in the appendix A.5 of the original version:\n\u201cIn Table 2, Table 3, and additional results provided in the Appendix, sparsity is set using a linear gradual pruning strategy, progressing from 0 to 0.75 or 0.95 across ten distinct stages for MLPNet and ResNet, and from 0 to 0.75 across eight distinct stages for MobileNetV1.\u201d\n\nUsing python code as an example:\n```{python} \ntarget_sparsity = 0.95\npruning_stage = np.array([0,1,2,3,4,5,6,7,8,9]) \n```\nAnd remark that in stage 0 we record the target weights $\\bar{w}$ and no actual pruning is conducted:\n```{python} \ntotal_stages = 10 - 1\n```\nHence:\n```{python} \n(pruning_stage / total_stages * target_sparsity).round(2)\n```\nyields the sparsity levels during this pruning process as\n```{python}\narray([0.  , 0.11, 0.21, 0.32, 0.42, 0.53, 0.63, 0.74, 0.84, 0.95])\n```\nTo clarify it further, we added the following content after the above cited paragraph:\n\n*The values are computed with linear incremental steps, from zero to the target sparsity.*\n\nAdditionally, we further clarified this in the captions of Tables 2, 3, 6, and 7."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1463/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700387313774,
                "cdate": 1700387313774,
                "tmdate": 1700387313774,
                "mdate": 1700387313774,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "vtnMTFjb85",
                "forum": "LJWizuuBUy",
                "replyto": "ybC8sL2P0B",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1463/Reviewer_WJBJ"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1463/Reviewer_WJBJ"
                ],
                "content": {
                    "title": {
                        "value": "Thanks"
                    },
                    "comment": {
                        "value": "Thank you for your response and answer to my questions. I will stick to my positive score."
                    }
                },
                "number": 11,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1463/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700713305411,
                "cdate": 1700713305411,
                "tmdate": 1700713305411,
                "mdate": 1700713305411,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "RtYQfYzV1q",
            "forum": "LJWizuuBUy",
            "replyto": "LJWizuuBUy",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1463/Reviewer_e6Ww"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1463/Reviewer_e6Ww"
            ],
            "content": {
                "summary": {
                    "value": "The authors propose a technique for pruning (sparsification) of neural networks that relies on robust estimation of the empirical Fisher Information Matrix as a surrogate for the Hessian of the training loss.  Earlier work has relied on a decomposition of the FIM to motivate a sparse LR formulation of an MIQP framework. \n\nIn contrast, in this work the authors propose a framework to address instances of contaminated gradients. In this situation, one must leverage robust estimators of the FIM, or risk a significant drop in empirical performance. By studying the original MIQP problem from the perspective of entropic Wasserstein regression, the authors propose a variation of the sparse LR formulation which amounts to substituting the 2-Wasserstein distance with entropic regularization for the quadratic regression loss. Notably, without entropic regularization, the formulation is equivalent to that of the sparse LR framework. \n\nTheoretically, the authors demonstrate that pruning via entropic Wasserstein regression exactly corresponds to gradient averaging using Neighborhood Interpolation, with the entropic regularization term governing the size of the neighborhood. Algorithmically, the method is simple and computationally efficient. Finding solutions to the problem is done via coupling sinkhorn iterations with SGD. Numerically, the performance of the method exceeds that of previous work and is competitive with the state of the art. \n\nThe method is simple and implies an elegant interpretation, as explored by the authors. Numerically, improvements over existing methods are observed- particularly when the training gradients are corrupted by noise. However, there is a significant number of grammatical mistakes and instances of poor phrasing. I do recommend this paper for acceptance, but suggest that the authors devote more time to proofreading the manuscript."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "The following are the primary strengths of this paper:\n\n- The authors propose a straightforward (but novel) modification to the sparse LR framework for neural network pruning. The modification amounts to an additional regularization term grounded by an interpretation using the principles of optimal transport. The optimization problem remains efficiently solvable. \n\n- The authors motivate their method via an analysis of the robustness  properties exhibited by solutions to their optimization problem. Namely, by proving that pruning using their technique implicitly corresponds to gradient averaging via a certain neighborhood interpolation and naturally trades off between a measure of robustness and the quality of the covariance estimator.\n\n- Additional discussions on sample complexity, ablations on the sparsity and regularization parameter, and alternative methods for computation of the EWR solution are comprehensive and provided in the appendix.\n\n- The method proposed by the authors improves results over existing methods, particularly when the training gradients are corrupted by noise. \n\n- Code is provided by the authors as a github link, which is appreciated."
                },
                "weaknesses": {
                    "value": "As a reviewer, I highlight that I am unfamiliar with the current state-of-the-art pruning techniques. I defer to other reviewers regarding the thoroughness of the comparative experiments.However, the method seems grounded. The structure of the manuscript is OK. The writing and clarity of this paper could be significantly  improved. In particular, many phrases and statements are unclear, beginning with the abstract:\n\n_This study unveils a cutting-edge technique for neural network pruning that judiciously addresses noisy gradients during the computation of the empirical Fisher Information Matrix (FIM)._\n\nAdditionally, some choices could be better motivated. E.g. the pruning step (step 10 of alg 1) as a projection onto the l-0 norm ball. However, as (reasonably) referenced by the authors, analysis of the optimization problem lies outside the scope of the paper. \n\nThroughout the main text, there are many typos and grammatical errors. Although the draft is readable in its current form, I would suggest the authors carefully review the manuscript and improve the writing- e.g. the following are some examples:\n- Now let\u2019s comparing the covariance between\u2026\n- Intuitively, a large dataset of high-quality training samples diminishes concerns over gradient noise, making the empirical fisher a close approximation to the true fisher.\n- Importantly, this seamless trade-off eludes the combination of the Euclidean distance with gradient averaging.\n- Remark that LR is a special case of EWR\u2026"
                },
                "questions": {
                    "value": "I may have missed it, but it is not obvious to me what kind of assumption is made regarding the noise. Additionally, it is unclear what kind of noise is introduced in the experiments. What kinds of noise can this method be a good choice for? What is an appropriate choice of the regularization weight for different kinds / magnitudes of noise?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission1463/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1463/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1463/Reviewer_e6Ww"
                    ]
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1463/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698945903256,
            "cdate": 1698945903256,
            "tmdate": 1700673574384,
            "mdate": 1700673574384,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "pKzwnpGsa0",
                "forum": "LJWizuuBUy",
                "replyto": "RtYQfYzV1q",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1463/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1463/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We thank the review for the comprehensive review and acknowledgement of our paper\u2019s work. We feel sorry for the unclear phrases and statements. We have done polishing and rephrasing in the recent submitted version. Careful proofreading will be conducted further. \nWe agree with the reviewer that the pruning step in Algorithm 1, especially the iterative hard-thresholding (IHT), should be better motivated and explained. Towards this goal, we added the following text after two paragraphs below equation (14):\nLine 10 in Algorithm 1 employs the IHT method that is commonly used in sparse learning, which together with line 9, forms a projected gradient descent algorithm. It finds a sparse representation of the updated gradient in line 9. Intuitively, IHT keeps the dominant model weights and essentially preserves the most impactful aspects of the to-be-trimmed model.\n\n**Answer 1** regarding the added noise is as follows:\n\nThe noise is added to the data as a Gaussian distribution, with zero mean and a specified standard deviation \u03c3. The value of \u03c3 is calibrated in the following way:\n- For a well-trained neural network (before pruning), we compute its derivative as a vector, and obtain the standard deviation of the elements in the vector. Denote it by \u03c3.\n- We then add Gaussian noise to the data. Denote the standard deviation of this Gaussian noise by \u03c3_{data}.  Denote the standard deviation of the computed derivative after adding this Gaussian noise as \u03c3\u2019. We have \u03c3\u2019 > \u03c3.\n- We tune and calibrate \u03c3_{data}, such that \u03c3\u2019 = 2 \u03c3 = \u03c3 + \u03c3. This is the case of the noise level being \u201c\u03c3\u201d. If we calibrate it to be \u03c3\u2019 = 2 \u03c3 = \u03c3 + 2\u03c3, then it is the case of the noise level to be \u201c2 \u03c3\u201d.\n\nTo clarify this in the paper, we added in Appendix A.5 the content below:\nIn calibrating noise for data in neural networks, we start with a well-trained network. First, we calculate the standard deviation $\\sigma$ of the network's derivative. Then, we add Gaussian noise with zero mean to the data. After adding the noise, the standard deviation of the network's derivative changes to a new value, $\\sigma'$, which is always greater than sigma. The goal is to adjust the standard deviation of the Gaussian noise so that $\\sigma'$ becomes $\\sigma'=\\sigma+\\sigma$ (referred to as noise level being $\\sigma$) or $\\sigma'=\\sigma+2\\sigma$  (referred to as noise level being $2\\sigma$).\n\nAdditionally, we modified the term \u201cnoisy gradient\u201d to be \u201cnoisy data\u201d in tables and the text descriptions  to avoid ambiguity.\n\n**Answer 2** regarding what kinds of noise can this method be a good choice for, is as follows.\n\nIn our experiments, we discovered that if the noise (random fluctuations) is either very small or very large, the performance of two methods, LR and EWR (our method), tend to be similar. It is straightforward that small noise does not lead to visible difference between LR and EWR. When the noise is very large, gradients would be heavily contaminated such that few true covariance information could be recovered in Hessian approximation, and hence LR and EWR stay on par. Regarding the question on whether the noise level is considered to be \u201csmall\u201d or \u201cvery large\u201d, it depends on the size of both the model and the dataset. We don\u2019t have a general answer to this, and it is mainly based on experimental observations.  However, in all cases, EWR never performed worse than LR, no matter the level of noise. We also think that if the mean of the noise is centered around zero (meaning it's equally likely to be positive or negative), our method could be a particularly good choice. This is because the way EWR interpolates, or blends data, might help in balancing out the noise.\n\n**Answer 3** regarding what would be an appropriate choice of the regularization weight for different kinds / magnitudes of noise, is as follows.\n\nThe resilience of noise originates from the neighborhood interpolation mechanism. Intuitively, if the gradients are really noisy, then we would trust each single data point less, because it may likely be contaminated with noise. Instead, we may want to enlarge the neighborhood size of performing the interpolation to combat the noise. A large value of $\\varepsilon$ does this favor for us. On the contrary, a small $\\varepsilon$ leads to few points participating effectively in interpolation. An extreme case is $\\varepsilon=0$ such that the entropic regularization term is entirely removed, indicating that no interpolation is performed when computing the Euclidean distance between two points. Yet, this case is not equivalent to the LR case, because the optimal transportation does not necessarily happen between data points in their originally assigned order. They are equivalent only if we impose the transportation plan to be $\\Pi=\\textit{diag}(1/n)$ consistently. An illustration of the neighborhood size can be seen in Figure 10 (a) - (d). The lighter the color, the more points are involved in neighborhood interpolation in computing the Euclidean distance."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1463/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700387310828,
                "cdate": 1700387310828,
                "tmdate": 1700387310828,
                "mdate": 1700387310828,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "F9rVvqKi7A",
                "forum": "LJWizuuBUy",
                "replyto": "RtYQfYzV1q",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1463/Reviewer_e6Ww"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1463/Reviewer_e6Ww"
                ],
                "content": {
                    "comment": {
                        "value": "Thank you for the comprehensive response and clarification re LR & EWR. I have read over the responses by the authors and have taken a look at the revision, which looks much better. I re-iterate that the topic of this work falls outside my area of expertise, but I would increase my score to an 8."
                    }
                },
                "number": 10,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1463/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700673550811,
                "cdate": 1700673550811,
                "tmdate": 1700673584865,
                "mdate": 1700673584865,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "20q40TxpSF",
            "forum": "LJWizuuBUy",
            "replyto": "LJWizuuBUy",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission1463/Reviewer_5Zk8"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission1463/Reviewer_5Zk8"
            ],
            "content": {
                "summary": {
                    "value": "Robust Network Pruning With Sparse Entropic Wassertein Regression\n\nIn this paper, the authors propose a method to prune neural networks. In particular, in the Sparse Linear Regression Formulation of network pruning, the authors replace the first $l_0$ regression term with Wasserstein regression. Theoretical justifications and empirical experiments show that the proposed pruning strategy is effective and robust against gradient/data noise."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "- The paper is well-written and the problem is well-motivated.\n- The proposed method has desirable properties and shows improved performance over previous methods, especially at larger sparsity."
                },
                "weaknesses": {
                    "value": "- \u201cThe noise level \u03c3 is set to be the standard deviation of the original gradients\u201d. Why is this the noise level for both gradients and data? I would like to see a more detailed explanation how how the noise is added to data and gradients.\n- Can the authors also provide an accuracy table for Table 2 and Table 3?"
                },
                "questions": {
                    "value": "Please see weaknesses."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission1463/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1463/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission1463/Reviewer_5Zk8"
                    ]
                }
            },
            "number": 5,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission1463/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699245337429,
            "cdate": 1699245337429,
            "tmdate": 1699636074868,
            "mdate": 1699636074868,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "vrsTSRDSs3",
                "forum": "LJWizuuBUy",
                "replyto": "20q40TxpSF",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1463/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1463/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We thank the reviewer for acknowledging the contributions of our work. We appreciate the reviewer for pointing out the ambiguity here. \n\n**Answer 1** regarding the noise level is as follows.\n\nThe noise is added to the data as a Gaussian distribution, with zero mean and a specified standard deviation \u03c3. The value of \u03c3 is calibrated in the following way:\n\n- For a well-trained neural network (before pruning), we compute its derivative as a vector, and obtain the standard deviation of the elements in the vector. Denote it by \u03c3.\n- We then add Gaussian noise to the data. Denote the standard deviation of this Gaussian noise by \u03c3_{data}.  Denote the standard deviation of the computed derivative after adding this Gaussian noise as \u03c3\u2019. We have \u03c3\u2019 > \u03c3.\n- We tune and calibrate \u03c3_{data}, such that \u03c3\u2019 = 2 \u03c3 = \u03c3 + \u03c3. This corresponds to the case of the noise level being \u201c\u03c3\u201d. If we calibrate it to be \u03c3\u2019 = 3 \u03c3 = \u03c3 +2 \u03c3, then it corresponds to the case of the noise level to be \u201c2 \u03c3\u201d.\n\\end{itemize}\n\nTo clarify this in the paper, we added in Appendix A.5 the content below:\n\n*In calibrating noise for data in neural networks, we start with a well-trained network. First, we calculate the standard deviation $\\sigma$ of the network's derivative. Then, we add Gaussian noise with zero mean to the data. After adding the noise, the standard deviation of the network's derivative changes to a new value, $\\sigma'$, which is always greater than sigma. The goal is to adjust the standard deviation of the Gaussian noise so that $\\sigma'$ becomes $\\sigma'=\\sigma+\\sigma$ (referred to as noise level being $\\sigma$) or $\\sigma'=\\sigma+2\\sigma$  (referred to as noise level being $2\\sigma$).*\n\nAdditionally, we modified the term \u201cnoisy gradient\u201d to be \u201cnoisy data\u201d in tables and the text descriptions  to avoid ambiguity.\n\n**Answer 2** regarding the accuracy of Table 2 and Table 3 is as follows.\n\nThank you for this good advice! We have added Table 6 and Table 7 showing the testing accuracy results, as compliment to the results of Table 2 and Table 3. \n\nRemark that these four tables differ with the benchmarking board of Table 1: In Table 1, all the pruning algorithms are fine-tuned on the training set after every pruning. This is to make our implemented LR and EWR align with the performance benchmarking results of MP, WF, and CBS, such that all algorithms are comparable to each other. The \u201cSparsity\u201d column is the target sparsity, such that every line in Table 1 is the final pruning result. \n\nTables 2, 3, 6 and 7 showcase the performance during one pruning process, where the loss and the accuracy values are taken immediately after pruning (without imposing any fine-tuning). This was clarified in the appendix A.5 of the original version:\n\u201c In Table 2, Table 3, and additional results provided in the Appendix, sparsity is set using a linear gradual pruning strategy, progressing from 0 to 0.75 or 0.95 across ten distinct stages for MLPNet and ResNet, and from 0 to 0.75 across eight distinct stages for MobileNetV1. Notably, all recorded loss values are captured immediately post-pruning, devoid of any subsequent fine-tuning.\u201d"
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1463/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700387301194,
                "cdate": 1700387301194,
                "tmdate": 1700387301194,
                "mdate": 1700387301194,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "lSv2KkkW1B",
                "forum": "LJWizuuBUy",
                "replyto": "vrsTSRDSs3",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission1463/Reviewer_5Zk8"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission1463/Reviewer_5Zk8"
                ],
                "content": {
                    "comment": {
                        "value": "I acknowledge that I have read the rebuttal, and all my concerns are addressed. I have decided to maintain my positive score."
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission1463/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700631423628,
                "cdate": 1700631423628,
                "tmdate": 1700631423628,
                "mdate": 1700631423628,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]