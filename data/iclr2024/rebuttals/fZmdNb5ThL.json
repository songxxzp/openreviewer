[
    {
        "title": "ShiftAddAug: Augment Multiplication-Free Tiny Neural Network with Hybrid Computation"
    },
    {
        "review": {
            "id": "6S30jSC7vE",
            "forum": "fZmdNb5ThL",
            "replyto": "fZmdNb5ThL",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2032/Reviewer_cMEX"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2032/Reviewer_cMEX"
            ],
            "content": {
                "summary": {
                    "value": "This paper introduces \"ShiftAddAug,\" a novel approach for training multiplication-free neural networks aiming to reduce energy costs. ShiftAddAug leverages costly multiplication operations during the training phase to enhance the activation of multiplication-free operations. These multiplication operations are subsequently deactivated during inference to avoid additional computational expenses. Additionally, the authors have developed a hardware-aware neural architecture search strategy rooted in a hybrid computing augmentation search space. This strategy dynamically reduces parts of the models to comply with specific hardware constraints throughout the training process. The results obtained from benchmarks such as CIFAR10/100 and ImageNet-1k, among others, demonstrate robust performance and significant gains in energy efficiency."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "4 excellent"
                },
                "contribution": {
                    "value": "4 excellent"
                },
                "strengths": {
                    "value": "I appreciate the logical structure and clarity of this paper. The authors present their motivations compellingly, and the proposed ShiftAddAug method is both intuitive and seemingly effective, as evidenced by the strong results reported."
                },
                "weaknesses": {
                    "value": "I have several questions that I hope the authors can clarify and expand upon to better understand the nuances of ShiftAddAug:\n\n1. Could you elucidate how ShiftAddAug augments a baseline model? Specifically, in the context of convolutions, are additional channels created for multiplication-free (MF) operations on top of the existing ones? Or is there a division of existing channels between multiplicative and MF operations?\n\n2. Regarding the dedicated input channels for shift/add operations, are they fixed throughout the training process? Figure 1 suggests the presence of a \"gate\" that directs input features, but this mechanism isn\u2019t elaborated upon in the paper.\n\n3. While the concept of heterogeneous weight sharing is intriguing, its practical application during training remains unclear. Are multiplication (M) weights dynamically mapped to MF weights, implying that operations aren't tied to specific input channels? If so, what determines the allocation of operations to particular channels?\n\n4. After the neural architecture search (NAS) process, is further retraining of the resultant models necessary to achieve optimal performance? Does the performance reported in Table 5 directly stem from the NAS search, or is it the result of additional training?\n\n5. Could the authors clarify the purpose of the last row in Table 3?\n\n6. Regarding the behavior during inference, it's clear that multiplicative operations can be disabled, but can they also be entirely removed? The paper doesn't explicitly guarantee alignment between input/output channels among MF channels. Given this, are there concerns about potential computational waste due to this misalignment?"
                },
                "questions": {
                    "value": "see weaknesses"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2032/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698617552754,
            "cdate": 1698617552754,
            "tmdate": 1699636134995,
            "mdate": 1699636134995,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "jWXGQDrQj2",
                "forum": "fZmdNb5ThL",
                "replyto": "6S30jSC7vE",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2032/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2032/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We greatly appreciate your positive comments and constructive suggestions. Below are our detailed responses to your concerns.\n\n**W1: Could you elucidate how ShiftAddAug augments a baseline model?** \n\nTaking depthwise Conv as an example, let's assume we have 3 channels for MF Conv and 7 channels for original Conv. We will maintain a convolutional weight parameter with 10 channels in our code. We divide the weights of the first 3 channels as targets and calculate them using MF Conv. The weights of the remaining 7 channels are divided as the augmented part and calculated using the original  Conv. At the end of training, only the weights of the target part are exported.\n\n---\n\n**W2: Regarding the dedicated input channels for shift/add operations, are they fixed throughout the training process? Figure 1 suggests the presence of a \"gate\" that directs input features, but this mechanism isn\u2019t elaborated upon in the paper.**\n\nYes, the channels used for shift/add operations are fixed. As mentioned above, we will manually maintain a set of parameters for each operator and only use the weights of the first few channels for shift/add operators. The rest will be used for augmented multiplicative operators. Therefore, it looks like a \"gate\" on each operator that controls the information flow.\n\n---\n\n**W3: Are multiplication (M) weights dynamically mapped to MF weights, implying that operations aren't tied to specific input channels? If so, what determines the allocation of operations to particular channels?**\n\nContinuing from the explanation in *W1*, we keep using the weights of the first 3 channels for MF Conv, and the last 7 channels for augmented multiplicative Conv. At the end of each epoch, we will reorganize the weights of these 10 channels and move the important weights to the first 3 channels. We use the L1 norm to evaluate its importance. Since good weights in original Conv may not be good in MF Conv, we need HWS to cope with different weight distributions among different operators. When applying HWS, the weights of the first 3 channels are first mapped through Eqn. (5)\uff0cthen being used for calculation. We will release the mapped result after calculation during training and only save it at the end of training for exportation.\n\n---\n\n**W4: Is further retraining of the resultant models necessary to achieve optimal performance?**\n\nYes, we do need additional training to obtain the final result. This setting is the same as MCUNet. Actually, This is necessary for our method, as superNet is multiplicative, and our NAS selects subNets on top of it for operator mutation and augmentation.\n\n---\n\n**W5: Could the authors clarify the purpose of the last row in Table 3?**\n\nThis is a serious editing error. Our intention was to place the best multiplication-free tiny NN we could achieve here. But considering that this data would duplicate the results in Tab. 5 and Tab. 6,  we abandoned this decision. Sorry for not deleting this line due to negligence. If you are interested, the data here should be:\n\n| Model            | Method | Params (M) | Mult (M) | Shift (M) | Add (M) | Accuracy(%) | Energy (mj) | Latency (ms) |\n| ---------------- | ------ | ---------- | -------- | --------- | ------- | ----------- | ----------- | ------------ |\n| ShiftAddAug-r160 | NAS    | 1.3        | 0.13     | 33.5      | 33.6    | 74.61       | 0.851       | 0.264        |\n\n---\n\n**W6: Can multiplicative operations also be entirely removed?** \n\nYes. In fact, we will first build a target model and then perform augmentation on the convolution channel. We guarantee alignment between input/output channels among MF channels."
                    }
                },
                "number": 1,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2032/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700486776261,
                "cdate": 1700486776261,
                "tmdate": 1700494197145,
                "mdate": 1700494197145,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "SYNJBqnP1l",
            "forum": "fZmdNb5ThL",
            "replyto": "fZmdNb5ThL",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2032/Reviewer_J3s9"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2032/Reviewer_J3s9"
            ],
            "content": {
                "summary": {
                    "value": "This work targets better accuracy vs. efficiency trade-offs for multiplication-free tiny neural networks. Specifically, it uses multiplication-based Conv in training to augment Shift-based Conv and Add-based Conv optimization for higher accuracy in the Shift/Add-based networks. The experiments on image classification tasks show the proposed ShiftAddAug framework can have higher accuracy (e.g., +4.05% on CIFAR-100) while reducing energy consumption (e.g., 68.9% reduction) as compared to multiplication-based networks."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "1. Motivation: Current tiny DNNs are primarily designed using multiplication-based operators, often overlooking the more energy-efficient shift and add operators. Exploring shift/add-based tiny DNNs is, therefore, a worthwhile endeavor. \n\n2. Comprehensive Review of Related Works and Preliminaries: The section on related works thoroughly covers existing multiplication-free networks. Additionally, the preliminaries provide a clear explanation of the shift and add operators utilized in this work. \n\n3. Clear and Understandable Figures: The figures presented are clear, making the entire paper straightforward and easy to follow."
                },
                "weaknesses": {
                    "value": "1. Quality of the Draft: It appears the authors may not have thoroughly proofread their draft before submission. In Table 3, the performance of the proposed ShiftAddAug is denoted as \"xx\". This is a crucial detail for comprehending the efficacy of the suggested framework.\n\n2. Ambiguity in the Contribution of the Proposed NAS: From the details provided in Sec. 3.4, the introduced NAS, which is highlighted as the third contribution, seems to essentially apply tinyNAS (Lin et al., 2020) over the ShiftAddAug. The search space is presented in Table 2 without clarifying its design rationale. Consequently, the true value-add of the proposed NAS remains ambiguous.\n\n3. Unclear Contribution of the Weight Sharing Strategy: The weight-tearing issue that the proposed weight sharing strategy addresses is previously identified in ShiftAddNAS (You et al., 2022). The weight mapping strategy delineated in Eq. 5 is similar to the approach in ShiftAddNAS, which employed a learnable transformation kernel, T (\u00b7), to transition shared weights from a Gaussian to a Laplacian distribution. However, there are no theoretical justifications or empirical findings illustrating why this strategy outperforms the one in ShiftAddNAS.\n\n4. Concerns on the Accuracy of the Efficiency Metric: As mentioned in Sec. 4.1, the efficiency metric chosen for this study is the energy and latency reported by an Eyeriss-like hardware accelerator simulator. However, the referenced studies (Chen et al., 2017; Zhao et al., 2020) are designed for multiplication-based networks. The authors have overlooked elaborating on the specific modifications implemented to adapt the simulator for multiplication-free networks. Given this, it's debatable if the evaluation backdrop is fair for multiplication-based networks. A recommendation for the authors would be to utilize more reproducible metrics, such as the latency from the TVM-based Shift/Add execution in ShiftAddViT (You et al., 2023)."
                },
                "questions": {
                    "value": "Besides the previously listed weaknesses, I have the following questions:\n\n1. The experiments exclusively consider the image classification task. How can it be asserted that this is the dominant task for IoT devices?\n\n2. As indicated in Tab. 5, when introducing multiplication into the search space, the proposed ShiftAddAug displays a reduced accuracy compared to the baseline ShiftAddNAS (You et al., 2022). The given justification, which states \"our method has given the multiplication-free operators strong capabilities, bridging the gap to the original operator\", appears inconsistent. Notably, the ShiftAddNAS baseline actually boasts a similar count of Mult, Shift, and Add parameters. If the assertion were accurate, ShiftAddAug should outperform ShiftAddNAS in terms of accuracy. It seems more plausible that ShiftAddAug adversely affects the efficacy of multiplication-based operators. If this is the case, an exclusive emphasis on shift/add-only networks might be misplaced, as the existing multiplication hardware in IoT devices would remain underutilized."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2032/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698654987518,
            "cdate": 1698654987518,
            "tmdate": 1699636134913,
            "mdate": 1699636134913,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "l2hQJ9diBt",
                "forum": "fZmdNb5ThL",
                "replyto": "SYNJBqnP1l",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2032/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2032/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We greatly appreciate your positive comments and constructive suggestions. Below are our detailed responses to your concerns.\n\n**W1: Data in Tab.3 missing.**\n\nThis is a serious editing error. Our intention was to place the best multiplication-free tiny NN we could achieve here. But this data would duplicate the results in Tab. 5 and Tab. 6. Sorry for not deleting this line due to negligence. The data here should be:\n\n| Model            | Method | Params (M) | Mult (M) | Shift (M) | Add (M) | Accuracy(%) | Energy (mj) | Latency (ms) |\n| - | - | - | - | - | - | - | - | - |\n| ShiftAddAug-r160 | NAS    | 1.3        | 0.13     | 33.5      | 33.6    | 74.61       | 0.851       | 0.264        |\n\n---\n\n**W2:  The third contribution, seems to essentially apply tinyNAS over the ShiftAddAug.**\n\n**The difference from TinyNas.** TinyNAS finds the best multiplicative SubNet architecture from SuperNet. The SubNet selected here will directly meet the hardware requirements.  For our method, the SubNet should exceed the hardware limitation we set, and then gradually shrink into it during further retraining. \n\n**The design of search space.** In the program, we will first take out a SubNet1 that meets the hardware limitation. We use the \"Block types\" in Tab.2 to determine which operator to use for each layer. Then, we take out a deeper SubNet2 along SubNet1. The \"block aug. index\" in Tab.2 determines which layer will be shrunk during the training process. We start with multiplicative SubNet2 and use the \"Augment Block\" and \"Block Mutation\" in Fig.3 to change it to multiplication-free SubNet1 during training.\n\n\"width aug. multiples\" and \"expand aug. multiples\" come from NetAug and represent the expansion factor of the convolution channel and the number of channel expansion in MobilenetInvertedBlock.\n\n---\n\n**W3: The weight mapping strategy delineated in Eq. 5 is similar to the approach in ShiftAddNAS.**\n\n**ShiftAddNas** sorts the values of weights, dividing them into n groups from bottom to top, and then sets n learnable parameters to scale the weight values within each group.  **Our HWS strategy** uses fully connected to remap the Conv kernel and use Equ(5) to handle different weight distributions.  The obtained result is only added to the original weight as a bias. We use directly trained multiplicative and multiplication-free Conv weights as datasets to train the FC layer here, and freeze it in augmented training. Our method has better training stability than ShiftAddNas. Please refer to **Appendix.C** for our updated ablation study.\n\n---\n\n**W4: The Eyeriss-like hardware accelerators are designed for multiplication-based networks.**\n\n**About Eyeriss-like hardware accelerators.** We are very sorry that we do not have the ability to create hardware specifically for shift and add operators, so we use a simulator that takes the unit energy of computation, communication, data bits, and operator type into account. ShiftAddNas used Eyeriss-like hardware to evaluate energy and latency too, and the simulator does come from their [codebase](https://github.com/GATECH-EIC/ShiftAddNAS/blob/main/CV/retraining_hybrid/hw_utils.py).  Considering the outstanding contribution of this work, we believe that they have carefully considered the fair evaluation between different operators.\n\n**TVM-based Shift/Add execution.** Thank you very much for your suggestion. We use TVM to build the shift/add operator and deploy our model on RTX 3090.  We used batch_size = 8 for latency testing (ms).  The Baseline multiplicative model is evaluated in Pytorch. The input resolution is 160. \n\n|          | MobileNetV2 w0.35 | MobileNetV3 \u2013 w0.35 | MCUNet | ProxylessNAS -w0.35 | MobileNet-tiny |\n| - | - | - | - | - | - |\n| Baseline | 4.65              | 5.42                | 4.75   | 5.38                | 4.73           |\n| Shift    | 1.35              | 2.24                | 1.55   | 1.62                | 1.36           |\n| Add      | 3.76              | 4.93                | 4.68   | 5.19                | 3.864          |\n\n---\n\n**Q1: Experiment on more task.**\n\nTo demonstrate the effectiveness of our method in specific applications, we apply it to a semantic segmentation task. Please refer to **Appendix.D**.\n\n---\n\n**Q2: Performance gap with ShiftAddNas**\n\nWe need to clarify that \"Mult (M), Shift (M), Add (M)\" in Tab.5 means the number of calculations, not the count of Params. We used higher input resolution to evaluate the count of Mult, Shift, and Add calculations. Specifically, our input resolution is 160, while ShiftAddNas' is 32. This gives us **25$\\times$** the count of calculations at the same model size.  We maintain this setting so that our hardware performance can be generalized to other high-resolution datasets.   \n\nWhen we choose to use a larger model with a smaller input resolution (96 instead of 160), we can still beat the results of ShiftAddNas, saving 37.1% of calculations on average with similar accuracy. Please check our updated **Tab.5**"
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2032/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700492109219,
                "cdate": 1700492109219,
                "tmdate": 1700492109219,
                "mdate": 1700492109219,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "uPMifmfe7n",
                "forum": "fZmdNb5ThL",
                "replyto": "SYNJBqnP1l",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2032/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2032/Authors"
                ],
                "content": {
                    "title": {
                        "value": "We Sincerely Look Forward to Your Post Rebuttal Feedback!"
                    },
                    "comment": {
                        "value": "Dear Reviewer J3s9,\n\nWe are following up to check whether our rebuttal responses have addressed your comments/concerns, and would be appreciative if you could let us know your feedback, thanks and have a good day!\n\nBest Regards."
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2032/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700718115575,
                "cdate": 1700718115575,
                "tmdate": 1700718115575,
                "mdate": 1700718115575,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "8Fx8P0BN7W",
            "forum": "fZmdNb5ThL",
            "replyto": "fZmdNb5ThL",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2032/Reviewer_x9yN"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2032/Reviewer_x9yN"
            ],
            "content": {
                "summary": {
                    "value": "The paper proposes to augment shiftadd operation kernel based training with traditional multiplication kernel based training to improve the performance of CNNs while doing inference with only shiftadd ops."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "1 poor"
                },
                "contribution": {
                    "value": "1 poor"
                },
                "strengths": {
                    "value": "1. The idea of leveraging shiftAdd operation to improve compute bottleneck of CNNs is a useful and effective direction.\n\n2. The paper is written well, apart from few sentences, example: the last sentence of related work (on NAS)"
                },
                "weaknesses": {
                    "value": "1. The paper's contribution needs improvement. The current draft is heavily based on ShiftAddNet and ShiftAddNAS. \n\n2. In the abstract the authors compared the energy performance with traditional DNN, however, it should have been ShiftAddNet, if there is any. As it is already understandable due to the earlier publications in this line that shift-add ops based computation would incur energy saving over MAC based computation.\n\n3. The idea of augmenting the training shiftadd kernel with multiplicative kernel would incur additional training compute and storage overhead, thus essentially altering the training recipe of the baseline shiftadd methods. Additionally, on device training and fine-tuning is a largely growing field, which is basically demeaned by this style of training compared to that of shiftaddnet.\n\n4. Interestingly shiftAddNAS can be assumed as a superset of this work, which not only proposes the option of multiple compute kernel types, but also searches over them based on resource budget. Thus, I find it very hard to appreciate the current work in its current format.\n\n5. The results are not comprehensive and the comparison baselines are not proper. The paper should be compared with ShiftAddNAS, ShiftAddNet, AdderNet, NetAug etc. Though having more comparisons are good, however, I am not sure why the authors compared with MCUNet, as there is already the next version in that family published > 1 year back,  MCUNet v2.\n\n6. Results on ImageNet are incomprehensive.\n\n7. Table 3 last row is not filled in!"
                },
                "questions": {
                    "value": "Please see weaknesses."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "3: reject, not good enough"
                },
                "confidence": {
                    "value": "5: You are absolutely certain about your assessment. You are very familiar with the related work and checked the math/other details carefully."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2032/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698723943839,
            "cdate": 1698723943839,
            "tmdate": 1699636134815,
            "mdate": 1699636134815,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "Io7r4O0cvG",
                "forum": "fZmdNb5ThL",
                "replyto": "8Fx8P0BN7W",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2032/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2032/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We greatly appreciate your positive comments and constructive suggestions. Below are our detailed responses to your concerns.\n\n**W1/W4: The current draft is heavily based on ShiftAddNet and ShiftAddNAS. ShiftAddNAS can be assumed as a superset of this work.**\n\nWe believe that our work is a lateral extension of the existing multiplication-free neural network.\n\n**The difference from ShiftAddNet.** ShiftAddNet proposes a method to jointly train the shift and add operators, while our work does not target the training method of multiplication-free operator itself. \n\n**The difference from ShiftAddNAS.** Although both use HWS, our method is more stable in training, while the ShiftAddNas method makes the loss not converge in our augmentation scenario. In addition, we used a completely different search process based on resource budget too. ShiftAddNas uses hybrid operators to train SuperNet, and selects the best SubNet on top of it that meets the hardware requirements. Our method starts from multiplicative SuperNet, selects a SubNet that exceeds the hardware performance limit, shrinks and mutates it to a multiplication-free NN that meets the requirements in further training. Please refer to our updated **Tab.5 and Appendix C**.\n\n---\n\n**W2: The baseline in abstract should be ShiftAddNet.**\n\nYour suggestion helps to make this comparison more rigorous. We will make modifications to the abstract.\n\n---\n\n**W3: Augmentation incur additional training overhead. It's not usable for on device training.**\n\nYes, you are right and we do not claim our method is also good for on-device training. Our goal is to deploy multiplication-free NNs without inference overhead. However, this does not mean that the model trained with our method can not be further trained on device. At the end of training, we will **only export the target model** and discard the augmented part. Any on-device training methods can now be applied to the target model without overhead.\n\n---\n\n**W5: The results are not comprehensive and the comparison baselines are not proper.** **Why compare MCUNet instead of MCUNet V2.**\n\nWe need to clarify that the shift and add data in Tab.3 represent the results of Deepshift and AdderNet on these models, and the multiplication-based NetAug is also compared in Tab.3. The data of ShiftAddNet and ShiftAddNas are also reported in Fig. 4 and Tab. 5. In order to make the results clearer, we have organized the data and updated it to **Appendix F**.\n\nRegarding MCUNetV2,  MCUNet [Codebase](https://github.com/mit-han-lab/mcunet) links to two papers (V1 and V2). Models available in this repository are: ['mcunet-in0', 'mcunet-in1', 'mcunet-in2', 'mcunet-in3', 'mcunet-in4', 'mbv2-w0.35', 'proxyless-w0.3', 'mcunet-vww0', 'mcunet-vww1', 'mcunet-vww2', 'person-det']. We follow NetAug and use \"mcunet-in3\". In short, **the author of MCUNet did not distinguish the models of V1 and V2 in detail**, so we did not distinguish them in our paper too.\n\n---\n\n**W6:  Results on ImageNet are incomprehensive.**\n\nWe put the experimental results of the additional three models on Imagenet in the supplementary material. Due to the poor training efficiency of the AddConv operator and limited computing resources, it is difficult for us to use ImageNet as our dataset baseline. We are very sorry for this.\n\n|          | MobileNetV2 w0.35 | MobileNetV3 \u2013 w0.35 | MCUNet | ProxylessNAS -w0.35 | MobileNet-tiny |\n| - | - | - | - | - | - |\n| shift    | 51.92             | 54.19               | 56.45  | 55.4                | 48.92          |\n| augshift | 53.86             | 56.07               | 57.34  | 56.3                | 50.0           |\n\n---\n\n**W7: Table 3 last row is not filled in!**\n\nThis is a serious editing error. Our intention was to place the best multiplication-free tiny NN we could achieve here. But considering that this data would duplicate the results in Tab. 5 and Tab. 6,  we abandoned this decision. Sorry for not deleting this line due to negligence. If you are interested, the data here should be:\n\n| Model            | Method | Params (M) | Mult (M) | Shift (M) | Add (M) | Accuracy(%) | Energy (mj) | Latency (ms) |\n| ---------------- | ------ | ---------- | -------- | --------- | ------- | ----------- | ----------- | ------------ |\n| ShiftAddAug-r160 | NAS    | 1.3        | 0.13     | 33.5      | 33.6    | 74.61       | 0.851       | 0.264        |"
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2032/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700490377104,
                "cdate": 1700490377104,
                "tmdate": 1700493065919,
                "mdate": 1700493065919,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "iJziJp7yty",
                "forum": "fZmdNb5ThL",
                "replyto": "8Fx8P0BN7W",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2032/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2032/Authors"
                ],
                "content": {
                    "title": {
                        "value": "We Sincerely Look Forward to Your Post Rebuttal Feedback!"
                    },
                    "comment": {
                        "value": "Dear Reviewer x9yN,\n\nWe are following up to check whether our rebuttal responses have addressed your comments/concerns, and would be appreciative if you could let us know your feedback, thanks and have a good day!\n\nBest Regards."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2032/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700718060946,
                "cdate": 1700718060946,
                "tmdate": 1700718125164,
                "mdate": 1700718125164,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "TVoBwztJtT",
            "forum": "fZmdNb5ThL",
            "replyto": "fZmdNb5ThL",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission2032/Reviewer_PuT1"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission2032/Reviewer_PuT1"
            ],
            "content": {
                "summary": {
                    "value": "This work proposed a network augmentation methods for muliplication-free (MF) convolutional neural networks (CNNs). The augmented part is multiplicative and only exists during training to \"condition\" the training of the multiplication-free part. During inference, the augmented part will be disgarded; hence the inference latency and energy efficiency will not be compromised.\n\nA key technical contribution of this work is the heterogeneous weight sharing between the MF part and the augmented part. The intuition is the observation of the distribution shift of the trained weights in the two parts. The authors proposed to use the so called \"heterogeneous weight sharing with remapping\" that maps the original conv weights to those in the MF convs so that the remapped weights approximately follow a Laplacian distribution. This weight sharing technique is essential for the success of the proposed method.\n\nThe authors conducted a number of experiments to show the effectiveness of the proposed method."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "+ The idea of conditioning MF network training via network augmentation is interesting. While this idea is not new as the authors discussed in the related work section, the authors identified a unique numerical issue encountered when applying the methodology to MF network training, that is the weight tearing issue --- the inconsistency of weight distribution between the MF and mulicative parts. Solving this issue brought significant boost in performance to the proposed method."
                },
                "weaknesses": {
                    "value": "**Clarity**. As the most important part of this work, the elaboration on the heterogeneous weight sharing technique is not clear enough. I feel confused about several parts of the technique when I was reading the paper.\n- Between which two parts are the weights shared, and how? The authors are not quite clear (mathematically and technically) about this. According to the authors description, I guess the augmented convs (multiplicative) contain the original weights. The weights are mapped to those in the ML convs using Eqn (5).\n- If my understanding is correct above, does it mean the augmented conv has to be in the exactly same size as the MF conv? If so, how do the [2.2, 2.4, 2.8, 3.2] multiples in Tab. 2 work for the NAS part?\n- Is it correct understanding that there are no actually weights stored for MF part during training; instead they are generated with mapping (5) instantly? \n- What is the consideration of adding a learnable FC layer in (5)? From my understanding, there are analytical way that maps data points from a Gaussian dist. to Lap dist, like optimal transport?\n- Are the weights rounded to powers of 2 for ShiftConv?\n\n**Experiment design**.\n- The plain multiplicaive augmentation seems only to hurt the MF part without the heterogeneous weight sharing technique. Another possibility is that the weight sharing technique plays a role as a special parameterization trick. What if we only apply the parameterization without augmentation? Will this improve the performance?\n- The MF augmentation seems to work well itself. Is the weight sharing also applied for this baseline? If so, what if we relax it? The point here is to see how the performance improves just by increasing the width of a MF network.\n\n**Overall writing quality**. While the overall flow of the paper is ok, there are writing issues here and there. A incomlete list of issues:\n- The ShiftAddAug-NAS row in Table 3 is missing. The MobileNetV3 Add/AddAug accuracy data is also missing without clarification.\n- The punctuations and capitalizations in many places are wrong.\n- The names of the compared methods are confusing. I recommend the authors use a dedicated paragraph to clarify the naming of counterparts compared in the experiments."
                },
                "questions": {
                    "value": "See the weaknesses part."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission2032/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698832586793,
            "cdate": 1698832586793,
            "tmdate": 1699636134749,
            "mdate": 1699636134749,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "EW0SWdNbsJ",
                "forum": "fZmdNb5ThL",
                "replyto": "TVoBwztJtT",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission2032/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission2032/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We greatly appreciate your positive comments and constructive suggestions. Below are our detailed responses to your concerns.\n\n**W1: Between which two parts are the weights shared, and how?**\n\nTaking depthwise Conv as an example, let's assume we have 3 channels for MF Conv and 7 channels for original Conv. We will maintain a weight parameter with 10 channels in our code. We divide the weights of the first 3 channels as targets and calculate by MF Conv. The weights of the remaining 7 channels are divided as the augmented part and calculated by the original  Conv. In the end, only the weights of the target part are exported. At the end of each epoch, we reorder these 10 channels and move the important weights to the first 3 channels. Weights are shared in this process.\n\n**W2: Does it mean the augmented conv has to be in the exactly same size as the MF conv?**\n\nNo, they can have different sizes. Taking the \"width aug. multiples \" = 2.2 as an example, assuming the target model has $n$ channels, we maintain a weight of $2.2n$ channels and divide the first $n$ channels for MF Conv, and the last $1.2n$ channels for original Conv.\n\n**W3: Are there no actually weights stored for MF part during training?**\n\nYes. Continuing from the explanation in *W1*, when applying HWS, the weights of the first 3 channels are first mapped through Eqn. (5)\uff0c then being used for calculation. We will release the mapped result after calculation during training and only save it at the end of training for exportation.\n\n**W4: What is the consideration of adding a learnable FC layer in (5).**\n\nWe were inspired by the method of ShiftAddNas and hope to learn a mapping. But we need to clarify that the FC layer in (5) is trained in advance and **frozen**. So it's not learnable in the process of training the augmented model. If we set FC=Linear(1, 1) and discard $r(\\cdot)$,   It will be similar to a simple OT mapping with linear kernel. We just changed the linear mapping to a 2-layer fully connected mapping, expecting it to have a stronger effect. \n\n**W5: Are the weights rounded to powers of 2 for ShiftConv?**\n\nYes, during ShiftConv calculation, the weights will be quantized to powers of 2, and the activation will be quantized to int16.\n\n---\n\n\n**Q1: Does the weight sharing technique play a role as a special parameterization trick?** \n\nIf we only apply the parameterization without augmentation, it slightly damages the accuracy of the model. It is only a compensation method for different weight distributions, and will not produce gain for directly trained multiplication-free NNs.\n\n|                               | MobileNetV2 w0.35 | MobileNetV3 \u2013 w0.35 | MCUNet    | ProxylessNAS -w0.35 | MobileNet-tiny |\n| ----------------------------- | ----------------- | ------------------- | --------- | ------------------- | -------------- |\n| w/o Aug. ,  w/o HWS    | 69.25             | 68.42               | 70.87     | 70.54               | 68.29          |\n| **w/o Aug. ,  w/ HWS** | 68.32         | 68.1            | 71.13 | 69.88           | 68.02      |\n| w/ Aug. ,  w/ HWS      | 71.83             | 73.37               | 74.59     | 73.86               | 71.89          |\n\n\n\n**Q2:  Is the weight sharing also applied for this baseline? What if we relax it?**\n\nYes, weight sharing is also in MF augmentation. Without weight sharing, the augmented part will have difficulty exchanging information with the target part.\n\n|                         | MobileNetV2 w0.35 | MobileNetV3 \u2013 w0.35 | MCUNet    | ProxylessNAS -w0.35 | MobileNet-tiny |\n| - | - | ------------ | --------- | ------------------- | -------------- |\n| Direct trained          | 69.25             | 68.42               | 70.87     | 70.54               | 68.29          |\n| **w/o. weight sharing** | 69.42        | 69.66           | 71.09 | 70.53           | 68.40      |\n| w/. weight sharing      | 70.12             | 71.56               | 72.68     | 70.91               | 69.28          |\n\n---\n\n**E1: The ShiftAddAug-NAS row in Table 3 is missing. The MobileNetV3 Add/AddAug accuracy data is also missing.**\n\nAbout ShiftAddAug-NAS row, it is a serious editing error. Our intention was to place the best multiplication-free tiny NN we could achieve here. But this data would duplicate the results in Tab. 5 and Tab. 6. Sorry for not deleting this line due to negligence. The data here should be:\n\n| Model            | Method | Params (M) | Mult (M) | Shift (M) | Add (M) | Accuracy(%) | Energy (mj) | Latency (ms) |\n| - | - | - | - | - | - | - | - | - |\n| ShiftAddAug-r160 | NAS    | 1.3        | 0.13     | 33.5      | 33.6    | 74.61       | 0.851       | 0.264        |\n\nThe MobileNetV3 Add/AddAug accuracy data is missing because we found that when we applied the AdderNet method to MobileNetV3, both baseline and AddAug were unable to train, resulting in loss divergence. We believe it is due to the incompatibility between AddConv itself and MobileNetV3. We will make modifications and updates to reduce confusion."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission2032/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700488239557,
                "cdate": 1700488239557,
                "tmdate": 1700488239557,
                "mdate": 1700488239557,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]