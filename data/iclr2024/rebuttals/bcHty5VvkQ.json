[
    {
        "title": "SkipDecode: Autoregressive Skip Decoding with Batching and Caching for Efficient LLM Inference"
    },
    {
        "review": {
            "id": "oqb0arY6HR",
            "forum": "bcHty5VvkQ",
            "replyto": "bcHty5VvkQ",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission7405/Reviewer_RFb8"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission7405/Reviewer_RFb8"
            ],
            "content": {
                "summary": {
                    "value": "> **TL;DR:** The proposed SkipDecode algorithm achieves significant inference speedups (2x to 5x) across various tasks and LLM model sizes while maintaining negligible performance regression. However, the algorithm has limitations, which are clearly stated and helpful. Addressing my concerns and questions would improve my score.\n\nThe paper introduces SkipDecode, a novel token-level early exit strategy designed to enhance the efficiency of autoregressive large language models (LLMs) in natural language generation tasks. The existing token-level early exit methods have limitations when applied to batch inferencing and Key-Value caching, as they require waiting for the last token in a batch to exit, hindering practicality. SkipDecode overcomes these constraints by enabling each token in a batch to exit independently at each sequence position, ensuring a monotonically decreasing exit point. This approach prioritizes computational resources on upper layers, allowing later tokens to benefit from earlier token computations. Experimental results demonstrate that SkipDecode achieves significant inference speedups (2x to 5x) across various tasks and LLM model sizes while maintaining negligible performance regression. This approach not only supports batch processing and KV caching but also identifies the saturation point of hidden states, contributing to a more efficient and sustainable AI ecosystem."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "* **S.1.** The paper is well written and the illustrations are informative.\n* **S.2.** The SkipDecode algorithm is novel, effective and compatible with many existing inference optimization techniques.\n* **S.3.** The SkipDecode algorithm outperforms previous algorithms and is evaluated on several datasets with two different LLM sizes.\n* **S.4.** The SkipDecode algorithm shows promising speedups and the paper clearly states its limitations."
                },
                "weaknesses": {
                    "value": "* **W.1.** The experiments are conducted solely on a single neural architecture. Providing results on other neural architectures (such as ENcoder-Decoder) would help.\n* **W.2.** The SkipDecode algorithm is compared to a single algorithm and the provided results are limited. While the SkipDecode algorithm was evaluated on three different datasets with three different evaluation metrics on each, the comparison evaluation includes only two different datasets with a single metric for each dataset. Adding more comparison results would help.\n* **W.3.** The paper was easy to follow, however, I find some information missing. Addressing my questions would improve my score.\n\nTypos:\n* saturatedSchuster -->saturated Schuster\n* Wile our method --> While our method"
                },
                "questions": {
                    "value": "* **Q.1.** How are the min_exit_layer and max_exit_layer chosen?\n* **Q.2.** What is the degradation of quality of using batch-wise exit-point function instead of a per example-wise?\n* **Q.3.** What is the gain of using Skipping instead of Early-Termination? If the function is monotonic decreasing wouldn't that solve the problem for Early-Termination?\n* **Q.4.** How is the speed-up and quality affected by the sequence-length hyperparameter? Why was is chosen to be the median? How would this work in a general chat-bot fashion where the generated sequence length can largely vary?\n* **Q.5.** Do the speedups include the prompt computation time?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission7405/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698322073521,
            "cdate": 1698322073521,
            "tmdate": 1699636887572,
            "mdate": 1699636887572,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "Kfr4YLWTjY",
                "forum": "bcHty5VvkQ",
                "replyto": "oqb0arY6HR",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7405/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7405/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "**We sincerely appreciate the insightful feedback and thoughtful inquiries provided by the reviewer.** In this response, we aim to comprehensively address the concerns and questions raised, hoping to clarify and enhance the understanding of our research.\n\n**OPT choice and decoder architecture:**\n\nPlease refer to the general answer above under \"OPT choice and decoder architecture\" [here](https://openreview.net/forum?id=bcHty5VvkQ&noteId=rNoNTTEd2m) as this point was raised by another reviewer.\n\n**Compared only with one baseline**\n\nWe do not know other work comparable to ours in terms of early exit in the decoding stage. CALM is the closest we are aware of.\n\nOur work is one of the first to focus on early exit strategies in the decoding stage of autoregresive neural networks. There are limited studies that align closely with our approach. \n\nWe identified CALM as the closest relevant work to our approach. However, CALM is designed for encoder-decoder architectures. To facilitate a meaningful comparison, we implemented a decoding-only version of CALM, which we believe is the most appropriate baseline given the specific focus of our research. The scarcity of directly comparable works in terms of early exit strategies in decoding stages has limited our ability to conduct a broader comparative analysis with a range of baselines.\n\nThe adaptation of CALM to a decoding-only context was necessary to provide at least one viable point of comparison. We acknowledge that this adaptation might not fully capture the nuances of other potential baselines designed explicitly for decoding-only architectures.\n\nWhile Skipdecode is implemented with the Metaseq framework and therefore we can handle a wide range of large datasets, our implementation of CALM is not as optimized as Metaseq, that's why we limited the comparison to fewer datasets and sizes. \n\n**Q.1. How are the min_exit_layer and max_exit_layer chosen?**\n\nOur approach to selecting min_exit_layer and max_exit_layer is driven by the target speedup, such as 2x. A given target speedup will give us different min_exit_layer and max_exit_layer configurations based on Figure 3 (Section 2.3). We determine these configurations through hyperparameter search on the E2E dataset and then apply the same configurations across other datasets. We touched on this in Section 3.1 (second paragraph) of our manuscript, **we will revise this section to provide a clearer and more explicit explanation of our method for choosing these layers.**\n\n**Q.2. What is the degradation of quality using batch-wise exit-point function instead of a per example-wise?**\n\nIn our case there is no degradation per se as it is a position wise exit. In the SkipDecode, we employ a position-wise exit strategy, meaning that tokens at the same position in different elements of the batch exit simultaneously. Our method maintains consistency across batch elements, regardless of the size of the batch.\n\n**Q.3. What is the gain of using Skipping instead of Early-Termination? If the function is monotonic decreasing wouldn't that solve the problem for Early-Termination?**\n\nThe key benefit of using Skipping over Early-Termination, even with a monotonic decreasing function, lies in how the transformer architecture processes information layer by layer. In Early-Termination, later tokens might only attend to intermediate hidden states, potentially missing out on crucial information processed in subsequent layers. Skipping ensures that the full computation performed by earlier tokens is utilized. This concept is illustrated in the 'Computational Efficiency' section of Figure 2 in our paper.\n\n**Q.4. How is the speed-up and quality affected by the sequence-length hyperparameter? Why was is chosen to be the median? How would this work in a general chat-bot fashion where the generated sequence length can largely vary?**\n\nThe sequence-length hyperparameter, when other variables are held constant, influences the slope of the decaying function (see Figure 3), but it doesn't significantly impact the overall speedup. The choice of sequence length depends on the dataset, as our framework focuses on Fine Tuning and specialization (refer to the [general answer](https://openreview.net/forum?id=bcHty5VvkQ&noteId=PYRP8JGGUt)). Therefore, it is not ideally suited for general chat-bot applications. The sequence length and prompt size will ultimately depend on the dataset training set statistics. We selected the median prompt size during training to allow the model to adapt naturally to the typical prompt sizes found within the dataset's variance (Section 2.3, last paragraph; Section 3.1, 4th paragraph).\n\n**Q.5. Do the speedups include the prompt computation time?**\n\nNo, the speedups reported in our study do not include the prompt computation time, only the decoding. **We will clarify it more. We will ensure to make this clearer in the revised version of the manuscript.**"
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7405/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700505995610,
                "cdate": 1700505995610,
                "tmdate": 1700581646298,
                "mdate": 1700581646298,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "GH98pYOhOI",
            "forum": "bcHty5VvkQ",
            "replyto": "bcHty5VvkQ",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission7405/Reviewer_rBkT"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission7405/Reviewer_rBkT"
            ],
            "content": {
                "summary": {
                    "value": "The authors claim that there is a problem with early exit methods like CALM as they create K,V cache issues. The authors propose a simple solution - predefine exit location for each token based on the sequence length. The strategy is based on the claim \"later tokens are easier to generate than the first tokens\"."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "1. The approch is simple. Directly applicable without a requiring a lot of low level implementation.\n2. Is the loss per token a valid proxy for \"hardness\" ?"
                },
                "weaknesses": {
                    "value": "1. I am still a bit unconvinced that fixing a schedule for early exit is good approach for reducing the computation. To an extent won't a better approach be do it based on the context rather than forcing it.\n2. The second is the validaty of the claim that\"KV cache\" generation is a massive bottleneck. Yes I agree it might makeup for unpredictable tail latencies, but can authors do an analysis of illustrating the problem.\n3. I understand the authors perspective of performing fine-tuning. However, do authors think it is a viable approach in real world, especially as the model sizes keep increasing. How would authors go about creating a dataset which reperesent real world examples.\n\n4. I am having a hard-time understanding Table-4. I have spent close to 15 minutes trying to understand the Table and reading text around. There are no lables, no descriptions what the numbers mean and how do you go about fixing speedup. Please improve the presentation.\n\nAll in all, I think I like the idea. However, I am still somewhat on the fence about this paper. I understand the problem about K,V cache with CALM. However, wouldn't just generating K,V cache solve that problem as well. How much proportion of time is regeneration of K,V cache is something I would like to understand.\nLooking forward to reading the authors response. Thank you for your great work."
                },
                "questions": {
                    "value": "Please see the weakness section"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission7405/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission7405/Reviewer_rBkT",
                        "ICLR.cc/2024/Conference/Submission7405/Senior_Area_Chairs"
                    ]
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission7405/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698778562605,
            "cdate": 1698778562605,
            "tmdate": 1700839086151,
            "mdate": 1700839086151,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "tylKYJ6YSK",
                "forum": "bcHty5VvkQ",
                "replyto": "GH98pYOhOI",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7405/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7405/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response (Part 1)"
                    },
                    "comment": {
                        "value": "**We sincerely appreciate the insightful feedback and thoughtful inquiries provided by the reviewer.** In this response, we aim to comprehensively address the concerns and questions raised, hoping to clarify and enhance the understanding of our research.\n\n**Position-wise schedule:**\n\nYou raise a valid point about the potential benefits of a context-based approach over a fixed schedule.\n\nIn an ideal scenario, as implemented in methods like CALM, decisions for early exits would indeed be made on a token-by-token basis. However, while theoretically advantageous, this approach faces practical limitations in batched scenarios. The computational theoretical gains presented in methods like CALM are only realized when the batch size is limited to one.\n\nOur method seeks to address this limitation by implementing position-based exits. While a context-driven approach at the batch level is conceptually appealing, it introduces significant complications. Each token in a batch might require a different exit point due to its unique context. For example, a token in the first element of a batch might need an early exit, whereas a token in the last element might benefit from a later exit. This variability can negate computational gains and introduce uncertainty in terms of computational cost.\n\nTo ensure efficiency and predictability, our approach focuses on having the entire batch exit at the same position. This exit strategy across the batch ensures that the computational gains are both effective and predictable. In this context, fine-tuning becomes a crucial aspect of our method as it allows us to optimize the exit points for different positions, balancing the trade-off between computational efficiency and the contextual nuances of each token.\n\n**KV cache analysis:**\n\nGenerative inference in LLMs often employs a KV Cache mechanism to enhance generation speed. In the causal decoder used by these models, attention for a token is calculated based on preceding tokens, leading to repetitive recalculations for each token generation. KV cache mitigates this by storing and reusing previously computed Key/Value vectors, thereby avoiding redundant computations at the cost of increased memory usage. Without KV caching, for each new token all KV representations for previous tokens, should be recomputed every time.\n\n[1] conducted an experiment with GPT-2 on a Tesla T4 GPU (details available in [1]) to quantify the impact of KV caching. The results were compelling:\n\nWith KV Caching: 11.885 \u00b1 0.272 seconds (for the generation of 1000 new tokens)\nWithout KV Caching: 56.197 \u00b1 1.855 seconds\n\nThis demonstrates the significant efficiency gains offered by KV caching. Our simple method, via skipping, allows the use of KV caching in early exit scenarios and, even more, as it progressively reduces layer usage, it decreases both KV requirements and overall memory footprint.\n\nThe memory consumption of KV cache increases rapidly as the model size and generation length increase, drastically increasing the pressure of on-device memory [2], in some scenarios even surpassing the model size [4]. When memory usage exceeds GPU capacity, the generative inference of LLMs typically resort to offloading and the KV cache loading ends up dominating the inference cost. According to [3] inference with multihead attention incurs significant memory capacity and bandwidth costs to store and load the KV cache, and these costs can dominate the rest of the inference at large batches or long context lengths.\n\nOur approach aims to improve both sides of the coin, utilizing KV cache to speed up the process in the context of early exit while minimizing its memory footprint. As [2] and [3] state, dealing with KV caching is critical for advancing efficient generative inference in LLMs.\n\n[1]: \"Transformers KV Caching Explained, Lages, 2022\" ( https://medium.com/@joaolages/kv-caching-explained-276520203249)\n\n[2]: Model Tells You What to Discard: Adaptive KV Cache Compression for LLMs, Ge et. al., 2023\n\n[3]: Efficiently Scaling Transformer Inference, Pope et. al., 2023.\n\n[4]: Scissorhands: Exploiting the Persistence of Importance Hypothesis for LLM KV Cache Compression at Test Time, Liu et. al, 2023\n\n**Role of Fine-Tuning in SkipDecode:**\n\nPlease refer to the general answer above under [\"Role of Fine-Tuning in SkipDecode\"](https://openreview.net/forum?id=bcHty5VvkQ&noteId=PYRP8JGGUt) title as this point was raised by another reviewer."
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7405/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700505133536,
                "cdate": 1700505133536,
                "tmdate": 1700581030321,
                "mdate": 1700581030321,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "7SOtnR4tLJ",
                "forum": "bcHty5VvkQ",
                "replyto": "GH98pYOhOI",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7405/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7405/Authors"
                ],
                "content": {
                    "title": {
                        "value": "Response (Part 2)"
                    },
                    "comment": {
                        "value": "**KV Cache in Early Exit:**\n\nRegarding the specific question about computing the cache for early exit methods. In CALM, and similar early exit methods, generating the K,V cache for tokens exiting at different layers presents some challenges. This is primarily due to the architectural deviations these methods introduce in the standard Transformer model. For example, if a token exits beyond the layer reached by previous tokens, CALM attends to the last computed layer for those tokens. While it is technically feasible to generate the cache in such scenarios, this process necessitates additional logic and careful handling to ensure a closer alignment with the original Transformer architecture.\n\nIn contrast, SkipDecode maintains the standard layer-by-layer attention mechanism of the Transformer. This adherence to the conventional architecture means that K,V caching can be utilized straightforwardly, without necessitating low-level implementation adjustments or architectural decisions. \n\nThe core advantage here is that SkipDecode retains the efficiency of the Transformer's attention mechanism, avoiding the computational overhead of on-the-fly cache recomputation that early exit methods might incur if they are to adhere to the Transformers original architecture (Figure 2).\n\n**Table 4:**\n\nTable 4 compares SkipDecode with 2 baselines derived from the CALM paper at different levels of Speedup. Speedup reflects the various sizes of the network according to each approach. Multilayer: reflects the number of layers used monolithically, while CALM-DEC reflects the exit points at each token level. The numbers reflect the accuracy in each dataset.\n\n**Sorry for the inconvenience, we will expand the section to include proper descriptions in the revised manuscript.**\n\nThank you for your feedback regarding Table 4. We apologize for any confusion caused by the presentation of the data.\n\nTable 4 is designed to compare the performance of our proposed system, SkipDecode, against two baseline approaches adapted from the CALM framework. These baselines are a multi-layer exit network and CALM-DEC, a variation tailored for decoder-only models like ours.\n\nThe 'Speedup' column in the table represents different levels of computational efficiency achieved by each method. For the Multi-layer approach, 'Speedup' indicates the number of layers used in a monolithic fashion, essentially a measure of how early the model exits. In the case of CALM-DEC, it reflects the dynamic exit points at each token level, determined by the network's hidden state saturation.\n\nThe subsequent columns show the performance of each approach on two datasets, E2E and Reddit-TLDR, at various speedup levels. The performance is measured in terms of accuracy, with the numbers provided being percentage scores.\n\n**Upon reviewing your feedback, we realize the need for a more comprehensive explanation of these concepts in the manuscript. **\n\nWe hope this clarification addresses your concerns. We will ensure the revised manuscript provides a clearer and more detailed explanation of Table 4.\n\n**Is the loss per token a valid proxy for \"hardness\"?**\n\nOur intuition is that, the loss per token, which measures the discrepancy between the predicted and actual outputs, can be indicative of the difficulty the model encounters in accurately predicting the correct answer at each token position. This interpretation aligns with the principle of loss functions where higher loss values typically reflect greater challenges in model prediction (and therefore require greater adjustments).\n\nThe context within which the model operates plays a significant role. For instance, in sequence-based tasks, predictions made early in a sequence may be more challenging due to limited preceding context, as opposed to later predictions where the model has more contextual information. This observation is consistent with the findings in the CALM paper (specifically Figure 2.a), where the impact of perturbations at different sequence positions was analyzed. The model found it more challenging to recover from perturbations occurring early in the sequence than those towards the end.\n\nIn our work, we use loss per token as an indicative measure, but we also acknowledge the complexity of interpreting this metric as a standalone indicator of 'hardness'. Future research could further refine this approach, perhaps by integrating additional metrics or considering the contextual factors that influence model predictions."
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7405/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700505499587,
                "cdate": 1700505499587,
                "tmdate": 1700581269792,
                "mdate": 1700581269792,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "QUze0sWKMb",
            "forum": "bcHty5VvkQ",
            "replyto": "bcHty5VvkQ",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission7405/Reviewer_HbUe"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission7405/Reviewer_HbUe"
            ],
            "content": {
                "summary": {
                    "value": "This work investigates token-level early exit for large language models. Existing approaches are an ill fit for batch inference and KV cache. To address these two challenges, the authors propose two designs: a shared exit point for every token in a batch at each sequence position for batching; a monotonic decrease in exit point for KV cache. The authors evaluate their method on three generation datasets using the OPT model."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "This work investigates an important problem, and provides a practical design for the batching serving setting."
                },
                "weaknesses": {
                    "value": "-> This work only considers the finetuning setting, whereas LLM is particular interesting for its in-context learning ability. \n\n-> The authors only discussed established direction such as distillation and quantization, but no recent works on compressing LLM nor efficient inference of LLM in Section 4.\n\nLin, Ji, et al. \"AWQ: Activation-aware Weight Quantization for LLM Compression and Acceleration.\" arXiv preprint arXiv:2306.00978 (2023).\n\nXiao, Guangxuan, et al. \"Smoothquant: Accurate and efficient post-training quantization for large language models.\" International Conference on Machine Learning. PMLR, 2023.\n\nFrantar, Elias, et al. \"Gptq: Accurate post-training quantization for generative pre-trained transformers.\" arXiv preprint arXiv:2210.17323 (2022).\n\nSheng, Ying, et al. \"FlexGen: High-Throughput Generative Inference of Large Language Models with a Single GPU.\" (2023)\n\nLiu, Zichang, et al. \"Deja vu: Contextual sparsity for efficient llms at  inference time.\" International Conference on Machine Learning. PMLR, 2023.\n\nZhang, Zhenyu, et al. \"H_2 O: Heavy-Hitter Oracle for Efficient Generative Inference of Large Language Models.\" arXiv preprint arXiv:2306.14048 (2023).\n\nLiu, Zichang, et al. \"Scissorhands: Exploiting the Persistence of Importance Hypothesis for LLM KV Cache Compression at Test Time.\" arXiv preprint arXiv:2305.17118 (2023).\n\n\n-> Minor: I believe if use \\citep can put the citation inside bracket, which will make the pdf much easier to read."
                },
                "questions": {
                    "value": "What is special about E2E?  Why E2E seems to have a significantly better performance? I think this will help us understand when this method works."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission7405/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698814296435,
            "cdate": 1698814296435,
            "tmdate": 1699636887343,
            "mdate": 1699636887343,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "4Nk0KtFoKn",
                "forum": "bcHty5VvkQ",
                "replyto": "QUze0sWKMb",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7405/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7405/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "**We sincerely appreciate the insightful feedback and thoughtful inquiries provided by the reviewer.** In this response, we aim to comprehensively address the concerns and questions raised, hoping to clarify and enhance the understanding of our research.\n\n**Role of Fine-Tuning in SkipDecode:**\n\nPlease refer to the general answer above under [\"Role of Fine-Tuning in SkipDecode\"](https://openreview.net/forum?id=bcHty5VvkQ&noteId=PYRP8JGGUt) title as this point was raised by another reviewer.\n\n**Missing angle on efficient LLM inference:**\n\nThe reviewer is right and we are thankful for your insightful feedback regarding the coverage of recent works on LLM compression and efficient inference in our manuscript. We acknowledge that incorporating recent advancements in this field would significantly strengthen our discussion and argument, especially concerning KV cache management during LLM inference.\n\nIn light of your suggestions, we realize the importance of emphasizing our method's ability to manage KV caches efficiently. Our approach not only facilitates KV caching during early exit scenarios but also effectively reduces the KV cache size, thereby diminishing the memory footprint. This point, although present in our initial submission, was not highlighted sufficiently. We appreciate that your comment has brought this to our attention, and even [1] suggested by the reviewer helped us argue in favor of efficiently dealing with KV caches in other reviewer response.\n\n**We will incorporate a more detailed discussion of these recent works in the revised version of our paper. Specifically, we plan to:** \n1. Discuss the relevance of these recent methods in the context of our work, particularly focusing on how they complement and contrast with our approach;\n2. Explicitly highlight how our method addresses some of the challenges posed by LLM compression and efficient inference;\n3. Strengthen the section on KV cache management, underscoring its significance in efficient LLM inference, as your suggestion and the reference [1] have prompted us to consider.\n\nWe believe that these additions will improve the overall quality and comprehensiveness of our manuscript.\n\nThank you once again for your constructive feedback.\n\n[1] *Specializing Smaller Language Models towards Multi-Step Reasoning, Fu et. al., 2023*\n\n**E2E Dataset:**\n\nOur approach is particularly effective in scenarios where generation tasks are extensive and the scope is well-defined. This makes it well-suited for applications such as summarization and translation.\n\nThe E2E dataset is also an ideal fit. It focuses on transforming structured data into coherent verbalizations, usually involving concise prompts. For instance, a typical prompt in the E2E dataset might be: {\"prompt\": \"name[The Dumpling Tree], eatType[restaurant], food[Italian], priceRange[high]\"}, with the corresponding response: \"The Dumpling Tree is an Italian restaurant with high prices.\" This dataset requires the model to convert structured, attribute-based information into a fluid narrative form \u2013 a task that aligns seamlessly with the strengths of our method. \n\nThe reason our method shows significant performance improvements with the E2E dataset can be attributed to several factors: \n1. The E2E dataset's well-defined nature and focused scope enable our model to specialize effectively via fine-tuning. \n2. Our method demonstrates its strength in maintaining quality up to the point of hidden state saturation. In the case of the E2E dataset, this threshold lies within the manageable size of the model. This indicates that our method can effectively handle the dataset's tasks without requiring a very large network. The good numbers in all speedups indicate that the method is able to avoid degradation up to the hidden state saturation point.\n\nIn summary, the E2E nature of its tasks play into the strengths of our method, allowing for more efficient language generation. This is reflected in the performance metrics we observed."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7405/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700504298718,
                "cdate": 1700504298718,
                "tmdate": 1700580517606,
                "mdate": 1700580517606,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "AkOYUKn0vX",
            "forum": "bcHty5VvkQ",
            "replyto": "bcHty5VvkQ",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission7405/Reviewer_zrR5"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission7405/Reviewer_zrR5"
            ],
            "content": {
                "summary": {
                    "value": "This work proposes SkipDecode, an early-exit method for speeding up the inference of autoregressive models. This method works by setting a fixed schedule for skipping earlier layers depending on the number of generated tokens. Authors validate the performance of SkipDecode by testing it on OPT models for several generative tasks, showing speedups over prior methods such as CALM."
                },
                "soundness": {
                    "value": "2 fair"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "* The work proposes an original way to simplify early-exit adaptive generation techniques that addresses their shortcomings. The method is conceptually simple yet efficient in practice.\n* Overall, the paper is well-written and the key contributions are clear.\n* The empirical results for studied models and datasets appear promising: in some cases, there are negligible accuracy degradations even with a 5x speedup."
                },
                "weaknesses": {
                    "value": "* For a work that claims practical performance speedups of deep learning inference, it should be important to comprehensively evaluate the real-world increase in speed compared to the baselines. However, I have found that part of the experiments to be missing multiple crucial details, for example, the type of hardware used to run the experiments, the batch size during generation, and the metric that was used to obtain the numbers for true speedup (was it latency, throughput, or something else?). Also, apparently there is no real-world speedup comparison between SkipDecode and CALM-DEC.\n* The choice of datasets could also be more comprehensive: currently, 2/3 problems are related to summarization with quite long prompts, and another is structure-to-text conversion. To give a broader view of whether SkipDecode performs reliably well across different problems, it would be useful to include tasks with different input-output relations and sequence length (for example, machine translation experiments from the CALM paper)\n* There are quite a few typos in the submission: for example, \"figure 2\" -> \"Figure 2\" at the bottom of page 3, \"e2e dataset\" -> \"E2E dataset\" and \"figure 3\" -> \"Figure 3\" on page 6, \"SkipDecodemodels\" -> \"SkipDecode models\" on page 8.\n* Lastly, I think that the OPT family of models is not fully representative of the architecture variations used today (for example, LLaMA models with multi-query attention), and the current findings about embedding saturation might not transfer to larger or more recent models."
                },
                "questions": {
                    "value": "* If I understood correctly, each of the experiments you ran involved finetuning the model on a target dataset. However, in practice, model providers might often serve a single model for many different applications: for example, this means that the average prompt/response lengths can vary dramatically. Is it possible to extend SkipDecode to such a scenario?\n* Which hardware did you use to run your experiments and how did you measure the true speedup?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission7405/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1699545124309,
            "cdate": 1699545124309,
            "tmdate": 1699636887228,
            "mdate": 1699636887228,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "gpWT9hqjJd",
                "forum": "bcHty5VvkQ",
                "replyto": "AkOYUKn0vX",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission7405/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission7405/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "**We sincerely appreciate the insightful feedback and thoughtful inquiries provided by the reviewer.** In this response, we aim to comprehensively address the concerns and questions raised, hoping to clarify and enhance the understanding of our research.\n\n**Speedup measurement and Hardware details:**\n\n**We will add hardware information and real time for the SkipDecode experiments.**\n\nAs hardware we use a single node with 16xV100 GPUs.\n\nWith respect to the baseline, real time might not be the best metric as our implementation is by no means optimized as it is the OPT Metaseq implementation. \n\nHowever, our aim here is to compare different configurations (2x, 3x, 4x, 5x) against the full network cost (1x) both in performance and speedup. \n\n**We will include detailed information about the hardware used for running our experiments. Additionally, we will provide real-time measurements for the SkipDecode experiments to offer a more tangible understanding of the speedups achieved.**\n\nWhile we understand the importance of real-time metrics, we would like to clarify that our baseline CALM-DEC implementation is not fully optimized. SkipDecode and CALM-DEC are implemented on different frameworks. Therefore, comparing real-time metrics directly might not accurately reflect the efficiency of the underlying method. \n\nWe followed the metric originally proposed by CALM which is the number of layers used, which is a good proxy for time and resources needed. Same as CALM, the True Speedup in table 3 is measured as the Total Number of Layers in the network by the Average Number of Layers used per token. Difference with CALM is that we can do batching so this measure includes a batched setting (i.e., batches of arbitrary size), while CALM restricts the analysis to a scenario with a batch size equal to 1.\n\nHowever, as our aim here is to compare different configurations (2x, 3x, 4x, 5x) against the full network cost (1x) both in performance and speedup. We can provide real-time metrics for different configurations of SkipDecode.\n\nWe believe these additions and clarifications will comprehensively address the concerns raised and provide a clearer picture of the practical performance speedups achievable by SkipDecode. We appreciate the opportunity to enhance our work based on your feedback.\n\n**More Diverse Datasets:**\n\nPlease refer to the general answer above under [\"More Diverse Datasets\"](https://openreview.net/forum?id=bcHty5VvkQ&noteId=ok0kucxlVL) title as this point was raised by another reviewer.\n\n**OPT choice and decoder architecture:**\n\nPlease refer to the general answer above under [\"OPT choice and decoder architecture\"](https://openreview.net/forum?id=bcHty5VvkQ&noteId=rNoNTTEd2m) title as this point was raised by another reviewer.\n\n**Role of Fine-Tuning in SkipDecode:**\n\nPlease refer to the general answer above under [\"Role of Fine-Tuning in SkipDecode\"](https://openreview.net/forum?id=bcHty5VvkQ&noteId=PYRP8JGGUt) title as this point was raised by another reviewer.\n\n**Adapting parameters to different datasets:**\n\nWe indeed fine-tune for each dataset (see [\"Role of Fine-Tuning in SkipDecode\"](https://openreview.net/forum?id=bcHty5VvkQ&noteId=PYRP8JGGUt)). To adapt for each dataset, we use the statistics of the training set. To handle varying prompt lengths we train the network using the median prompt size (Section 3.1) which has worked well in our experiments.\n\nRegarding the prompt length again we set the max_len based on our training set, and if a datapoint in test is longer than that it will be assigned the min_layer for each token beyond the max_len parameter (Section 3.1). \n\n* Thank you very much for the typos we will fix it in the reviewed version"
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission7405/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700503983015,
                "cdate": 1700503983015,
                "tmdate": 1700580305343,
                "mdate": 1700580305343,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]