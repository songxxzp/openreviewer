[
    {
        "title": "Entropy Coding of Unordered Data Structures"
    },
    {
        "review": {
            "id": "BTx1TMeRyU",
            "forum": "afQuNt3Ruh",
            "replyto": "afQuNt3Ruh",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4023/Reviewer_72sp"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4023/Reviewer_72sp"
            ],
            "content": {
                "summary": {
                    "value": "This paper proposes a general method called shuffle coding for compressing sequences of unordered objects using bits-back coding.    \nThe proposed shuffle coding is applicable to multisets, graphs, hypergraphs etc.    \nSOTA compression rate is achieved on several graph datasets including molecular data."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "The problem of compressing unordered data optimally by considering the storing order as redundancy is novel to me.    \nThe paper is a solid contribution with solid theoretical foundations. The mathematical structures from group theory are closely connected with the target unordered data.      \nThe idea of decoding the ordering as part of an encode function in the spirits of bits-back coding is very interesting.    \nThe background and proposed methods are clearly explained and relatively easy to follow.    \nExperiments are conducted on server different datasets, and achieve sota compression rate.   \nLimitations of the proposed method is properly discussed."
                },
                "weaknesses": {
                    "value": "One major concern is the practical value of compressing those unordered data. Compared with images or videos, it seems to me the data volume of those unordered date is very limited. However, I still appreciate the technical contribution of this paper. \n\nCurrently the numbers in Table 4 is relatively not easy to understand. It would be better to report speed as GB/s or MB/s and compare this with previous methods, so that readers can better feel the efficiency."
                },
                "questions": {
                    "value": "Definition 2.5 is described in a very concise way. It is not clear why the definition is specifically connected with rANS. I think is also applies to arithmetic coding.    \n\nIt is not clear how eq9 is related to the real bitrate. In this definition, the data is compressed in an instance-wise manner and l(m) is the initial bit cost which can be amortized later if we compress more instances. However, log(1/p(x)), which is defined as the rate of the codec, is an averaged value averaging over the input symbol number. I do not understand why l(m) can be added with log(1\\p(x)).  \n\nDefinition 2.3 (Automorphism group) is actually the difinition of stabilizer. If I remember correctly, the concept of Automorphism in group theory is connected with operation by conjugation. Did I miss anything?"
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "8: accept, good paper"
                },
                "confidence": {
                    "value": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 1,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4023/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1697698430963,
            "cdate": 1697698430963,
            "tmdate": 1699636365049,
            "mdate": 1699636365049,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "VjmSx6Qajt",
                "forum": "afQuNt3Ruh",
                "replyto": "BTx1TMeRyU",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4023/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4023/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We thank reviewer 72sp for their review.\n\n> Currently the numbers in Table 4 is relatively not easy to understand. It would be better to report speed as GB/s or MB/s and compare this with previous methods, so that readers can better feel the efficiency.\n\nWe fully agree with the reviewer, and updated Table 4 to show speeds in the more standard unit of kB/s. While we did not find information on speeds for PnC, we added a column for SZIP compression speeds for comparison (no decompression speeds were reported).\n\n---\n\n> Definition 2.5 is described in a very concise way. It is not clear why the definition is specifically connected with rANS. I think is also applies to arithmetic coding.\n\nOur method requires stack-like (LIFO) codecs, such as those based on the range variant of asymmetric numeral systems (rANS), to recover bits corresponding to the redundant order using bits-back. Queue-like (FIFO) codes such as arithmetic coding cannot be directly used to implement bits-back coding, see Townsend et al. (2019) for more detail. This was previously not explicitly stated. We revised section 2.2, including definition 2.5, to clarify this.\n\n---\n\n> It is not clear how eq9 is related to the real bitrate. In this definition, the data is compressed in an instance-wise manner and l(m) is the initial bit cost which can be amortized later if we compress more instances. However, log(1/p(x)), which is defined as the rate of the codec, is an averaged value averaging over the input symbol number. I do not understand why l(m) can be added with log(1\\p(x)).\n\nIf $m$ is the initial message, the left-hand side $l(\\text{encode}(m, x))$ of eq. 9 is the real bit rate for a specific input $x$, measuring how many bits are needed to store $x$ without encoding any other information. $\\log(1/\\text{p}(x))$ is the ideal (amortized) bit rate for that specific input $x$, bounding the real bit rate from below. This is not an average over all possible inputs $x$. Note that in general, $m$ can contain previously compressed objects, and $l(m)$ is therefore not necessarily just the initial bit cost.\n\n---\n\n> Definition 2.3 (Automorphism group) is actually the difinition of stabilizer. If I remember correctly, the concept of Automorphism in group theory is connected with operation by conjugation. Did I miss anything?\n\nThat is all absolutely correct. The automorphism group of $f$ is the stabilizer subgroup of $f$ under the action of $\\mathcal{S}_n$, as mentioned right after definition 2.3. The concepts of automorphism and conjugation are indeed closely related in group theory. For example, the function $f_h(g) = h^{-1}gh$ that conjugates any element $g$ of a group $G$ by a fixed element $h$ of $G$ is an automorphism of $G$ (called an inner automorphism)."
                    }
                },
                "number": 5,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4023/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700021766563,
                "cdate": 1700021766563,
                "tmdate": 1700021766563,
                "mdate": 1700021766563,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "310kQCPJPV",
                "forum": "afQuNt3Ruh",
                "replyto": "VjmSx6Qajt",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4023/Reviewer_72sp"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4023/Reviewer_72sp"
                ],
                "content": {
                    "title": {
                        "value": "Post rebuttal"
                    },
                    "comment": {
                        "value": "Thanks for the reply. I keep my score"
                    }
                },
                "number": 6,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4023/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700299686988,
                "cdate": 1700299686988,
                "tmdate": 1700299686988,
                "mdate": 1700299686988,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "gDgZgb4zvI",
            "forum": "afQuNt3Ruh",
            "replyto": "afQuNt3Ruh",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4023/Reviewer_NBHy"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4023/Reviewer_NBHy"
            ],
            "content": {
                "summary": {
                    "value": "## Summary\n* This paper propose shuffle coding, a BB-ANS approach towards lossless compression of unordered sets. The scenario described by the paper seems to related to the Birkhoff Polytope in variational inference of permutation [Linderman 2017, Reparameterizing the Birkhoff Polytope for Variational Permutation Inference], where each permutation's likelihood is the same. The authors demonstrate the effectiveness of their approach on various datasets."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "## Strength\n* The unordered set / graph compression problem is of good practical value. The proposed approach is a neat extension of bits-back coding. It is simple, novel and works well."
                },
                "weaknesses": {
                    "value": "## Weakness\n* As the authors have discussed, the current initial bits required is quite large. This hinders the practical application of the proposed approach to one-shot object coding. Though it is still possible to apply this approach to a dataset to amortize the initial bits. An alternative to the bit-swap approach mentioned by authors is correlation communication [Harsha 2010, The Communication Complexity of Correlation] [Li 2018, Strong Functional Representation Lemma and Applications to Coding Theorems] [Theis 2021, Algorithms for the Communication of Samples], which has extra overhead of approximately $\\log \\log N!$, but does not require any initial bits."
                },
                "questions": {
                    "value": "## Questions\n* For practically large structure, what is the computational cost for finding and sampling from the isomorphism class $\\hat{f}$? For practical codec, the metrics such as latency and throughput should also be discussed."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "value": "Yes",
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission4023/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission4023/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission4023/Reviewer_NBHy"
                    ]
                }
            },
            "number": 2,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4023/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1697779854593,
            "cdate": 1697779854593,
            "tmdate": 1699636364970,
            "mdate": 1699636364970,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "JvBVLiCkgb",
                "forum": "afQuNt3Ruh",
                "replyto": "gDgZgb4zvI",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4023/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4023/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We thank reviewer NBHy for taking the time to review our paper.\n\n> The scenario described by the paper seems to related to the Birkhoff Polytope in variational inference of permutation\n\nIndeed, as the reviewer pointed out, our method is related to [Linderman 2017], where they reparameterize the Birkhoff Polytope to perform variational inference over permutation matrices. The vertices of the n-dimensional Birkhoff Polytope represent permutations over n elements. Our decoding algorithm can be seen as performing inference of the permutation applied to the input via canonicalization. Relaxing this inference to the inner hull of the Birkhoff Polytope, as done in [Linderman 2017], could be a way to perform lossy compression of combinatorial objects.\n\n---\n\n> An alternative to the bit-swap approach mentioned by authors is correlation communication\n\nWhile correlation communication methods could theoretically be an alternative to the future work of interleaving, these methods have computational complexity which scale exponentially with the entropy of the source, making them impractical. However, the reviewer is correct that these methods could in theory be used to avoid the initial bits problem, if we disregard computational complexity.\n\nThese methods relate to bits-back coding in the following way. Consider the source $X$ and another random variable $Y$ from which we can recover $X$ deterministically, i.e., $X = f(Y)$ for some function $f$. Note this implies that $H(X|Y) = 0$. As a concrete example from BB-ANS, $Y = (Z, X)$ where $Z$ is the latent variable of the VAE. Then, bits-back coding implements rate $$R = H(Y) - H(Y|X) = I(X; Y) = H(X) - H(X|Y) = H(X),$$ where $-H(Y|X)$ is the savings from the bits-back step. \n\nCorrelation communication methods can be used to communicate a sample Y | X, achieving a rate of $R + log(R+1) + 5$ via the Poisson Functional Representation Lemma (in this case, the discrete version which falls back onto the exponential races) [Li & El Gammal 2017], and X can then be recovered from that sample. Unfortunately, as mentioned, the computational complexity would be much larger than our method. \n\nBits-back can be viewed as an extremely efficient algorithm for \u201cdeterministic\u201d correlation communication (i.e., when $X = f(Y)$ for some $f$).\n\n---\n\n> For practically large structure, what is the computational cost for finding and sampling from the isomorphism class $\\tilde{f}$?\n\nWe provided relative timings for nauty, the library we used to find the canonical labeling and automorphism group (these are the computational bottlenecks for sampling from the isomorphism class), in Appendix E. As mentioned in the paper, no polynomial-time algorithm for the graph isomorphism is known, but nauty and Traces solve this problem efficiently for various graph classes. Thorough benchmarks of nauty and traces on different graph types and sizes can be found at https://pallini.di.uniroma1.it/.\n\n---\n\n> For practical codec, the metrics such as latency and throughput should also be discussed.\n\nWe have updated Appendix E to now report compression throughput. We believe that latency is more appropriate for streaming applications, such as video decoding. We would envision our codec being used in a non-streaming setting, where a whole file would be downloaded and then decompressed."
                    }
                },
                "number": 4,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4023/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700021761150,
                "cdate": 1700021761150,
                "tmdate": 1700021761150,
                "mdate": 1700021761150,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "myQkfxu25W",
                "forum": "afQuNt3Ruh",
                "replyto": "JvBVLiCkgb",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4023/Reviewer_NBHy"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4023/Reviewer_NBHy"
                ],
                "content": {
                    "comment": {
                        "value": "Thanks for the feedback, I keep my rating as accept."
                    }
                },
                "number": 7,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4023/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700631514962,
                "cdate": 1700631514962,
                "tmdate": 1700631514962,
                "mdate": 1700631514962,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "N0pJVgYGhr",
            "forum": "afQuNt3Ruh",
            "replyto": "afQuNt3Ruh",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4023/Reviewer_aWcE"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4023/Reviewer_aWcE"
            ],
            "content": {
                "summary": {
                    "value": "In this work, the authors introduce _shuffle coding_, a method for compressing sequences of unordered objects based on bits-back coding. They provide an exposition of the group-theoretic fundamentals relevant for shuffle coding (Section 2 and Appendix A), define the desiderata required for an optimal-rate codec for unordered sequences (Section 3) and present shuffle coding, an algorithm that fulfils these desiderata (Section 3.1). They apply shuffle coding to unordered data structures (specifically graphs), showing strong performance compared to PnC and SZIP (Section 5)."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "3 good"
                },
                "contribution": {
                    "value": "3 good"
                },
                "strengths": {
                    "value": "This paper presents a few key strengths which, in my view, are as follows:\n\n__Elegant unified framework:__\nThis paper provides an unified theoretical framework for compressing unordered objects, such as multisets and graphs.\nThis approach is based on the elegant idea that the order of the parts of an object does not matter, one can reduce the cost of communicating the object by getting a certain number of bits, i.e. the bits corresponding to a particular ordering of the parts, back.\nThis generality is appealing because one does not have to devise specialised method for each different type of unstructured object.\nHowever, it should be noted that this framework assumes access to a \"canonicalisation\" function, which determines a canonical representation  as well as the automorphism group of the object (e.g. graph) in question (also see weaknesses section below).\n\n__Strong compression performance:__\nThe authors demonstrate that shuffle coding achieves strong compression rates in practice.\nIn particular, shuffle coding outperforms SZIP and PnC on a range of graph datasets.\nThis is an encouraging result because, while the proposed method is asymptotically optimal, it also involves a non-trivial overhead (which is amortised as more data are compressed).\nTherefore it is good that despite this cost, shuffle coding seems to perform well in practice.\n\n__Well written paper:__\nThe paper is generally clearly written and well motivated.\nThe authors have made an effort to discuss the limitations of their work, specifically about the time complexity and initial rate overheads induced by their method.\nI appreciated the illustrations and pseudocode listings in the main text, which helped understand their method."
                },
                "weaknesses": {
                    "value": "The paper's main weaknesses, in my view, revolve around the practical applicability of shuffle coding:\n\n__Large runtime complexity:__\nAs the authors note, applying shuffle coding to a graph requires solving a graph isomorphism problem, for which no polynomial-time algorithm is known.\nThis can be a significant hurdle when coding larger graphs.\nThe authors brought up this issue in the paper, and suggested that approximately solving the isomorphism problem is a promising way to scale the method.\nHowever, in its current form, the method does not scale to larger graphs.\nFurther, it is unclear what the tradeoff between the communication rate and computational complexity of the method would be, if one were to use an approximate scheme instead.\n\n__Initial bit overhead:__\nDue to the requirement of initial bits, shuffle coding introduces a communication overhead to the transmitted message.\nThis can be significant in the one-shot or few-shot case, making the method from compressing small sequences of messages.\nI think the authors should specify the amount of extra bits used in the experiments (see Table 3) in the main text.\n\n__Contribution as a general solution seems somewhat exaggerated:__ \nWhile the shuffle coding approach is general from a theoretical point of view, it requires access to a \"canonicalisation\" function.\nThe authors focus on graphs, for which existing libraries offering this functionality exist.\nFor other permutable classes, the authors argue that one can \"embed objects into graphs in such a way that the structure is preserved and the canonization remains valid.\"\nHowever, it is unclear whether, for example, this embedding might affect the compression rate, or how difficult it is to construct such an embedding.\nIn light of this latter point, the statement that the authors' \"implementation can easily be adapted to different data types\" in the abstract may be regarded as exaggerated (if for example coming up with an algorithm that constructs such graph embeddings is challenging, or if the computational / memory complexity of such an algorithm is large).\nA more measured statement in the appendix and / or positioning of the main text might be beneficial in this regard.\n\n__Summary:__\nIn conclusion, while I find the paper to be well-motivated and elegant, I think the practical applicability of shuffle coding may be limited due to runtime issues, as well as issues pertaining to the embedding of other kinds of permuted classes on graphs, and the initial bit overhead.\nTherefore I have recommended a moderately positive score for the paper, but I am willing to adjust my score if the authors address my points of concern raised above, and the questions and recommendations made below."
                },
                "questions": {
                    "value": "Below are some questions for the authors and suggestions that I think could improve the paper.\n\n## Questions\n\n__Clarification on the discount factors for Table 3:__\nThe ER and PU models are specific probabilistic models for graphs and, as the authors explain, they can be swapped in with any other exchangeable model of graphs.\nTherefore, while it is important to report the overall communication cost in the experiments, an equally important (in my view) quantity to report is the rate discount afforded by shuffle coding.\nWhat are the discounts corresponding to the results in table 3?\nPerhaps the authors can report these as an extra column, since the discount is a function of the graph alone and not the modelling distribution $P.$\n\n\n__Extending the framework with approximate isomorphism solutions:__\nThe authors claim that while no known polynomial-time solution for solving the exact graph isomorphism problem is known\n\n> this limitation can be overcome by approximating an object\u2019s canonical ordering, instead of calculating it exactly. This introduces a trade-off between speed and compression rate in the method, and lowers runtime complexity to polynomial time.\n\nCan the authors comment on the tradeoff between the speed and compression rate of this modified method, here and / or the main text?\n\n\n## Suggestions\n\n__Definition 2.5:__\nI think that definition 2.5 is not totally accurate and / or could be improved.\nPresumably, what the authors mean by \"inverse functions\" is that $\\texttt{decode}$ is the inverse function of $\\texttt{encode}.$\nIn that case the $\\texttt{decode}$ function isn't really needed and / or can be defined as $\\texttt{decode} = \\texttt{encode}^{-1}.$\nAlso, the statement \"with respect to $P$\" does not seem to make sense on its own.\nI think clearer statement is to say that \n\n> an optimal codec for $P$ is an invertible function $\\texttt{encode} : M \\times X \\to M$, which is optimal with respect to $P,$ in the sense that for any [...].\n\nMore importantly however, in shuffle coding, the $\\texttt{encode}$ function is _not invertible_, because for $f \\in \\mathcal{F},$ applying $\\texttt{decode}(\\texttt{encode}(M, f))$ returns the message $M$ together with the canonical representation $\\bar{f}$ rather than $f$ itself (see for example the function signature and return statements in the code listing in Section 3.1).\nWhile this is a technicality that does not seem affect the validity of the algorithm, I think the authors should modify their definition and / or exposition to account for this.\n\n__Framing of definition 2.5:__\nI think definition 2.5 and the paragraph under it could be framed better.\nIn particular, the authors define optimal codecs and explain that \"definition 2.5 captures the abstract properties of codecs based on the range variant of asymmetric numeral systems.\"\nI think a clearer approach would be to say up-front that their plan is to set up a method that gets those bits which correspond to permutations of the graph in question back.\nThis in turn necessitates using a last-in-first-out codec, such as (r)ANS, and that definition 2.5 specifies \"Optimal last-in-first-out codecs\", rather than \"Optimal codecs\".\n\n__Initial bit overhead statement:__\nThe authors argue that the constant bit overhead incurred by bits-back \"exists for all entropy coding methods.\"\nWhile all entropy coding methods have a constant overhead that is amortised as more and more data are compressed, typical methods such as Arithmetic Coding (AC), have constant overheads of the order of a couple of bits.\nThis is far smaller than the claimed overhead of \"at most 64 bits\" of bits-back for shuffle coding.\nI think the authors' phrasing somewhat misrepresents the overhead of other entropy coding methods.\nA more accurate statement would be welcome here, such as: \"As in other entropy coding methods, which invariably have similar (though typically smaller) constant overheads, the constant 'initial bit cost' of bits-back is amortised as more data are compressed.\"\n\n__All units in bits?__\nAre all reported rates, including for example Table 1, in bits?\nIf so, it would be good to add a statement up front, early in the paper, that specifies this."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "6: marginally above the acceptance threshold"
                },
                "confidence": {
                    "value": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                }
            },
            "number": 3,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4023/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698705538987,
            "cdate": 1698705538987,
            "tmdate": 1699636364807,
            "mdate": 1699636364807,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "KLPyaIQKu4",
                "forum": "afQuNt3Ruh",
                "replyto": "N0pJVgYGhr",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4023/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4023/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We thank reviewer aWcE for their thoughtful, thorough and constructive review.\n\n## Weaknesses\n**Large runtime complexity:** We address this in our overall response.\n\n**Initial bit overhead:** The average initial bit cost per TU dataset in Table 3 is 0.01 bits per edge for both ER and PU, demonstrating good amortization. We added this result to section 5.\n\n\n**Clarification of the discount factors for Table 3:** We added a column to report the discounts for all datasets in Table 3. As in Table 2, the discounts are very significant for compression performance.\n\n## Questions\n**Extending the framework with approximate isomorphism solutions:** The tradeoff between rate and performance of the approximate version of shuffle coding is promising: Preliminary experiments show that on SZIP graphs, we can achieve speedups of multiple orders of magnitude for a few-percent increase in compression rate compared to optimal-rate shuffle coding, i. e. a 1000x speedup for a 4% rate increase on the \u201cgeom\u201d dataset. We implemented a version of shuffle coding that has pseudo-linear runtime and completes on graphs with more than 10 million edges. The approximate method saves the \u201ceasy-to-find\u201d redundant bits, leaving the \u201chard\u201d bits out that cause most of the computational complexity when calculating the canonical ordering in nauty and traces. On all datasets we tested, there seems to be a favorable distribution between these, i. e. many easy bits vs. few hard bits. Characterizing and predicting this tradeoff would be an interesting avenue for future work.\n\n**Contribution as a general solution seems somewhat exaggerated:** We updated section 2.1.1 to clarify that our method critically depends on the availability of function to retrieve a canonical ordering (as well as a set of generators of the automorphism group) for elements of the permutable class. As mentioned in Anders and Schweitzer (2021), embedding into vertex-colored graphs, and then running nauty/traces, is the standard technique for computing the automorphism group (and canonization) of other objects. It would be great though to prove that this is always possible, and to have a general embedding method. We actually used an embedding of edge-colored graphs into vertex-colored graphs in order to canonize and compress graphs with edge attributes (which are not directly supported by nauty/traces) for our experiments. We have updated the paper to mention that we did this.\n\n## Suggestions\nWe agree with all of the reviewer\u2019s suggestions and have implemented them in our updated paper version. This includes a simplified and better-framed definition 2.5, an updated statement regarding the initial bit overhead of rANS, and a missing clarification regarding units (all results are indeed in bits, this information was missing for Table 5).\n\n**Invertibility of encode function.** The encode function for shuffle coding *is* invertible because it takes an unordered object of type $X=\\tilde{F}$ (not $F$), so the codec signature is $M\u00d7\\tilde{F}\u2192M$. We updated section 3.1 to mention this explicitly. We merely use an ordered object with arbitrary order to represent the unordered object in our implementation, as described in section 3.1. Their order has no meaning in the sense that equality of unordered objects is implemented by comparing canonized versions of their ordered representations. In practice, we use a wrapper data type called `Unordered` to define equality in this way (i. e. `Unordered(\u2018abc\u2019) == Unordered(\u2018bca\u2019)`), so that the universal invertibility property `c.decode(c.encode(m, x)) == (m, x)` of codecs is upheld. This is omitted in the listing of section 3.1 for simplicity."
                    }
                },
                "number": 3,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4023/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700021755886,
                "cdate": 1700021755886,
                "tmdate": 1700021755886,
                "mdate": 1700021755886,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "Yamrz3NF3T",
                "forum": "afQuNt3Ruh",
                "replyto": "KLPyaIQKu4",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4023/Reviewer_aWcE"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4023/Reviewer_aWcE"
                ],
                "content": {
                    "title": {
                        "value": "Response to rebuttal"
                    },
                    "comment": {
                        "value": "Thank you for your rebuttal.\nI am happy to hear you found my review thoughtful, thorough and constructive, and that some of the suggestions I made were useful for improving the paper itself.\nYour rebuttal has generally addressed most points of concern that I have.\nI also think the preliminary exploration on extending this approach with approximate graph isomorphisms is a very interesting one, and that if the speed-up to rate trade-offs you are claiming are in fact consistent / robust across different graphs, this would make for a very compelling method.\nI am currently erring on maintaining my score of 6 (on the grounds of the current version of the method being potentially very slow).\nHowever, I think the possible improvements that could come from this extension could make this a very effective and practical compression scheme, and that __this is a potentially important factor in favour of this method that the AC could consider when assessing the paper__."
                    }
                },
                "number": 8,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4023/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700674215167,
                "cdate": 1700674215167,
                "tmdate": 1700674215167,
                "mdate": 1700674215167,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    },
    {
        "review": {
            "id": "adPDOmu6u9",
            "forum": "afQuNt3Ruh",
            "replyto": "afQuNt3Ruh",
            "signatures": [
                "ICLR.cc/2024/Conference/Submission4023/Reviewer_gbs3"
            ],
            "nonreaders": [],
            "readers": [
                "everyone"
            ],
            "writers": [
                "ICLR.cc/2024/Conference",
                "ICLR.cc/2024/Conference/Submission4023/Reviewer_gbs3"
            ],
            "content": {
                "summary": {
                    "value": "This paper focuses on the problem of compressing unordered objects. It presents a general approach called \u201cshuffle coding\u201d to compress different data structures with bits-back coding. After introducing the background in Section2, including data structures and the problem definition of compressing unordered objects, the authors derive Lemma3.2 and then provide the pseudo algorithm for the proposed method. The key idea is to decode an ordering as part of an encode function. The experimental results demonstrate that the proposed shuffle coding could compress different data structures with better lossless compression performance, compared with ordered ER."
                },
                "soundness": {
                    "value": "3 good"
                },
                "presentation": {
                    "value": "2 fair"
                },
                "contribution": {
                    "value": "2 fair"
                },
                "strengths": {
                    "value": "It seems to be meaningful to reduce compression cost by removing the order information in data structure. The proposed shuffle coding can get a discount in lossless compression of such data structures, as illustrated by Equation 14."
                },
                "weaknesses": {
                    "value": "My major concern is about the significance of the problem studied in this paper: considering the complexity, will the proposed method have wide/potential applications in practice? For my side, it seems slightly intuitive to remove the order information so that we can reduce the coding cost when we compressing graph data. Is bits-back coding necessary in this scheme? These my concern may partially be attributed to my lack of expertise in the field of compressing graphs. In addition,  Appendix C describes the modifications compared with Daniel et al., 2023b, which is also an important baseline in this paper. But for a reader that is not very familiar with the area, appendix C may be hard to understand."
                },
                "questions": {
                    "value": "As I am not entirely familiar with this field, the authors are welcome to direct my attention and address my concerns with more details provided. And I\u2019ll gladly consider increasing my initial rating."
                },
                "flag_for_ethics_review": {
                    "value": [
                        "No ethics review needed."
                    ]
                },
                "rating": {
                    "value": "5: marginally below the acceptance threshold"
                },
                "confidence": {
                    "value": "2: You are willing to defend your assessment, but it is quite likely that you did not understand the central parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
                },
                "code_of_conduct": {
                    "value": "Yes"
                },
                "first_time_reviewer": {
                    "readers": [
                        "ICLR.cc/2024/Conference/Program_Chairs",
                        "ICLR.cc/2024/Conference/Submission4023/Senior_Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission4023/Area_Chairs",
                        "ICLR.cc/2024/Conference/Submission4023/Reviewer_gbs3"
                    ]
                }
            },
            "number": 4,
            "invitations": [
                "ICLR.cc/2024/Conference/Submission4023/-/Official_Review",
                "ICLR.cc/2024/Conference/-/Edit"
            ],
            "domain": "ICLR.cc/2024/Conference",
            "tcdate": 1698835317931,
            "cdate": 1698835317931,
            "tmdate": 1700720211099,
            "mdate": 1700720211099,
            "license": "CC BY 4.0",
            "version": 2
        },
        "responses": [
            {
                "id": "RFOB3lddui",
                "forum": "afQuNt3Ruh",
                "replyto": "adPDOmu6u9",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4023/Authors"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4023/Authors"
                ],
                "content": {
                    "comment": {
                        "value": "We thank reviewer gbs3 for the time to review our paper.\n\nWe addressed the concern regarding runtime complexity in our overall response.\n\nIt is intractable to directly compress unordered objects without bits-back at the optimal rate. The role of bits-back coding is to enable us to convert the problem of compressing unordered objects into a problem of compressing ordered objects, where we can apply common sequential methods such as the ones shown in Listing 1 in the paper. \n\nAppendix C describes details of an ordered graph model that we plug into shuffle coding for our experiments. It is not a baseline for shuffle coding, since we are concerned with unordered graph compression. It is not core to our method either since shuffle coding can be combined with any ordered graph codec. We merely aimed to demonstrate that a few-parameter ordered model/codec can lead to competitive results in combination with shuffle coding, and Severo et al. 2023b is a good fit for that purpose. The minor modifications lead to rate improvements as shown in Appendix F, but are not core to our method."
                    }
                },
                "number": 2,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4023/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700021725614,
                "cdate": 1700021725614,
                "tmdate": 1700021725614,
                "mdate": 1700021725614,
                "license": "CC BY 4.0",
                "version": 2
            },
            {
                "id": "lD4HzPO9Gb",
                "forum": "afQuNt3Ruh",
                "replyto": "RFOB3lddui",
                "signatures": [
                    "ICLR.cc/2024/Conference/Submission4023/Reviewer_gbs3"
                ],
                "readers": [
                    "everyone"
                ],
                "writers": [
                    "ICLR.cc/2024/Conference",
                    "ICLR.cc/2024/Conference/Submission4023/Reviewer_gbs3"
                ],
                "content": {
                    "comment": {
                        "value": "Thanks for the feedback and confirmation on the concern regarding the limited practical value. I would like to keep the score."
                    }
                },
                "number": 9,
                "invitations": [
                    "ICLR.cc/2024/Conference/Submission4023/-/Official_Comment"
                ],
                "domain": "ICLR.cc/2024/Conference",
                "tcdate": 1700720385258,
                "cdate": 1700720385258,
                "tmdate": 1700720385258,
                "mdate": 1700720385258,
                "license": "CC BY 4.0",
                "version": 2
            }
        ]
    }
]